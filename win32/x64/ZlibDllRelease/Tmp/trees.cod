; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	_length_code
PUBLIC	_dist_code
_length_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
_dist_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	00H
	DB	00H
	DB	010H
	DB	011H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
static_dtree DW	00H
	DW	05H
	DW	010H
	DW	05H
	DW	08H
	DW	05H
	DW	018H
	DW	05H
	DW	04H
	DW	05H
	DW	014H
	DW	05H
	DW	0cH
	DW	05H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	012H
	DW	05H
	DW	0aH
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	05H
	DW	016H
	DW	05H
	DW	0eH
	DW	05H
	DW	01eH
	DW	05H
	DW	01H
	DW	05H
	DW	011H
	DW	05H
	DW	09H
	DW	05H
	DW	019H
	DW	05H
	DW	05H
	DW	05H
	DW	015H
	DW	05H
	DW	0dH
	DW	05H
	DW	01dH
	DW	05H
	DW	03H
	DW	05H
	DW	013H
	DW	05H
	DW	0bH
	DW	05H
	DW	01bH
	DW	05H
	DW	07H
	DW	05H
	DW	017H
	DW	05H
	ORG $+8
extra_blbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	03H
	DD	07H
	ORG $+4
extra_lbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	ORG $+12
base_dist DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	06H
	DD	08H
	DD	0cH
	DD	010H
	DD	018H
	DD	020H
	DD	030H
	DD	040H
	DD	060H
	DD	080H
	DD	0c0H
	DD	0100H
	DD	0180H
	DD	0200H
	DD	0300H
	DD	0400H
	DD	0600H
	DD	0800H
	DD	0c00H
	DD	01000H
	DD	01800H
	DD	02000H
	DD	03000H
	DD	04000H
	DD	06000H
	ORG $+8
base_length DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	0aH
	DD	0cH
	DD	0eH
	DD	010H
	DD	014H
	DD	018H
	DD	01cH
	DD	020H
	DD	028H
	DD	030H
	DD	038H
	DD	040H
	DD	050H
	DD	060H
	DD	070H
	DD	080H
	DD	0a0H
	DD	0c0H
	DD	0e0H
	DD	00H
	ORG $+4
static_l_desc DQ FLAT:static_ltree
	DQ	FLAT:extra_lbits
	DD	0101H
	DD	011eH
	DD	0fH
	ORG $+4
static_bl_desc DQ 0000000000000000H
	DQ	FLAT:extra_blbits
	DD	00H
	DD	013H
	DD	07H
	ORG $+4
	ORG $+8
extra_dbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
static_ltree DW	0cH
	DW	08H
	DW	08cH
	DW	08H
	DW	04cH
	DW	08H
	DW	0ccH
	DW	08H
	DW	02cH
	DW	08H
	DW	0acH
	DW	08H
	DW	06cH
	DW	08H
	DW	0ecH
	DW	08H
	DW	01cH
	DW	08H
	DW	09cH
	DW	08H
	DW	05cH
	DW	08H
	DW	0dcH
	DW	08H
	DW	03cH
	DW	08H
	DW	0bcH
	DW	08H
	DW	07cH
	DW	08H
	DW	0fcH
	DW	08H
	DW	02H
	DW	08H
	DW	082H
	DW	08H
	DW	042H
	DW	08H
	DW	0c2H
	DW	08H
	DW	022H
	DW	08H
	DW	0a2H
	DW	08H
	DW	062H
	DW	08H
	DW	0e2H
	DW	08H
	DW	012H
	DW	08H
	DW	092H
	DW	08H
	DW	052H
	DW	08H
	DW	0d2H
	DW	08H
	DW	032H
	DW	08H
	DW	0b2H
	DW	08H
	DW	072H
	DW	08H
	DW	0f2H
	DW	08H
	DW	0aH
	DW	08H
	DW	08aH
	DW	08H
	DW	04aH
	DW	08H
	DW	0caH
	DW	08H
	DW	02aH
	DW	08H
	DW	0aaH
	DW	08H
	DW	06aH
	DW	08H
	DW	0eaH
	DW	08H
	DW	01aH
	DW	08H
	DW	09aH
	DW	08H
	DW	05aH
	DW	08H
	DW	0daH
	DW	08H
	DW	03aH
	DW	08H
	DW	0baH
	DW	08H
	DW	07aH
	DW	08H
	DW	0faH
	DW	08H
	DW	06H
	DW	08H
	DW	086H
	DW	08H
	DW	046H
	DW	08H
	DW	0c6H
	DW	08H
	DW	026H
	DW	08H
	DW	0a6H
	DW	08H
	DW	066H
	DW	08H
	DW	0e6H
	DW	08H
	DW	016H
	DW	08H
	DW	096H
	DW	08H
	DW	056H
	DW	08H
	DW	0d6H
	DW	08H
	DW	036H
	DW	08H
	DW	0b6H
	DW	08H
	DW	076H
	DW	08H
	DW	0f6H
	DW	08H
	DW	0eH
	DW	08H
	DW	08eH
	DW	08H
	DW	04eH
	DW	08H
	DW	0ceH
	DW	08H
	DW	02eH
	DW	08H
	DW	0aeH
	DW	08H
	DW	06eH
	DW	08H
	DW	0eeH
	DW	08H
	DW	01eH
	DW	08H
	DW	09eH
	DW	08H
	DW	05eH
	DW	08H
	DW	0deH
	DW	08H
	DW	03eH
	DW	08H
	DW	0beH
	DW	08H
	DW	07eH
	DW	08H
	DW	0feH
	DW	08H
	DW	01H
	DW	08H
	DW	081H
	DW	08H
	DW	041H
	DW	08H
	DW	0c1H
	DW	08H
	DW	021H
	DW	08H
	DW	0a1H
	DW	08H
	DW	061H
	DW	08H
	DW	0e1H
	DW	08H
	DW	011H
	DW	08H
	DW	091H
	DW	08H
	DW	051H
	DW	08H
	DW	0d1H
	DW	08H
	DW	031H
	DW	08H
	DW	0b1H
	DW	08H
	DW	071H
	DW	08H
	DW	0f1H
	DW	08H
	DW	09H
	DW	08H
	DW	089H
	DW	08H
	DW	049H
	DW	08H
	DW	0c9H
	DW	08H
	DW	029H
	DW	08H
	DW	0a9H
	DW	08H
	DW	069H
	DW	08H
	DW	0e9H
	DW	08H
	DW	019H
	DW	08H
	DW	099H
	DW	08H
	DW	059H
	DW	08H
	DW	0d9H
	DW	08H
	DW	039H
	DW	08H
	DW	0b9H
	DW	08H
	DW	079H
	DW	08H
	DW	0f9H
	DW	08H
	DW	05H
	DW	08H
	DW	085H
	DW	08H
	DW	045H
	DW	08H
	DW	0c5H
	DW	08H
	DW	025H
	DW	08H
	DW	0a5H
	DW	08H
	DW	065H
	DW	08H
	DW	0e5H
	DW	08H
	DW	015H
	DW	08H
	DW	095H
	DW	08H
	DW	055H
	DW	08H
	DW	0d5H
	DW	08H
	DW	035H
	DW	08H
	DW	0b5H
	DW	08H
	DW	075H
	DW	08H
	DW	0f5H
	DW	08H
	DW	0dH
	DW	08H
	DW	08dH
	DW	08H
	DW	04dH
	DW	08H
	DW	0cdH
	DW	08H
	DW	02dH
	DW	08H
	DW	0adH
	DW	08H
	DW	06dH
	DW	08H
	DW	0edH
	DW	08H
	DW	01dH
	DW	08H
	DW	09dH
	DW	08H
	DW	05dH
	DW	08H
	DW	0ddH
	DW	08H
	DW	03dH
	DW	08H
	DW	0bdH
	DW	08H
	DW	07dH
	DW	08H
	DW	0fdH
	DW	08H
	DW	013H
	DW	09H
	DW	0113H
	DW	09H
	DW	093H
	DW	09H
	DW	0193H
	DW	09H
	DW	053H
	DW	09H
	DW	0153H
	DW	09H
	DW	0d3H
	DW	09H
	DW	01d3H
	DW	09H
	DW	033H
	DW	09H
	DW	0133H
	DW	09H
	DW	0b3H
	DW	09H
	DW	01b3H
	DW	09H
	DW	073H
	DW	09H
	DW	0173H
	DW	09H
	DW	0f3H
	DW	09H
	DW	01f3H
	DW	09H
	DW	0bH
	DW	09H
	DW	010bH
	DW	09H
	DW	08bH
	DW	09H
	DW	018bH
	DW	09H
	DW	04bH
	DW	09H
	DW	014bH
	DW	09H
	DW	0cbH
	DW	09H
	DW	01cbH
	DW	09H
	DW	02bH
	DW	09H
	DW	012bH
	DW	09H
	DW	0abH
	DW	09H
	DW	01abH
	DW	09H
	DW	06bH
	DW	09H
	DW	016bH
	DW	09H
	DW	0ebH
	DW	09H
	DW	01ebH
	DW	09H
	DW	01bH
	DW	09H
	DW	011bH
	DW	09H
	DW	09bH
	DW	09H
	DW	019bH
	DW	09H
	DW	05bH
	DW	09H
	DW	015bH
	DW	09H
	DW	0dbH
	DW	09H
	DW	01dbH
	DW	09H
	DW	03bH
	DW	09H
	DW	013bH
	DW	09H
	DW	0bbH
	DW	09H
	DW	01bbH
	DW	09H
	DW	07bH
	DW	09H
	DW	017bH
	DW	09H
	DW	0fbH
	DW	09H
	DW	01fbH
	DW	09H
	DW	07H
	DW	09H
	DW	0107H
	DW	09H
	DW	087H
	DW	09H
	DW	0187H
	DW	09H
	DW	047H
	DW	09H
	DW	0147H
	DW	09H
	DW	0c7H
	DW	09H
	DW	01c7H
	DW	09H
	DW	027H
	DW	09H
	DW	0127H
	DW	09H
	DW	0a7H
	DW	09H
	DW	01a7H
	DW	09H
	DW	067H
	DW	09H
	DW	0167H
	DW	09H
	DW	0e7H
	DW	09H
	DW	01e7H
	DW	09H
	DW	017H
	DW	09H
	DW	0117H
	DW	09H
	DW	097H
	DW	09H
	DW	0197H
	DW	09H
	DW	057H
	DW	09H
	DW	0157H
	DW	09H
	DW	0d7H
	DW	09H
	DW	01d7H
	DW	09H
	DW	037H
	DW	09H
	DW	0137H
	DW	09H
	DW	0b7H
	DW	09H
	DW	01b7H
	DW	09H
	DW	077H
	DW	09H
	DW	0177H
	DW	09H
	DW	0f7H
	DW	09H
	DW	01f7H
	DW	09H
	DW	0fH
	DW	09H
	DW	010fH
	DW	09H
	DW	08fH
	DW	09H
	DW	018fH
	DW	09H
	DW	04fH
	DW	09H
	DW	014fH
	DW	09H
	DW	0cfH
	DW	09H
	DW	01cfH
	DW	09H
	DW	02fH
	DW	09H
	DW	012fH
	DW	09H
	DW	0afH
	DW	09H
	DW	01afH
	DW	09H
	DW	06fH
	DW	09H
	DW	016fH
	DW	09H
	DW	0efH
	DW	09H
	DW	01efH
	DW	09H
	DW	01fH
	DW	09H
	DW	011fH
	DW	09H
	DW	09fH
	DW	09H
	DW	019fH
	DW	09H
	DW	05fH
	DW	09H
	DW	015fH
	DW	09H
	DW	0dfH
	DW	09H
	DW	01dfH
	DW	09H
	DW	03fH
	DW	09H
	DW	013fH
	DW	09H
	DW	0bfH
	DW	09H
	DW	01bfH
	DW	09H
	DW	07fH
	DW	09H
	DW	017fH
	DW	09H
	DW	0ffH
	DW	09H
	DW	01ffH
	DW	09H
	DW	00H
	DW	07H
	DW	040H
	DW	07H
	DW	020H
	DW	07H
	DW	060H
	DW	07H
	DW	010H
	DW	07H
	DW	050H
	DW	07H
	DW	030H
	DW	07H
	DW	070H
	DW	07H
	DW	08H
	DW	07H
	DW	048H
	DW	07H
	DW	028H
	DW	07H
	DW	068H
	DW	07H
	DW	018H
	DW	07H
	DW	058H
	DW	07H
	DW	038H
	DW	07H
	DW	078H
	DW	07H
	DW	04H
	DW	07H
	DW	044H
	DW	07H
	DW	024H
	DW	07H
	DW	064H
	DW	07H
	DW	014H
	DW	07H
	DW	054H
	DW	07H
	DW	034H
	DW	07H
	DW	074H
	DW	07H
	DW	03H
	DW	08H
	DW	083H
	DW	08H
	DW	043H
	DW	08H
	DW	0c3H
	DW	08H
	DW	023H
	DW	08H
	DW	0a3H
	DW	08H
	DW	063H
	DW	08H
	DW	0e3H
	DW	08H
static_d_desc DQ FLAT:static_dtree
	DQ	FLAT:extra_dbits
	DD	00H
	DD	01eH
	DD	0fH
	ORG $+4
bl_order DB	010H
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__669B3C77_trees@c DB 01H
PUBLIC	_tr_align
PUBLIC	_tr_init
PUBLIC	_tr_flush_block
PUBLIC	_tr_flush_bits
PUBLIC	_tr_stored_block
;	COMDAT pdata
pdata	SEGMENT
$pdata$bi_windup DD imagerel bi_windup
	DD	imagerel bi_windup+265
	DD	imagerel $unwind$bi_windup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bi_flush DD imagerel bi_flush
	DD	imagerel bi_flush+322
	DD	imagerel $unwind$bi_flush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bi_reverse DD imagerel bi_reverse
	DD	imagerel bi_reverse+120
	DD	imagerel $unwind$bi_reverse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$detect_data_type DD imagerel detect_data_type
	DD	imagerel detect_data_type+283
	DD	imagerel $unwind$detect_data_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress_block DD imagerel compress_block
	DD	imagerel compress_block+3030
	DD	imagerel $unwind$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_all_trees DD imagerel send_all_trees
	DD	imagerel send_all_trees+1598
	DD	imagerel $unwind$send_all_trees
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_bl_tree DD imagerel build_bl_tree
	DD	imagerel build_bl_tree+250
	DD	imagerel $unwind$build_bl_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_tree DD imagerel send_tree
	DD	imagerel send_tree+3999
	DD	imagerel $unwind$send_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scan_tree DD imagerel scan_tree
	DD	imagerel scan_tree+613
	DD	imagerel $unwind$scan_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_tree DD imagerel build_tree
	DD	imagerel build_tree+1229
	DD	imagerel $unwind$build_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gen_codes DD imagerel gen_codes
	DD	imagerel gen_codes+304
	DD	imagerel $unwind$gen_codes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gen_bitlen DD imagerel gen_bitlen
	DD	imagerel gen_bitlen+1128
	DD	imagerel $unwind$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pqdownheap DD imagerel pqdownheap
	DD	imagerel pqdownheap+578
	DD	imagerel $unwind$pqdownheap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_block DD imagerel init_block
	DD	imagerel init_block+288
	DD	imagerel $unwind$init_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$tr_static_init DD imagerel tr_static_init
	DD	imagerel tr_static_init+39
	DD	imagerel $unwind$tr_static_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_align DD imagerel $LN7
	DD	imagerel $LN7+800
	DD	imagerel $unwind$_tr_align
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_init DD imagerel $LN3
	DD	imagerel $LN3+218
	DD	imagerel $unwind$_tr_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_flush_block DD imagerel $LN17
	DD	imagerel $LN17+1182
	DD	imagerel $unwind$_tr_flush_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_flush_bits DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$_tr_flush_bits
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_stored_block DD imagerel $LN5
	DD	imagerel $LN5+661
	DD	imagerel $unwind$_tr_stored_block
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_stored_block DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_flush_bits DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_flush_block DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_init DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_align DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tr_static_init DD 021501H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_block DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pqdownheap DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gen_bitlen DD 022601H
	DD	0700bd20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gen_codes DD 022a01H
	DD	0700fd213H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
gen_codes$rtcName$0 DB 06eH
	DB	065H
	DB	078H
	DB	074H
	DB	05fH
	DB	063H
	DB	06fH
	DB	064H
	DB	065H
	DB	00H
	ORG $+6
gen_codes$rtcVarDesc DD 028H
	DD	020H
	DQ	FLAT:gen_codes$rtcName$0
	ORG $+48
gen_codes$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:gen_codes$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_tree DD 022301H
	DD	0700bb20fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scan_tree DD 022801H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_tree DD 022e01H
	DD	07010f217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_bl_tree DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_all_trees DD 022c01H
	DD	070149218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress_block DD 022b01H
	DD	07010d214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$detect_data_type DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bi_reverse DD 022001H
	DD	07009520dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bi_flush DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bi_windup DD 021e01H
	DD	07006320aH
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT _tr_stored_block
_TEXT	SEGMENT
len$1 = 32
val$2 = 36
s$ = 64
buf$ = 72
stored_len$ = 80
last$ = 88
_tr_stored_block PROC					; COMDAT

; 868  : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00034	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 869  :     send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */

  00039	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR len$1[rsp], 3
  00041	b8 10 00 00 00	 mov	 eax, 16
  00046	2b 44 24 20	 sub	 eax, DWORD PTR len$1[rsp]
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004f	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00055	0f 8e e7 00 00
	00		 jle	 $LN2@tr_stored_
  0005b	8b 44 24 58	 mov	 eax, DWORD PTR last$[rsp]
  0005f	89 44 24 24	 mov	 DWORD PTR val$2[rsp], eax
  00063	0f b7 44 24 24	 movzx	 eax, WORD PTR val$2[rsp]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006d	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00073	d3 e0		 shl	 eax, cl
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0007a	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00081	0b c8		 or	 ecx, eax
  00083	8b c1		 mov	 eax, ecx
  00085	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0008a	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00096	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0009d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a7	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  000aa	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000af	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000b3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000bb	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000be	ff c0		 inc	 eax
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c5	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000cd	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  000d4	c1 f8 08	 sar	 eax, 8
  000d7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000dc	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  000df	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000e4	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000e8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000eb	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000f0	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000f3	ff c0		 inc	 eax
  000f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000fa	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  000fd	0f b7 44 24 24	 movzx	 eax, WORD PTR val$2[rsp]
  00102	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00107	ba 10 00 00 00	 mov	 edx, 16
  0010c	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00112	8b ca		 mov	 ecx, edx
  00114	d3 f8		 sar	 eax, cl
  00116	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0011b	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00122	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00127	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  0012d	8b 4c 24 20	 mov	 ecx, DWORD PTR len$1[rsp]
  00131	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00135	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0013a	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  00140	eb 48		 jmp	 SHORT $LN3@tr_stored_
$LN2@tr_stored_:
  00142	0f b7 44 24 58	 movzx	 eax, WORD PTR last$[rsp]
  00147	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0014c	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00152	d3 e0		 shl	 eax, cl
  00154	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00159	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00160	0b c8		 or	 ecx, eax
  00162	8b c1		 mov	 eax, ecx
  00164	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00169	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00170	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00175	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  0017b	03 44 24 20	 add	 eax, DWORD PTR len$1[rsp]
  0017f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00184	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN3@tr_stored_:

; 870  :     bi_windup(s);        /* align on byte boundary */

  0018a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0018f	e8 00 00 00 00	 call	 bi_windup

; 871  :     put_short(s, (ush)stored_len);

  00194	0f b7 44 24 50	 movzx	 eax, WORD PTR stored_len$[rsp]
  00199	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0019e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  001a3	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  001a6	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  001ab	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  001af	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001b2	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  001b7	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001ba	ff c0		 inc	 eax
  001bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  001c1	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  001c4	0f b7 44 24 50	 movzx	 eax, WORD PTR stored_len$[rsp]
  001c9	c1 f8 08	 sar	 eax, 8
  001cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  001d1	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  001d4	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  001d9	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  001dd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001e0	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  001e5	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001e8	ff c0		 inc	 eax
  001ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  001ef	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 872  :     put_short(s, (ush)~stored_len);

  001f2	8b 44 24 50	 mov	 eax, DWORD PTR stored_len$[rsp]
  001f6	f7 d0		 not	 eax
  001f8	0f b7 c0	 movzx	 eax, ax
  001fb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00205	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00208	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  0020d	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00211	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00214	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00219	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0021c	ff c0		 inc	 eax
  0021e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00223	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00226	8b 44 24 50	 mov	 eax, DWORD PTR stored_len$[rsp]
  0022a	f7 d0		 not	 eax
  0022c	0f b7 c0	 movzx	 eax, ax
  0022f	c1 f8 08	 sar	 eax, 8
  00232	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00237	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0023a	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  0023f	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00243	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00246	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0024b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0024e	ff c0		 inc	 eax
  00250	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00255	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 873  :     zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);

  00258	8b 44 24 50	 mov	 eax, DWORD PTR stored_len$[rsp]
  0025c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00261	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00264	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  00269	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  0026d	44 8b c0	 mov	 r8d, eax
  00270	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 874  :     s->pending += stored_len;

  0027b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00280	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00283	03 44 24 50	 add	 eax, DWORD PTR stored_len$[rsp]
  00287	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0028c	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 875  : #ifdef ZLIB_DEBUG
; 876  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 877  :     s->compressed_len += (stored_len + 4) << 3;
; 878  :     s->bits_sent += 2*16;
; 879  :     s->bits_sent += stored_len<<3;
; 880  : #endif
; 881  : }

  0028f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00293	5f		 pop	 rdi
  00294	c3		 ret	 0
_tr_stored_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT _tr_flush_bits
_TEXT	SEGMENT
s$ = 48
_tr_flush_bits PROC					; COMDAT

; 888  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 889  :     bi_flush(s);

  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	e8 00 00 00 00	 call	 bi_flush

; 890  : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
_tr_flush_bits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT _tr_flush_block
_TEXT	SEGMENT
opt_lenb$ = 32
static_lenb$ = 36
max_blindex$ = 40
len$1 = 44
val$2 = 48
len$3 = 52
val$4 = 56
s$ = 80
buf$ = 88
stored_len$ = 96
last$ = 104
_tr_flush_block PROC					; COMDAT

; 916  : {

$LN17:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00034	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 917  :     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
; 918  :     int max_blindex = 0;  /* index of last bit length code of non zero freq */

  00039	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR max_blindex$[rsp], 0

; 919  : 
; 920  :     /* Build the Huffman trees unless a stored block is forced */
; 921  :     if (s->level > 0) {

  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00046	83 b8 ac 00 00
	00 00		 cmp	 DWORD PTR [rax+172], 0
  0004d	0f 8e 9f 00 00
	00		 jle	 $LN2@tr_flush_b

; 922  : 
; 923  :         /* Check if the file is binary or text */
; 924  :         if (s->strm->data_type == Z_UNKNOWN)

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00058	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005b	83 78 48 02	 cmp	 DWORD PTR [rax+72], 2
  0005f	75 15		 jne	 SHORT $LN4@tr_flush_b

; 925  :             s->strm->data_type = detect_data_type(s);

  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00066	e8 00 00 00 00	 call	 detect_data_type
  0006b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00070	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00073	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN4@tr_flush_b:

; 926  : 
; 927  :         /* Construct the literal and distance trees */
; 928  :         build_tree(s, (tree_desc *)(&(s->l_desc)));

  00076	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0007b	48 05 40 0b 00
	00		 add	 rax, 2880		; 00000b40H
  00081	48 8b d0	 mov	 rdx, rax
  00084	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00089	e8 00 00 00 00	 call	 build_tree

; 929  :         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
; 930  :                 s->static_len));
; 931  : 
; 932  :         build_tree(s, (tree_desc *)(&(s->d_desc)));

  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00093	48 05 58 0b 00
	00		 add	 rax, 2904		; 00000b58H
  00099	48 8b d0	 mov	 rdx, rax
  0009c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000a1	e8 00 00 00 00	 call	 build_tree

; 933  :         Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
; 934  :                 s->static_len));
; 935  :         /* At this point, opt_len and static_len are the total bit lengths of
; 936  :          * the compressed block data, excluding the tree representations.
; 937  :          */
; 938  : 
; 939  :         /* Build the bit length tree for the above two trees, and get the index
; 940  :          * in bl_order of the last bit length code to send.
; 941  :          */
; 942  :         max_blindex = build_bl_tree(s);

  000a6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000ab	e8 00 00 00 00	 call	 build_bl_tree
  000b0	89 44 24 28	 mov	 DWORD PTR max_blindex$[rsp], eax

; 943  : 
; 944  :         /* Determine the best encoding. Compute the block lengths in bytes. */
; 945  :         opt_lenb = (s->opt_len+3+7)>>3;

  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000b9	8b 80 00 17 00
	00		 mov	 eax, DWORD PTR [rax+5888]
  000bf	83 c0 0a	 add	 eax, 10
  000c2	c1 e8 03	 shr	 eax, 3
  000c5	89 44 24 20	 mov	 DWORD PTR opt_lenb$[rsp], eax

; 946  :         static_lenb = (s->static_len+3+7)>>3;

  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000ce	8b 80 04 17 00
	00		 mov	 eax, DWORD PTR [rax+5892]
  000d4	83 c0 0a	 add	 eax, 10
  000d7	c1 e8 03	 shr	 eax, 3
  000da	89 44 24 24	 mov	 DWORD PTR static_lenb$[rsp], eax

; 947  : 
; 948  :         Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
; 949  :                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
; 950  :                 s->last_lit));
; 951  : 
; 952  :         if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

  000de	8b 44 24 20	 mov	 eax, DWORD PTR opt_lenb$[rsp]
  000e2	39 44 24 24	 cmp	 DWORD PTR static_lenb$[rsp], eax
  000e6	77 08		 ja	 SHORT $LN5@tr_flush_b
  000e8	8b 44 24 24	 mov	 eax, DWORD PTR static_lenb$[rsp]
  000ec	89 44 24 20	 mov	 DWORD PTR opt_lenb$[rsp], eax
$LN5@tr_flush_b:

; 953  : 
; 954  :     } else {

  000f0	eb 13		 jmp	 SHORT $LN3@tr_flush_b
$LN2@tr_flush_b:

; 955  :         Assert(buf != (char*)0, "lost buf");
; 956  :         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */

  000f2	8b 44 24 60	 mov	 eax, DWORD PTR stored_len$[rsp]
  000f6	83 c0 05	 add	 eax, 5
  000f9	89 44 24 24	 mov	 DWORD PTR static_lenb$[rsp], eax
  000fd	8b 44 24 24	 mov	 eax, DWORD PTR static_lenb$[rsp]
  00101	89 44 24 20	 mov	 DWORD PTR opt_lenb$[rsp], eax
$LN3@tr_flush_b:

; 957  :     }
; 958  : 
; 959  : #ifdef FORCE_STORED
; 960  :     if (buf != (char*)0) { /* force stored block */
; 961  : #else
; 962  :     if (stored_len+4 <= opt_lenb && buf != (char*)0) {

  00105	8b 44 24 60	 mov	 eax, DWORD PTR stored_len$[rsp]
  00109	83 c0 04	 add	 eax, 4
  0010c	3b 44 24 20	 cmp	 eax, DWORD PTR opt_lenb$[rsp]
  00110	77 29		 ja	 SHORT $LN6@tr_flush_b
  00112	48 83 7c 24 58
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00118	74 21		 je	 SHORT $LN6@tr_flush_b

; 963  :                        /* 4: two words for the lengths */
; 964  : #endif
; 965  :         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
; 966  :          * Otherwise we can't have processed more than WSIZE input bytes since
; 967  :          * the last block flush, because compression would have been
; 968  :          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
; 969  :          * transform a block into a stored block.
; 970  :          */
; 971  :         _tr_stored_block(s, buf, stored_len, last);

  0011a	0f ae e8	 lfence
  0011d	44 8b 4c 24 68	 mov	 r9d, DWORD PTR last$[rsp]
  00122	44 8b 44 24 60	 mov	 r8d, DWORD PTR stored_len$[rsp]
  00127	48 8b 54 24 58	 mov	 rdx, QWORD PTR buf$[rsp]
  0012c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00131	e8 00 00 00 00	 call	 _tr_stored_block
  00136	e9 42 03 00 00	 jmp	 $LN7@tr_flush_b
$LN6@tr_flush_b:

; 972  : 
; 973  : #ifdef FORCE_STATIC
; 974  :     } else if (static_lenb >= 0) { /* force static trees */
; 975  : #else
; 976  :     } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {

  0013b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00140	83 b8 b0 00 00
	00 04		 cmp	 DWORD PTR [rax+176], 4
  00147	74 0e		 je	 SHORT $LN10@tr_flush_b
  00149	8b 44 24 20	 mov	 eax, DWORD PTR opt_lenb$[rsp]
  0014d	39 44 24 24	 cmp	 DWORD PTR static_lenb$[rsp], eax
  00151	0f 85 76 01 00
	00		 jne	 $LN8@tr_flush_b
$LN10@tr_flush_b:

; 977  : #endif
; 978  :         send_bits(s, (STATIC_TREES<<1)+last, 3);

  00157	c7 44 24 2c 03
	00 00 00	 mov	 DWORD PTR len$1[rsp], 3
  0015f	b8 10 00 00 00	 mov	 eax, 16
  00164	2b 44 24 2c	 sub	 eax, DWORD PTR len$1[rsp]
  00168	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0016d	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00173	0f 8e ea 00 00
	00		 jle	 $LN11@tr_flush_b
  00179	8b 44 24 68	 mov	 eax, DWORD PTR last$[rsp]
  0017d	83 c0 02	 add	 eax, 2
  00180	89 44 24 30	 mov	 DWORD PTR val$2[rsp], eax
  00184	0f b7 44 24 30	 movzx	 eax, WORD PTR val$2[rsp]
  00189	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0018e	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00194	d3 e0		 shl	 eax, cl
  00196	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0019b	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  001a2	0b c8		 or	 ecx, eax
  001a4	8b c1		 mov	 eax, ecx
  001a6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001ab	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  001b2	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001b7	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  001be	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001c8	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  001cb	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  001d0	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  001d4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001d7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001dc	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001df	ff c0		 inc	 eax
  001e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001e6	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  001e9	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001ee	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  001f5	c1 f8 08	 sar	 eax, 8
  001f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001fd	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00200	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  00205	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00209	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0020c	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00211	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00214	ff c0		 inc	 eax
  00216	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0021b	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0021e	0f b7 44 24 30	 movzx	 eax, WORD PTR val$2[rsp]
  00223	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00228	ba 10 00 00 00	 mov	 edx, 16
  0022d	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00233	8b ca		 mov	 ecx, edx
  00235	d3 f8		 sar	 eax, cl
  00237	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0023c	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00243	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00248	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  0024e	8b 4c 24 2c	 mov	 ecx, DWORD PTR len$1[rsp]
  00252	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00256	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0025b	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  00261	eb 4d		 jmp	 SHORT $LN12@tr_flush_b
$LN11@tr_flush_b:
  00263	8b 44 24 68	 mov	 eax, DWORD PTR last$[rsp]
  00267	83 c0 02	 add	 eax, 2
  0026a	0f b7 c0	 movzx	 eax, ax
  0026d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00272	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00278	d3 e0		 shl	 eax, cl
  0027a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0027f	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00286	0b c8		 or	 ecx, eax
  00288	8b c1		 mov	 eax, ecx
  0028a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0028f	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00296	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0029b	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  002a1	03 44 24 2c	 add	 eax, DWORD PTR len$1[rsp]
  002a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002aa	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN12@tr_flush_b:

; 979  :         compress_block(s, (const ct_data *)static_ltree,

  002b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:static_dtree
  002b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:static_ltree
  002be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002c3	e8 00 00 00 00	 call	 compress_block

; 980  :                        (const ct_data *)static_dtree);
; 981  : #ifdef ZLIB_DEBUG
; 982  :         s->compressed_len += 3 + s->static_len;
; 983  : #endif
; 984  :     } else {

  002c8	e9 b0 01 00 00	 jmp	 $LN9@tr_flush_b
$LN8@tr_flush_b:

; 985  :         send_bits(s, (DYN_TREES<<1)+last, 3);

  002cd	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR len$3[rsp], 3
  002d5	b8 10 00 00 00	 mov	 eax, 16
  002da	2b 44 24 34	 sub	 eax, DWORD PTR len$3[rsp]
  002de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002e3	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  002e9	0f 8e ea 00 00
	00		 jle	 $LN13@tr_flush_b
  002ef	8b 44 24 68	 mov	 eax, DWORD PTR last$[rsp]
  002f3	83 c0 04	 add	 eax, 4
  002f6	89 44 24 38	 mov	 DWORD PTR val$4[rsp], eax
  002fa	0f b7 44 24 38	 movzx	 eax, WORD PTR val$4[rsp]
  002ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00304	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  0030a	d3 e0		 shl	 eax, cl
  0030c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00311	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00318	0b c8		 or	 ecx, eax
  0031a	8b c1		 mov	 eax, ecx
  0031c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00321	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00328	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0032d	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00334	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00339	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0033e	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00341	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  00346	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0034a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0034d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00352	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00355	ff c0		 inc	 eax
  00357	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0035c	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0035f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00364	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0036b	c1 f8 08	 sar	 eax, 8
  0036e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00373	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00376	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  0037b	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0037f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00382	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00387	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0038a	ff c0		 inc	 eax
  0038c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00391	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00394	0f b7 44 24 38	 movzx	 eax, WORD PTR val$4[rsp]
  00399	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0039e	ba 10 00 00 00	 mov	 edx, 16
  003a3	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  003a9	8b ca		 mov	 ecx, edx
  003ab	d3 f8		 sar	 eax, cl
  003ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  003b2	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  003b9	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  003be	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  003c4	8b 4c 24 34	 mov	 ecx, DWORD PTR len$3[rsp]
  003c8	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  003cc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  003d1	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  003d7	eb 4d		 jmp	 SHORT $LN14@tr_flush_b
$LN13@tr_flush_b:
  003d9	8b 44 24 68	 mov	 eax, DWORD PTR last$[rsp]
  003dd	83 c0 04	 add	 eax, 4
  003e0	0f b7 c0	 movzx	 eax, ax
  003e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  003e8	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  003ee	d3 e0		 shl	 eax, cl
  003f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  003f5	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  003fc	0b c8		 or	 ecx, eax
  003fe	8b c1		 mov	 eax, ecx
  00400	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00405	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0040c	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00411	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00417	03 44 24 34	 add	 eax, DWORD PTR len$3[rsp]
  0041b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00420	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN14@tr_flush_b:

; 986  :         send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,

  00426	8b 44 24 28	 mov	 eax, DWORD PTR max_blindex$[rsp]
  0042a	ff c0		 inc	 eax
  0042c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00431	8b 89 60 0b 00
	00		 mov	 ecx, DWORD PTR [rcx+2912]
  00437	ff c1		 inc	 ecx
  00439	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  0043e	8b 92 48 0b 00
	00		 mov	 edx, DWORD PTR [rdx+2888]
  00444	ff c2		 inc	 edx
  00446	44 8b c8	 mov	 r9d, eax
  00449	44 8b c1	 mov	 r8d, ecx
  0044c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00451	e8 00 00 00 00	 call	 send_all_trees

; 987  :                        max_blindex+1);
; 988  :         compress_block(s, (const ct_data *)s->dyn_ltree,

  00456	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0045b	48 05 b0 09 00
	00		 add	 rax, 2480		; 000009b0H
  00461	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00466	48 81 c1 bc 00
	00 00		 add	 rcx, 188		; 000000bcH
  0046d	4c 8b c0	 mov	 r8, rax
  00470	48 8b d1	 mov	 rdx, rcx
  00473	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00478	e8 00 00 00 00	 call	 compress_block
$LN9@tr_flush_b:
$LN7@tr_flush_b:

; 989  :                        (const ct_data *)s->dyn_dtree);
; 990  : #ifdef ZLIB_DEBUG
; 991  :         s->compressed_len += 3 + s->opt_len;
; 992  : #endif
; 993  :     }
; 994  :     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
; 995  :     /* The above check is made mod 2^32, for files larger than 512 MB
; 996  :      * and uLong implemented on 32 bits.
; 997  :      */
; 998  :     init_block(s);

  0047d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00482	e8 00 00 00 00	 call	 init_block

; 999  : 
; 1000 :     if (last) {

  00487	83 7c 24 68 00	 cmp	 DWORD PTR last$[rsp], 0
  0048c	74 0a		 je	 SHORT $LN15@tr_flush_b

; 1001 :         bi_windup(s);

  0048e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00493	e8 00 00 00 00	 call	 bi_windup
$LN15@tr_flush_b:

; 1002 : #ifdef ZLIB_DEBUG
; 1003 :         s->compressed_len += 7;  /* align on byte boundary */
; 1004 : #endif
; 1005 :     }
; 1006 :     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
; 1007 :            s->compressed_len-7*last));
; 1008 : }

  00498	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0049c	5f		 pop	 rdi
  0049d	c3		 ret	 0
_tr_flush_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT _tr_init
_TEXT	SEGMENT
s$ = 48
_tr_init PROC						; COMDAT

; 381  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 382  :     tr_static_init();

  0002a	e8 00 00 00 00	 call	 tr_static_init

; 383  : 
; 384  :     s->l_desc.dyn_tree = s->dyn_ltree;

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00034	48 05 bc 00 00
	00		 add	 rax, 188		; 000000bcH
  0003a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0003f	48 89 81 40 0b
	00 00		 mov	 QWORD PTR [rcx+2880], rax

; 385  :     s->l_desc.stat_desc = &static_l_desc;

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:static_l_desc
  00052	48 89 88 50 0b
	00 00		 mov	 QWORD PTR [rax+2896], rcx

; 386  : 
; 387  :     s->d_desc.dyn_tree = s->dyn_dtree;

  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0005e	48 05 b0 09 00
	00		 add	 rax, 2480		; 000009b0H
  00064	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00069	48 89 81 58 0b
	00 00		 mov	 QWORD PTR [rcx+2904], rax

; 388  :     s->d_desc.stat_desc = &static_d_desc;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:static_d_desc
  0007c	48 89 88 68 0b
	00 00		 mov	 QWORD PTR [rax+2920], rcx

; 389  : 
; 390  :     s->bl_desc.dyn_tree = s->bl_tree;

  00083	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00088	48 05 a4 0a 00
	00		 add	 rax, 2724		; 00000aa4H
  0008e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00093	48 89 81 70 0b
	00 00		 mov	 QWORD PTR [rcx+2928], rax

; 391  :     s->bl_desc.stat_desc = &static_bl_desc;

  0009a	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:static_bl_desc
  000a6	48 89 88 80 0b
	00 00		 mov	 QWORD PTR [rax+2944], rcx

; 392  : 
; 393  :     s->bi_buf = 0;

  000ad	33 c0		 xor	 eax, eax
  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000b4	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax

; 394  :     s->bi_valid = 0;

  000bb	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000c0	c7 80 14 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5908], 0

; 395  : #ifdef ZLIB_DEBUG
; 396  :     s->compressed_len = 0L;
; 397  :     s->bits_sent = 0L;
; 398  : #endif
; 399  : 
; 400  :     /* Initialize the first block of the first file: */
; 401  :     init_block(s);

  000ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	e8 00 00 00 00	 call	 init_block

; 402  : }

  000d4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d8	5f		 pop	 rdi
  000d9	c3		 ret	 0
_tr_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT _tr_align
_TEXT	SEGMENT
len$1 = 32
val$2 = 36
len$3 = 40
val$4 = 44
tv280 = 48
s$ = 80
_tr_align PROC						; COMDAT

; 898  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 899  :     send_bits(s, STATIC_TREES<<1, 3);

  0002a	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR len$1[rsp], 3
  00032	b8 10 00 00 00	 mov	 eax, 16
  00037	2b 44 24 20	 sub	 eax, DWORD PTR len$1[rsp]
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00040	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00046	0f 8e e7 00 00
	00		 jle	 $LN2@tr_align
  0004c	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR val$2[rsp], 2
  00054	0f b7 44 24 24	 movzx	 eax, WORD PTR val$2[rsp]
  00059	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0005e	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00064	d3 e0		 shl	 eax, cl
  00066	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0006b	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00072	0b c8		 or	 ecx, eax
  00074	8b c1		 mov	 eax, ecx
  00076	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0007b	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00087	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00098	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0009b	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  000a0	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000a4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000a7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000ac	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000af	ff c0		 inc	 eax
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000b6	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  000b9	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000be	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  000c5	c1 f8 08	 sar	 eax, 8
  000c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000cd	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  000d0	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  000d5	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000d9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000dc	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000e1	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000e4	ff c0		 inc	 eax
  000e6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000eb	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  000ee	0f b7 44 24 24	 movzx	 eax, WORD PTR val$2[rsp]
  000f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000f8	ba 10 00 00 00	 mov	 edx, 16
  000fd	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00103	8b ca		 mov	 ecx, edx
  00105	d3 f8		 sar	 eax, cl
  00107	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0010c	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00113	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00118	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  0011e	8b 4c 24 20	 mov	 ecx, DWORD PTR len$1[rsp]
  00122	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00126	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0012b	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  00131	eb 53		 jmp	 SHORT $LN3@tr_align
$LN2@tr_align:
  00133	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00138	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  0013e	b9 02 00 00 00	 mov	 ecx, 2
  00143	89 4c 24 30	 mov	 DWORD PTR tv280[rsp], ecx
  00147	0f b6 c8	 movzx	 ecx, al
  0014a	8b 44 24 30	 mov	 eax, DWORD PTR tv280[rsp]
  0014e	d3 e0		 shl	 eax, cl
  00150	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00155	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  0015c	0b c8		 or	 ecx, eax
  0015e	8b c1		 mov	 eax, ecx
  00160	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00165	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0016c	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00171	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00177	03 44 24 20	 add	 eax, DWORD PTR len$1[rsp]
  0017b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00180	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN3@tr_align:

; 900  :     send_code(s, END_BLOCK, static_ltree);

  00186	b8 04 00 00 00	 mov	 eax, 4
  0018b	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:static_ltree
  00199	0f b7 44 01 02	 movzx	 eax, WORD PTR [rcx+rax+2]
  0019e	89 44 24 28	 mov	 DWORD PTR len$3[rsp], eax
  001a2	b8 10 00 00 00	 mov	 eax, 16
  001a7	2b 44 24 28	 sub	 eax, DWORD PTR len$3[rsp]
  001ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001b0	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  001b6	0f 8e fa 00 00
	00		 jle	 $LN4@tr_align
  001bc	b8 04 00 00 00	 mov	 eax, 4
  001c1	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:static_ltree
  001cf	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  001d3	89 44 24 2c	 mov	 DWORD PTR val$4[rsp], eax
  001d7	0f b7 44 24 2c	 movzx	 eax, WORD PTR val$4[rsp]
  001dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001e1	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  001e7	d3 e0		 shl	 eax, cl
  001e9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001ee	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  001f5	0b c8		 or	 ecx, eax
  001f7	8b c1		 mov	 eax, ecx
  001f9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001fe	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00205	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0020a	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00211	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00216	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0021b	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0021e	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  00223	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00227	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0022a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0022f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00232	ff c0		 inc	 eax
  00234	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00239	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0023c	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00241	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00248	c1 f8 08	 sar	 eax, 8
  0024b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00250	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00253	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  00258	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0025c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0025f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00264	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00267	ff c0		 inc	 eax
  00269	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0026e	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00271	0f b7 44 24 2c	 movzx	 eax, WORD PTR val$4[rsp]
  00276	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0027b	ba 10 00 00 00	 mov	 edx, 16
  00280	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00286	8b ca		 mov	 ecx, edx
  00288	d3 f8		 sar	 eax, cl
  0028a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0028f	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00296	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0029b	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  002a1	8b 4c 24 28	 mov	 ecx, DWORD PTR len$3[rsp]
  002a5	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  002a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002ae	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  002b4	eb 5a		 jmp	 SHORT $LN5@tr_align
$LN4@tr_align:
  002b6	b8 04 00 00 00	 mov	 eax, 4
  002bb	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  002c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:static_ltree
  002c9	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  002cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002d2	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  002d8	d3 e0		 shl	 eax, cl
  002da	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002df	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  002e6	0b c8		 or	 ecx, eax
  002e8	8b c1		 mov	 eax, ecx
  002ea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002ef	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  002f6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002fb	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00301	03 44 24 28	 add	 eax, DWORD PTR len$3[rsp]
  00305	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0030a	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN5@tr_align:

; 901  : #ifdef ZLIB_DEBUG
; 902  :     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
; 903  : #endif
; 904  :     bi_flush(s);

  00310	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00315	e8 00 00 00 00	 call	 bi_flush

; 905  : }

  0031a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0031e	5f		 pop	 rdi
  0031f	c3		 ret	 0
_tr_align ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT tr_static_init
_TEXT	SEGMENT
tr_static_init PROC					; COMDAT

; 233  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b fc	 mov	 rdi, rsp
  00009	b9 08 00 00 00	 mov	 ecx, 8
  0000e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00013	f3 ab		 rep stosd
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0001c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 234  : #if defined(GEN_TREES_H) || !defined(STDC)
; 235  :     static int static_init_done = 0;
; 236  :     int n;        /* iterates over tree elements */
; 237  :     int bits;     /* bit counter */
; 238  :     int length;   /* length value */
; 239  :     int code;     /* code value */
; 240  :     int dist;     /* distance index */
; 241  :     ush bl_count[MAX_BITS+1];
; 242  :     /* number of codes at each bit length for an optimal tree */
; 243  : 
; 244  :     if (static_init_done) return;
; 245  : 
; 246  :     /* For some embedded targets, global variables are not initialized: */
; 247  : #ifdef NO_INIT_GLOBAL_POINTERS
; 248  :     static_l_desc.static_tree = static_ltree;
; 249  :     static_l_desc.extra_bits = extra_lbits;
; 250  :     static_d_desc.static_tree = static_dtree;
; 251  :     static_d_desc.extra_bits = extra_dbits;
; 252  :     static_bl_desc.extra_bits = extra_blbits;
; 253  : #endif
; 254  : 
; 255  :     /* Initialize the mapping length (0..255) -> length code (0..28) */
; 256  :     length = 0;
; 257  :     for (code = 0; code < LENGTH_CODES-1; code++) {
; 258  :         base_length[code] = length;
; 259  :         for (n = 0; n < (1<<extra_lbits[code]); n++) {
; 260  :             _length_code[length++] = (uch)code;
; 261  :         }
; 262  :     }
; 263  :     Assert (length == 256, "tr_static_init: length != 256");
; 264  :     /* Note that the length 255 (match length 258) can be represented
; 265  :      * in two different ways: code 284 + 5 bits or code 285, so we
; 266  :      * overwrite length_code[255] to use the best encoding:
; 267  :      */
; 268  :     _length_code[length-1] = (uch)code;
; 269  : 
; 270  :     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
; 271  :     dist = 0;
; 272  :     for (code = 0 ; code < 16; code++) {
; 273  :         base_dist[code] = dist;
; 274  :         for (n = 0; n < (1<<extra_dbits[code]); n++) {
; 275  :             _dist_code[dist++] = (uch)code;
; 276  :         }
; 277  :     }
; 278  :     Assert (dist == 256, "tr_static_init: dist != 256");
; 279  :     dist >>= 7; /* from now on, all distances are divided by 128 */
; 280  :     for ( ; code < D_CODES; code++) {
; 281  :         base_dist[code] = dist << 7;
; 282  :         for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
; 283  :             _dist_code[256 + dist++] = (uch)code;
; 284  :         }
; 285  :     }
; 286  :     Assert (dist == 256, "tr_static_init: 256+dist != 512");
; 287  : 
; 288  :     /* Construct the codes of the static literal tree */
; 289  :     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
; 290  :     n = 0;
; 291  :     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
; 292  :     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
; 293  :     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
; 294  :     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
; 295  :     /* Codes 286 and 287 do not exist, but we must include them in the
; 296  :      * tree construction to get a canonical Huffman tree (longest code
; 297  :      * all ones)
; 298  :      */
; 299  :     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
; 300  : 
; 301  :     /* The static distance tree is trivial: */
; 302  :     for (n = 0; n < D_CODES; n++) {
; 303  :         static_dtree[n].Len = 5;
; 304  :         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
; 305  :     }
; 306  :     static_init_done = 1;
; 307  : 
; 308  : #  ifdef GEN_TREES_H
; 309  :     gen_trees_header();
; 310  : #  endif
; 311  : #endif /* defined(GEN_TREES_H) || !defined(STDC) */
; 312  : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
tr_static_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT init_block
_TEXT	SEGMENT
n$ = 32
s$ = 64
init_block PROC						; COMDAT

; 409  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 410  :     int n; /* iterates over tree elements */
; 411  : 
; 412  :     /* Initialize the trees. */
; 413  :     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;

  0002a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00032	eb 0a		 jmp	 SHORT $LN4@init_block
$LN2@init_block:
  00034	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00038	ff c0		 inc	 eax
  0003a	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN4@init_block:
  0003e	81 7c 24 20 1e
	01 00 00	 cmp	 DWORD PTR n$[rsp], 286	; 0000011eH
  00046	7d 16		 jge	 SHORT $LN3@init_block
  00048	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$[rsp]
  0004d	33 c9		 xor	 ecx, ecx
  0004f	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  00054	66 89 8c 82 bc
	00 00 00	 mov	 WORD PTR [rdx+rax*4+188], cx
  0005c	eb d6		 jmp	 SHORT $LN2@init_block
$LN3@init_block:

; 414  :     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;

  0005e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00066	eb 0a		 jmp	 SHORT $LN7@init_block
$LN5@init_block:
  00068	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0006c	ff c0		 inc	 eax
  0006e	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN7@init_block:
  00072	83 7c 24 20 1e	 cmp	 DWORD PTR n$[rsp], 30
  00077	7d 16		 jge	 SHORT $LN6@init_block
  00079	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$[rsp]
  0007e	33 c9		 xor	 ecx, ecx
  00080	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  00085	66 89 8c 82 b0
	09 00 00	 mov	 WORD PTR [rdx+rax*4+2480], cx
  0008d	eb d9		 jmp	 SHORT $LN5@init_block
$LN6@init_block:

; 415  :     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

  0008f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00097	eb 0a		 jmp	 SHORT $LN10@init_block
$LN8@init_block:
  00099	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN10@init_block:
  000a3	83 7c 24 20 13	 cmp	 DWORD PTR n$[rsp], 19
  000a8	7d 16		 jge	 SHORT $LN9@init_block
  000aa	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$[rsp]
  000af	33 c9		 xor	 ecx, ecx
  000b1	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000b6	66 89 8c 82 a4
	0a 00 00	 mov	 WORD PTR [rdx+rax*4+2724], cx
  000be	eb d9		 jmp	 SHORT $LN8@init_block
$LN9@init_block:

; 416  : 
; 417  :     s->dyn_ltree[END_BLOCK].Freq = 1;

  000c0	b8 04 00 00 00	 mov	 eax, 4
  000c5	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  000cc	b9 01 00 00 00	 mov	 ecx, 1
  000d1	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000d6	66 89 8c 02 bc
	00 00 00	 mov	 WORD PTR [rdx+rax+188], cx

; 418  :     s->opt_len = s->static_len = 0L;

  000de	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000e3	c7 80 04 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5892], 0
  000ed	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000f2	c7 80 00 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5888], 0

; 419  :     s->last_lit = s->matches = 0;

  000fc	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00101	c7 80 08 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5896], 0
  0010b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00110	c7 80 f4 16 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5876], 0

; 420  : }

  0011a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011e	5f		 pop	 rdi
  0011f	c3		 ret	 0
init_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT pqdownheap
_TEXT	SEGMENT
v$ = 32
j$ = 36
s$ = 64
tree$ = 72
k$ = 80
pqdownheap PROC						; COMDAT

; 455  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 456  :     int v = s->heap[k];

  00034	48 63 44 24 50	 movsxd	 rax, DWORD PTR k$[rsp]
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003e	8b 84 81 a8 0b
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+2984]
  00045	89 44 24 20	 mov	 DWORD PTR v$[rsp], eax

; 457  :     int j = k << 1;  /* left son of k */

  00049	8b 44 24 50	 mov	 eax, DWORD PTR k$[rsp]
  0004d	d1 e0		 shl	 eax, 1
  0004f	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN2@pqdownheap:

; 458  :     while (j <= s->heap_len) {

  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00058	8b 80 9c 14 00
	00		 mov	 eax, DWORD PTR [rax+5276]
  0005e	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  00062	0f 8f bf 01 00
	00		 jg	 $LN3@pqdownheap

; 459  :         /* Set j to the smallest of the two sons: */
; 460  :         if (j < s->heap_len &&

  00068	0f ae e8	 lfence
  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00070	8b 80 9c 14 00
	00		 mov	 eax, DWORD PTR [rax+5276]
  00076	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  0007a	0f 8d d6 00 00
	00		 jge	 $LN4@pqdownheap
  00080	0f ae e8	 lfence
  00083	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00087	ff c0		 inc	 eax
  00089	48 98		 cdqe
  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00090	48 63 84 81 a8
	0b 00 00	 movsxd	 rax, DWORD PTR [rcx+rax*4+2984]
  00098	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tree$[rsp]
  0009d	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  000a1	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000a6	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000ab	48 63 8c 8a a8
	0b 00 00	 movsxd	 rcx, DWORD PTR [rdx+rcx*4+2984]
  000b3	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  000b8	0f b7 0c 8a	 movzx	 ecx, WORD PTR [rdx+rcx*4]
  000bc	3b c1		 cmp	 eax, ecx
  000be	0f 8c 88 00 00
	00		 jl	 $LN5@pqdownheap
  000c4	0f ae e8	 lfence
  000c7	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  000cb	ff c0		 inc	 eax
  000cd	48 98		 cdqe
  000cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000d4	48 63 84 81 a8
	0b 00 00	 movsxd	 rax, DWORD PTR [rcx+rax*4+2984]
  000dc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tree$[rsp]
  000e1	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  000e5	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000ea	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000ef	48 63 8c 8a a8
	0b 00 00	 movsxd	 rcx, DWORD PTR [rdx+rcx*4+2984]
  000f7	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  000fc	0f b7 0c 8a	 movzx	 ecx, WORD PTR [rdx+rcx*4]
  00100	3b c1		 cmp	 eax, ecx
  00102	75 52		 jne	 SHORT $LN4@pqdownheap
  00104	0f ae e8	 lfence
  00107	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0010b	ff c0		 inc	 eax
  0010d	48 98		 cdqe
  0010f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00114	48 63 84 81 a8
	0b 00 00	 movsxd	 rax, DWORD PTR [rcx+rax*4+2984]
  0011c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00121	0f b6 84 01 a4
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5284]
  00129	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0012e	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  00133	48 63 8c 8a a8
	0b 00 00	 movsxd	 rcx, DWORD PTR [rdx+rcx*4+2984]
  0013b	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  00140	0f b6 8c 0a a4
	14 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+5284]
  00148	3b c1		 cmp	 eax, ecx
  0014a	7f 0a		 jg	 SHORT $LN4@pqdownheap
$LN5@pqdownheap:

; 461  :             smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
; 462  :             j++;

  0014c	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00150	ff c0		 inc	 eax
  00152	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@pqdownheap:

; 463  :         }
; 464  :         /* Exit if v is smaller than both sons */
; 465  :         if (smaller(tree, v, s->heap[j], s->depth)) break;

  00156	48 63 44 24 20	 movsxd	 rax, DWORD PTR v$[rsp]
  0015b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tree$[rsp]
  00160	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  00164	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00169	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  0016e	48 63 8c 8a a8
	0b 00 00	 movsxd	 rcx, DWORD PTR [rdx+rcx*4+2984]
  00176	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  0017b	0f b7 0c 8a	 movzx	 ecx, WORD PTR [rdx+rcx*4]
  0017f	3b c1		 cmp	 eax, ecx
  00181	7c 68		 jl	 SHORT $LN7@pqdownheap
  00183	0f ae e8	 lfence
  00186	48 63 44 24 20	 movsxd	 rax, DWORD PTR v$[rsp]
  0018b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tree$[rsp]
  00190	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  00194	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00199	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  0019e	48 63 8c 8a a8
	0b 00 00	 movsxd	 rcx, DWORD PTR [rdx+rcx*4+2984]
  001a6	48 8b 54 24 48	 mov	 rdx, QWORD PTR tree$[rsp]
  001ab	0f b7 0c 8a	 movzx	 ecx, WORD PTR [rdx+rcx*4]
  001af	3b c1		 cmp	 eax, ecx
  001b1	75 3a		 jne	 SHORT $LN6@pqdownheap
  001b3	0f ae e8	 lfence
  001b6	48 63 44 24 20	 movsxd	 rax, DWORD PTR v$[rsp]
  001bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  001c0	0f b6 84 01 a4
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5284]
  001c8	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  001cd	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  001d2	48 63 8c 8a a8
	0b 00 00	 movsxd	 rcx, DWORD PTR [rdx+rcx*4+2984]
  001da	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  001df	0f b6 8c 0a a4
	14 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+5284]
  001e7	3b c1		 cmp	 eax, ecx
  001e9	7f 02		 jg	 SHORT $LN6@pqdownheap
$LN7@pqdownheap:
  001eb	eb 3a		 jmp	 SHORT $LN3@pqdownheap
$LN6@pqdownheap:

; 466  : 
; 467  :         /* Exchange v with the smallest son */
; 468  :         s->heap[k] = s->heap[j];  k = j;

  001ed	48 63 44 24 24	 movsxd	 rax, DWORD PTR j$[rsp]
  001f2	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR k$[rsp]
  001f7	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  001fc	4c 8b 44 24 40	 mov	 r8, QWORD PTR s$[rsp]
  00201	41 8b 84 80 a8
	0b 00 00	 mov	 eax, DWORD PTR [r8+rax*4+2984]
  00209	89 84 8a a8 0b
	00 00		 mov	 DWORD PTR [rdx+rcx*4+2984], eax
  00210	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00214	89 44 24 50	 mov	 DWORD PTR k$[rsp], eax

; 469  : 
; 470  :         /* And continue down the tree, setting j to the left son of k */
; 471  :         j <<= 1;

  00218	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0021c	d1 e0		 shl	 eax, 1
  0021e	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax

; 472  :     }

  00222	e9 2c fe ff ff	 jmp	 $LN2@pqdownheap
$LN3@pqdownheap:

; 473  :     s->heap[k] = v;

  00227	48 63 44 24 50	 movsxd	 rax, DWORD PTR k$[rsp]
  0022c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00231	8b 54 24 20	 mov	 edx, DWORD PTR v$[rsp]
  00235	89 94 81 a8 0b
	00 00		 mov	 DWORD PTR [rcx+rax*4+2984], edx

; 474  : }

  0023c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00240	5f		 pop	 rdi
  00241	c3		 ret	 0
pqdownheap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT gen_bitlen
_TEXT	SEGMENT
tree$ = 32
max_code$ = 40
stree$ = 48
extra$ = 56
base$ = 64
max_length$ = 68
h$ = 72
n$ = 76
m$ = 80
bits$ = 84
xbits$ = 88
f$ = 92
overflow$ = 96
s$ = 128
desc$ = 136
gen_bitlen PROC						; COMDAT

; 489  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 1c 00 00 00	 mov	 ecx, 28
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 490  :     ct_data *tree        = desc->dyn_tree;

  00032	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR desc$[rsp]
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003d	48 89 44 24 20	 mov	 QWORD PTR tree$[rsp], rax

; 491  :     int max_code         = desc->max_code;

  00042	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR desc$[rsp]
  0004a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004d	89 44 24 28	 mov	 DWORD PTR max_code$[rsp], eax

; 492  :     const ct_data *stree = desc->stat_desc->static_tree;

  00051	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR desc$[rsp]
  00059	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00060	48 89 44 24 30	 mov	 QWORD PTR stree$[rsp], rax

; 493  :     const intf *extra    = desc->stat_desc->extra_bits;

  00065	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR desc$[rsp]
  0006d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00071	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00075	48 89 44 24 38	 mov	 QWORD PTR extra$[rsp], rax

; 494  :     int base             = desc->stat_desc->extra_base;

  0007a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR desc$[rsp]
  00082	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00086	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00089	89 44 24 40	 mov	 DWORD PTR base$[rsp], eax

; 495  :     int max_length       = desc->stat_desc->max_length;

  0008d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR desc$[rsp]
  00095	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00099	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0009c	89 44 24 44	 mov	 DWORD PTR max_length$[rsp], eax

; 496  :     int h;              /* heap index */
; 497  :     int n, m;           /* iterate over the tree elements */
; 498  :     int bits;           /* bit length */
; 499  :     int xbits;          /* extra bits */
; 500  :     ush f;              /* frequency */
; 501  :     int overflow = 0;   /* number of elements with bit length too large */

  000a0	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR overflow$[rsp], 0

; 502  : 
; 503  :     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

  000a8	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  000b0	eb 0a		 jmp	 SHORT $LN4@gen_bitlen
$LN2@gen_bitlen:
  000b2	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  000b6	ff c0		 inc	 eax
  000b8	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
$LN4@gen_bitlen:
  000bc	83 7c 24 54 0f	 cmp	 DWORD PTR bits$[rsp], 15
  000c1	7f 19		 jg	 SHORT $LN3@gen_bitlen
  000c3	48 63 44 24 54	 movsxd	 rax, DWORD PTR bits$[rsp]
  000c8	33 c9		 xor	 ecx, ecx
  000ca	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  000d2	66 89 8c 42 88
	0b 00 00	 mov	 WORD PTR [rdx+rax*2+2952], cx
  000da	eb d6		 jmp	 SHORT $LN2@gen_bitlen
$LN3@gen_bitlen:

; 504  : 
; 505  :     /* In a first pass, compute the optimal bit lengths (which may
; 506  :      * overflow in the case of the bit length tree).
; 507  :      */
; 508  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

  000dc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000e4	48 63 80 a0 14
	00 00		 movsxd	 rax, DWORD PTR [rax+5280]
  000eb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f3	48 63 84 81 a8
	0b 00 00	 movsxd	 rax, DWORD PTR [rcx+rax*4+2984]
  000fb	33 c9		 xor	 ecx, ecx
  000fd	48 8b 54 24 20	 mov	 rdx, QWORD PTR tree$[rsp]
  00102	66 89 4c 82 02	 mov	 WORD PTR [rdx+rax*4+2], cx

; 509  : 
; 510  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  00107	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0010f	8b 80 a0 14 00
	00		 mov	 eax, DWORD PTR [rax+5280]
  00115	ff c0		 inc	 eax
  00117	89 44 24 48	 mov	 DWORD PTR h$[rsp], eax
  0011b	eb 0a		 jmp	 SHORT $LN7@gen_bitlen
$LN5@gen_bitlen:
  0011d	8b 44 24 48	 mov	 eax, DWORD PTR h$[rsp]
  00121	ff c0		 inc	 eax
  00123	89 44 24 48	 mov	 DWORD PTR h$[rsp], eax
$LN7@gen_bitlen:
  00127	81 7c 24 48 3d
	02 00 00	 cmp	 DWORD PTR h$[rsp], 573	; 0000023dH
  0012f	0f 8d 59 01 00
	00		 jge	 $LN6@gen_bitlen

; 511  :         n = s->heap[h];

  00135	0f ae e8	 lfence
  00138	48 63 44 24 48	 movsxd	 rax, DWORD PTR h$[rsp]
  0013d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00145	8b 84 81 a8 0b
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+2984]
  0014c	89 44 24 4c	 mov	 DWORD PTR n$[rsp], eax

; 512  :         bits = tree[tree[n].Dad].Len + 1;

  00150	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  00155	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  0015a	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  0015f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  00164	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  00169	ff c0		 inc	 eax
  0016b	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax

; 513  :         if (bits > max_length) bits = max_length, overflow++;

  0016f	8b 44 24 44	 mov	 eax, DWORD PTR max_length$[rsp]
  00173	39 44 24 54	 cmp	 DWORD PTR bits$[rsp], eax
  00177	7e 12		 jle	 SHORT $LN18@gen_bitlen
  00179	8b 44 24 44	 mov	 eax, DWORD PTR max_length$[rsp]
  0017d	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  00181	8b 44 24 60	 mov	 eax, DWORD PTR overflow$[rsp]
  00185	ff c0		 inc	 eax
  00187	89 44 24 60	 mov	 DWORD PTR overflow$[rsp], eax
$LN18@gen_bitlen:

; 514  :         tree[n].Len = (ush)bits;

  0018b	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  00190	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  00195	0f b7 54 24 54	 movzx	 edx, WORD PTR bits$[rsp]
  0019a	66 89 54 81 02	 mov	 WORD PTR [rcx+rax*4+2], dx

; 515  :         /* We overwrite tree[n].Dad which is no longer needed */
; 516  : 
; 517  :         if (n > max_code) continue; /* not a leaf node */

  0019f	8b 44 24 28	 mov	 eax, DWORD PTR max_code$[rsp]
  001a3	39 44 24 4c	 cmp	 DWORD PTR n$[rsp], eax
  001a7	7e 05		 jle	 SHORT $LN19@gen_bitlen
  001a9	e9 6f ff ff ff	 jmp	 $LN5@gen_bitlen
$LN19@gen_bitlen:

; 518  : 
; 519  :         s->bl_count[bits]++;

  001ae	48 63 44 24 54	 movsxd	 rax, DWORD PTR bits$[rsp]
  001b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001bb	0f b7 84 41 88
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2952]
  001c3	66 ff c0	 inc	 ax
  001c6	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR bits$[rsp]
  001cb	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  001d3	66 89 84 4a 88
	0b 00 00	 mov	 WORD PTR [rdx+rcx*2+2952], ax

; 520  :         xbits = 0;

  001db	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR xbits$[rsp], 0

; 521  :         if (n >= base) xbits = extra[n-base];

  001e3	8b 44 24 40	 mov	 eax, DWORD PTR base$[rsp]
  001e7	39 44 24 4c	 cmp	 DWORD PTR n$[rsp], eax
  001eb	7c 1a		 jl	 SHORT $LN20@gen_bitlen
  001ed	8b 44 24 40	 mov	 eax, DWORD PTR base$[rsp]
  001f1	8b 4c 24 4c	 mov	 ecx, DWORD PTR n$[rsp]
  001f5	2b c8		 sub	 ecx, eax
  001f7	8b c1		 mov	 eax, ecx
  001f9	48 98		 cdqe
  001fb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR extra$[rsp]
  00200	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00203	89 44 24 58	 mov	 DWORD PTR xbits$[rsp], eax
$LN20@gen_bitlen:

; 522  :         f = tree[n].Freq;

  00207	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  0020c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  00211	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  00215	66 89 44 24 5c	 mov	 WORD PTR f$[rsp], ax

; 523  :         s->opt_len += (ulg)f * (unsigned)(bits + xbits);

  0021a	0f b7 44 24 5c	 movzx	 eax, WORD PTR f$[rsp]
  0021f	8b 4c 24 58	 mov	 ecx, DWORD PTR xbits$[rsp]
  00223	8b 54 24 54	 mov	 edx, DWORD PTR bits$[rsp]
  00227	03 d1		 add	 edx, ecx
  00229	8b ca		 mov	 ecx, edx
  0022b	0f af c1	 imul	 eax, ecx
  0022e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00236	03 81 00 17 00
	00		 add	 eax, DWORD PTR [rcx+5888]
  0023c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00244	89 81 00 17 00
	00		 mov	 DWORD PTR [rcx+5888], eax

; 524  :         if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);

  0024a	48 83 7c 24 30
	00		 cmp	 QWORD PTR stree$[rsp], 0
  00250	74 37		 je	 SHORT $LN21@gen_bitlen
  00252	0f b7 44 24 5c	 movzx	 eax, WORD PTR f$[rsp]
  00257	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR n$[rsp]
  0025c	48 8b 54 24 30	 mov	 rdx, QWORD PTR stree$[rsp]
  00261	0f b7 4c 8a 02	 movzx	 ecx, WORD PTR [rdx+rcx*4+2]
  00266	03 4c 24 58	 add	 ecx, DWORD PTR xbits$[rsp]
  0026a	0f af c1	 imul	 eax, ecx
  0026d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00275	03 81 04 17 00
	00		 add	 eax, DWORD PTR [rcx+5892]
  0027b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00283	89 81 04 17 00
	00		 mov	 DWORD PTR [rcx+5892], eax
$LN21@gen_bitlen:

; 525  :     }

  00289	e9 8f fe ff ff	 jmp	 $LN5@gen_bitlen
$LN6@gen_bitlen:

; 526  :     if (overflow == 0) return;

  0028e	83 7c 24 60 00	 cmp	 DWORD PTR overflow$[rsp], 0
  00293	75 05		 jne	 SHORT $LN22@gen_bitlen
  00295	e9 c8 01 00 00	 jmp	 $LN1@gen_bitlen
$LN22@gen_bitlen:
$LN10@gen_bitlen:

; 527  : 
; 528  :     Tracev((stderr,"\nbit length overflow\n"));
; 529  :     /* This happens for example on obj2 and pic of the Calgary corpus */
; 530  : 
; 531  :     /* Find the first bit length which could increase: */
; 532  :     do {
; 533  :         bits = max_length-1;

  0029a	8b 44 24 44	 mov	 eax, DWORD PTR max_length$[rsp]
  0029e	ff c8		 dec	 eax
  002a0	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
$LN11@gen_bitlen:

; 534  :         while (s->bl_count[bits] == 0) bits--;

  002a4	48 63 44 24 54	 movsxd	 rax, DWORD PTR bits$[rsp]
  002a9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002b1	0f b7 84 41 88
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2952]
  002b9	85 c0		 test	 eax, eax
  002bb	75 0c		 jne	 SHORT $LN12@gen_bitlen
  002bd	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  002c1	ff c8		 dec	 eax
  002c3	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  002c7	eb db		 jmp	 SHORT $LN11@gen_bitlen
$LN12@gen_bitlen:

; 535  :         s->bl_count[bits]--;      /* move one leaf down the tree */

  002c9	48 63 44 24 54	 movsxd	 rax, DWORD PTR bits$[rsp]
  002ce	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002d6	0f b7 84 41 88
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2952]
  002de	66 ff c8	 dec	 ax
  002e1	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR bits$[rsp]
  002e6	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  002ee	66 89 84 4a 88
	0b 00 00	 mov	 WORD PTR [rdx+rcx*2+2952], ax

; 536  :         s->bl_count[bits+1] += 2; /* move one overflow item as its brother */

  002f6	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  002fa	ff c0		 inc	 eax
  002fc	48 98		 cdqe
  002fe	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00306	0f b7 84 41 88
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2952]
  0030e	83 c0 02	 add	 eax, 2
  00311	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  00315	ff c1		 inc	 ecx
  00317	48 63 c9	 movsxd	 rcx, ecx
  0031a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00322	66 89 84 4a 88
	0b 00 00	 mov	 WORD PTR [rdx+rcx*2+2952], ax

; 537  :         s->bl_count[max_length]--;

  0032a	48 63 44 24 44	 movsxd	 rax, DWORD PTR max_length$[rsp]
  0032f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00337	0f b7 84 41 88
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2952]
  0033f	66 ff c8	 dec	 ax
  00342	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR max_length$[rsp]
  00347	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0034f	66 89 84 4a 88
	0b 00 00	 mov	 WORD PTR [rdx+rcx*2+2952], ax

; 538  :         /* The brother of the overflow item also moves one step up,
; 539  :          * but this does not affect bl_count[max_length]
; 540  :          */
; 541  :         overflow -= 2;

  00357	8b 44 24 60	 mov	 eax, DWORD PTR overflow$[rsp]
  0035b	83 e8 02	 sub	 eax, 2
  0035e	89 44 24 60	 mov	 DWORD PTR overflow$[rsp], eax

; 542  :     } while (overflow > 0);

  00362	83 7c 24 60 00	 cmp	 DWORD PTR overflow$[rsp], 0
  00367	0f 8f 2d ff ff
	ff		 jg	 $LN10@gen_bitlen

; 543  : 
; 544  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 545  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 546  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 547  :      * from 'ar' written by Haruhiko Okumura.)
; 548  :      */
; 549  :     for (bits = max_length; bits != 0; bits--) {

  0036d	8b 44 24 44	 mov	 eax, DWORD PTR max_length$[rsp]
  00371	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  00375	eb 0a		 jmp	 SHORT $LN15@gen_bitlen
$LN13@gen_bitlen:
  00377	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  0037b	ff c8		 dec	 eax
  0037d	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
$LN15@gen_bitlen:
  00381	83 7c 24 54 00	 cmp	 DWORD PTR bits$[rsp], 0
  00386	0f 84 d6 00 00
	00		 je	 $LN14@gen_bitlen

; 550  :         n = s->bl_count[bits];

  0038c	48 63 44 24 54	 movsxd	 rax, DWORD PTR bits$[rsp]
  00391	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00399	0f b7 84 41 88
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2952]
  003a1	89 44 24 4c	 mov	 DWORD PTR n$[rsp], eax
$LN26@gen_bitlen:
$LN16@gen_bitlen:

; 551  :         while (n != 0) {

  003a5	83 7c 24 4c 00	 cmp	 DWORD PTR n$[rsp], 0
  003aa	0f 84 ad 00 00
	00		 je	 $LN17@gen_bitlen

; 552  :             m = s->heap[--h];

  003b0	0f ae e8	 lfence
  003b3	8b 44 24 48	 mov	 eax, DWORD PTR h$[rsp]
  003b7	ff c8		 dec	 eax
  003b9	89 44 24 48	 mov	 DWORD PTR h$[rsp], eax
  003bd	48 63 44 24 48	 movsxd	 rax, DWORD PTR h$[rsp]
  003c2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003ca	8b 84 81 a8 0b
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+2984]
  003d1	89 44 24 50	 mov	 DWORD PTR m$[rsp], eax

; 553  :             if (m > max_code) continue;

  003d5	8b 44 24 28	 mov	 eax, DWORD PTR max_code$[rsp]
  003d9	39 44 24 50	 cmp	 DWORD PTR m$[rsp], eax
  003dd	7e 02		 jle	 SHORT $LN23@gen_bitlen
  003df	eb c4		 jmp	 SHORT $LN16@gen_bitlen
$LN23@gen_bitlen:

; 554  :             if ((unsigned) tree[m].Len != (unsigned) bits) {

  003e1	48 63 44 24 50	 movsxd	 rax, DWORD PTR m$[rsp]
  003e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  003eb	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  003f0	3b 44 24 54	 cmp	 eax, DWORD PTR bits$[rsp]
  003f4	74 58		 je	 SHORT $LN24@gen_bitlen

; 555  :                 Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
; 556  :                 s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;

  003f6	48 63 44 24 50	 movsxd	 rax, DWORD PTR m$[rsp]
  003fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  00400	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  00405	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  00409	2b c8		 sub	 ecx, eax
  0040b	8b c1		 mov	 eax, ecx
  0040d	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR m$[rsp]
  00412	48 8b 54 24 20	 mov	 rdx, QWORD PTR tree$[rsp]
  00417	0f b7 0c 8a	 movzx	 ecx, WORD PTR [rdx+rcx*4]
  0041b	0f af c1	 imul	 eax, ecx
  0041e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00426	03 81 00 17 00
	00		 add	 eax, DWORD PTR [rcx+5888]
  0042c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00434	89 81 00 17 00
	00		 mov	 DWORD PTR [rcx+5888], eax

; 557  :                 tree[m].Len = (ush)bits;

  0043a	48 63 44 24 50	 movsxd	 rax, DWORD PTR m$[rsp]
  0043f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  00444	0f b7 54 24 54	 movzx	 edx, WORD PTR bits$[rsp]
  00449	66 89 54 81 02	 mov	 WORD PTR [rcx+rax*4+2], dx
$LN24@gen_bitlen:

; 558  :             }
; 559  :             n--;

  0044e	8b 44 24 4c	 mov	 eax, DWORD PTR n$[rsp]
  00452	ff c8		 dec	 eax
  00454	89 44 24 4c	 mov	 DWORD PTR n$[rsp], eax

; 560  :         }

  00458	e9 48 ff ff ff	 jmp	 $LN26@gen_bitlen
$LN17@gen_bitlen:

; 561  :     }

  0045d	e9 15 ff ff ff	 jmp	 $LN13@gen_bitlen
$LN14@gen_bitlen:
$LN1@gen_bitlen:

; 562  : }

  00462	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00466	5f		 pop	 rdi
  00467	c3		 ret	 0
gen_bitlen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT gen_codes
_TEXT	SEGMENT
next_code$ = 40
code$ = 84
bits$ = 88
n$ = 92
len$4 = 96
tv132 = 100
tree$ = 128
max_code$ = 136
bl_count$ = 144
gen_codes PROC						; COMDAT

; 576  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 1c 00 00 00	 mov	 ecx, 28
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00031	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 577  :     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
; 578  :     unsigned code = 0;         /* running code value */

  00036	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR code$[rsp], 0

; 579  :     int bits;                  /* bit index */
; 580  :     int n;                     /* code index */
; 581  : 
; 582  :     /* The distribution counts are first used to generate the code values
; 583  :      * without bit reversal.
; 584  :      */
; 585  :     for (bits = 1; bits <= MAX_BITS; bits++) {

  0003e	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR bits$[rsp], 1
  00046	eb 0a		 jmp	 SHORT $LN4@gen_codes
$LN2@gen_codes:
  00048	8b 44 24 58	 mov	 eax, DWORD PTR bits$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 58	 mov	 DWORD PTR bits$[rsp], eax
$LN4@gen_codes:
  00052	83 7c 24 58 0f	 cmp	 DWORD PTR bits$[rsp], 15
  00057	7f 33		 jg	 SHORT $LN3@gen_codes

; 586  :         code = (code + bl_count[bits-1]) << 1;

  00059	8b 44 24 58	 mov	 eax, DWORD PTR bits$[rsp]
  0005d	ff c8		 dec	 eax
  0005f	48 98		 cdqe
  00061	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bl_count$[rsp]
  00069	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0006d	8b 4c 24 54	 mov	 ecx, DWORD PTR code$[rsp]
  00071	03 c8		 add	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	d1 e0		 shl	 eax, 1
  00077	89 44 24 54	 mov	 DWORD PTR code$[rsp], eax

; 587  :         next_code[bits] = (ush)code;

  0007b	48 63 44 24 58	 movsxd	 rax, DWORD PTR bits$[rsp]
  00080	0f b7 4c 24 54	 movzx	 ecx, WORD PTR code$[rsp]
  00085	66 89 4c 44 28	 mov	 WORD PTR next_code$[rsp+rax*2], cx

; 588  :     }

  0008a	eb bc		 jmp	 SHORT $LN2@gen_codes
$LN3@gen_codes:

; 589  :     /* Check that the bit counts in bl_count are consistent. The last code
; 590  :      * must be all ones.
; 591  :      */
; 592  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 593  :             "inconsistent bit counts");
; 594  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 595  : 
; 596  :     for (n = 0;  n <= max_code; n++) {

  0008c	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00094	eb 0a		 jmp	 SHORT $LN7@gen_codes
$LN5@gen_codes:
  00096	8b 44 24 5c	 mov	 eax, DWORD PTR n$[rsp]
  0009a	ff c0		 inc	 eax
  0009c	89 44 24 5c	 mov	 DWORD PTR n$[rsp], eax
$LN7@gen_codes:
  000a0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR max_code$[rsp]
  000a7	39 44 24 5c	 cmp	 DWORD PTR n$[rsp], eax
  000ab	7f 6e		 jg	 SHORT $LN6@gen_codes

; 597  :         int len = tree[n].Len;

  000ad	0f ae e8	 lfence
  000b0	48 63 44 24 5c	 movsxd	 rax, DWORD PTR n$[rsp]
  000b5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tree$[rsp]
  000bd	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  000c2	89 44 24 60	 mov	 DWORD PTR len$4[rsp], eax

; 598  :         if (len == 0) continue;

  000c6	83 7c 24 60 00	 cmp	 DWORD PTR len$4[rsp], 0
  000cb	75 02		 jne	 SHORT $LN8@gen_codes
  000cd	eb c7		 jmp	 SHORT $LN5@gen_codes
$LN8@gen_codes:

; 599  :         /* Now reverse the bits */
; 600  :         tree[n].Code = (ush)bi_reverse(next_code[len]++, len);

  000cf	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$4[rsp]
  000d4	0f b7 44 44 28	 movzx	 eax, WORD PTR next_code$[rsp+rax*2]
  000d9	66 89 44 24 64	 mov	 WORD PTR tv132[rsp], ax
  000de	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$4[rsp]
  000e3	0f b7 44 44 28	 movzx	 eax, WORD PTR next_code$[rsp+rax*2]
  000e8	66 ff c0	 inc	 ax
  000eb	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR len$4[rsp]
  000f0	66 89 44 4c 28	 mov	 WORD PTR next_code$[rsp+rcx*2], ax
  000f5	0f b7 44 24 64	 movzx	 eax, WORD PTR tv132[rsp]
  000fa	8b 54 24 60	 mov	 edx, DWORD PTR len$4[rsp]
  000fe	8b c8		 mov	 ecx, eax
  00100	e8 00 00 00 00	 call	 bi_reverse
  00105	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR n$[rsp]
  0010a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tree$[rsp]
  00112	66 89 04 8a	 mov	 WORD PTR [rdx+rcx*4], ax

; 601  : 
; 602  :         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
; 603  :              n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
; 604  :     }

  00116	e9 7b ff ff ff	 jmp	 $LN5@gen_codes
$LN6@gen_codes:

; 605  : }

  0011b	48 8b cc	 mov	 rcx, rsp
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gen_codes$rtcFrameData
  00125	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0012a	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0012e	5f		 pop	 rdi
  0012f	c3		 ret	 0
gen_codes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT build_tree
_TEXT	SEGMENT
tree$ = 32
stree$ = 40
elems$ = 48
n$ = 52
m$ = 56
max_code$ = 60
node$ = 64
tv82 = 68
tv137 = 72
tv131 = 76
tv190 = 80
tv197 = 84
tv242 = 88
tv265 = 92
s$ = 112
desc$ = 120
build_tree PROC						; COMDAT

; 618  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 18 00 00 00	 mov	 ecx, 24
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 619  :     ct_data *tree         = desc->dyn_tree;

  0002f	48 8b 44 24 78	 mov	 rax, QWORD PTR desc$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 89 44 24 20	 mov	 QWORD PTR tree$[rsp], rax

; 620  :     const ct_data *stree  = desc->stat_desc->static_tree;

  0003c	48 8b 44 24 78	 mov	 rax, QWORD PTR desc$[rsp]
  00041	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 89 44 24 28	 mov	 QWORD PTR stree$[rsp], rax

; 621  :     int elems             = desc->stat_desc->elems;

  0004d	48 8b 44 24 78	 mov	 rax, QWORD PTR desc$[rsp]
  00052	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00056	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00059	89 44 24 30	 mov	 DWORD PTR elems$[rsp], eax

; 622  :     int n, m;          /* iterate over heap elements */
; 623  :     int max_code = -1; /* largest code with non zero frequency */

  0005d	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR max_code$[rsp], -1

; 624  :     int node;          /* new node being created */
; 625  : 
; 626  :     /* Construct the initial heap, with least frequent element in
; 627  :      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
; 628  :      * heap[0] is not used.
; 629  :      */
; 630  :     s->heap_len = 0, s->heap_max = HEAP_SIZE;

  00065	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0006a	c7 80 9c 14 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5276], 0
  00074	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00079	c7 80 a0 14 00
	00 3d 02 00 00	 mov	 DWORD PTR [rax+5280], 573 ; 0000023dH

; 631  : 
; 632  :     for (n = 0; n < elems; n++) {

  00083	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0008b	eb 0a		 jmp	 SHORT $LN4@build_tree
$LN2@build_tree:
  0008d	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00091	ff c0		 inc	 eax
  00093	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN4@build_tree:
  00097	8b 44 24 30	 mov	 eax, DWORD PTR elems$[rsp]
  0009b	39 44 24 34	 cmp	 DWORD PTR n$[rsp], eax
  0009f	7d 79		 jge	 SHORT $LN3@build_tree

; 633  :         if (tree[n].Freq != 0) {

  000a1	48 63 44 24 34	 movsxd	 rax, DWORD PTR n$[rsp]
  000a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  000ab	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  000af	85 c0		 test	 eax, eax
  000b1	74 51		 je	 SHORT $LN13@build_tree

; 634  :             s->heap[++(s->heap_len)] = max_code = n;

  000b3	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  000b7	89 44 24 3c	 mov	 DWORD PTR max_code$[rsp], eax
  000bb	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000c0	8b 80 9c 14 00
	00		 mov	 eax, DWORD PTR [rax+5276]
  000c6	ff c0		 inc	 eax
  000c8	89 44 24 44	 mov	 DWORD PTR tv82[rsp], eax
  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000d1	8b 4c 24 44	 mov	 ecx, DWORD PTR tv82[rsp]
  000d5	89 88 9c 14 00
	00		 mov	 DWORD PTR [rax+5276], ecx
  000db	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv82[rsp]
  000e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000e5	8b 54 24 3c	 mov	 edx, DWORD PTR max_code$[rsp]
  000e9	89 94 81 a8 0b
	00 00		 mov	 DWORD PTR [rcx+rax*4+2984], edx

; 635  :             s->depth[n] = 0;

  000f0	48 63 44 24 34	 movsxd	 rax, DWORD PTR n$[rsp]
  000f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000fa	c6 84 01 a4 14
	00 00 00	 mov	 BYTE PTR [rcx+rax+5284], 0

; 636  :         } else {

  00102	eb 11		 jmp	 SHORT $LN14@build_tree
$LN13@build_tree:

; 637  :             tree[n].Len = 0;

  00104	48 63 44 24 34	 movsxd	 rax, DWORD PTR n$[rsp]
  00109	33 c9		 xor	 ecx, ecx
  0010b	48 8b 54 24 20	 mov	 rdx, QWORD PTR tree$[rsp]
  00110	66 89 4c 82 02	 mov	 WORD PTR [rdx+rax*4+2], cx
$LN14@build_tree:

; 638  :         }
; 639  :     }

  00115	e9 73 ff ff ff	 jmp	 $LN2@build_tree
$LN3@build_tree:
$LN5@build_tree:

; 640  : 
; 641  :     /* The pkzip format requires that at least one distance code exists,
; 642  :      * and that at least one bit should be sent even if there is only one
; 643  :      * possible code. So to avoid special checks later on we force at least
; 644  :      * two codes of non zero frequency.
; 645  :      */
; 646  :     while (s->heap_len < 2) {

  0011a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0011f	83 b8 9c 14 00
	00 02		 cmp	 DWORD PTR [rax+5276], 2
  00126	0f 8d d3 00 00
	00		 jge	 $LN6@build_tree

; 647  :         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);

  0012c	83 7c 24 3c 02	 cmp	 DWORD PTR max_code$[rsp], 2
  00131	7d 14		 jge	 SHORT $LN17@build_tree
  00133	8b 44 24 3c	 mov	 eax, DWORD PTR max_code$[rsp]
  00137	ff c0		 inc	 eax
  00139	89 44 24 3c	 mov	 DWORD PTR max_code$[rsp], eax
  0013d	8b 44 24 3c	 mov	 eax, DWORD PTR max_code$[rsp]
  00141	89 44 24 48	 mov	 DWORD PTR tv137[rsp], eax
  00145	eb 08		 jmp	 SHORT $LN18@build_tree
$LN17@build_tree:
  00147	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN18@build_tree:
  0014f	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00154	8b 80 9c 14 00
	00		 mov	 eax, DWORD PTR [rax+5276]
  0015a	ff c0		 inc	 eax
  0015c	89 44 24 4c	 mov	 DWORD PTR tv131[rsp], eax
  00160	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00165	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv131[rsp]
  00169	89 88 9c 14 00
	00		 mov	 DWORD PTR [rax+5276], ecx
  0016f	48 63 44 24 4c	 movsxd	 rax, DWORD PTR tv131[rsp]
  00174	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00179	8b 54 24 48	 mov	 edx, DWORD PTR tv137[rsp]
  0017d	89 94 81 a8 0b
	00 00		 mov	 DWORD PTR [rcx+rax*4+2984], edx
  00184	8b 44 24 48	 mov	 eax, DWORD PTR tv137[rsp]
  00188	89 44 24 40	 mov	 DWORD PTR node$[rsp], eax

; 648  :         tree[node].Freq = 1;

  0018c	48 63 44 24 40	 movsxd	 rax, DWORD PTR node$[rsp]
  00191	b9 01 00 00 00	 mov	 ecx, 1
  00196	48 8b 54 24 20	 mov	 rdx, QWORD PTR tree$[rsp]
  0019b	66 89 0c 82	 mov	 WORD PTR [rdx+rax*4], cx

; 649  :         s->depth[node] = 0;

  0019f	48 63 44 24 40	 movsxd	 rax, DWORD PTR node$[rsp]
  001a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001a9	c6 84 01 a4 14
	00 00 00	 mov	 BYTE PTR [rcx+rax+5284], 0

; 650  :         s->opt_len--; if (stree) s->static_len -= stree[node].Len;

  001b1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001b6	8b 80 00 17 00
	00		 mov	 eax, DWORD PTR [rax+5888]
  001bc	ff c8		 dec	 eax
  001be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001c3	89 81 00 17 00
	00		 mov	 DWORD PTR [rcx+5888], eax
  001c9	48 83 7c 24 28
	00		 cmp	 QWORD PTR stree$[rsp], 0
  001cf	74 29		 je	 SHORT $LN15@build_tree
  001d1	48 63 44 24 40	 movsxd	 rax, DWORD PTR node$[rsp]
  001d6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR stree$[rsp]
  001db	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  001e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001e5	8b 89 04 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5892]
  001eb	2b c8		 sub	 ecx, eax
  001ed	8b c1		 mov	 eax, ecx
  001ef	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001f4	89 81 04 17 00
	00		 mov	 DWORD PTR [rcx+5892], eax
$LN15@build_tree:

; 651  :         /* node is 0 or 1 so it does not have extra bits */
; 652  :     }

  001fa	e9 1b ff ff ff	 jmp	 $LN5@build_tree
$LN6@build_tree:

; 653  :     desc->max_code = max_code;

  001ff	48 8b 44 24 78	 mov	 rax, QWORD PTR desc$[rsp]
  00204	8b 4c 24 3c	 mov	 ecx, DWORD PTR max_code$[rsp]
  00208	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 654  : 
; 655  :     /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
; 656  :      * establish sub-heaps of increasing lengths:
; 657  :      */
; 658  :     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

  0020b	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00210	8b 80 9c 14 00
	00		 mov	 eax, DWORD PTR [rax+5276]
  00216	99		 cdq
  00217	2b c2		 sub	 eax, edx
  00219	d1 f8		 sar	 eax, 1
  0021b	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
  0021f	eb 0a		 jmp	 SHORT $LN9@build_tree
$LN7@build_tree:
  00221	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00225	ff c8		 dec	 eax
  00227	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN9@build_tree:
  0022b	83 7c 24 34 01	 cmp	 DWORD PTR n$[rsp], 1
  00230	7c 19		 jl	 SHORT $LN8@build_tree
  00232	0f ae e8	 lfence
  00235	44 8b 44 24 34	 mov	 r8d, DWORD PTR n$[rsp]
  0023a	48 8b 54 24 20	 mov	 rdx, QWORD PTR tree$[rsp]
  0023f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00244	e8 00 00 00 00	 call	 pqdownheap
  00249	eb d6		 jmp	 SHORT $LN7@build_tree
$LN8@build_tree:

; 659  : 
; 660  :     /* Construct the Huffman tree by repeatedly combining the least two
; 661  :      * frequent nodes.
; 662  :      */
; 663  :     node = elems;              /* next internal node of the tree */

  0024b	8b 44 24 30	 mov	 eax, DWORD PTR elems$[rsp]
  0024f	89 44 24 40	 mov	 DWORD PTR node$[rsp], eax
$LN12@build_tree:

; 664  :     do {
; 665  :         pqremove(s, tree, n);  /* n = node of least frequency */

  00253	b8 04 00 00 00	 mov	 eax, 4
  00258	48 6b c0 01	 imul	 rax, rax, 1
  0025c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00261	8b 84 01 a8 0b
	00 00		 mov	 eax, DWORD PTR [rcx+rax+2984]
  00268	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
  0026c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00271	48 63 80 9c 14
	00 00		 movsxd	 rax, DWORD PTR [rax+5276]
  00278	b9 04 00 00 00	 mov	 ecx, 4
  0027d	48 6b c9 01	 imul	 rcx, rcx, 1
  00281	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  00286	4c 8b 44 24 70	 mov	 r8, QWORD PTR s$[rsp]
  0028b	41 8b 84 80 a8
	0b 00 00	 mov	 eax, DWORD PTR [r8+rax*4+2984]
  00293	89 84 0a a8 0b
	00 00		 mov	 DWORD PTR [rdx+rcx+2984], eax
  0029a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0029f	8b 80 9c 14 00
	00		 mov	 eax, DWORD PTR [rax+5276]
  002a5	ff c8		 dec	 eax
  002a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002ac	89 81 9c 14 00
	00		 mov	 DWORD PTR [rcx+5276], eax
  002b2	41 b8 01 00 00
	00		 mov	 r8d, 1
  002b8	48 8b 54 24 20	 mov	 rdx, QWORD PTR tree$[rsp]
  002bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002c2	e8 00 00 00 00	 call	 pqdownheap

; 666  :         m = s->heap[SMALLEST]; /* m = node of next least frequency */

  002c7	b8 04 00 00 00	 mov	 eax, 4
  002cc	48 6b c0 01	 imul	 rax, rax, 1
  002d0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002d5	8b 84 01 a8 0b
	00 00		 mov	 eax, DWORD PTR [rcx+rax+2984]
  002dc	89 44 24 38	 mov	 DWORD PTR m$[rsp], eax

; 667  : 
; 668  :         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */

  002e0	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002e5	8b 80 a0 14 00
	00		 mov	 eax, DWORD PTR [rax+5280]
  002eb	ff c8		 dec	 eax
  002ed	89 44 24 50	 mov	 DWORD PTR tv190[rsp], eax
  002f1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002f6	8b 4c 24 50	 mov	 ecx, DWORD PTR tv190[rsp]
  002fa	89 88 a0 14 00
	00		 mov	 DWORD PTR [rax+5280], ecx
  00300	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv190[rsp]
  00305	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0030a	8b 54 24 34	 mov	 edx, DWORD PTR n$[rsp]
  0030e	89 94 81 a8 0b
	00 00		 mov	 DWORD PTR [rcx+rax*4+2984], edx

; 669  :         s->heap[--(s->heap_max)] = m;

  00315	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0031a	8b 80 a0 14 00
	00		 mov	 eax, DWORD PTR [rax+5280]
  00320	ff c8		 dec	 eax
  00322	89 44 24 54	 mov	 DWORD PTR tv197[rsp], eax
  00326	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0032b	8b 4c 24 54	 mov	 ecx, DWORD PTR tv197[rsp]
  0032f	89 88 a0 14 00
	00		 mov	 DWORD PTR [rax+5280], ecx
  00335	48 63 44 24 54	 movsxd	 rax, DWORD PTR tv197[rsp]
  0033a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0033f	8b 54 24 38	 mov	 edx, DWORD PTR m$[rsp]
  00343	89 94 81 a8 0b
	00 00		 mov	 DWORD PTR [rcx+rax*4+2984], edx

; 670  : 
; 671  :         /* Create a new node father of n and m */
; 672  :         tree[node].Freq = tree[n].Freq + tree[m].Freq;

  0034a	48 63 44 24 34	 movsxd	 rax, DWORD PTR n$[rsp]
  0034f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  00354	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  00358	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR m$[rsp]
  0035d	48 8b 54 24 20	 mov	 rdx, QWORD PTR tree$[rsp]
  00362	0f b7 0c 8a	 movzx	 ecx, WORD PTR [rdx+rcx*4]
  00366	03 c1		 add	 eax, ecx
  00368	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR node$[rsp]
  0036d	48 8b 54 24 20	 mov	 rdx, QWORD PTR tree$[rsp]
  00372	66 89 04 8a	 mov	 WORD PTR [rdx+rcx*4], ax

; 673  :         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?

  00376	48 63 44 24 34	 movsxd	 rax, DWORD PTR n$[rsp]
  0037b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00380	0f b6 84 01 a4
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5284]
  00388	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR m$[rsp]
  0038d	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  00392	0f b6 8c 0a a4
	14 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+5284]
  0039a	3b c1		 cmp	 eax, ecx
  0039c	7c 18		 jl	 SHORT $LN19@build_tree
  0039e	48 63 44 24 34	 movsxd	 rax, DWORD PTR n$[rsp]
  003a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003a8	0f b6 84 01 a4
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5284]
  003b0	89 44 24 58	 mov	 DWORD PTR tv242[rsp], eax
  003b4	eb 16		 jmp	 SHORT $LN20@build_tree
$LN19@build_tree:
  003b6	48 63 44 24 38	 movsxd	 rax, DWORD PTR m$[rsp]
  003bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003c0	0f b6 84 01 a4
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5284]
  003c8	89 44 24 58	 mov	 DWORD PTR tv242[rsp], eax
$LN20@build_tree:
  003cc	8b 44 24 58	 mov	 eax, DWORD PTR tv242[rsp]
  003d0	ff c0		 inc	 eax
  003d2	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR node$[rsp]
  003d7	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  003dc	88 84 0a a4 14
	00 00		 mov	 BYTE PTR [rdx+rcx+5284], al

; 674  :                                 s->depth[n] : s->depth[m]) + 1);
; 675  :         tree[n].Dad = tree[m].Dad = (ush)node;

  003e3	48 63 44 24 38	 movsxd	 rax, DWORD PTR m$[rsp]
  003e8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  003ed	0f b7 54 24 40	 movzx	 edx, WORD PTR node$[rsp]
  003f2	66 89 54 81 02	 mov	 WORD PTR [rcx+rax*4+2], dx
  003f7	48 63 44 24 34	 movsxd	 rax, DWORD PTR n$[rsp]
  003fc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  00401	0f b7 54 24 40	 movzx	 edx, WORD PTR node$[rsp]
  00406	66 89 54 81 02	 mov	 WORD PTR [rcx+rax*4+2], dx

; 676  : #ifdef DUMP_BL_TREE
; 677  :         if (tree == s->bl_tree) {
; 678  :             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
; 679  :                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
; 680  :         }
; 681  : #endif
; 682  :         /* and insert the new node in the heap */
; 683  :         s->heap[SMALLEST] = node++;

  0040b	b8 04 00 00 00	 mov	 eax, 4
  00410	48 6b c0 01	 imul	 rax, rax, 1
  00414	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00419	8b 54 24 40	 mov	 edx, DWORD PTR node$[rsp]
  0041d	89 94 01 a8 0b
	00 00		 mov	 DWORD PTR [rcx+rax+2984], edx
  00424	8b 44 24 40	 mov	 eax, DWORD PTR node$[rsp]
  00428	ff c0		 inc	 eax
  0042a	89 44 24 40	 mov	 DWORD PTR node$[rsp], eax

; 684  :         pqdownheap(s, tree, SMALLEST);

  0042e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00434	48 8b 54 24 20	 mov	 rdx, QWORD PTR tree$[rsp]
  00439	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0043e	e8 00 00 00 00	 call	 pqdownheap

; 685  : 
; 686  :     } while (s->heap_len >= 2);

  00443	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00448	83 b8 9c 14 00
	00 02		 cmp	 DWORD PTR [rax+5276], 2
  0044f	0f 8d fe fd ff
	ff		 jge	 $LN12@build_tree

; 687  : 
; 688  :     s->heap[--(s->heap_max)] = s->heap[SMALLEST];

  00455	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0045a	8b 80 a0 14 00
	00		 mov	 eax, DWORD PTR [rax+5280]
  00460	ff c8		 dec	 eax
  00462	89 44 24 5c	 mov	 DWORD PTR tv265[rsp], eax
  00466	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0046b	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv265[rsp]
  0046f	89 88 a0 14 00
	00		 mov	 DWORD PTR [rax+5280], ecx
  00475	48 63 44 24 5c	 movsxd	 rax, DWORD PTR tv265[rsp]
  0047a	b9 04 00 00 00	 mov	 ecx, 4
  0047f	48 6b c9 01	 imul	 rcx, rcx, 1
  00483	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  00488	4c 8b 44 24 70	 mov	 r8, QWORD PTR s$[rsp]
  0048d	41 8b 8c 08 a8
	0b 00 00	 mov	 ecx, DWORD PTR [r8+rcx+2984]
  00495	89 8c 82 a8 0b
	00 00		 mov	 DWORD PTR [rdx+rax*4+2984], ecx

; 689  : 
; 690  :     /* At this point, the fields freq and dad are set. We can now
; 691  :      * generate the bit lengths.
; 692  :      */
; 693  :     gen_bitlen(s, (tree_desc *)desc);

  0049c	48 8b 54 24 78	 mov	 rdx, QWORD PTR desc$[rsp]
  004a1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004a6	e8 00 00 00 00	 call	 gen_bitlen

; 694  : 
; 695  :     /* The field len is now set, we can generate the bit codes */
; 696  :     gen_codes ((ct_data *)tree, max_code, s->bl_count);

  004ab	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004b0	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  004b6	4c 8b c0	 mov	 r8, rax
  004b9	8b 54 24 3c	 mov	 edx, DWORD PTR max_code$[rsp]
  004bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tree$[rsp]
  004c2	e8 00 00 00 00	 call	 gen_codes

; 697  : }

  004c7	48 83 c4 60	 add	 rsp, 96			; 00000060H
  004cb	5f		 pop	 rdi
  004cc	c3		 ret	 0
build_tree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT scan_tree
_TEXT	SEGMENT
n$ = 32
prevlen$ = 36
curlen$ = 40
nextlen$ = 44
count$ = 48
max_count$ = 52
min_count$ = 56
s$ = 80
tree$ = 88
max_code$ = 96
scan_tree PROC						; COMDAT

; 707  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 10 00 00 00	 mov	 ecx, 16
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 708  :     int n;                     /* iterates over all tree elements */
; 709  :     int prevlen = -1;          /* last emitted length */

  00034	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR prevlen$[rsp], -1

; 710  :     int curlen;                /* length of current code */
; 711  :     int nextlen = tree[0].Len; /* length of next code */

  0003c	b8 04 00 00 00	 mov	 eax, 4
  00041	48 6b c0 00	 imul	 rax, rax, 0
  00045	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tree$[rsp]
  0004a	0f b7 44 01 02	 movzx	 eax, WORD PTR [rcx+rax+2]
  0004f	89 44 24 2c	 mov	 DWORD PTR nextlen$[rsp], eax

; 712  :     int count = 0;             /* repeat count of the current code */

  00053	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0

; 713  :     int max_count = 7;         /* max repeat count */

  0005b	c7 44 24 34 07
	00 00 00	 mov	 DWORD PTR max_count$[rsp], 7

; 714  :     int min_count = 4;         /* min repeat count */

  00063	c7 44 24 38 04
	00 00 00	 mov	 DWORD PTR min_count$[rsp], 4

; 715  : 
; 716  :     if (nextlen == 0) max_count = 138, min_count = 3;

  0006b	83 7c 24 2c 00	 cmp	 DWORD PTR nextlen$[rsp], 0
  00070	75 10		 jne	 SHORT $LN5@scan_tree
  00072	c7 44 24 34 8a
	00 00 00	 mov	 DWORD PTR max_count$[rsp], 138 ; 0000008aH
  0007a	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR min_count$[rsp], 3
$LN5@scan_tree:

; 717  :     tree[max_code+1].Len = (ush)0xffff; /* guard */

  00082	8b 44 24 60	 mov	 eax, DWORD PTR max_code$[rsp]
  00086	ff c0		 inc	 eax
  00088	48 98		 cdqe
  0008a	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR tree$[rsp]
  00094	66 89 4c 82 02	 mov	 WORD PTR [rdx+rax*4+2], cx

; 718  : 
; 719  :     for (n = 0; n <= max_code; n++) {

  00099	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  000a1	eb 0a		 jmp	 SHORT $LN4@scan_tree
$LN2@scan_tree:
  000a3	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000a7	ff c0		 inc	 eax
  000a9	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN4@scan_tree:
  000ad	8b 44 24 60	 mov	 eax, DWORD PTR max_code$[rsp]
  000b1	39 44 24 20	 cmp	 DWORD PTR n$[rsp], eax
  000b5	0f 8f a4 01 00
	00		 jg	 $LN3@scan_tree

; 720  :         curlen = nextlen; nextlen = tree[n+1].Len;

  000bb	8b 44 24 2c	 mov	 eax, DWORD PTR nextlen$[rsp]
  000bf	89 44 24 28	 mov	 DWORD PTR curlen$[rsp], eax
  000c3	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000c7	ff c0		 inc	 eax
  000c9	48 98		 cdqe
  000cb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tree$[rsp]
  000d0	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  000d5	89 44 24 2c	 mov	 DWORD PTR nextlen$[rsp], eax

; 721  :         if (++count < max_count && curlen == nextlen) {

  000d9	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  000dd	ff c0		 inc	 eax
  000df	89 44 24 30	 mov	 DWORD PTR count$[rsp], eax
  000e3	8b 44 24 34	 mov	 eax, DWORD PTR max_count$[rsp]
  000e7	39 44 24 30	 cmp	 DWORD PTR count$[rsp], eax
  000eb	7d 11		 jge	 SHORT $LN6@scan_tree
  000ed	8b 44 24 2c	 mov	 eax, DWORD PTR nextlen$[rsp]
  000f1	39 44 24 28	 cmp	 DWORD PTR curlen$[rsp], eax
  000f5	75 07		 jne	 SHORT $LN6@scan_tree

; 722  :             continue;

  000f7	eb aa		 jmp	 SHORT $LN2@scan_tree
  000f9	e9 07 01 00 00	 jmp	 $LN7@scan_tree
$LN6@scan_tree:

; 723  :         } else if (count < min_count) {

  000fe	8b 44 24 38	 mov	 eax, DWORD PTR min_count$[rsp]
  00102	39 44 24 30	 cmp	 DWORD PTR count$[rsp], eax
  00106	7d 2d		 jge	 SHORT $LN8@scan_tree

; 724  :             s->bl_tree[curlen].Freq += count;

  00108	48 63 44 24 28	 movsxd	 rax, DWORD PTR curlen$[rsp]
  0010d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00112	0f b7 84 81 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2724]
  0011a	03 44 24 30	 add	 eax, DWORD PTR count$[rsp]
  0011e	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR curlen$[rsp]
  00123	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  00128	66 89 84 8a a4
	0a 00 00	 mov	 WORD PTR [rdx+rcx*4+2724], ax
  00130	e9 d0 00 00 00	 jmp	 $LN9@scan_tree
$LN8@scan_tree:

; 725  :         } else if (curlen != 0) {

  00135	83 7c 24 28 00	 cmp	 DWORD PTR curlen$[rsp], 0
  0013a	74 62		 je	 SHORT $LN10@scan_tree

; 726  :             if (curlen != prevlen) s->bl_tree[curlen].Freq++;

  0013c	8b 44 24 24	 mov	 eax, DWORD PTR prevlen$[rsp]
  00140	39 44 24 28	 cmp	 DWORD PTR curlen$[rsp], eax
  00144	74 27		 je	 SHORT $LN12@scan_tree
  00146	48 63 44 24 28	 movsxd	 rax, DWORD PTR curlen$[rsp]
  0014b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00150	0f b7 84 81 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2724]
  00158	66 ff c0	 inc	 ax
  0015b	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR curlen$[rsp]
  00160	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  00165	66 89 84 8a a4
	0a 00 00	 mov	 WORD PTR [rdx+rcx*4+2724], ax
$LN12@scan_tree:

; 727  :             s->bl_tree[REP_3_6].Freq++;

  0016d	b8 04 00 00 00	 mov	 eax, 4
  00172	48 6b c0 10	 imul	 rax, rax, 16
  00176	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0017b	0f b7 84 01 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2724]
  00183	66 ff c0	 inc	 ax
  00186	b9 04 00 00 00	 mov	 ecx, 4
  0018b	48 6b c9 10	 imul	 rcx, rcx, 16
  0018f	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  00194	66 89 84 0a a4
	0a 00 00	 mov	 WORD PTR [rdx+rcx+2724], ax
  0019c	eb 67		 jmp	 SHORT $LN11@scan_tree
$LN10@scan_tree:

; 728  :         } else if (count <= 10) {

  0019e	83 7c 24 30 0a	 cmp	 DWORD PTR count$[rsp], 10
  001a3	7f 31		 jg	 SHORT $LN13@scan_tree

; 729  :             s->bl_tree[REPZ_3_10].Freq++;

  001a5	b8 04 00 00 00	 mov	 eax, 4
  001aa	48 6b c0 11	 imul	 rax, rax, 17
  001ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001b3	0f b7 84 01 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2724]
  001bb	66 ff c0	 inc	 ax
  001be	b9 04 00 00 00	 mov	 ecx, 4
  001c3	48 6b c9 11	 imul	 rcx, rcx, 17
  001c7	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  001cc	66 89 84 0a a4
	0a 00 00	 mov	 WORD PTR [rdx+rcx+2724], ax

; 730  :         } else {

  001d4	eb 2f		 jmp	 SHORT $LN14@scan_tree
$LN13@scan_tree:

; 731  :             s->bl_tree[REPZ_11_138].Freq++;

  001d6	b8 04 00 00 00	 mov	 eax, 4
  001db	48 6b c0 12	 imul	 rax, rax, 18
  001df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001e4	0f b7 84 01 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2724]
  001ec	66 ff c0	 inc	 ax
  001ef	b9 04 00 00 00	 mov	 ecx, 4
  001f4	48 6b c9 12	 imul	 rcx, rcx, 18
  001f8	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  001fd	66 89 84 0a a4
	0a 00 00	 mov	 WORD PTR [rdx+rcx+2724], ax
$LN14@scan_tree:
$LN11@scan_tree:
$LN9@scan_tree:
$LN7@scan_tree:

; 732  :         }
; 733  :         count = 0; prevlen = curlen;

  00205	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
  0020d	8b 44 24 28	 mov	 eax, DWORD PTR curlen$[rsp]
  00211	89 44 24 24	 mov	 DWORD PTR prevlen$[rsp], eax

; 734  :         if (nextlen == 0) {

  00215	83 7c 24 2c 00	 cmp	 DWORD PTR nextlen$[rsp], 0
  0021a	75 12		 jne	 SHORT $LN15@scan_tree

; 735  :             max_count = 138, min_count = 3;

  0021c	c7 44 24 34 8a
	00 00 00	 mov	 DWORD PTR max_count$[rsp], 138 ; 0000008aH
  00224	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR min_count$[rsp], 3
  0022c	eb 2c		 jmp	 SHORT $LN16@scan_tree
$LN15@scan_tree:

; 736  :         } else if (curlen == nextlen) {

  0022e	8b 44 24 2c	 mov	 eax, DWORD PTR nextlen$[rsp]
  00232	39 44 24 28	 cmp	 DWORD PTR curlen$[rsp], eax
  00236	75 12		 jne	 SHORT $LN17@scan_tree

; 737  :             max_count = 6, min_count = 3;

  00238	c7 44 24 34 06
	00 00 00	 mov	 DWORD PTR max_count$[rsp], 6
  00240	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR min_count$[rsp], 3

; 738  :         } else {

  00248	eb 10		 jmp	 SHORT $LN18@scan_tree
$LN17@scan_tree:

; 739  :             max_count = 7, min_count = 4;

  0024a	c7 44 24 34 07
	00 00 00	 mov	 DWORD PTR max_count$[rsp], 7
  00252	c7 44 24 38 04
	00 00 00	 mov	 DWORD PTR min_count$[rsp], 4
$LN18@scan_tree:
$LN16@scan_tree:

; 740  :         }
; 741  :     }

  0025a	e9 44 fe ff ff	 jmp	 $LN2@scan_tree
$LN3@scan_tree:

; 742  : }

  0025f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00263	5f		 pop	 rdi
  00264	c3		 ret	 0
scan_tree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT send_tree
_TEXT	SEGMENT
n$ = 32
prevlen$ = 36
curlen$ = 40
nextlen$ = 44
count$ = 48
max_count$ = 52
min_count$ = 56
len$1 = 60
val$2 = 64
len$3 = 68
val$4 = 72
len$5 = 76
val$6 = 80
len$7 = 84
val$8 = 88
len$9 = 92
val$10 = 96
len$11 = 100
val$12 = 104
len$13 = 108
val$14 = 112
len$15 = 116
val$16 = 120
s$ = 144
tree$ = 152
max_code$ = 160
send_tree PROC						; COMDAT

; 752  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8b fc	 mov	 rdi, rsp
  0001a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00035	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 753  :     int n;                     /* iterates over all tree elements */
; 754  :     int prevlen = -1;          /* last emitted length */

  0003a	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR prevlen$[rsp], -1

; 755  :     int curlen;                /* length of current code */
; 756  :     int nextlen = tree[0].Len; /* length of next code */

  00042	b8 04 00 00 00	 mov	 eax, 4
  00047	48 6b c0 00	 imul	 rax, rax, 0
  0004b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tree$[rsp]
  00053	0f b7 44 01 02	 movzx	 eax, WORD PTR [rcx+rax+2]
  00058	89 44 24 2c	 mov	 DWORD PTR nextlen$[rsp], eax

; 757  :     int count = 0;             /* repeat count of the current code */

  0005c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0

; 758  :     int max_count = 7;         /* max repeat count */

  00064	c7 44 24 34 07
	00 00 00	 mov	 DWORD PTR max_count$[rsp], 7

; 759  :     int min_count = 4;         /* min repeat count */

  0006c	c7 44 24 38 04
	00 00 00	 mov	 DWORD PTR min_count$[rsp], 4

; 760  : 
; 761  :     /* tree[max_code+1].Len = -1; */  /* guard already set */
; 762  :     if (nextlen == 0) max_count = 138, min_count = 3;

  00074	83 7c 24 2c 00	 cmp	 DWORD PTR nextlen$[rsp], 0
  00079	75 10		 jne	 SHORT $LN8@send_tree
  0007b	c7 44 24 34 8a
	00 00 00	 mov	 DWORD PTR max_count$[rsp], 138 ; 0000008aH
  00083	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR min_count$[rsp], 3
$LN8@send_tree:

; 763  : 
; 764  :     for (n = 0; n <= max_code; n++) {

  0008b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00093	eb 0a		 jmp	 SHORT $LN4@send_tree
$LN2@send_tree:
  00095	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00099	ff c0		 inc	 eax
  0009b	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN4@send_tree:
  0009f	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR max_code$[rsp]
  000a6	39 44 24 20	 cmp	 DWORD PTR n$[rsp], eax
  000aa	0f 8f e6 0e 00
	00		 jg	 $LN3@send_tree

; 765  :         curlen = nextlen; nextlen = tree[n+1].Len;

  000b0	8b 44 24 2c	 mov	 eax, DWORD PTR nextlen$[rsp]
  000b4	89 44 24 28	 mov	 DWORD PTR curlen$[rsp], eax
  000b8	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000bc	ff c0		 inc	 eax
  000be	48 98		 cdqe
  000c0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tree$[rsp]
  000c8	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  000cd	89 44 24 2c	 mov	 DWORD PTR nextlen$[rsp], eax

; 766  :         if (++count < max_count && curlen == nextlen) {

  000d1	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  000d5	ff c0		 inc	 eax
  000d7	89 44 24 30	 mov	 DWORD PTR count$[rsp], eax
  000db	8b 44 24 34	 mov	 eax, DWORD PTR max_count$[rsp]
  000df	39 44 24 30	 cmp	 DWORD PTR count$[rsp], eax
  000e3	7d 11		 jge	 SHORT $LN9@send_tree
  000e5	8b 44 24 2c	 mov	 eax, DWORD PTR nextlen$[rsp]
  000e9	39 44 24 28	 cmp	 DWORD PTR curlen$[rsp], eax
  000ed	75 07		 jne	 SHORT $LN9@send_tree

; 767  :             continue;

  000ef	eb a4		 jmp	 SHORT $LN2@send_tree
  000f1	e9 46 0e 00 00	 jmp	 $LN10@send_tree
$LN9@send_tree:

; 768  :         } else if (count < min_count) {

  000f6	8b 44 24 38	 mov	 eax, DWORD PTR min_count$[rsp]
  000fa	39 44 24 30	 cmp	 DWORD PTR count$[rsp], eax
  000fe	0f 8d e2 01 00
	00		 jge	 $LN11@send_tree
$LN7@send_tree:

; 769  :             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

  00104	48 63 44 24 28	 movsxd	 rax, DWORD PTR curlen$[rsp]
  00109	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00111	0f b7 84 81 a6
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2726]
  00119	89 44 24 3c	 mov	 DWORD PTR len$1[rsp], eax
  0011d	b8 10 00 00 00	 mov	 eax, 16
  00122	2b 44 24 3c	 sub	 eax, DWORD PTR len$1[rsp]
  00126	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0012e	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00134	0f 8e 2b 01 00
	00		 jle	 $LN13@send_tree
  0013a	48 63 44 24 28	 movsxd	 rax, DWORD PTR curlen$[rsp]
  0013f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00147	0f b7 84 81 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2724]
  0014f	89 44 24 40	 mov	 DWORD PTR val$2[rsp], eax
  00153	0f b7 44 24 40	 movzx	 eax, WORD PTR val$2[rsp]
  00158	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00160	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00166	d3 e0		 shl	 eax, cl
  00168	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00170	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00177	0b c8		 or	 ecx, eax
  00179	8b c1		 mov	 eax, ecx
  0017b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00183	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0018a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00192	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00199	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0019e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001a6	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  001a9	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  001b1	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  001b5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001b8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001c0	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001c3	ff c0		 inc	 eax
  001c5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001cd	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  001d0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001d8	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  001df	c1 f8 08	 sar	 eax, 8
  001e2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001ea	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  001ed	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  001f5	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  001f9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001fc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00204	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00207	ff c0		 inc	 eax
  00209	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00211	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00214	0f b7 44 24 40	 movzx	 eax, WORD PTR val$2[rsp]
  00219	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00221	ba 10 00 00 00	 mov	 edx, 16
  00226	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  0022c	8b ca		 mov	 ecx, edx
  0022e	d3 f8		 sar	 eax, cl
  00230	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00238	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0023f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00247	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  0024d	8b 4c 24 3c	 mov	 ecx, DWORD PTR len$1[rsp]
  00251	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00255	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0025d	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  00263	eb 67		 jmp	 SHORT $LN14@send_tree
$LN13@send_tree:
  00265	48 63 44 24 28	 movsxd	 rax, DWORD PTR curlen$[rsp]
  0026a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00272	0f b7 84 81 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2724]
  0027a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00282	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00288	d3 e0		 shl	 eax, cl
  0028a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00292	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00299	0b c8		 or	 ecx, eax
  0029b	8b c1		 mov	 eax, ecx
  0029d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a5	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  002ac	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002b4	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  002ba	03 44 24 3c	 add	 eax, DWORD PTR len$1[rsp]
  002be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002c6	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN14@send_tree:
  002cc	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  002d0	ff c8		 dec	 eax
  002d2	89 44 24 30	 mov	 DWORD PTR count$[rsp], eax
  002d6	83 7c 24 30 00	 cmp	 DWORD PTR count$[rsp], 0
  002db	0f 85 23 fe ff
	ff		 jne	 $LN7@send_tree

; 770  : 
; 771  :         } else if (curlen != 0) {

  002e1	e9 56 0c 00 00	 jmp	 $LN12@send_tree
$LN11@send_tree:
  002e6	83 7c 24 28 00	 cmp	 DWORD PTR curlen$[rsp], 0
  002eb	0f 84 57 05 00
	00		 je	 $LN15@send_tree

; 772  :             if (curlen != prevlen) {

  002f1	8b 44 24 24	 mov	 eax, DWORD PTR prevlen$[rsp]
  002f5	39 44 24 28	 cmp	 DWORD PTR curlen$[rsp], eax
  002f9	0f 84 d2 01 00
	00		 je	 $LN17@send_tree

; 773  :                 send_code(s, curlen, s->bl_tree); count--;

  002ff	48 63 44 24 28	 movsxd	 rax, DWORD PTR curlen$[rsp]
  00304	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0030c	0f b7 84 81 a6
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2726]
  00314	89 44 24 44	 mov	 DWORD PTR len$3[rsp], eax
  00318	b8 10 00 00 00	 mov	 eax, 16
  0031d	2b 44 24 44	 sub	 eax, DWORD PTR len$3[rsp]
  00321	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00329	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  0032f	0f 8e 2b 01 00
	00		 jle	 $LN18@send_tree
  00335	48 63 44 24 28	 movsxd	 rax, DWORD PTR curlen$[rsp]
  0033a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00342	0f b7 84 81 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2724]
  0034a	89 44 24 48	 mov	 DWORD PTR val$4[rsp], eax
  0034e	0f b7 44 24 48	 movzx	 eax, WORD PTR val$4[rsp]
  00353	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0035b	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00361	d3 e0		 shl	 eax, cl
  00363	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0036b	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00372	0b c8		 or	 ecx, eax
  00374	8b c1		 mov	 eax, ecx
  00376	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0037e	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00385	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0038d	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00394	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00399	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003a1	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  003a4	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  003ac	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  003b0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003b3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003bb	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  003be	ff c0		 inc	 eax
  003c0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003c8	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  003cb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003d3	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  003da	c1 f8 08	 sar	 eax, 8
  003dd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003e5	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  003e8	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  003f0	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  003f4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003f7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003ff	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00402	ff c0		 inc	 eax
  00404	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0040c	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0040f	0f b7 44 24 48	 movzx	 eax, WORD PTR val$4[rsp]
  00414	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0041c	ba 10 00 00 00	 mov	 edx, 16
  00421	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00427	8b ca		 mov	 ecx, edx
  00429	d3 f8		 sar	 eax, cl
  0042b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00433	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0043a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00442	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00448	8b 4c 24 44	 mov	 ecx, DWORD PTR len$3[rsp]
  0044c	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00450	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00458	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  0045e	eb 67		 jmp	 SHORT $LN19@send_tree
$LN18@send_tree:
  00460	48 63 44 24 28	 movsxd	 rax, DWORD PTR curlen$[rsp]
  00465	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0046d	0f b7 84 81 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2724]
  00475	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0047d	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00483	d3 e0		 shl	 eax, cl
  00485	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0048d	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00494	0b c8		 or	 ecx, eax
  00496	8b c1		 mov	 eax, ecx
  00498	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004a0	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  004a7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004af	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  004b5	03 44 24 44	 add	 eax, DWORD PTR len$3[rsp]
  004b9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004c1	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN19@send_tree:
  004c7	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  004cb	ff c8		 dec	 eax
  004cd	89 44 24 30	 mov	 DWORD PTR count$[rsp], eax
$LN17@send_tree:

; 774  :             }
; 775  :             Assert(count >= 3 && count <= 6, " 3_6?");
; 776  :             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

  004d1	b8 04 00 00 00	 mov	 eax, 4
  004d6	48 6b c0 10	 imul	 rax, rax, 16
  004da	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004e2	0f b7 84 01 a6
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2726]
  004ea	89 44 24 4c	 mov	 DWORD PTR len$5[rsp], eax
  004ee	b8 10 00 00 00	 mov	 eax, 16
  004f3	2b 44 24 4c	 sub	 eax, DWORD PTR len$5[rsp]
  004f7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004ff	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00505	0f 8e 2f 01 00
	00		 jle	 $LN20@send_tree
  0050b	b8 04 00 00 00	 mov	 eax, 4
  00510	48 6b c0 10	 imul	 rax, rax, 16
  00514	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0051c	0f b7 84 01 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2724]
  00524	89 44 24 50	 mov	 DWORD PTR val$6[rsp], eax
  00528	0f b7 44 24 50	 movzx	 eax, WORD PTR val$6[rsp]
  0052d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00535	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  0053b	d3 e0		 shl	 eax, cl
  0053d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00545	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  0054c	0b c8		 or	 ecx, eax
  0054e	8b c1		 mov	 eax, ecx
  00550	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00558	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0055f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00567	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0056e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00573	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0057b	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0057e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00586	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0058a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0058d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00595	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00598	ff c0		 inc	 eax
  0059a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005a2	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  005a5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005ad	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  005b4	c1 f8 08	 sar	 eax, 8
  005b7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005bf	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  005c2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  005ca	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  005ce	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005d1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005d9	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  005dc	ff c0		 inc	 eax
  005de	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005e6	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  005e9	0f b7 44 24 50	 movzx	 eax, WORD PTR val$6[rsp]
  005ee	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005f6	ba 10 00 00 00	 mov	 edx, 16
  005fb	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00601	8b ca		 mov	 ecx, edx
  00603	d3 f8		 sar	 eax, cl
  00605	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0060d	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00614	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0061c	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00622	8b 4c 24 4c	 mov	 ecx, DWORD PTR len$5[rsp]
  00626	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  0062a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00632	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  00638	eb 6b		 jmp	 SHORT $LN21@send_tree
$LN20@send_tree:
  0063a	b8 04 00 00 00	 mov	 eax, 4
  0063f	48 6b c0 10	 imul	 rax, rax, 16
  00643	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0064b	0f b7 84 01 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2724]
  00653	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0065b	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00661	d3 e0		 shl	 eax, cl
  00663	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0066b	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00672	0b c8		 or	 ecx, eax
  00674	8b c1		 mov	 eax, ecx
  00676	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0067e	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00685	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0068d	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00693	03 44 24 4c	 add	 eax, DWORD PTR len$5[rsp]
  00697	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0069f	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN21@send_tree:
  006a5	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR len$7[rsp], 2
  006ad	b8 10 00 00 00	 mov	 eax, 16
  006b2	2b 44 24 54	 sub	 eax, DWORD PTR len$7[rsp]
  006b6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006be	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  006c4	0f 8e 1d 01 00
	00		 jle	 $LN22@send_tree
  006ca	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  006ce	83 e8 03	 sub	 eax, 3
  006d1	89 44 24 58	 mov	 DWORD PTR val$8[rsp], eax
  006d5	0f b7 44 24 58	 movzx	 eax, WORD PTR val$8[rsp]
  006da	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006e2	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  006e8	d3 e0		 shl	 eax, cl
  006ea	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006f2	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  006f9	0b c8		 or	 ecx, eax
  006fb	8b c1		 mov	 eax, ecx
  006fd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00705	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0070c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00714	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0071b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00720	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00728	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0072b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00733	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00737	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0073a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00742	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00745	ff c0		 inc	 eax
  00747	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0074f	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00752	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0075a	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00761	c1 f8 08	 sar	 eax, 8
  00764	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0076c	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0076f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00777	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0077b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0077e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00786	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00789	ff c0		 inc	 eax
  0078b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00793	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00796	0f b7 44 24 58	 movzx	 eax, WORD PTR val$8[rsp]
  0079b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007a3	ba 10 00 00 00	 mov	 edx, 16
  007a8	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  007ae	8b ca		 mov	 ecx, edx
  007b0	d3 f8		 sar	 eax, cl
  007b2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007ba	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  007c1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007c9	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  007cf	8b 4c 24 54	 mov	 ecx, DWORD PTR len$7[rsp]
  007d3	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  007d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007df	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  007e5	eb 5c		 jmp	 SHORT $LN23@send_tree
$LN22@send_tree:
  007e7	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  007eb	83 e8 03	 sub	 eax, 3
  007ee	0f b7 c0	 movzx	 eax, ax
  007f1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007f9	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  007ff	d3 e0		 shl	 eax, cl
  00801	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00809	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00810	0b c8		 or	 ecx, eax
  00812	8b c1		 mov	 eax, ecx
  00814	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0081c	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00823	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0082b	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00831	03 44 24 54	 add	 eax, DWORD PTR len$7[rsp]
  00835	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0083d	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN23@send_tree:
  00843	e9 f4 06 00 00	 jmp	 $LN16@send_tree
$LN15@send_tree:

; 777  : 
; 778  :         } else if (count <= 10) {

  00848	83 7c 24 30 0a	 cmp	 DWORD PTR count$[rsp], 10
  0084d	0f 8f 77 03 00
	00		 jg	 $LN24@send_tree

; 779  :             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

  00853	b8 04 00 00 00	 mov	 eax, 4
  00858	48 6b c0 11	 imul	 rax, rax, 17
  0085c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00864	0f b7 84 01 a6
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2726]
  0086c	89 44 24 5c	 mov	 DWORD PTR len$9[rsp], eax
  00870	b8 10 00 00 00	 mov	 eax, 16
  00875	2b 44 24 5c	 sub	 eax, DWORD PTR len$9[rsp]
  00879	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00881	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00887	0f 8e 2f 01 00
	00		 jle	 $LN26@send_tree
  0088d	b8 04 00 00 00	 mov	 eax, 4
  00892	48 6b c0 11	 imul	 rax, rax, 17
  00896	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0089e	0f b7 84 01 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2724]
  008a6	89 44 24 60	 mov	 DWORD PTR val$10[rsp], eax
  008aa	0f b7 44 24 60	 movzx	 eax, WORD PTR val$10[rsp]
  008af	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008b7	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  008bd	d3 e0		 shl	 eax, cl
  008bf	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008c7	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  008ce	0b c8		 or	 ecx, eax
  008d0	8b c1		 mov	 eax, ecx
  008d2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008da	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  008e1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008e9	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  008f0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008f5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008fd	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00900	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00908	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0090c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0090f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00917	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0091a	ff c0		 inc	 eax
  0091c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00924	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00927	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0092f	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00936	c1 f8 08	 sar	 eax, 8
  00939	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00941	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00944	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0094c	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00950	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00953	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0095b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0095e	ff c0		 inc	 eax
  00960	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00968	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0096b	0f b7 44 24 60	 movzx	 eax, WORD PTR val$10[rsp]
  00970	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00978	ba 10 00 00 00	 mov	 edx, 16
  0097d	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00983	8b ca		 mov	 ecx, edx
  00985	d3 f8		 sar	 eax, cl
  00987	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0098f	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00996	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0099e	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  009a4	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$9[rsp]
  009a8	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  009ac	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009b4	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  009ba	eb 6b		 jmp	 SHORT $LN27@send_tree
$LN26@send_tree:
  009bc	b8 04 00 00 00	 mov	 eax, 4
  009c1	48 6b c0 11	 imul	 rax, rax, 17
  009c5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009cd	0f b7 84 01 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2724]
  009d5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009dd	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  009e3	d3 e0		 shl	 eax, cl
  009e5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009ed	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  009f4	0b c8		 or	 ecx, eax
  009f6	8b c1		 mov	 eax, ecx
  009f8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a00	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00a07	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a0f	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00a15	03 44 24 5c	 add	 eax, DWORD PTR len$9[rsp]
  00a19	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a21	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN27@send_tree:
  00a27	c7 44 24 64 03
	00 00 00	 mov	 DWORD PTR len$11[rsp], 3
  00a2f	b8 10 00 00 00	 mov	 eax, 16
  00a34	2b 44 24 64	 sub	 eax, DWORD PTR len$11[rsp]
  00a38	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a40	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00a46	0f 8e 1d 01 00
	00		 jle	 $LN28@send_tree
  00a4c	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  00a50	83 e8 03	 sub	 eax, 3
  00a53	89 44 24 68	 mov	 DWORD PTR val$12[rsp], eax
  00a57	0f b7 44 24 68	 movzx	 eax, WORD PTR val$12[rsp]
  00a5c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a64	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00a6a	d3 e0		 shl	 eax, cl
  00a6c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a74	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00a7b	0b c8		 or	 ecx, eax
  00a7d	8b c1		 mov	 eax, ecx
  00a7f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a87	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00a8e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a96	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00a9d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00aa2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aaa	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00aad	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00ab5	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00ab9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00abc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ac4	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00ac7	ff c0		 inc	 eax
  00ac9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ad1	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00ad4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00adc	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00ae3	c1 f8 08	 sar	 eax, 8
  00ae6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aee	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00af1	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00af9	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00afd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00b00	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b08	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b0b	ff c0		 inc	 eax
  00b0d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b15	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00b18	0f b7 44 24 68	 movzx	 eax, WORD PTR val$12[rsp]
  00b1d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b25	ba 10 00 00 00	 mov	 edx, 16
  00b2a	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00b30	8b ca		 mov	 ecx, edx
  00b32	d3 f8		 sar	 eax, cl
  00b34	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b3c	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00b43	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b4b	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00b51	8b 4c 24 64	 mov	 ecx, DWORD PTR len$11[rsp]
  00b55	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00b59	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b61	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  00b67	eb 5c		 jmp	 SHORT $LN29@send_tree
$LN28@send_tree:
  00b69	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  00b6d	83 e8 03	 sub	 eax, 3
  00b70	0f b7 c0	 movzx	 eax, ax
  00b73	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b7b	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00b81	d3 e0		 shl	 eax, cl
  00b83	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b8b	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00b92	0b c8		 or	 ecx, eax
  00b94	8b c1		 mov	 eax, ecx
  00b96	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b9e	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00ba5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bad	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00bb3	03 44 24 64	 add	 eax, DWORD PTR len$11[rsp]
  00bb7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bbf	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN29@send_tree:

; 780  : 
; 781  :         } else {

  00bc5	e9 72 03 00 00	 jmp	 $LN25@send_tree
$LN24@send_tree:

; 782  :             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);

  00bca	b8 04 00 00 00	 mov	 eax, 4
  00bcf	48 6b c0 12	 imul	 rax, rax, 18
  00bd3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bdb	0f b7 84 01 a6
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2726]
  00be3	89 44 24 6c	 mov	 DWORD PTR len$13[rsp], eax
  00be7	b8 10 00 00 00	 mov	 eax, 16
  00bec	2b 44 24 6c	 sub	 eax, DWORD PTR len$13[rsp]
  00bf0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bf8	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00bfe	0f 8e 2f 01 00
	00		 jle	 $LN30@send_tree
  00c04	b8 04 00 00 00	 mov	 eax, 4
  00c09	48 6b c0 12	 imul	 rax, rax, 18
  00c0d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c15	0f b7 84 01 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2724]
  00c1d	89 44 24 70	 mov	 DWORD PTR val$14[rsp], eax
  00c21	0f b7 44 24 70	 movzx	 eax, WORD PTR val$14[rsp]
  00c26	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c2e	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00c34	d3 e0		 shl	 eax, cl
  00c36	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c3e	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00c45	0b c8		 or	 ecx, eax
  00c47	8b c1		 mov	 eax, ecx
  00c49	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c51	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00c58	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c60	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00c67	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c6c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c74	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00c77	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00c7f	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00c83	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00c86	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c8e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00c91	ff c0		 inc	 eax
  00c93	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c9b	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00c9e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ca6	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00cad	c1 f8 08	 sar	 eax, 8
  00cb0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00cb8	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00cbb	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00cc3	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00cc7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00cca	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00cd2	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00cd5	ff c0		 inc	 eax
  00cd7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00cdf	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00ce2	0f b7 44 24 70	 movzx	 eax, WORD PTR val$14[rsp]
  00ce7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00cef	ba 10 00 00 00	 mov	 edx, 16
  00cf4	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00cfa	8b ca		 mov	 ecx, edx
  00cfc	d3 f8		 sar	 eax, cl
  00cfe	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d06	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00d0d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d15	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00d1b	8b 4c 24 6c	 mov	 ecx, DWORD PTR len$13[rsp]
  00d1f	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00d23	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d2b	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  00d31	eb 6b		 jmp	 SHORT $LN31@send_tree
$LN30@send_tree:
  00d33	b8 04 00 00 00	 mov	 eax, 4
  00d38	48 6b c0 12	 imul	 rax, rax, 18
  00d3c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d44	0f b7 84 01 a4
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax+2724]
  00d4c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d54	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00d5a	d3 e0		 shl	 eax, cl
  00d5c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d64	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00d6b	0b c8		 or	 ecx, eax
  00d6d	8b c1		 mov	 eax, ecx
  00d6f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d77	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00d7e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d86	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00d8c	03 44 24 6c	 add	 eax, DWORD PTR len$13[rsp]
  00d90	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d98	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN31@send_tree:
  00d9e	c7 44 24 74 07
	00 00 00	 mov	 DWORD PTR len$15[rsp], 7
  00da6	b8 10 00 00 00	 mov	 eax, 16
  00dab	2b 44 24 74	 sub	 eax, DWORD PTR len$15[rsp]
  00daf	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00db7	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00dbd	0f 8e 1d 01 00
	00		 jle	 $LN32@send_tree
  00dc3	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  00dc7	83 e8 0b	 sub	 eax, 11
  00dca	89 44 24 78	 mov	 DWORD PTR val$16[rsp], eax
  00dce	0f b7 44 24 78	 movzx	 eax, WORD PTR val$16[rsp]
  00dd3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ddb	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00de1	d3 e0		 shl	 eax, cl
  00de3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00deb	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00df2	0b c8		 or	 ecx, eax
  00df4	8b c1		 mov	 eax, ecx
  00df6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00dfe	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00e05	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e0d	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00e14	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00e19	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e21	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00e24	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00e2c	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00e30	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00e33	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e3b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00e3e	ff c0		 inc	 eax
  00e40	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e48	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00e4b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e53	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00e5a	c1 f8 08	 sar	 eax, 8
  00e5d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e65	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00e68	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00e70	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00e74	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00e77	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e7f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00e82	ff c0		 inc	 eax
  00e84	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e8c	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00e8f	0f b7 44 24 78	 movzx	 eax, WORD PTR val$16[rsp]
  00e94	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00e9c	ba 10 00 00 00	 mov	 edx, 16
  00ea1	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00ea7	8b ca		 mov	 ecx, edx
  00ea9	d3 f8		 sar	 eax, cl
  00eab	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00eb3	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00eba	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ec2	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00ec8	8b 4c 24 74	 mov	 ecx, DWORD PTR len$15[rsp]
  00ecc	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00ed0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ed8	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  00ede	eb 5c		 jmp	 SHORT $LN33@send_tree
$LN32@send_tree:
  00ee0	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  00ee4	83 e8 0b	 sub	 eax, 11
  00ee7	0f b7 c0	 movzx	 eax, ax
  00eea	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ef2	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00ef8	d3 e0		 shl	 eax, cl
  00efa	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f02	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00f09	0b c8		 or	 ecx, eax
  00f0b	8b c1		 mov	 eax, ecx
  00f0d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f15	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00f1c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00f24	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00f2a	03 44 24 74	 add	 eax, DWORD PTR len$15[rsp]
  00f2e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00f36	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN33@send_tree:
$LN25@send_tree:
$LN16@send_tree:
$LN12@send_tree:
$LN10@send_tree:

; 783  :         }
; 784  :         count = 0; prevlen = curlen;

  00f3c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
  00f44	8b 44 24 28	 mov	 eax, DWORD PTR curlen$[rsp]
  00f48	89 44 24 24	 mov	 DWORD PTR prevlen$[rsp], eax

; 785  :         if (nextlen == 0) {

  00f4c	83 7c 24 2c 00	 cmp	 DWORD PTR nextlen$[rsp], 0
  00f51	75 12		 jne	 SHORT $LN34@send_tree

; 786  :             max_count = 138, min_count = 3;

  00f53	c7 44 24 34 8a
	00 00 00	 mov	 DWORD PTR max_count$[rsp], 138 ; 0000008aH
  00f5b	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR min_count$[rsp], 3
  00f63	eb 2c		 jmp	 SHORT $LN35@send_tree
$LN34@send_tree:

; 787  :         } else if (curlen == nextlen) {

  00f65	8b 44 24 2c	 mov	 eax, DWORD PTR nextlen$[rsp]
  00f69	39 44 24 28	 cmp	 DWORD PTR curlen$[rsp], eax
  00f6d	75 12		 jne	 SHORT $LN36@send_tree

; 788  :             max_count = 6, min_count = 3;

  00f6f	c7 44 24 34 06
	00 00 00	 mov	 DWORD PTR max_count$[rsp], 6
  00f77	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR min_count$[rsp], 3

; 789  :         } else {

  00f7f	eb 10		 jmp	 SHORT $LN37@send_tree
$LN36@send_tree:

; 790  :             max_count = 7, min_count = 4;

  00f81	c7 44 24 34 07
	00 00 00	 mov	 DWORD PTR max_count$[rsp], 7
  00f89	c7 44 24 38 04
	00 00 00	 mov	 DWORD PTR min_count$[rsp], 4
$LN37@send_tree:
$LN35@send_tree:

; 791  :         }
; 792  :     }

  00f91	e9 ff f0 ff ff	 jmp	 $LN2@send_tree
$LN3@send_tree:

; 793  : }

  00f96	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00f9d	5f		 pop	 rdi
  00f9e	c3		 ret	 0
send_tree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT build_bl_tree
_TEXT	SEGMENT
max_blindex$ = 32
s$ = 64
build_bl_tree PROC					; COMDAT

; 801  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 802  :     int max_blindex;  /* index of last bit length code of non zero freq */
; 803  : 
; 804  :     /* Determine the bit length frequencies for literal and distance trees */
; 805  :     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0002f	48 05 bc 00 00
	00		 add	 rax, 188		; 000000bcH
  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003a	44 8b 81 48 0b
	00 00		 mov	 r8d, DWORD PTR [rcx+2888]
  00041	48 8b d0	 mov	 rdx, rax
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00049	e8 00 00 00 00	 call	 scan_tree

; 806  :     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00053	48 05 b0 09 00
	00		 add	 rax, 2480		; 000009b0H
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005e	44 8b 81 60 0b
	00 00		 mov	 r8d, DWORD PTR [rcx+2912]
  00065	48 8b d0	 mov	 rdx, rax
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006d	e8 00 00 00 00	 call	 scan_tree

; 807  : 
; 808  :     /* Build the bit length tree: */
; 809  :     build_tree(s, (tree_desc *)(&(s->bl_desc)));

  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00077	48 05 70 0b 00
	00		 add	 rax, 2928		; 00000b70H
  0007d	48 8b d0	 mov	 rdx, rax
  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00085	e8 00 00 00 00	 call	 build_tree

; 810  :     /* opt_len now includes the length of the tree representations, except
; 811  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 812  :      */
; 813  : 
; 814  :     /* Determine the number of bit length codes to send. The pkzip format
; 815  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 816  :      * 3 but the actual value used is 4.)
; 817  :      */
; 818  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  0008a	c7 44 24 20 12
	00 00 00	 mov	 DWORD PTR max_blindex$[rsp], 18
  00092	eb 0a		 jmp	 SHORT $LN4@build_bl_t
$LN2@build_bl_t:
  00094	8b 44 24 20	 mov	 eax, DWORD PTR max_blindex$[rsp]
  00098	ff c8		 dec	 eax
  0009a	89 44 24 20	 mov	 DWORD PTR max_blindex$[rsp], eax
$LN4@build_bl_t:
  0009e	83 7c 24 20 03	 cmp	 DWORD PTR max_blindex$[rsp], 3
  000a3	7c 28		 jl	 SHORT $LN3@build_bl_t

; 819  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  000a5	0f ae e8	 lfence
  000a8	48 63 44 24 20	 movsxd	 rax, DWORD PTR max_blindex$[rsp]
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bl_order
  000b4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000bd	0f b7 84 81 a6
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2726]
  000c5	85 c0		 test	 eax, eax
  000c7	74 02		 je	 SHORT $LN5@build_bl_t
  000c9	eb 02		 jmp	 SHORT $LN3@build_bl_t
$LN5@build_bl_t:

; 820  :     }

  000cb	eb c7		 jmp	 SHORT $LN2@build_bl_t
$LN3@build_bl_t:

; 821  :     /* Update opt_len to include the bit length tree and counts */
; 822  :     s->opt_len += 3*((ulg)max_blindex+1) + 5+5+4;

  000cd	8b 44 24 20	 mov	 eax, DWORD PTR max_blindex$[rsp]
  000d1	ff c0		 inc	 eax
  000d3	6b c0 03	 imul	 eax, eax, 3
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000db	8b 89 00 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5888]
  000e1	8d 44 08 0e	 lea	 eax, DWORD PTR [rax+rcx+14]
  000e5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000ea	89 81 00 17 00
	00		 mov	 DWORD PTR [rcx+5888], eax

; 823  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 824  :             s->opt_len, s->static_len));
; 825  : 
; 826  :     return max_blindex;

  000f0	8b 44 24 20	 mov	 eax, DWORD PTR max_blindex$[rsp]

; 827  : }

  000f4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0
build_bl_tree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT send_all_trees
_TEXT	SEGMENT
rank$ = 32
len$1 = 36
val$2 = 40
len$3 = 44
val$4 = 48
len$5 = 52
val$6 = 56
len$7 = 60
val$8 = 64
s$ = 96
lcodes$ = 104
dcodes$ = 112
blcodes$ = 120
send_all_trees PROC					; COMDAT

; 837  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 14 00 00 00	 mov	 ecx, 20
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00033	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 838  :     int rank;                    /* index in bl_order */
; 839  : 
; 840  :     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
; 841  :     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
; 842  :             "too many codes");
; 843  :     Tracev((stderr, "\nbl counts: "));
; 844  :     send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */

  00038	c7 44 24 24 05
	00 00 00	 mov	 DWORD PTR len$1[rsp], 5
  00040	b8 10 00 00 00	 mov	 eax, 16
  00045	2b 44 24 24	 sub	 eax, DWORD PTR len$1[rsp]
  00049	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0004e	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00054	0f 8e ec 00 00
	00		 jle	 $LN5@send_all_t
  0005a	8b 44 24 68	 mov	 eax, DWORD PTR lcodes$[rsp]
  0005e	2d 01 01 00 00	 sub	 eax, 257		; 00000101H
  00063	89 44 24 28	 mov	 DWORD PTR val$2[rsp], eax
  00067	0f b7 44 24 28	 movzx	 eax, WORD PTR val$2[rsp]
  0006c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00071	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00077	d3 e0		 shl	 eax, cl
  00079	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0007e	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00085	0b c8		 or	 ecx, eax
  00087	8b c1		 mov	 eax, ecx
  00089	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0008e	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00095	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0009a	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  000a1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000ab	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  000ae	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  000b3	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000b7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000ba	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000bf	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000c2	ff c0		 inc	 eax
  000c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000c9	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  000cc	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000d1	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  000d8	c1 f8 08	 sar	 eax, 8
  000db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e0	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  000e3	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  000e8	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000ec	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000ef	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000f4	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000f7	ff c0		 inc	 eax
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000fe	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00101	0f b7 44 24 28	 movzx	 eax, WORD PTR val$2[rsp]
  00106	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0010b	ba 10 00 00 00	 mov	 edx, 16
  00110	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00116	8b ca		 mov	 ecx, edx
  00118	d3 f8		 sar	 eax, cl
  0011a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0011f	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00126	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0012b	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00131	8b 4c 24 24	 mov	 ecx, DWORD PTR len$1[rsp]
  00135	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00139	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0013e	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  00144	eb 4f		 jmp	 SHORT $LN6@send_all_t
$LN5@send_all_t:
  00146	8b 44 24 68	 mov	 eax, DWORD PTR lcodes$[rsp]
  0014a	2d 01 01 00 00	 sub	 eax, 257		; 00000101H
  0014f	0f b7 c0	 movzx	 eax, ax
  00152	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00157	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  0015d	d3 e0		 shl	 eax, cl
  0015f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00164	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  0016b	0b c8		 or	 ecx, eax
  0016d	8b c1		 mov	 eax, ecx
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00174	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0017b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00180	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00186	03 44 24 24	 add	 eax, DWORD PTR len$1[rsp]
  0018a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0018f	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN6@send_all_t:

; 845  :     send_bits(s, dcodes-1,   5);

  00195	c7 44 24 2c 05
	00 00 00	 mov	 DWORD PTR len$3[rsp], 5
  0019d	b8 10 00 00 00	 mov	 eax, 16
  001a2	2b 44 24 2c	 sub	 eax, DWORD PTR len$3[rsp]
  001a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001ab	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  001b1	0f 8e e9 00 00
	00		 jle	 $LN7@send_all_t
  001b7	8b 44 24 70	 mov	 eax, DWORD PTR dcodes$[rsp]
  001bb	ff c8		 dec	 eax
  001bd	89 44 24 30	 mov	 DWORD PTR val$4[rsp], eax
  001c1	0f b7 44 24 30	 movzx	 eax, WORD PTR val$4[rsp]
  001c6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001cb	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  001d1	d3 e0		 shl	 eax, cl
  001d3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001d8	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  001df	0b c8		 or	 ecx, eax
  001e1	8b c1		 mov	 eax, ecx
  001e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001e8	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  001ef	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001f4	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  001fb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00200	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00205	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00208	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  0020d	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00211	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00214	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00219	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0021c	ff c0		 inc	 eax
  0021e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00223	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00226	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0022b	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00232	c1 f8 08	 sar	 eax, 8
  00235	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0023a	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0023d	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  00242	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00246	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00249	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0024e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00251	ff c0		 inc	 eax
  00253	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00258	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0025b	0f b7 44 24 30	 movzx	 eax, WORD PTR val$4[rsp]
  00260	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00265	ba 10 00 00 00	 mov	 edx, 16
  0026a	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00270	8b ca		 mov	 ecx, edx
  00272	d3 f8		 sar	 eax, cl
  00274	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00279	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00280	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00285	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  0028b	8b 4c 24 2c	 mov	 ecx, DWORD PTR len$3[rsp]
  0028f	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00293	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00298	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  0029e	eb 4c		 jmp	 SHORT $LN8@send_all_t
$LN7@send_all_t:
  002a0	8b 44 24 70	 mov	 eax, DWORD PTR dcodes$[rsp]
  002a4	ff c8		 dec	 eax
  002a6	0f b7 c0	 movzx	 eax, ax
  002a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002ae	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  002b4	d3 e0		 shl	 eax, cl
  002b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002bb	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  002c2	0b c8		 or	 ecx, eax
  002c4	8b c1		 mov	 eax, ecx
  002c6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002cb	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  002d2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002d7	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  002dd	03 44 24 2c	 add	 eax, DWORD PTR len$3[rsp]
  002e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002e6	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN8@send_all_t:

; 846  :     send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */

  002ec	c7 44 24 34 04
	00 00 00	 mov	 DWORD PTR len$5[rsp], 4
  002f4	b8 10 00 00 00	 mov	 eax, 16
  002f9	2b 44 24 34	 sub	 eax, DWORD PTR len$5[rsp]
  002fd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00302	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00308	0f 8e ea 00 00
	00		 jle	 $LN9@send_all_t
  0030e	8b 44 24 78	 mov	 eax, DWORD PTR blcodes$[rsp]
  00312	83 e8 04	 sub	 eax, 4
  00315	89 44 24 38	 mov	 DWORD PTR val$6[rsp], eax
  00319	0f b7 44 24 38	 movzx	 eax, WORD PTR val$6[rsp]
  0031e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00323	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00329	d3 e0		 shl	 eax, cl
  0032b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00330	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00337	0b c8		 or	 ecx, eax
  00339	8b c1		 mov	 eax, ecx
  0033b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00340	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00347	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0034c	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00353	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00358	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0035d	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00360	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  00365	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00369	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0036c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00371	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00374	ff c0		 inc	 eax
  00376	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0037b	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0037e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00383	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0038a	c1 f8 08	 sar	 eax, 8
  0038d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00392	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00395	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  0039a	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0039e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003a1	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  003a6	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  003a9	ff c0		 inc	 eax
  003ab	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003b0	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  003b3	0f b7 44 24 38	 movzx	 eax, WORD PTR val$6[rsp]
  003b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003bd	ba 10 00 00 00	 mov	 edx, 16
  003c2	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  003c8	8b ca		 mov	 ecx, edx
  003ca	d3 f8		 sar	 eax, cl
  003cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003d1	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  003d8	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  003dd	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  003e3	8b 4c 24 34	 mov	 ecx, DWORD PTR len$5[rsp]
  003e7	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  003eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003f0	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  003f6	eb 4d		 jmp	 SHORT $LN10@send_all_t
$LN9@send_all_t:
  003f8	8b 44 24 78	 mov	 eax, DWORD PTR blcodes$[rsp]
  003fc	83 e8 04	 sub	 eax, 4
  003ff	0f b7 c0	 movzx	 eax, ax
  00402	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00407	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  0040d	d3 e0		 shl	 eax, cl
  0040f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00414	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  0041b	0b c8		 or	 ecx, eax
  0041d	8b c1		 mov	 eax, ecx
  0041f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00424	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0042b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00430	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00436	03 44 24 34	 add	 eax, DWORD PTR len$5[rsp]
  0043a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0043f	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN10@send_all_t:

; 847  :     for (rank = 0; rank < blcodes; rank++) {

  00445	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rank$[rsp], 0
  0044d	eb 0a		 jmp	 SHORT $LN4@send_all_t
$LN2@send_all_t:
  0044f	8b 44 24 20	 mov	 eax, DWORD PTR rank$[rsp]
  00453	ff c0		 inc	 eax
  00455	89 44 24 20	 mov	 DWORD PTR rank$[rsp], eax
$LN4@send_all_t:
  00459	8b 44 24 78	 mov	 eax, DWORD PTR blcodes$[rsp]
  0045d	39 44 24 20	 cmp	 DWORD PTR rank$[rsp], eax
  00461	0f 8d 8d 01 00
	00		 jge	 $LN3@send_all_t

; 848  :         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
; 849  :         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);

  00467	c7 44 24 3c 03
	00 00 00	 mov	 DWORD PTR len$7[rsp], 3
  0046f	b8 10 00 00 00	 mov	 eax, 16
  00474	2b 44 24 3c	 sub	 eax, DWORD PTR len$7[rsp]
  00478	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0047d	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00483	0f 8e 03 01 00
	00		 jle	 $LN11@send_all_t
  00489	0f ae e8	 lfence
  0048c	48 63 44 24 20	 movsxd	 rax, DWORD PTR rank$[rsp]
  00491	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bl_order
  00498	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0049c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  004a1	0f b7 84 81 a6
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2726]
  004a9	89 44 24 40	 mov	 DWORD PTR val$8[rsp], eax
  004ad	0f b7 44 24 40	 movzx	 eax, WORD PTR val$8[rsp]
  004b2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  004b7	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  004bd	d3 e0		 shl	 eax, cl
  004bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  004c4	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  004cb	0b c8		 or	 ecx, eax
  004cd	8b c1		 mov	 eax, ecx
  004cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  004d4	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  004db	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  004e0	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  004e7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  004f1	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  004f4	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  004f9	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  004fd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00500	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00505	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00508	ff c0		 inc	 eax
  0050a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0050f	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00512	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00517	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0051e	c1 f8 08	 sar	 eax, 8
  00521	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00526	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00529	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  0052e	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00532	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00535	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0053a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0053d	ff c0		 inc	 eax
  0053f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00544	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00547	0f b7 44 24 40	 movzx	 eax, WORD PTR val$8[rsp]
  0054c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00551	ba 10 00 00 00	 mov	 edx, 16
  00556	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  0055c	8b ca		 mov	 ecx, edx
  0055e	d3 f8		 sar	 eax, cl
  00560	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00565	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0056c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00571	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00577	8b 4c 24 3c	 mov	 ecx, DWORD PTR len$7[rsp]
  0057b	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  0057f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00584	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  0058a	eb 63		 jmp	 SHORT $LN12@send_all_t
$LN11@send_all_t:
  0058c	0f ae e8	 lfence
  0058f	48 63 44 24 20	 movsxd	 rax, DWORD PTR rank$[rsp]
  00594	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bl_order
  0059b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0059f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  005a4	0f b7 84 81 a6
	0a 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2726]
  005ac	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  005b1	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  005b7	d3 e0		 shl	 eax, cl
  005b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  005be	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  005c5	0b c8		 or	 ecx, eax
  005c7	8b c1		 mov	 eax, ecx
  005c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  005ce	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  005d5	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  005da	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  005e0	03 44 24 3c	 add	 eax, DWORD PTR len$7[rsp]
  005e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  005e9	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN12@send_all_t:

; 850  :     }

  005ef	e9 5b fe ff ff	 jmp	 $LN2@send_all_t
$LN3@send_all_t:

; 851  :     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
; 852  : 
; 853  :     send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */

  005f4	8b 44 24 68	 mov	 eax, DWORD PTR lcodes$[rsp]
  005f8	ff c8		 dec	 eax
  005fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  005ff	48 81 c1 bc 00
	00 00		 add	 rcx, 188		; 000000bcH
  00606	44 8b c0	 mov	 r8d, eax
  00609	48 8b d1	 mov	 rdx, rcx
  0060c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00611	e8 00 00 00 00	 call	 send_tree

; 854  :     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
; 855  : 
; 856  :     send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */

  00616	8b 44 24 70	 mov	 eax, DWORD PTR dcodes$[rsp]
  0061a	ff c8		 dec	 eax
  0061c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00621	48 81 c1 b0 09
	00 00		 add	 rcx, 2480		; 000009b0H
  00628	44 8b c0	 mov	 r8d, eax
  0062b	48 8b d1	 mov	 rdx, rcx
  0062e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00633	e8 00 00 00 00	 call	 send_tree

; 857  :     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
; 858  : }

  00638	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0063c	5f		 pop	 rdi
  0063d	c3		 ret	 0
send_all_trees ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT compress_block
_TEXT	SEGMENT
dist$ = 32
lc$ = 36
lx$ = 40
code$ = 44
extra$ = 48
len$1 = 52
val$2 = 56
len$3 = 60
val$4 = 64
len$5 = 68
val$6 = 72
len$7 = 76
val$8 = 80
len$9 = 84
val$10 = 88
len$11 = 92
val$12 = 96
tv336 = 100
s$ = 128
ltree$ = 136
dtree$ = 144
compress_block PROC					; COMDAT

; 1068 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 1c 00 00 00	 mov	 ecx, 28
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00032	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1069 :     unsigned dist;      /* distance of matched string */
; 1070 :     int lc;             /* match length or unmatched char (if dist == 0) */
; 1071 :     unsigned lx = 0;    /* running index in l_buf */

  00037	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR lx$[rsp], 0

; 1072 :     unsigned code;      /* the code to send */
; 1073 :     int extra;          /* number of extra bits to send */
; 1074 : 
; 1075 :     if (s->last_lit != 0) do {

  0003f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00047	83 b8 f4 16 00
	00 00		 cmp	 DWORD PTR [rax+5876], 0
  0004e	0f 84 aa 09 00
	00		 je	 $LN5@compress_b
$LN4@compress_b:

; 1076 :         dist = s->d_buf[lx];

  00054	8b 44 24 28	 mov	 eax, DWORD PTR lx$[rsp]
  00058	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00060	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00067	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0006b	89 44 24 20	 mov	 DWORD PTR dist$[rsp], eax

; 1077 :         lc = s->l_buf[lx++];

  0006f	8b 44 24 28	 mov	 eax, DWORD PTR lx$[rsp]
  00073	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0007b	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00082	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00086	89 44 24 24	 mov	 DWORD PTR lc$[rsp], eax
  0008a	8b 44 24 28	 mov	 eax, DWORD PTR lx$[rsp]
  0008e	ff c0		 inc	 eax
  00090	89 44 24 28	 mov	 DWORD PTR lx$[rsp], eax

; 1078 :         if (dist == 0) {

  00094	83 7c 24 20 00	 cmp	 DWORD PTR dist$[rsp], 0
  00099	0f 85 c2 01 00
	00		 jne	 $LN6@compress_b

; 1079 :             send_code(s, lc, ltree); /* send a literal byte */

  0009f	48 63 44 24 24	 movsxd	 rax, DWORD PTR lc$[rsp]
  000a4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ltree$[rsp]
  000ac	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  000b1	89 44 24 34	 mov	 DWORD PTR len$1[rsp], eax
  000b5	b8 10 00 00 00	 mov	 eax, 16
  000ba	2b 44 24 34	 sub	 eax, DWORD PTR len$1[rsp]
  000be	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c6	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  000cc	0f 8e 27 01 00
	00		 jle	 $LN8@compress_b
  000d2	48 63 44 24 24	 movsxd	 rax, DWORD PTR lc$[rsp]
  000d7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ltree$[rsp]
  000df	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  000e3	89 44 24 38	 mov	 DWORD PTR val$2[rsp], eax
  000e7	0f b7 44 24 38	 movzx	 eax, WORD PTR val$2[rsp]
  000ec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f4	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  000fa	d3 e0		 shl	 eax, cl
  000fc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00104	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  0010b	0b c8		 or	 ecx, eax
  0010d	8b c1		 mov	 eax, ecx
  0010f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00117	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0011e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00126	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0012d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00132	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0013a	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0013d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00145	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00149	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0014c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00154	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00157	ff c0		 inc	 eax
  00159	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00161	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00164	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0016c	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00173	c1 f8 08	 sar	 eax, 8
  00176	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0017e	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00181	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00189	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0018d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00190	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00198	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0019b	ff c0		 inc	 eax
  0019d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001a5	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  001a8	0f b7 44 24 38	 movzx	 eax, WORD PTR val$2[rsp]
  001ad	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001b5	ba 10 00 00 00	 mov	 edx, 16
  001ba	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  001c0	8b ca		 mov	 ecx, edx
  001c2	d3 f8		 sar	 eax, cl
  001c4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001cc	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  001d3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001db	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  001e1	8b 4c 24 34	 mov	 ecx, DWORD PTR len$1[rsp]
  001e5	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  001e9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001f1	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  001f7	eb 63		 jmp	 SHORT $LN9@compress_b
$LN8@compress_b:
  001f9	48 63 44 24 24	 movsxd	 rax, DWORD PTR lc$[rsp]
  001fe	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ltree$[rsp]
  00206	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  0020a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00212	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00218	d3 e0		 shl	 eax, cl
  0021a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00222	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00229	0b c8		 or	 ecx, eax
  0022b	8b c1		 mov	 eax, ecx
  0022d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00235	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  0023c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00244	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  0024a	03 44 24 34	 add	 eax, DWORD PTR len$1[rsp]
  0024e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00256	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN9@compress_b:

; 1080 :             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
; 1081 :         } else {

  0025c	e9 85 07 00 00	 jmp	 $LN7@compress_b
$LN6@compress_b:

; 1082 :             /* Here, lc is the match length - MIN_MATCH */
; 1083 :             code = _length_code[lc];

  00261	48 63 44 24 24	 movsxd	 rax, DWORD PTR lc$[rsp]
  00266	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_length_code
  0026d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00271	89 44 24 2c	 mov	 DWORD PTR code$[rsp], eax

; 1084 :             send_code(s, code+LITERALS+1, ltree); /* send the length code */

  00275	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00279	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0027e	8b c0		 mov	 eax, eax
  00280	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ltree$[rsp]
  00288	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  0028d	89 44 24 3c	 mov	 DWORD PTR len$3[rsp], eax
  00291	b8 10 00 00 00	 mov	 eax, 16
  00296	2b 44 24 3c	 sub	 eax, DWORD PTR len$3[rsp]
  0029a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a2	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  002a8	0f 8e 2d 01 00
	00		 jle	 $LN10@compress_b
  002ae	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  002b2	05 01 01 00 00	 add	 eax, 257		; 00000101H
  002b7	8b c0		 mov	 eax, eax
  002b9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ltree$[rsp]
  002c1	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  002c5	89 44 24 40	 mov	 DWORD PTR val$4[rsp], eax
  002c9	0f b7 44 24 40	 movzx	 eax, WORD PTR val$4[rsp]
  002ce	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002d6	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  002dc	d3 e0		 shl	 eax, cl
  002de	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002e6	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  002ed	0b c8		 or	 ecx, eax
  002ef	8b c1		 mov	 eax, ecx
  002f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002f9	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00300	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00308	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0030f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00314	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0031c	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0031f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00327	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0032b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0032e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00336	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00339	ff c0		 inc	 eax
  0033b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00343	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00346	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0034e	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00355	c1 f8 08	 sar	 eax, 8
  00358	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00360	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00363	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0036b	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0036f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00372	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0037a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0037d	ff c0		 inc	 eax
  0037f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00387	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0038a	0f b7 44 24 40	 movzx	 eax, WORD PTR val$4[rsp]
  0038f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00397	ba 10 00 00 00	 mov	 edx, 16
  0039c	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  003a2	8b ca		 mov	 ecx, edx
  003a4	d3 f8		 sar	 eax, cl
  003a6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003ae	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  003b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003bd	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  003c3	8b 4c 24 3c	 mov	 ecx, DWORD PTR len$3[rsp]
  003c7	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  003cb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003d3	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  003d9	eb 69		 jmp	 SHORT $LN11@compress_b
$LN10@compress_b:
  003db	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  003df	05 01 01 00 00	 add	 eax, 257		; 00000101H
  003e4	8b c0		 mov	 eax, eax
  003e6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ltree$[rsp]
  003ee	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  003f2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003fa	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00400	d3 e0		 shl	 eax, cl
  00402	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0040a	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00411	0b c8		 or	 ecx, eax
  00413	8b c1		 mov	 eax, ecx
  00415	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0041d	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00424	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0042c	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00432	03 44 24 3c	 add	 eax, DWORD PTR len$3[rsp]
  00436	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0043e	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN11@compress_b:

; 1085 :             extra = extra_lbits[code];

  00444	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00448	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:extra_lbits
  0044f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00452	89 44 24 30	 mov	 DWORD PTR extra$[rsp], eax

; 1086 :             if (extra != 0) {

  00456	83 7c 24 30 00	 cmp	 DWORD PTR extra$[rsp], 0
  0045b	0f 84 b0 01 00
	00		 je	 $LN12@compress_b

; 1087 :                 lc -= base_length[code];

  00461	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00465	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:base_length
  0046c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0046f	8b 4c 24 24	 mov	 ecx, DWORD PTR lc$[rsp]
  00473	2b c8		 sub	 ecx, eax
  00475	8b c1		 mov	 eax, ecx
  00477	89 44 24 24	 mov	 DWORD PTR lc$[rsp], eax

; 1088 :                 send_bits(s, lc, extra);       /* send the extra length bits */

  0047b	8b 44 24 30	 mov	 eax, DWORD PTR extra$[rsp]
  0047f	89 44 24 44	 mov	 DWORD PTR len$5[rsp], eax
  00483	b8 10 00 00 00	 mov	 eax, 16
  00488	2b 44 24 44	 sub	 eax, DWORD PTR len$5[rsp]
  0048c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00494	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  0049a	0f 8e 1a 01 00
	00		 jle	 $LN13@compress_b
  004a0	8b 44 24 24	 mov	 eax, DWORD PTR lc$[rsp]
  004a4	89 44 24 48	 mov	 DWORD PTR val$6[rsp], eax
  004a8	0f b7 44 24 48	 movzx	 eax, WORD PTR val$6[rsp]
  004ad	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004b5	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  004bb	d3 e0		 shl	 eax, cl
  004bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004c5	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  004cc	0b c8		 or	 ecx, eax
  004ce	8b c1		 mov	 eax, ecx
  004d0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004d8	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  004df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004e7	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  004ee	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004f3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004fb	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  004fe	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00506	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0050a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0050d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00515	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00518	ff c0		 inc	 eax
  0051a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00522	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00525	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0052d	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00534	c1 f8 08	 sar	 eax, 8
  00537	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0053f	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00542	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0054a	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0054e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00551	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00559	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0055c	ff c0		 inc	 eax
  0055e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00566	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00569	0f b7 44 24 48	 movzx	 eax, WORD PTR val$6[rsp]
  0056e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00576	ba 10 00 00 00	 mov	 edx, 16
  0057b	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00581	8b ca		 mov	 ecx, edx
  00583	d3 f8		 sar	 eax, cl
  00585	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0058d	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00594	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0059c	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  005a2	8b 4c 24 44	 mov	 ecx, DWORD PTR len$5[rsp]
  005a6	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  005aa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005b2	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  005b8	eb 57		 jmp	 SHORT $LN14@compress_b
$LN13@compress_b:
  005ba	0f b7 44 24 24	 movzx	 eax, WORD PTR lc$[rsp]
  005bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005c7	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  005cd	d3 e0		 shl	 eax, cl
  005cf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005d7	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  005de	0b c8		 or	 ecx, eax
  005e0	8b c1		 mov	 eax, ecx
  005e2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005ea	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  005f1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005f9	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  005ff	03 44 24 44	 add	 eax, DWORD PTR len$5[rsp]
  00603	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0060b	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN14@compress_b:
$LN12@compress_b:

; 1089 :             }
; 1090 :             dist--; /* dist is now the match distance - 1 */

  00611	8b 44 24 20	 mov	 eax, DWORD PTR dist$[rsp]
  00615	ff c8		 dec	 eax
  00617	89 44 24 20	 mov	 DWORD PTR dist$[rsp], eax

; 1091 :             code = d_code(dist);

  0061b	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR dist$[rsp], 256 ; 00000100H
  00623	73 15		 jae	 SHORT $LN23@compress_b
  00625	8b 44 24 20	 mov	 eax, DWORD PTR dist$[rsp]
  00629	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  00630	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00634	89 44 24 64	 mov	 DWORD PTR tv336[rsp], eax
  00638	eb 1d		 jmp	 SHORT $LN24@compress_b
$LN23@compress_b:
  0063a	8b 44 24 20	 mov	 eax, DWORD PTR dist$[rsp]
  0063e	c1 e8 07	 shr	 eax, 7
  00641	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00646	8b c0		 mov	 eax, eax
  00648	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  0064f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00653	89 44 24 64	 mov	 DWORD PTR tv336[rsp], eax
$LN24@compress_b:
  00657	8b 44 24 64	 mov	 eax, DWORD PTR tv336[rsp]
  0065b	89 44 24 2c	 mov	 DWORD PTR code$[rsp], eax

; 1092 :             Assert (code < D_CODES, "bad d_code");
; 1093 : 
; 1094 :             send_code(s, code, dtree);       /* send the distance code */

  0065f	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00663	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dtree$[rsp]
  0066b	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  00670	89 44 24 4c	 mov	 DWORD PTR len$7[rsp], eax
  00674	b8 10 00 00 00	 mov	 eax, 16
  00679	2b 44 24 4c	 sub	 eax, DWORD PTR len$7[rsp]
  0067d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00685	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  0068b	0f 8e 26 01 00
	00		 jle	 $LN15@compress_b
  00691	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00695	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dtree$[rsp]
  0069d	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  006a1	89 44 24 50	 mov	 DWORD PTR val$8[rsp], eax
  006a5	0f b7 44 24 50	 movzx	 eax, WORD PTR val$8[rsp]
  006aa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006b2	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  006b8	d3 e0		 shl	 eax, cl
  006ba	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006c2	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  006c9	0b c8		 or	 ecx, eax
  006cb	8b c1		 mov	 eax, ecx
  006cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006d5	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  006dc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006e4	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  006eb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006f8	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  006fb	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00703	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00707	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0070a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00712	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00715	ff c0		 inc	 eax
  00717	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0071f	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00722	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0072a	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00731	c1 f8 08	 sar	 eax, 8
  00734	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0073c	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0073f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00747	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0074b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0074e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00756	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00759	ff c0		 inc	 eax
  0075b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00763	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00766	0f b7 44 24 50	 movzx	 eax, WORD PTR val$8[rsp]
  0076b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00773	ba 10 00 00 00	 mov	 edx, 16
  00778	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  0077e	8b ca		 mov	 ecx, edx
  00780	d3 f8		 sar	 eax, cl
  00782	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0078a	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00791	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00799	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  0079f	8b 4c 24 4c	 mov	 ecx, DWORD PTR len$7[rsp]
  007a3	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  007a7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007af	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  007b5	eb 62		 jmp	 SHORT $LN16@compress_b
$LN15@compress_b:
  007b7	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  007bb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dtree$[rsp]
  007c3	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  007c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007cf	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  007d5	d3 e0		 shl	 eax, cl
  007d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007df	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  007e6	0b c8		 or	 ecx, eax
  007e8	8b c1		 mov	 eax, ecx
  007ea	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007f2	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  007f9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00801	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00807	03 44 24 4c	 add	 eax, DWORD PTR len$7[rsp]
  0080b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00813	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN16@compress_b:

; 1095 :             extra = extra_dbits[code];

  00819	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  0081d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:extra_dbits
  00824	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00827	89 44 24 30	 mov	 DWORD PTR extra$[rsp], eax

; 1096 :             if (extra != 0) {

  0082b	83 7c 24 30 00	 cmp	 DWORD PTR extra$[rsp], 0
  00830	0f 84 b0 01 00
	00		 je	 $LN17@compress_b

; 1097 :                 dist -= (unsigned)base_dist[code];

  00836	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  0083a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:base_dist
  00841	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00844	8b 4c 24 20	 mov	 ecx, DWORD PTR dist$[rsp]
  00848	2b c8		 sub	 ecx, eax
  0084a	8b c1		 mov	 eax, ecx
  0084c	89 44 24 20	 mov	 DWORD PTR dist$[rsp], eax

; 1098 :                 send_bits(s, dist, extra);   /* send the extra distance bits */

  00850	8b 44 24 30	 mov	 eax, DWORD PTR extra$[rsp]
  00854	89 44 24 54	 mov	 DWORD PTR len$9[rsp], eax
  00858	b8 10 00 00 00	 mov	 eax, 16
  0085d	2b 44 24 54	 sub	 eax, DWORD PTR len$9[rsp]
  00861	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00869	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  0086f	0f 8e 1a 01 00
	00		 jle	 $LN18@compress_b
  00875	8b 44 24 20	 mov	 eax, DWORD PTR dist$[rsp]
  00879	89 44 24 58	 mov	 DWORD PTR val$10[rsp], eax
  0087d	0f b7 44 24 58	 movzx	 eax, WORD PTR val$10[rsp]
  00882	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0088a	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00890	d3 e0		 shl	 eax, cl
  00892	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0089a	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  008a1	0b c8		 or	 ecx, eax
  008a3	8b c1		 mov	 eax, ecx
  008a5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008ad	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  008b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008bc	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  008c3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008c8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008d0	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  008d3	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  008db	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  008df	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008ea	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  008ed	ff c0		 inc	 eax
  008ef	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008f7	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  008fa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00902	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00909	c1 f8 08	 sar	 eax, 8
  0090c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00914	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00917	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0091f	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00923	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00926	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0092e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00931	ff c0		 inc	 eax
  00933	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0093b	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0093e	0f b7 44 24 58	 movzx	 eax, WORD PTR val$10[rsp]
  00943	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0094b	ba 10 00 00 00	 mov	 edx, 16
  00950	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00956	8b ca		 mov	 ecx, edx
  00958	d3 f8		 sar	 eax, cl
  0095a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00962	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00969	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00971	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00977	8b 4c 24 54	 mov	 ecx, DWORD PTR len$9[rsp]
  0097b	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  0097f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00987	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  0098d	eb 57		 jmp	 SHORT $LN19@compress_b
$LN18@compress_b:
  0098f	0f b7 44 24 20	 movzx	 eax, WORD PTR dist$[rsp]
  00994	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0099c	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  009a2	d3 e0		 shl	 eax, cl
  009a4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009ac	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  009b3	0b c8		 or	 ecx, eax
  009b5	8b c1		 mov	 eax, ecx
  009b7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009bf	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  009c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009ce	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  009d4	03 44 24 54	 add	 eax, DWORD PTR len$9[rsp]
  009d8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009e0	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN19@compress_b:
$LN17@compress_b:
$LN7@compress_b:

; 1099 :             }
; 1100 :         } /* literal or match pair ? */
; 1101 : 
; 1102 :         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
; 1103 :         Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
; 1104 :                "pendingBuf overflow");
; 1105 : 
; 1106 :     } while (lx < s->last_lit);

  009e6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009ee	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  009f4	39 44 24 28	 cmp	 DWORD PTR lx$[rsp], eax
  009f8	0f 82 56 f6 ff
	ff		 jb	 $LN4@compress_b
$LN5@compress_b:

; 1107 : 
; 1108 :     send_code(s, END_BLOCK, ltree);

  009fe	b8 04 00 00 00	 mov	 eax, 4
  00a03	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  00a0a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ltree$[rsp]
  00a12	0f b7 44 01 02	 movzx	 eax, WORD PTR [rcx+rax+2]
  00a17	89 44 24 5c	 mov	 DWORD PTR len$11[rsp], eax
  00a1b	b8 10 00 00 00	 mov	 eax, 16
  00a20	2b 44 24 5c	 sub	 eax, DWORD PTR len$11[rsp]
  00a24	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a2c	39 81 14 17 00
	00		 cmp	 DWORD PTR [rcx+5908], eax
  00a32	0f 8e 2e 01 00
	00		 jle	 $LN20@compress_b
  00a38	b8 04 00 00 00	 mov	 eax, 4
  00a3d	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  00a44	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ltree$[rsp]
  00a4c	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00a50	89 44 24 60	 mov	 DWORD PTR val$12[rsp], eax
  00a54	0f b7 44 24 60	 movzx	 eax, WORD PTR val$12[rsp]
  00a59	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a61	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00a67	d3 e0		 shl	 eax, cl
  00a69	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a71	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00a78	0b c8		 or	 ecx, eax
  00a7a	8b c1		 mov	 eax, ecx
  00a7c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a84	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00a8b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a93	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00a9a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a9f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aa7	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00aaa	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00ab2	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00ab6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00ab9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ac1	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00ac4	ff c0		 inc	 eax
  00ac6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ace	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00ad1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ad9	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00ae0	c1 f8 08	 sar	 eax, 8
  00ae3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aeb	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00aee	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00af6	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00afa	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00afd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b05	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b08	ff c0		 inc	 eax
  00b0a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b12	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00b15	0f b7 44 24 60	 movzx	 eax, WORD PTR val$12[rsp]
  00b1a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b22	ba 10 00 00 00	 mov	 edx, 16
  00b27	2b 91 14 17 00
	00		 sub	 edx, DWORD PTR [rcx+5908]
  00b2d	8b ca		 mov	 ecx, edx
  00b2f	d3 f8		 sar	 eax, cl
  00b31	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b39	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00b40	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b48	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00b4e	8b 4c 24 5c	 mov	 ecx, DWORD PTR len$11[rsp]
  00b52	8d 44 01 f0	 lea	 eax, DWORD PTR [rcx+rax-16]
  00b56	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b5e	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
  00b64	eb 6a		 jmp	 SHORT $LN21@compress_b
$LN20@compress_b:
  00b66	b8 04 00 00 00	 mov	 eax, 4
  00b6b	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  00b72	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ltree$[rsp]
  00b7a	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00b7e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b86	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00b8c	d3 e0		 shl	 eax, cl
  00b8e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b96	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  00b9d	0b c8		 or	 ecx, eax
  00b9f	8b c1		 mov	 eax, ecx
  00ba1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ba9	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00bb0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bb8	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00bbe	03 44 24 5c	 add	 eax, DWORD PTR len$11[rsp]
  00bc2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bca	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN21@compress_b:

; 1109 : }

  00bd0	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00bd4	5f		 pop	 rdi
  00bd5	c3		 ret	 0
compress_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT detect_data_type
_TEXT	SEGMENT
black_mask$ = 32
n$ = 36
s$ = 64
detect_data_type PROC					; COMDAT

; 1126 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1127 :     /* black_mask is the bit mask of black-listed bytes
; 1128 :      * set bits 0..6, 14..25, and 28..31
; 1129 :      * 0xf3ffc07f = binary 11110011111111111100000001111111
; 1130 :      */
; 1131 :     unsigned long black_mask = 0xf3ffc07fUL;

  0002a	c7 44 24 20 7f
	c0 ff f3	 mov	 DWORD PTR black_mask$[rsp], -201342849 ; f3ffc07fH

; 1132 :     int n;
; 1133 : 
; 1134 :     /* Check for non-textual ("black-listed") bytes. */
; 1135 :     for (n = 0; n <= 31; n++, black_mask >>= 1)

  00032	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0003a	eb 14		 jmp	 SHORT $LN4@detect_dat
$LN2@detect_dat:
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00040	ff c0		 inc	 eax
  00042	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR black_mask$[rsp]
  0004a	d1 e8		 shr	 eax, 1
  0004c	89 44 24 20	 mov	 DWORD PTR black_mask$[rsp], eax
$LN4@detect_dat:
  00050	83 7c 24 24 1f	 cmp	 DWORD PTR n$[rsp], 31
  00055	7f 2a		 jg	 SHORT $LN3@detect_dat

; 1136 :         if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))

  00057	8b 44 24 20	 mov	 eax, DWORD PTR black_mask$[rsp]
  0005b	83 e0 01	 and	 eax, 1
  0005e	85 c0		 test	 eax, eax
  00060	74 1d		 je	 SHORT $LN8@detect_dat
  00062	48 63 44 24 24	 movsxd	 rax, DWORD PTR n$[rsp]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006c	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  00074	85 c0		 test	 eax, eax
  00076	74 07		 je	 SHORT $LN8@detect_dat

; 1137 :             return Z_BINARY;

  00078	33 c0		 xor	 eax, eax
  0007a	e9 96 00 00 00	 jmp	 $LN1@detect_dat
$LN8@detect_dat:
  0007f	eb bb		 jmp	 SHORT $LN2@detect_dat
$LN3@detect_dat:

; 1138 : 
; 1139 :     /* Check for textual ("white-listed") bytes. */
; 1140 :     if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
; 1141 :             || s->dyn_ltree[13].Freq != 0)

  00081	b8 04 00 00 00	 mov	 eax, 4
  00086	48 6b c0 09	 imul	 rax, rax, 9
  0008a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0008f	0f b7 84 01 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax+188]
  00097	85 c0		 test	 eax, eax
  00099	75 34		 jne	 SHORT $LN10@detect_dat
  0009b	b8 04 00 00 00	 mov	 eax, 4
  000a0	48 6b c0 0a	 imul	 rax, rax, 10
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a9	0f b7 84 01 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax+188]
  000b1	85 c0		 test	 eax, eax
  000b3	75 1a		 jne	 SHORT $LN10@detect_dat
  000b5	b8 04 00 00 00	 mov	 eax, 4
  000ba	48 6b c0 0d	 imul	 rax, rax, 13
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c3	0f b7 84 01 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax+188]
  000cb	85 c0		 test	 eax, eax
  000cd	74 07		 je	 SHORT $LN9@detect_dat
$LN10@detect_dat:

; 1142 :         return Z_TEXT;

  000cf	b8 01 00 00 00	 mov	 eax, 1
  000d4	eb 3f		 jmp	 SHORT $LN1@detect_dat
$LN9@detect_dat:

; 1143 :     for (n = 32; n < LITERALS; n++)

  000d6	c7 44 24 24 20
	00 00 00	 mov	 DWORD PTR n$[rsp], 32	; 00000020H
  000de	eb 0a		 jmp	 SHORT $LN7@detect_dat
$LN5@detect_dat:
  000e0	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  000e4	ff c0		 inc	 eax
  000e6	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
$LN7@detect_dat:
  000ea	81 7c 24 24 00
	01 00 00	 cmp	 DWORD PTR n$[rsp], 256	; 00000100H
  000f2	7d 1f		 jge	 SHORT $LN6@detect_dat

; 1144 :         if (s->dyn_ltree[n].Freq != 0)

  000f4	48 63 44 24 24	 movsxd	 rax, DWORD PTR n$[rsp]
  000f9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000fe	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  00106	85 c0		 test	 eax, eax
  00108	74 07		 je	 SHORT $LN11@detect_dat

; 1145 :             return Z_TEXT;

  0010a	b8 01 00 00 00	 mov	 eax, 1
  0010f	eb 04		 jmp	 SHORT $LN1@detect_dat
$LN11@detect_dat:
  00111	eb cd		 jmp	 SHORT $LN5@detect_dat
$LN6@detect_dat:

; 1146 : 
; 1147 :     /* There are no "black-listed" or "white-listed" bytes:
; 1148 :      * this stream either is empty or has tolerated ("gray-listed") bytes only.
; 1149 :      */
; 1150 :     return Z_BINARY;

  00113	33 c0		 xor	 eax, eax
$LN1@detect_dat:

; 1151 : }

  00115	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00119	5f		 pop	 rdi
  0011a	c3		 ret	 0
detect_data_type ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT bi_reverse
_TEXT	SEGMENT
res$ = 32
code$ = 64
len$ = 72
bi_reverse PROC						; COMDAT

; 1161 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	57		 push	 rdi
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 0c 00 00 00	 mov	 ecx, 12
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00027	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1162 :     register unsigned res = 0;

  0002c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR res$[rsp], 0
$LN4@bi_reverse:

; 1163 :     do {
; 1164 :         res |= code & 1;

  00034	8b 44 24 40	 mov	 eax, DWORD PTR code$[rsp]
  00038	83 e0 01	 and	 eax, 1
  0003b	8b 4c 24 20	 mov	 ecx, DWORD PTR res$[rsp]
  0003f	0b c8		 or	 ecx, eax
  00041	8b c1		 mov	 eax, ecx
  00043	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 1165 :         code >>= 1, res <<= 1;

  00047	8b 44 24 40	 mov	 eax, DWORD PTR code$[rsp]
  0004b	d1 e8		 shr	 eax, 1
  0004d	89 44 24 40	 mov	 DWORD PTR code$[rsp], eax
  00051	8b 44 24 20	 mov	 eax, DWORD PTR res$[rsp]
  00055	d1 e0		 shl	 eax, 1
  00057	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 1166 :     } while (--len > 0);

  0005b	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  0005f	ff c8		 dec	 eax
  00061	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax
  00065	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  0006a	7f c8		 jg	 SHORT $LN4@bi_reverse

; 1167 :     return res >> 1;

  0006c	8b 44 24 20	 mov	 eax, DWORD PTR res$[rsp]
  00070	d1 e8		 shr	 eax, 1

; 1168 : }

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
bi_reverse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT bi_flush
_TEXT	SEGMENT
s$ = 48
bi_flush PROC						; COMDAT

; 1175 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1176 :     if (s->bi_valid == 16) {

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0002f	83 b8 14 17 00
	00 10		 cmp	 DWORD PTR [rax+5908], 16
  00036	0f 85 8b 00 00
	00		 jne	 $LN2@bi_flush

; 1177 :         put_short(s, s->bi_buf);

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00041	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00048	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00052	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00055	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  0005a	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0005e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00061	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00066	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00069	ff c0		 inc	 eax
  0006b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00070	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00078	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0007f	c1 f8 08	 sar	 eax, 8
  00082	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00087	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0008a	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  0008f	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00093	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0009b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0009e	ff c0		 inc	 eax
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000a5	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1178 :         s->bi_buf = 0;

  000a8	33 c0		 xor	 eax, eax
  000aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000af	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax

; 1179 :         s->bi_valid = 0;

  000b6	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000bb	c7 80 14 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5908], 0
  000c5	eb 75		 jmp	 SHORT $LN3@bi_flush
$LN2@bi_flush:

; 1180 :     } else if (s->bi_valid >= 8) {

  000c7	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000cc	83 b8 14 17 00
	00 08		 cmp	 DWORD PTR [rax+5908], 8
  000d3	7c 67		 jl	 SHORT $LN4@bi_flush

; 1181 :         put_byte(s, (Byte)s->bi_buf);

  000d5	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000da	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000dd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000e2	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000e6	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  000eb	0f b6 92 10 17
	00 00		 movzx	 edx, BYTE PTR [rdx+5904]
  000f2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  000f5	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000fa	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000fd	ff c0		 inc	 eax
  000ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00104	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1182 :         s->bi_buf >>= 8;

  00107	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0010c	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00113	66 c1 e8 08	 shr	 ax, 8
  00117	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0011c	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax

; 1183 :         s->bi_valid -= 8;

  00123	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00128	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  0012e	83 e8 08	 sub	 eax, 8
  00131	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00136	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax
$LN4@bi_flush:
$LN3@bi_flush:

; 1184 :     }
; 1185 : }

  0013c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00140	5f		 pop	 rdi
  00141	c3		 ret	 0
bi_flush ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\trees.c
;	COMDAT bi_windup
_TEXT	SEGMENT
s$ = 48
bi_windup PROC						; COMDAT

; 1192 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1193 :     if (s->bi_valid > 8) {

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0002f	83 b8 14 17 00
	00 08		 cmp	 DWORD PTR [rax+5908], 8
  00036	7e 6e		 jle	 SHORT $LN2@bi_windup

; 1194 :         put_short(s, s->bi_buf);

  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0003d	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  00044	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0004e	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00051	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  00056	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0005a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00062	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00065	ff c0		 inc	 eax
  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0006c	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00074	0f b7 80 10 17
	00 00		 movzx	 eax, WORD PTR [rax+5904]
  0007b	c1 f8 08	 sar	 eax, 8
  0007e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00083	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00086	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  0008b	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0008f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00092	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00097	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0009a	ff c0		 inc	 eax
  0009c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000a1	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  000a4	eb 40		 jmp	 SHORT $LN3@bi_windup
$LN2@bi_windup:

; 1195 :     } else if (s->bi_valid > 0) {

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000ab	83 b8 14 17 00
	00 00		 cmp	 DWORD PTR [rax+5908], 0
  000b2	7e 32		 jle	 SHORT $LN4@bi_windup

; 1196 :         put_byte(s, (Byte)s->bi_buf);

  000b4	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000b9	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000bc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000c1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000c5	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  000ca	0f b6 92 10 17
	00 00		 movzx	 edx, BYTE PTR [rdx+5904]
  000d1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  000d4	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000d9	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000dc	ff c0		 inc	 eax
  000de	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000e3	89 41 28	 mov	 DWORD PTR [rcx+40], eax
$LN4@bi_windup:
$LN3@bi_windup:

; 1197 :     }
; 1198 :     s->bi_buf = 0;

  000e6	33 c0		 xor	 eax, eax
  000e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000ed	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax

; 1199 :     s->bi_valid = 0;

  000f4	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000f9	c7 80 14 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5908], 0

; 1200 : #ifdef ZLIB_DEBUG
; 1201 :     s->bits_sent = (s->bits_sent+7) & ~7;
; 1202 : #endif
; 1203 : }

  00103	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00107	5f		 pop	 rdi
  00108	c3		 ret	 0
bi_windup ENDP
_TEXT	ENDS
END
