; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@		; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_C@_06DIJPEION@?$CFs?$CFs?$CFs@		; `string'
EXTRN	__imp_malloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_strlen:PROC
EXTRN	__imp_wcstombs:PROC
EXTRN	__imp__open:PROC
EXTRN	__imp__wopen:PROC
EXTRN	__imp__lseeki64:PROC
;	COMDAT ??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
CONST	SEGMENT
??_C@_06DIJPEION@?$CFs?$CFs?$CFs@ DB '%s%s%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@ DB '<fd:%d>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
__DB664BEB_corecrt_stdio_config@h DB 01H
__E28BBA23_corecrt_wstdio@h DB 01H
__4A1C29A8_stdio@h DB 01H
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__86DC2CC7_gzlib@c DB 01H
PUBLIC	gz_error
PUBLIC	gzclearerr
PUBLIC	gzerror
PUBLIC	gzeof
PUBLIC	gzoffset
PUBLIC	gzoffset64
PUBLIC	gztell
PUBLIC	gztell64
PUBLIC	gzseek
PUBLIC	gzseek64
PUBLIC	gzrewind
PUBLIC	gzbuffer
PUBLIC	gzopen_w
PUBLIC	gzdopen
PUBLIC	gzopen
PUBLIC	snprintf
PUBLIC	vsnprintf
PUBLIC	__local_stdio_printf_options
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_error DD imagerel $LN10
	DD	imagerel $LN10+357
	DD	imagerel $unwind$gz_error
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclearerr DD imagerel $LN6
	DD	imagerel $LN6+151
	DD	imagerel $unwind$gzclearerr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzerror DD imagerel $LN11
	DD	imagerel $LN11+213
	DD	imagerel $unwind$gzerror
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzeof DD	imagerel $LN8
	DD	imagerel $LN8+142
	DD	imagerel $unwind$gzeof
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzoffset DD imagerel $LN6
	DD	imagerel $LN6+97
	DD	imagerel $unwind$gzoffset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzoffset64 DD imagerel $LN8
	DD	imagerel $LN8+205
	DD	imagerel $unwind$gzoffset64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gztell DD imagerel $LN6
	DD	imagerel $LN6+97
	DD	imagerel $unwind$gztell
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gztell64 DD imagerel $LN8
	DD	imagerel $LN8+162
	DD	imagerel $unwind$gztell64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek DD imagerel $LN6
	DD	imagerel $LN6+119
	DD	imagerel $unwind$gzseek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek64 DD imagerel $LN22
	DD	imagerel $LN22+811
	DD	imagerel $unwind$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzrewind DD imagerel $LN8
	DD	imagerel $LN8+167
	DD	imagerel $unwind$gzrewind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzbuffer DD imagerel $LN9
	DD	imagerel $LN9+178
	DD	imagerel $unwind$gzbuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzopen_w DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$gzopen_w
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdopen DD imagerel $LN6
	DD	imagerel $LN6+153
	DD	imagerel $unwind$gzdopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzopen DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$gzopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_open DD imagerel gz_open
	DD	imagerel gz_open+1290
	DD	imagerel $unwind$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_reset DD imagerel gz_reset
	DD	imagerel gz_reset+164
	DD	imagerel $unwind$gz_reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$snprintf DD imagerel $LN8
	DD	imagerel $LN8+232
	DD	imagerel $unwind$snprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsnprintf DD imagerel $LN6
	DD	imagerel $LN6+151
	DD	imagerel $unwind$vsnprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN4
	DD	imagerel $LN4+46
	DD	imagerel $unwind$__local_stdio_printf_options
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 021501H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsnprintf DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$snprintf DD 023001H
	DD	07015d219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
snprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
snprintf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:snprintf$rtcName$0
	ORG $+48
snprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:snprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_reset DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_open DD 022701H
	DD	0700f9213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzopen DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdopen DD 022101H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzopen_w DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzbuffer DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzrewind DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek64 DD 022801H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gztell64 DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gztell DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzoffset64 DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzoffset DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzeof DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzerror DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclearerr DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_error DD 022701H
	DD	0700f9213H
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 85   :     {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b fc	 mov	 rdi, rsp
  00009	b9 08 00 00 00	 mov	 ecx, 8
  0000e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00013	f3 ab		 rep stosd
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__DB664BEB_corecrt_stdio_config@h
  0001c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\stdio.h
;	COMDAT vsnprintf
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_ArgList$ = 104
vsnprintf PROC						; COMDAT

; 1437 :     {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__4A1C29A8_stdio@h
  00034	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1438 :         int const _Result = __stdio_common_vsprintf(

  00039	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0003e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00041	48 83 c8 02	 or	 rax, 2
  00045	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  0004a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00058	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0005d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00062	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00067	48 8b c8	 mov	 rcx, rax
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00070	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1439 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1440 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1441 : 
; 1442 :         return _Result < 0 ? -1 : _Result;

  00074	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00079	7d 0a		 jge	 SHORT $LN3@vsnprintf
  0007b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00083	eb 08		 jmp	 SHORT $LN4@vsnprintf
$LN3@vsnprintf:
  00085	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00089	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf:
  0008d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1443 :     }

  00091	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\stdio.h
;	COMDAT snprintf
_TEXT	SEGMENT
_Result$ = 48
_ArgList$ = 72
_Format$ = 88
_ArgList$ = 96
_Result$4 = 104
tv83 = 108
_Buffer$ = 128
_BufferCount$ = 136
_Format$ = 144
snprintf PROC						; COMDAT

; 1946 :     {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 1c 00 00 00	 mov	 ecx, 28
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__4A1C29A8_stdio@h
  00037	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1947 :         int _Result;
; 1948 :         va_list _ArgList;
; 1949 :         __crt_va_start(_ArgList, _Format);

  0003c	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00044	48 89 44 24 48	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1950 :     #pragma warning(suppress:28719)    // 28719
; 1951 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0004e	48 89 44 24 60	 mov	 QWORD PTR _ArgList$[rsp], rax
  00053	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR _Format$[rsp]
  0005b	48 89 44 24 58	 mov	 QWORD PTR _Format$[rsp], rax

; 1438 :         int const _Result = __stdio_common_vsprintf(

  00060	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 83 c8 02	 or	 rax, 2
  0006c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00071	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00076	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0007f	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00084	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0008c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  0009d	89 44 24 68	 mov	 DWORD PTR _Result$4[rsp], eax

; 1439 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1440 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1441 : 
; 1442 :         return _Result < 0 ? -1 : _Result;

  000a1	83 7c 24 68 00	 cmp	 DWORD PTR _Result$4[rsp], 0
  000a6	7d 0a		 jge	 SHORT $LN5@snprintf
  000a8	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR tv83[rsp], -1
  000b0	eb 08		 jmp	 SHORT $LN6@snprintf
$LN5@snprintf:
  000b2	8b 44 24 68	 mov	 eax, DWORD PTR _Result$4[rsp]
  000b6	89 44 24 6c	 mov	 DWORD PTR tv83[rsp], eax
$LN6@snprintf:

; 1950 :     #pragma warning(suppress:28719)    // 28719
; 1951 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  000ba	8b 44 24 6c	 mov	 eax, DWORD PTR tv83[rsp]
  000be	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1952 :         __crt_va_end(_ArgList);

  000c2	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1953 :         return _Result;

  000cb	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]

; 1954 :     }

  000cf	8b f8		 mov	 edi, eax
  000d1	48 8b cc	 mov	 rcx, rsp
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:snprintf$rtcFrameData
  000db	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000e0	8b c7		 mov	 eax, edi
  000e2	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gz_reset
_TEXT	SEGMENT
state$ = 48
gz_reset PROC						; COMDAT

; 77   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 78   :     state->x.have = 0;              /* no output data available */

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 79   :     if (state->mode == GZ_READ) {   /* for reading ... */

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0003a	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00041	75 24		 jne	 SHORT $LN2@gz_reset

; 80   :         state->eof = 0;             /* not at end of file */

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00048	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [rax+80], 0

; 81   :         state->past = 0;            /* have not read past end yet */

  0004f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00054	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [rax+84], 0

; 82   :         state->how = LOOK;          /* look for gzip header */

  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00060	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [rax+68], 0
$LN2@gz_reset:

; 83   :     }
; 84   :     state->seek = 0;                /* no seek request pending */

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0006c	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 85   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00073	45 33 c0	 xor	 r8d, r8d
  00076	33 d2		 xor	 edx, edx
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0007d	e8 00 00 00 00	 call	 gz_error

; 86   :     state->x.pos = 0;               /* no uncompressed data yet */

  00082	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00087	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 87   :     state->strm.avail_in = 0;       /* no input data yet */

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00094	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+128], 0

; 88   : }

  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
gz_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gz_open
_TEXT	SEGMENT
state$ = 32
len$ = 40
oflag$ = 48
exclusive$ = 52
tv88 = 56
tv184 = 60
tv178 = 64
tv182 = 68
tv198 = 72
tv197 = 76
path$ = 96
fd$ = 104
mode$ = 112
gz_open	PROC						; COMDAT

; 95   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 14 00 00 00	 mov	 ecx, 20
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 96   :     gz_statep state;
; 97   :     z_size_t len;
; 98   :     int oflag;
; 99   : #ifdef O_CLOEXEC
; 100  :     int cloexec = 0;
; 101  : #endif
; 102  : #ifdef O_EXCL
; 103  :     int exclusive = 0;

  00033	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR exclusive$[rsp], 0

; 104  : #endif
; 105  : 
; 106  :     /* check input */
; 107  :     if (path == NULL)

  0003b	48 83 7c 24 60
	00		 cmp	 QWORD PTR path$[rsp], 0
  00041	75 07		 jne	 SHORT $LN6@gz_open

; 108  :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 40 04 00 00	 jmp	 $LN1@gz_open
$LN6@gz_open:

; 109  : 
; 110  :     /* allocate gzFile structure to return */
; 111  :     state = (gz_statep)malloc(sizeof(gz_state));

  0004a	b9 d0 00 00 00	 mov	 ecx, 208		; 000000d0H
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00055	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 112  :     if (state == NULL)

  0005a	48 83 7c 24 20
	00		 cmp	 QWORD PTR state$[rsp], 0
  00060	75 07		 jne	 SHORT $LN7@gz_open

; 113  :         return NULL;

  00062	33 c0		 xor	 eax, eax
  00064	e9 21 04 00 00	 jmp	 $LN1@gz_open
$LN7@gz_open:

; 114  :     state->size = 0;            /* no buffers allocated yet */

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006e	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 115  :     state->want = GZBUFSIZE;    /* requested buffer size */

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0007a	c7 40 2c 00 20
	00 00		 mov	 DWORD PTR [rax+44], 8192 ; 00002000H

; 116  :     state->msg = NULL;          /* no error message yet */

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00086	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 117  : 
; 118  :     /* interpret mode */
; 119  :     state->mode = GZ_NONE;

  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00093	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 120  :     state->level = Z_DEFAULT_COMPRESSION;

  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0009f	c7 40 58 ff ff
	ff ff		 mov	 DWORD PTR [rax+88], -1

; 121  :     state->strategy = Z_DEFAULT_STRATEGY;

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000ab	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 122  :     state->direct = 0;

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000b7	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0
$LN2@gz_open:

; 123  :     while (*mode) {

  000be	48 8b 44 24 70	 mov	 rax, QWORD PTR mode$[rsp]
  000c3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c6	85 c0		 test	 eax, eax
  000c8	0f 84 12 01 00
	00		 je	 $LN3@gz_open

; 124  :         if (*mode >= '0' && *mode <= '9')

  000ce	48 8b 44 24 70	 mov	 rax, QWORD PTR mode$[rsp]
  000d3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000d6	83 f8 30	 cmp	 eax, 48			; 00000030H
  000d9	7c 25		 jl	 SHORT $LN8@gz_open
  000db	48 8b 44 24 70	 mov	 rax, QWORD PTR mode$[rsp]
  000e0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000e3	83 f8 39	 cmp	 eax, 57			; 00000039H
  000e6	7f 18		 jg	 SHORT $LN8@gz_open

; 125  :             state->level = *mode - '0';

  000e8	48 8b 44 24 70	 mov	 rax, QWORD PTR mode$[rsp]
  000ed	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f0	83 e8 30	 sub	 eax, 48			; 00000030H
  000f3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000f8	89 41 58	 mov	 DWORD PTR [rcx+88], eax
  000fb	e9 ce 00 00 00	 jmp	 $LN9@gz_open
$LN8@gz_open:

; 126  :         else
; 127  :             switch (*mode) {

  00100	48 8b 44 24 70	 mov	 rax, QWORD PTR mode$[rsp]
  00105	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00108	89 44 24 38	 mov	 DWORD PTR tv88[rsp], eax
  0010c	8b 44 24 38	 mov	 eax, DWORD PTR tv88[rsp]
  00110	83 e8 2b	 sub	 eax, 43			; 0000002bH
  00113	89 44 24 38	 mov	 DWORD PTR tv88[rsp], eax
  00117	83 7c 24 38 4d	 cmp	 DWORD PTR tv88[rsp], 77	; 0000004dH
  0011c	0f 87 ac 00 00
	00		 ja	 $LN21@gz_open
  00122	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv88[rsp]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0012e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN55@gz_open[rcx+rax]
  00136	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN56@gz_open[rcx+rax*4]
  0013d	48 03 c1	 add	 rax, rcx
  00140	ff e0		 jmp	 rax
$LN10@gz_open:

; 128  :             case 'r':
; 129  :                 state->mode = GZ_READ;

  00142	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00147	c7 40 18 4f 1c
	00 00		 mov	 DWORD PTR [rax+24], 7247 ; 00001c4fH

; 130  :                 break;

  0014e	eb 7e		 jmp	 SHORT $LN4@gz_open
$LN11@gz_open:

; 131  : #ifndef NO_GZCOMPRESS
; 132  :             case 'w':
; 133  :                 state->mode = GZ_WRITE;

  00150	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00155	c7 40 18 b1 79
	00 00		 mov	 DWORD PTR [rax+24], 31153 ; 000079b1H

; 134  :                 break;

  0015c	eb 70		 jmp	 SHORT $LN4@gz_open
$LN12@gz_open:

; 135  :             case 'a':
; 136  :                 state->mode = GZ_APPEND;

  0015e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00163	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [rax+24], 1

; 137  :                 break;

  0016a	eb 62		 jmp	 SHORT $LN4@gz_open
$LN13@gz_open:

; 138  : #endif
; 139  :             case '+':       /* can't read and write at the same time */
; 140  :                 free(state);

  0016c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 141  :                 return NULL;

  00177	33 c0		 xor	 eax, eax
  00179	e9 0c 03 00 00	 jmp	 $LN1@gz_open

; 142  :             case 'b':       /* ignore -- will request binary anyway */
; 143  :                 break;

  0017e	eb 4e		 jmp	 SHORT $LN4@gz_open
$LN15@gz_open:

; 144  : #ifdef O_CLOEXEC
; 145  :             case 'e':
; 146  :                 cloexec = 1;
; 147  :                 break;
; 148  : #endif
; 149  : #ifdef O_EXCL
; 150  :             case 'x':
; 151  :                 exclusive = 1;

  00180	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR exclusive$[rsp], 1

; 152  :                 break;

  00188	eb 44		 jmp	 SHORT $LN4@gz_open
$LN16@gz_open:

; 153  : #endif
; 154  :             case 'f':
; 155  :                 state->strategy = Z_FILTERED;

  0018a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0018f	c7 40 5c 01 00
	00 00		 mov	 DWORD PTR [rax+92], 1

; 156  :                 break;

  00196	eb 36		 jmp	 SHORT $LN4@gz_open
$LN17@gz_open:

; 157  :             case 'h':
; 158  :                 state->strategy = Z_HUFFMAN_ONLY;

  00198	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0019d	c7 40 5c 02 00
	00 00		 mov	 DWORD PTR [rax+92], 2

; 159  :                 break;

  001a4	eb 28		 jmp	 SHORT $LN4@gz_open
$LN18@gz_open:

; 160  :             case 'R':
; 161  :                 state->strategy = Z_RLE;

  001a6	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001ab	c7 40 5c 03 00
	00 00		 mov	 DWORD PTR [rax+92], 3

; 162  :                 break;

  001b2	eb 1a		 jmp	 SHORT $LN4@gz_open
$LN19@gz_open:

; 163  :             case 'F':
; 164  :                 state->strategy = Z_FIXED;

  001b4	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001b9	c7 40 5c 04 00
	00 00		 mov	 DWORD PTR [rax+92], 4

; 165  :                 break;

  001c0	eb 0c		 jmp	 SHORT $LN4@gz_open
$LN20@gz_open:

; 166  :             case 'T':
; 167  :                 state->direct = 1;

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001c7	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN21@gz_open:
$LN4@gz_open:
$LN9@gz_open:

; 168  :                 break;
; 169  :             default:        /* could consider as an error, but just ignore */
; 170  :                 ;
; 171  :             }
; 172  :         mode++;

  001ce	48 8b 44 24 70	 mov	 rax, QWORD PTR mode$[rsp]
  001d3	48 ff c0	 inc	 rax
  001d6	48 89 44 24 70	 mov	 QWORD PTR mode$[rsp], rax

; 173  :     }

  001db	e9 de fe ff ff	 jmp	 $LN2@gz_open
$LN3@gz_open:

; 174  : 
; 175  :     /* must provide an "r", "w", or "a" */
; 176  :     if (state->mode == GZ_NONE) {

  001e0	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001e5	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001e9	75 12		 jne	 SHORT $LN22@gz_open

; 177  :         free(state);

  001eb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 178  :         return NULL;

  001f6	33 c0		 xor	 eax, eax
  001f8	e9 8d 02 00 00	 jmp	 $LN1@gz_open
$LN22@gz_open:

; 179  :     }
; 180  : 
; 181  :     /* can't force transparent read */
; 182  :     if (state->mode == GZ_READ) {

  001fd	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00202	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00209	75 29		 jne	 SHORT $LN23@gz_open

; 183  :         if (state->direct) {

  0020b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00210	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00214	74 12		 je	 SHORT $LN24@gz_open

; 184  :             free(state);

  00216	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 185  :             return NULL;

  00221	33 c0		 xor	 eax, eax
  00223	e9 62 02 00 00	 jmp	 $LN1@gz_open
$LN24@gz_open:

; 186  :         }
; 187  :         state->direct = 1;      /* for empty file */

  00228	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0022d	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN23@gz_open:

; 188  :     }
; 189  : 
; 190  :     /* save the path name for error messages */
; 191  : #ifdef WIDECHAR
; 192  :     if (fd == -2) {

  00234	83 7c 24 68 fe	 cmp	 DWORD PTR fd$[rsp], -2
  00239	75 28		 jne	 SHORT $LN25@gz_open

; 193  :         len = wcstombs(NULL, path, 0);

  0023b	45 33 c0	 xor	 r8d, r8d
  0023e	48 8b 54 24 60	 mov	 rdx, QWORD PTR path$[rsp]
  00243	33 c9		 xor	 ecx, ecx
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs
  0024b	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 194  :         if (len == (z_size_t)-1)

  00250	48 83 7c 24 28
	ff		 cmp	 QWORD PTR len$[rsp], -1
  00256	75 09		 jne	 SHORT $LN27@gz_open

; 195  :             len = 0;

  00258	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0
$LN27@gz_open:

; 196  :     }

  00261	eb 10		 jmp	 SHORT $LN26@gz_open
$LN25@gz_open:

; 197  :     else
; 198  : #endif
; 199  :         len = strlen((const char *)path);

  00263	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp]
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlen
  0026e	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax
$LN26@gz_open:

; 200  :     state->path = (char *)malloc(len + 1);

  00273	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00278	48 ff c0	 inc	 rax
  0027b	48 8b c8	 mov	 rcx, rax
  0027e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00284	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00289	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 201  :     if (state->path == NULL) {

  0028d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00292	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00297	75 12		 jne	 SHORT $LN28@gz_open

; 202  :         free(state);

  00299	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 203  :         return NULL;

  002a4	33 c0		 xor	 eax, eax
  002a6	e9 df 01 00 00	 jmp	 $LN1@gz_open
$LN28@gz_open:

; 204  :     }
; 205  : #ifdef WIDECHAR
; 206  :     if (fd == -2)

  002ab	83 7c 24 68 fe	 cmp	 DWORD PTR fd$[rsp], -2
  002b0	75 37		 jne	 SHORT $LN29@gz_open

; 207  :         if (len)

  002b2	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  002b8	74 21		 je	 SHORT $LN31@gz_open

; 208  :             wcstombs(state->path, path, len + 1);

  002ba	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  002bf	48 ff c0	 inc	 rax
  002c2	4c 8b c0	 mov	 r8, rax
  002c5	48 8b 54 24 60	 mov	 rdx, QWORD PTR path$[rsp]
  002ca	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  002cf	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs
  002d9	eb 0c		 jmp	 SHORT $LN32@gz_open
$LN31@gz_open:

; 209  :         else
; 210  :             *(state->path) = 0;

  002db	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  002e0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002e4	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN32@gz_open:
  002e7	eb 25		 jmp	 SHORT $LN30@gz_open
$LN29@gz_open:

; 211  :     else
; 212  : #endif
; 213  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 214  :         (void)snprintf(state->path, len + 1, "%s", (const char *)path);

  002e9	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  002ee	48 ff c0	 inc	 rax
  002f1	4c 8b 4c 24 60	 mov	 r9, QWORD PTR path$[rsp]
  002f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  002fd	48 8b d0	 mov	 rdx, rax
  00300	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00305	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00309	e8 00 00 00 00	 call	 snprintf
$LN30@gz_open:

; 215  : #else
; 216  :         strcpy(state->path, path);
; 217  : #endif
; 218  : 
; 219  :     /* compute the flags for open() */
; 220  :     oflag =

  0030e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00313	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  0031a	75 0a		 jne	 SHORT $LN42@gz_open
  0031c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv184[rsp], 0
  00324	eb 4a		 jmp	 SHORT $LN43@gz_open
$LN42@gz_open:
  00326	83 7c 24 34 00	 cmp	 DWORD PTR exclusive$[rsp], 0
  0032b	74 0a		 je	 SHORT $LN38@gz_open
  0032d	c7 44 24 40 00
	04 00 00	 mov	 DWORD PTR tv178[rsp], 1024 ; 00000400H
  00335	eb 08		 jmp	 SHORT $LN39@gz_open
$LN38@gz_open:
  00337	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN39@gz_open:
  0033f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00344	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  0034b	75 0a		 jne	 SHORT $LN40@gz_open
  0034d	c7 44 24 44 00
	02 00 00	 mov	 DWORD PTR tv182[rsp], 512 ; 00000200H
  00355	eb 08		 jmp	 SHORT $LN41@gz_open
$LN40@gz_open:
  00357	c7 44 24 44 08
	00 00 00	 mov	 DWORD PTR tv182[rsp], 8
$LN41@gz_open:
  0035f	8b 44 24 40	 mov	 eax, DWORD PTR tv178[rsp]
  00363	0d 01 01 00 00	 or	 eax, 257		; 00000101H
  00368	0b 44 24 44	 or	 eax, DWORD PTR tv182[rsp]
  0036c	89 44 24 3c	 mov	 DWORD PTR tv184[rsp], eax
$LN43@gz_open:
  00370	8b 44 24 3c	 mov	 eax, DWORD PTR tv184[rsp]
  00374	0f ba e8 0f	 bts	 eax, 15
  00378	89 44 24 30	 mov	 DWORD PTR oflag$[rsp], eax

; 221  : #ifdef O_LARGEFILE
; 222  :         O_LARGEFILE |
; 223  : #endif
; 224  : #ifdef O_BINARY
; 225  :         O_BINARY |
; 226  : #endif
; 227  : #ifdef O_CLOEXEC
; 228  :         (cloexec ? O_CLOEXEC : 0) |
; 229  : #endif
; 230  :         (state->mode == GZ_READ ?
; 231  :          O_RDONLY :
; 232  :          (O_WRONLY | O_CREAT |
; 233  : #ifdef O_EXCL
; 234  :           (exclusive ? O_EXCL : 0) |
; 235  : #endif
; 236  :           (state->mode == GZ_WRITE ?
; 237  :            O_TRUNC :
; 238  :            O_APPEND)));
; 239  : 
; 240  :     /* open the file with the appropriate flags (or just use fd) */
; 241  :     state->fd = fd > -1 ? fd : (

  0037c	83 7c 24 68 ff	 cmp	 DWORD PTR fd$[rsp], -1
  00381	7e 0a		 jle	 SHORT $LN46@gz_open
  00383	8b 44 24 68	 mov	 eax, DWORD PTR fd$[rsp]
  00387	89 44 24 48	 mov	 DWORD PTR tv198[rsp], eax
  0038b	eb 43		 jmp	 SHORT $LN47@gz_open
$LN46@gz_open:
  0038d	83 7c 24 68 fe	 cmp	 DWORD PTR fd$[rsp], -2
  00392	75 1b		 jne	 SHORT $LN44@gz_open
  00394	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  0039a	8b 54 24 30	 mov	 edx, DWORD PTR oflag$[rsp]
  0039e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp]
  003a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wopen
  003a9	89 44 24 4c	 mov	 DWORD PTR tv197[rsp], eax
  003ad	eb 19		 jmp	 SHORT $LN45@gz_open
$LN44@gz_open:
  003af	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  003b5	8b 54 24 30	 mov	 edx, DWORD PTR oflag$[rsp]
  003b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp]
  003be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__open
  003c4	89 44 24 4c	 mov	 DWORD PTR tv197[rsp], eax
$LN45@gz_open:
  003c8	8b 44 24 4c	 mov	 eax, DWORD PTR tv197[rsp]
  003cc	89 44 24 48	 mov	 DWORD PTR tv198[rsp], eax
$LN47@gz_open:
  003d0	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  003d5	8b 4c 24 48	 mov	 ecx, DWORD PTR tv198[rsp]
  003d9	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 242  : #ifdef WIDECHAR
; 243  :         fd == -2 ? _wopen(path, oflag, 0666) :
; 244  : #endif
; 245  :         open((const char *)path, oflag, 0666));
; 246  :     if (state->fd == -1) {

  003dc	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  003e1	83 78 1c ff	 cmp	 DWORD PTR [rax+28], -1
  003e5	75 21		 jne	 SHORT $LN33@gz_open

; 247  :         free(state->path);

  003e7	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  003ec	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  003f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 248  :         free(state);

  003f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 249  :         return NULL;

  00401	33 c0		 xor	 eax, eax
  00403	e9 82 00 00 00	 jmp	 $LN1@gz_open
$LN33@gz_open:

; 250  :     }
; 251  :     if (state->mode == GZ_APPEND) {

  00408	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0040d	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00411	75 22		 jne	 SHORT $LN34@gz_open

; 252  :         LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */

  00413	41 b8 02 00 00
	00		 mov	 r8d, 2
  00419	33 d2		 xor	 edx, edx
  0041b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00420	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00423	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64

; 253  :         state->mode = GZ_WRITE;         /* simplify later checks */

  00429	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0042e	c7 40 18 b1 79
	00 00		 mov	 DWORD PTR [rax+24], 31153 ; 000079b1H
$LN34@gz_open:

; 254  :     }
; 255  : 
; 256  :     /* save the current position for rewinding (only if reading) */
; 257  :     if (state->mode == GZ_READ) {

  00435	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0043a	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00441	75 38		 jne	 SHORT $LN35@gz_open

; 258  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  00443	41 b8 01 00 00
	00		 mov	 r8d, 1
  00449	33 d2		 xor	 edx, edx
  0044b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00450	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00453	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00459	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0045e	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax

; 259  :         if (state->start == -1) state->start = 0;

  00462	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00467	48 83 78 48 ff	 cmp	 QWORD PTR [rax+72], -1
  0046c	75 0d		 jne	 SHORT $LN36@gz_open
  0046e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00473	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0
$LN36@gz_open:
$LN35@gz_open:

; 260  :     }
; 261  : 
; 262  :     /* initialize stream */
; 263  :     gz_reset(state);

  0047b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00480	e8 00 00 00 00	 call	 gz_reset

; 264  : 
; 265  :     /* return stream */
; 266  :     return (gzFile)state;

  00485	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
$LN1@gz_open:

; 267  : }

  0048a	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0048e	5f		 pop	 rdi
  0048f	c3		 ret	 0
$LN56@gz_open:
  00490	00 00 00 00	 DD	 $LN13@gz_open
  00494	00 00 00 00	 DD	 $LN19@gz_open
  00498	00 00 00 00	 DD	 $LN18@gz_open
  0049c	00 00 00 00	 DD	 $LN20@gz_open
  004a0	00 00 00 00	 DD	 $LN12@gz_open
  004a4	00 00 00 00	 DD	 $LN16@gz_open
  004a8	00 00 00 00	 DD	 $LN17@gz_open
  004ac	00 00 00 00	 DD	 $LN10@gz_open
  004b0	00 00 00 00	 DD	 $LN11@gz_open
  004b4	00 00 00 00	 DD	 $LN15@gz_open
  004b8	00 00 00 00	 DD	 $LN21@gz_open
$LN55@gz_open:
  004bc	00		 DB	 0
  004bd	0a		 DB	 10
  004be	0a		 DB	 10
  004bf	0a		 DB	 10
  004c0	0a		 DB	 10
  004c1	0a		 DB	 10
  004c2	0a		 DB	 10
  004c3	0a		 DB	 10
  004c4	0a		 DB	 10
  004c5	0a		 DB	 10
  004c6	0a		 DB	 10
  004c7	0a		 DB	 10
  004c8	0a		 DB	 10
  004c9	0a		 DB	 10
  004ca	0a		 DB	 10
  004cb	0a		 DB	 10
  004cc	0a		 DB	 10
  004cd	0a		 DB	 10
  004ce	0a		 DB	 10
  004cf	0a		 DB	 10
  004d0	0a		 DB	 10
  004d1	0a		 DB	 10
  004d2	0a		 DB	 10
  004d3	0a		 DB	 10
  004d4	0a		 DB	 10
  004d5	0a		 DB	 10
  004d6	0a		 DB	 10
  004d7	01		 DB	 1
  004d8	0a		 DB	 10
  004d9	0a		 DB	 10
  004da	0a		 DB	 10
  004db	0a		 DB	 10
  004dc	0a		 DB	 10
  004dd	0a		 DB	 10
  004de	0a		 DB	 10
  004df	0a		 DB	 10
  004e0	0a		 DB	 10
  004e1	0a		 DB	 10
  004e2	0a		 DB	 10
  004e3	02		 DB	 2
  004e4	0a		 DB	 10
  004e5	03		 DB	 3
  004e6	0a		 DB	 10
  004e7	0a		 DB	 10
  004e8	0a		 DB	 10
  004e9	0a		 DB	 10
  004ea	0a		 DB	 10
  004eb	0a		 DB	 10
  004ec	0a		 DB	 10
  004ed	0a		 DB	 10
  004ee	0a		 DB	 10
  004ef	0a		 DB	 10
  004f0	0a		 DB	 10
  004f1	0a		 DB	 10
  004f2	04		 DB	 4
  004f3	0a		 DB	 10
  004f4	0a		 DB	 10
  004f5	0a		 DB	 10
  004f6	0a		 DB	 10
  004f7	05		 DB	 5
  004f8	0a		 DB	 10
  004f9	06		 DB	 6
  004fa	0a		 DB	 10
  004fb	0a		 DB	 10
  004fc	0a		 DB	 10
  004fd	0a		 DB	 10
  004fe	0a		 DB	 10
  004ff	0a		 DB	 10
  00500	0a		 DB	 10
  00501	0a		 DB	 10
  00502	0a		 DB	 10
  00503	07		 DB	 7
  00504	0a		 DB	 10
  00505	0a		 DB	 10
  00506	0a		 DB	 10
  00507	0a		 DB	 10
  00508	08		 DB	 8
  00509	09		 DB	 9
gz_open	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzopen
_TEXT	SEGMENT
path$ = 48
mode$ = 56
gzopen	PROC						; COMDAT

; 273  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 274  :     return gz_open(path, -1, mode);

  0002f	4c 8b 44 24 38	 mov	 r8, QWORD PTR mode$[rsp]
  00034	ba ff ff ff ff	 mov	 edx, -1
  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$[rsp]
  0003e	e8 00 00 00 00	 call	 gz_open

; 275  : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
gzopen	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzdopen
_TEXT	SEGMENT
path$ = 32
gz$ = 40
fd$ = 64
mode$ = 72
gzdopen	PROC						; COMDAT

; 289  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 290  :     char *path;         /* identifier for error messages */
; 291  :     gzFile gz;
; 292  : 
; 293  :     if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)

  0002d	83 7c 24 40 ff	 cmp	 DWORD PTR fd$[rsp], -1
  00032	74 18		 je	 SHORT $LN3@gzdopen
  00034	b9 13 00 00 00	 mov	 ecx, 19
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003f	48 89 44 24 20	 mov	 QWORD PTR path$[rsp], rax
  00044	48 83 7c 24 20
	00		 cmp	 QWORD PTR path$[rsp], 0
  0004a	75 04		 jne	 SHORT $LN2@gzdopen
$LN3@gzdopen:

; 294  :         return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 43		 jmp	 SHORT $LN1@gzdopen
$LN2@gzdopen:

; 295  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 296  :     (void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);

  00050	44 8b 4c 24 40	 mov	 r9d, DWORD PTR fd$[rsp]
  00055	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@
  0005c	ba 13 00 00 00	 mov	 edx, 19
  00061	48 8b 4c 24 20	 mov	 rcx, QWORD PTR path$[rsp]
  00066	e8 00 00 00 00	 call	 snprintf

; 297  : #else
; 298  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */
; 299  : #endif
; 300  :     gz = gz_open(path, fd, mode);

  0006b	4c 8b 44 24 48	 mov	 r8, QWORD PTR mode$[rsp]
  00070	8b 54 24 40	 mov	 edx, DWORD PTR fd$[rsp]
  00074	48 8b 4c 24 20	 mov	 rcx, QWORD PTR path$[rsp]
  00079	e8 00 00 00 00	 call	 gz_open
  0007e	48 89 44 24 28	 mov	 QWORD PTR gz$[rsp], rax

; 301  :     free(path);

  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR path$[rsp]
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 302  :     return gz;

  0008e	48 8b 44 24 28	 mov	 rax, QWORD PTR gz$[rsp]
$LN1@gzdopen:

; 303  : }

  00093	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
gzdopen	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzopen_w
_TEXT	SEGMENT
path$ = 48
mode$ = 56
gzopen_w PROC						; COMDAT

; 310  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 311  :     return gz_open(path, -2, mode);

  0002f	4c 8b 44 24 38	 mov	 r8, QWORD PTR mode$[rsp]
  00034	ba fe ff ff ff	 mov	 edx, -2
  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$[rsp]
  0003e	e8 00 00 00 00	 call	 gz_open

; 312  : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
gzopen_w ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzbuffer
_TEXT	SEGMENT
state$ = 32
file$ = 64
size$ = 72
gzbuffer PROC						; COMDAT

; 319  : {

$LN9:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 320  :     gz_statep state;
; 321  : 
; 322  :     /* get internal structure and check integrity */
; 323  :     if (file == NULL)

  0002e	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00034	75 07		 jne	 SHORT $LN2@gzbuffer

; 324  :         return -1;

  00036	b8 ff ff ff ff	 mov	 eax, -1
  0003b	eb 6f		 jmp	 SHORT $LN1@gzbuffer
$LN2@gzbuffer:

; 325  :     state = (gz_statep)file;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 326  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0004c	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00053	74 15		 je	 SHORT $LN3@gzbuffer
  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005a	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  00061	74 07		 je	 SHORT $LN3@gzbuffer

; 327  :         return -1;

  00063	b8 ff ff ff ff	 mov	 eax, -1
  00068	eb 42		 jmp	 SHORT $LN1@gzbuffer
$LN3@gzbuffer:

; 328  : 
; 329  :     /* make sure we haven't already allocated memory */
; 330  :     if (state->size != 0)

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006f	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00073	74 07		 je	 SHORT $LN4@gzbuffer

; 331  :         return -1;

  00075	b8 ff ff ff ff	 mov	 eax, -1
  0007a	eb 30		 jmp	 SHORT $LN1@gzbuffer
$LN4@gzbuffer:

; 332  : 
; 333  :     /* check and set requested size */
; 334  :     if ((size << 1) < size)

  0007c	8b 44 24 48	 mov	 eax, DWORD PTR size$[rsp]
  00080	d1 e0		 shl	 eax, 1
  00082	3b 44 24 48	 cmp	 eax, DWORD PTR size$[rsp]
  00086	73 07		 jae	 SHORT $LN5@gzbuffer

; 335  :         return -1;              /* need to be able to double it */

  00088	b8 ff ff ff ff	 mov	 eax, -1
  0008d	eb 1d		 jmp	 SHORT $LN1@gzbuffer
$LN5@gzbuffer:

; 336  :     if (size < 2)

  0008f	83 7c 24 48 02	 cmp	 DWORD PTR size$[rsp], 2
  00094	73 08		 jae	 SHORT $LN6@gzbuffer

; 337  :         size = 2;               /* need two bytes to check magic header */

  00096	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR size$[rsp], 2
$LN6@gzbuffer:

; 338  :     state->want = size;

  0009e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000a3	8b 4c 24 48	 mov	 ecx, DWORD PTR size$[rsp]
  000a7	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 339  :     return 0;

  000aa	33 c0		 xor	 eax, eax
$LN1@gzbuffer:

; 340  : }

  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
gzbuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzrewind
_TEXT	SEGMENT
state$ = 32
file$ = 64
gzrewind PROC						; COMDAT

; 345  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 346  :     gz_statep state;
; 347  : 
; 348  :     /* get internal structure */
; 349  :     if (file == NULL)

  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00030	75 07		 jne	 SHORT $LN2@gzrewind

; 350  :         return -1;

  00032	b8 ff ff ff ff	 mov	 eax, -1
  00037	eb 68		 jmp	 SHORT $LN1@gzrewind
$LN2@gzrewind:

; 351  :     state = (gz_statep)file;

  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0003e	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 352  : 
; 353  :     /* check that we're reading and that there's no error */
; 354  :     if (state->mode != GZ_READ ||

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00048	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  0004f	75 16		 jne	 SHORT $LN4@gzrewind
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00056	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  0005a	74 12		 je	 SHORT $LN3@gzrewind
  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00061	83 78 6c fb	 cmp	 DWORD PTR [rax+108], -5
  00065	74 07		 je	 SHORT $LN3@gzrewind
$LN4@gzrewind:

; 355  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 356  :         return -1;

  00067	b8 ff ff ff ff	 mov	 eax, -1
  0006c	eb 33		 jmp	 SHORT $LN1@gzrewind
$LN3@gzrewind:

; 357  : 
; 358  :     /* back up and start over */
; 359  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  0006e	45 33 c0	 xor	 r8d, r8d
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00076	48 8b 50 48	 mov	 rdx, QWORD PTR [rax+72]
  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0007f	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00088	48 83 f8 ff	 cmp	 rax, -1
  0008c	75 07		 jne	 SHORT $LN5@gzrewind

; 360  :         return -1;

  0008e	b8 ff ff ff ff	 mov	 eax, -1
  00093	eb 0c		 jmp	 SHORT $LN1@gzrewind
$LN5@gzrewind:

; 361  :     gz_reset(state);

  00095	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0009a	e8 00 00 00 00	 call	 gz_reset

; 362  :     return 0;

  0009f	33 c0		 xor	 eax, eax
$LN1@gzrewind:

; 363  : }

  000a1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
gzrewind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzseek64
_TEXT	SEGMENT
n$ = 32
ret$ = 40
state$ = 48
tv159 = 56
file$ = 80
offset$ = 88
whence$ = 96
gzseek64 PROC						; COMDAT

; 370  : {

$LN22:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 10 00 00 00	 mov	 ecx, 16
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 371  :     unsigned n;
; 372  :     z_off64_t ret;
; 373  :     gz_statep state;
; 374  : 
; 375  :     /* get internal structure and check integrity */
; 376  :     if (file == NULL)

  00034	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  0003a	75 0c		 jne	 SHORT $LN2@gzseek64

; 377  :         return -1;

  0003c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00043	e9 dd 02 00 00	 jmp	 $LN1@gzseek64
$LN2@gzseek64:

; 378  :     state = (gz_statep)file;

  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  0004d	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 379  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00057	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  0005e	74 1a		 je	 SHORT $LN3@gzseek64
  00060	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00065	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  0006c	74 0c		 je	 SHORT $LN3@gzseek64

; 380  :         return -1;

  0006e	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00075	e9 ab 02 00 00	 jmp	 $LN1@gzseek64
$LN3@gzseek64:

; 381  : 
; 382  :     /* check that there's no error */
; 383  :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0007f	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00083	74 17		 je	 SHORT $LN4@gzseek64
  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0008a	83 78 6c fb	 cmp	 DWORD PTR [rax+108], -5
  0008e	74 0c		 je	 SHORT $LN4@gzseek64

; 384  :         return -1;

  00090	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00097	e9 89 02 00 00	 jmp	 $LN1@gzseek64
$LN4@gzseek64:

; 385  : 
; 386  :     /* can only seek from start or relative to current position */
; 387  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  0009c	83 7c 24 60 00	 cmp	 DWORD PTR whence$[rsp], 0
  000a1	74 13		 je	 SHORT $LN5@gzseek64
  000a3	83 7c 24 60 01	 cmp	 DWORD PTR whence$[rsp], 1
  000a8	74 0c		 je	 SHORT $LN5@gzseek64

; 388  :         return -1;

  000aa	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000b1	e9 6f 02 00 00	 jmp	 $LN1@gzseek64
$LN5@gzseek64:

; 389  : 
; 390  :     /* normalize offset to a SEEK_CUR specification */
; 391  :     if (whence == SEEK_SET)

  000b6	83 7c 24 60 00	 cmp	 DWORD PTR whence$[rsp], 0
  000bb	75 1b		 jne	 SHORT $LN6@gzseek64

; 392  :         offset -= state->x.pos;

  000bd	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000c2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR offset$[rsp]
  000cb	48 2b c8	 sub	 rcx, rax
  000ce	48 8b c1	 mov	 rax, rcx
  000d1	48 89 44 24 58	 mov	 QWORD PTR offset$[rsp], rax
  000d6	eb 24		 jmp	 SHORT $LN7@gzseek64
$LN6@gzseek64:

; 393  :     else if (state->seek)

  000d8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000dd	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  000e1	74 19		 je	 SHORT $LN8@gzseek64

; 394  :         offset += state->skip;

  000e3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000e8	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR offset$[rsp]
  000f1	48 03 c8	 add	 rcx, rax
  000f4	48 8b c1	 mov	 rax, rcx
  000f7	48 89 44 24 58	 mov	 QWORD PTR offset$[rsp], rax
$LN8@gzseek64:
$LN7@gzseek64:

; 395  :     state->seek = 0;

  000fc	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00101	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 396  : 
; 397  :     /* if within raw area while reading, just go there */
; 398  :     if (state->mode == GZ_READ && state->how == COPY &&

  00108	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0010d	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00114	0f 85 da 00 00
	00		 jne	 $LN9@gzseek64
  0011a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0011f	83 78 44 01	 cmp	 DWORD PTR [rax+68], 1
  00123	0f 85 cb 00 00
	00		 jne	 $LN9@gzseek64
  00129	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0012e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00132	48 03 44 24 58	 add	 rax, QWORD PTR offset$[rsp]
  00137	48 85 c0	 test	 rax, rax
  0013a	0f 8c b4 00 00
	00		 jl	 $LN9@gzseek64

; 399  :             state->x.pos + offset >= 0) {
; 400  :         ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);

  00140	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00145	8b 00		 mov	 eax, DWORD PTR [rax]
  00147	48 8b 4c 24 58	 mov	 rcx, QWORD PTR offset$[rsp]
  0014c	48 2b c8	 sub	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	41 b8 01 00 00
	00		 mov	 r8d, 1
  00158	48 8b d0	 mov	 rdx, rax
  0015b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00160	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00169	48 89 44 24 28	 mov	 QWORD PTR ret$[rsp], rax

; 401  :         if (ret == -1)

  0016e	48 83 7c 24 28
	ff		 cmp	 QWORD PTR ret$[rsp], -1
  00174	75 0c		 jne	 SHORT $LN10@gzseek64

; 402  :             return -1;

  00176	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0017d	e9 a3 01 00 00	 jmp	 $LN1@gzseek64
$LN10@gzseek64:

; 403  :         state->x.have = 0;

  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00187	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 404  :         state->eof = 0;

  0018d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00192	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [rax+80], 0

; 405  :         state->past = 0;

  00199	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0019e	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [rax+84], 0

; 406  :         state->seek = 0;

  001a5	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  001aa	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 407  :         gz_error(state, Z_OK, NULL);

  001b1	45 33 c0	 xor	 r8d, r8d
  001b4	33 d2		 xor	 edx, edx
  001b6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  001bb	e8 00 00 00 00	 call	 gz_error

; 408  :         state->strm.avail_in = 0;

  001c0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  001c5	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+128], 0

; 409  :         state->x.pos += offset;

  001cf	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  001d4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001d8	48 03 44 24 58	 add	 rax, QWORD PTR offset$[rsp]
  001dd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  001e2	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 410  :         return state->x.pos;

  001e6	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  001eb	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001ef	e9 31 01 00 00	 jmp	 $LN1@gzseek64
$LN9@gzseek64:

; 411  :     }
; 412  : 
; 413  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 414  :     if (offset < 0) {

  001f4	48 83 7c 24 58
	00		 cmp	 QWORD PTR offset$[rsp], 0
  001fa	7d 62		 jge	 SHORT $LN11@gzseek64

; 415  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  001fc	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00201	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00208	74 0c		 je	 SHORT $LN12@gzseek64

; 416  :             return -1;

  0020a	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00211	e9 0f 01 00 00	 jmp	 $LN1@gzseek64
$LN12@gzseek64:

; 417  :         offset += state->x.pos;

  00216	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0021b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0021f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR offset$[rsp]
  00224	48 03 c8	 add	 rcx, rax
  00227	48 8b c1	 mov	 rax, rcx
  0022a	48 89 44 24 58	 mov	 QWORD PTR offset$[rsp], rax

; 418  :         if (offset < 0)                     /* before start of file! */

  0022f	48 83 7c 24 58
	00		 cmp	 QWORD PTR offset$[rsp], 0
  00235	7d 0c		 jge	 SHORT $LN13@gzseek64

; 419  :             return -1;

  00237	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0023e	e9 e2 00 00 00	 jmp	 $LN1@gzseek64
$LN13@gzseek64:

; 420  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  00243	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00248	e8 00 00 00 00	 call	 gzrewind
  0024d	83 f8 ff	 cmp	 eax, -1
  00250	75 0c		 jne	 SHORT $LN14@gzseek64

; 421  :             return -1;

  00252	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00259	e9 c7 00 00 00	 jmp	 $LN1@gzseek64
$LN14@gzseek64:
$LN11@gzseek64:

; 422  :     }
; 423  : 
; 424  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 425  :     if (state->mode == GZ_READ) {

  0025e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00263	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  0026a	0f 85 85 00 00
	00		 jne	 $LN15@gzseek64

; 426  :         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?

  00270	33 c0		 xor	 eax, eax
  00272	85 c0		 test	 eax, eax
  00274	75 1b		 jne	 SHORT $LN18@gzseek64
  00276	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0027b	8b 00		 mov	 eax, DWORD PTR [rax]
  0027d	48 3b 44 24 58	 cmp	 rax, QWORD PTR offset$[rsp]
  00282	7f 0d		 jg	 SHORT $LN18@gzseek64
  00284	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00289	8b 00		 mov	 eax, DWORD PTR [rax]
  0028b	89 44 24 38	 mov	 DWORD PTR tv159[rsp], eax
  0028f	eb 08		 jmp	 SHORT $LN19@gzseek64
$LN18@gzseek64:
  00291	8b 44 24 58	 mov	 eax, DWORD PTR offset$[rsp]
  00295	89 44 24 38	 mov	 DWORD PTR tv159[rsp], eax
$LN19@gzseek64:
  00299	8b 44 24 38	 mov	 eax, DWORD PTR tv159[rsp]
  0029d	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 427  :             (unsigned)offset : state->x.have;
; 428  :         state->x.have -= n;

  002a1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  002a6	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  002aa	8b 00		 mov	 eax, DWORD PTR [rax]
  002ac	2b c1		 sub	 eax, ecx
  002ae	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  002b3	89 01		 mov	 DWORD PTR [rcx], eax

; 429  :         state->x.next += n;

  002b5	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  002b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  002be	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  002c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  002c7	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 430  :         state->x.pos += n;

  002cb	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  002cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  002d4	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  002d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  002dd	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 431  :         offset -= n;

  002e1	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  002e5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR offset$[rsp]
  002ea	48 2b c8	 sub	 rcx, rax
  002ed	48 8b c1	 mov	 rax, rcx
  002f0	48 89 44 24 58	 mov	 QWORD PTR offset$[rsp], rax
$LN15@gzseek64:

; 432  :     }
; 433  : 
; 434  :     /* request skip (if not zero) */
; 435  :     if (offset) {

  002f5	48 83 7c 24 58
	00		 cmp	 QWORD PTR offset$[rsp], 0
  002fb	74 1a		 je	 SHORT $LN16@gzseek64

; 436  :         state->seek = 1;

  002fd	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00302	c7 40 68 01 00
	00 00		 mov	 DWORD PTR [rax+104], 1

; 437  :         state->skip = offset;

  00309	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0030e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR offset$[rsp]
  00313	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
$LN16@gzseek64:

; 438  :     }
; 439  :     return state->x.pos + offset;

  00317	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0031c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00320	48 03 44 24 58	 add	 rax, QWORD PTR offset$[rsp]
$LN1@gzseek64:

; 440  : }

  00325	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00329	5f		 pop	 rdi
  0032a	c3		 ret	 0
gzseek64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzseek
_TEXT	SEGMENT
ret$ = 32
tv71 = 40
file$ = 64
offset$ = 72
whence$ = 80
gzseek	PROC						; COMDAT

; 447  : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 448  :     z_off64_t ret;
; 449  : 
; 450  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00033	48 63 44 24 48	 movsxd	 rax, DWORD PTR offset$[rsp]
  00038	44 8b 44 24 50	 mov	 r8d, DWORD PTR whence$[rsp]
  0003d	48 8b d0	 mov	 rdx, rax
  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  00045	e8 00 00 00 00	 call	 gzseek64
  0004a	48 89 44 24 20	 mov	 QWORD PTR ret$[rsp], rax

; 451  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0004f	48 63 44 24 20	 movsxd	 rax, DWORD PTR ret$[rsp]
  00054	48 39 44 24 20	 cmp	 QWORD PTR ret$[rsp], rax
  00059	75 0a		 jne	 SHORT $LN3@gzseek
  0005b	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  0005f	89 44 24 28	 mov	 DWORD PTR tv71[rsp], eax
  00063	eb 08		 jmp	 SHORT $LN4@gzseek
$LN3@gzseek:
  00065	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR tv71[rsp], -1
$LN4@gzseek:
  0006d	8b 44 24 28	 mov	 eax, DWORD PTR tv71[rsp]

; 452  : }

  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
gzseek	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gztell64
_TEXT	SEGMENT
state$ = 32
tv73 = 40
file$ = 64
gztell64 PROC						; COMDAT

; 457  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 458  :     gz_statep state;
; 459  : 
; 460  :     /* get internal structure and check integrity */
; 461  :     if (file == NULL)

  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00030	75 09		 jne	 SHORT $LN2@gztell64

; 462  :         return -1;

  00032	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00039	eb 61		 jmp	 SHORT $LN1@gztell64
$LN2@gztell64:

; 463  :     state = (gz_statep)file;

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00040	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 464  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0004a	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00051	74 17		 je	 SHORT $LN3@gztell64
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00058	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  0005f	74 09		 je	 SHORT $LN3@gztell64

; 465  :         return -1;

  00061	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00068	eb 32		 jmp	 SHORT $LN1@gztell64
$LN3@gztell64:

; 466  : 
; 467  :     /* return position */
; 468  :     return state->x.pos + (state->seek ? state->skip : 0);

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006f	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00073	74 10		 je	 SHORT $LN5@gztell64
  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0007a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0007e	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
  00083	eb 09		 jmp	 SHORT $LN6@gztell64
$LN5@gztell64:
  00085	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
$LN6@gztell64:
  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00093	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00097	48 03 44 24 28	 add	 rax, QWORD PTR tv73[rsp]
$LN1@gztell64:

; 469  : }

  0009c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
gztell64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gztell
_TEXT	SEGMENT
ret$ = 32
tv68 = 40
file$ = 64
gztell	PROC						; COMDAT

; 474  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 475  :     z_off64_t ret;
; 476  : 
; 477  :     ret = gztell64(file);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0002f	e8 00 00 00 00	 call	 gztell64
  00034	48 89 44 24 20	 mov	 QWORD PTR ret$[rsp], rax

; 478  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00039	48 63 44 24 20	 movsxd	 rax, DWORD PTR ret$[rsp]
  0003e	48 39 44 24 20	 cmp	 QWORD PTR ret$[rsp], rax
  00043	75 0a		 jne	 SHORT $LN3@gztell
  00045	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  00049	89 44 24 28	 mov	 DWORD PTR tv68[rsp], eax
  0004d	eb 08		 jmp	 SHORT $LN4@gztell
$LN3@gztell:
  0004f	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR tv68[rsp], -1
$LN4@gztell:
  00057	8b 44 24 28	 mov	 eax, DWORD PTR tv68[rsp]

; 479  : }

  0005b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
gztell	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzoffset64
_TEXT	SEGMENT
offset$ = 32
state$ = 40
file$ = 64
gzoffset64 PROC						; COMDAT

; 484  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 485  :     z_off64_t offset;
; 486  :     gz_statep state;
; 487  : 
; 488  :     /* get internal structure and check integrity */
; 489  :     if (file == NULL)

  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00030	75 0c		 jne	 SHORT $LN2@gzoffset64

; 490  :         return -1;

  00032	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00039	e9 89 00 00 00	 jmp	 $LN1@gzoffset64
$LN2@gzoffset64:

; 491  :     state = (gz_statep)file;

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00043	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 492  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0004d	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00054	74 17		 je	 SHORT $LN3@gzoffset64
  00056	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0005b	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  00062	74 09		 je	 SHORT $LN3@gzoffset64

; 493  :         return -1;

  00064	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0006b	eb 5a		 jmp	 SHORT $LN1@gzoffset64
$LN3@gzoffset64:

; 494  : 
; 495  :     /* compute and return effective offset in file */
; 496  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  0006d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00073	33 d2		 xor	 edx, edx
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0007a	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00083	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 497  :     if (offset == -1)

  00088	48 83 7c 24 20
	ff		 cmp	 QWORD PTR offset$[rsp], -1
  0008e	75 09		 jne	 SHORT $LN4@gzoffset64

; 498  :         return -1;

  00090	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00097	eb 2e		 jmp	 SHORT $LN1@gzoffset64
$LN4@gzoffset64:

; 499  :     if (state->mode == GZ_READ)             /* reading */

  00099	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0009e	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  000a5	75 1b		 jne	 SHORT $LN5@gzoffset64

; 500  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ac	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000b2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  000b7	48 2b c8	 sub	 rcx, rax
  000ba	48 8b c1	 mov	 rax, rcx
  000bd	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax
$LN5@gzoffset64:

; 501  :     return offset;

  000c2	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
$LN1@gzoffset64:

; 502  : }

  000c7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cb	5f		 pop	 rdi
  000cc	c3		 ret	 0
gzoffset64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzoffset
_TEXT	SEGMENT
ret$ = 32
tv68 = 40
file$ = 64
gzoffset PROC						; COMDAT

; 507  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 508  :     z_off64_t ret;
; 509  : 
; 510  :     ret = gzoffset64(file);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0002f	e8 00 00 00 00	 call	 gzoffset64
  00034	48 89 44 24 20	 mov	 QWORD PTR ret$[rsp], rax

; 511  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00039	48 63 44 24 20	 movsxd	 rax, DWORD PTR ret$[rsp]
  0003e	48 39 44 24 20	 cmp	 QWORD PTR ret$[rsp], rax
  00043	75 0a		 jne	 SHORT $LN3@gzoffset
  00045	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  00049	89 44 24 28	 mov	 DWORD PTR tv68[rsp], eax
  0004d	eb 08		 jmp	 SHORT $LN4@gzoffset
$LN3@gzoffset:
  0004f	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR tv68[rsp], -1
$LN4@gzoffset:
  00057	8b 44 24 28	 mov	 eax, DWORD PTR tv68[rsp]

; 512  : }

  0005b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
gzoffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzeof
_TEXT	SEGMENT
state$ = 32
tv72 = 40
file$ = 64
gzeof	PROC						; COMDAT

; 517  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 518  :     gz_statep state;
; 519  : 
; 520  :     /* get internal structure and check integrity */
; 521  :     if (file == NULL)

  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00030	75 04		 jne	 SHORT $LN2@gzeof

; 522  :         return 0;

  00032	33 c0		 xor	 eax, eax
  00034	eb 52		 jmp	 SHORT $LN1@gzeof
$LN2@gzeof:

; 523  :     state = (gz_statep)file;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0003b	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 524  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00045	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  0004c	74 12		 je	 SHORT $LN3@gzeof
  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00053	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  0005a	74 04		 je	 SHORT $LN3@gzeof

; 525  :         return 0;

  0005c	33 c0		 xor	 eax, eax
  0005e	eb 28		 jmp	 SHORT $LN1@gzeof
$LN3@gzeof:

; 526  : 
; 527  :     /* return end-of-file state */
; 528  :     return state->mode == GZ_READ ? state->past : 0;

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00065	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  0006c	75 0e		 jne	 SHORT $LN5@gzeof
  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00073	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  00076	89 44 24 28	 mov	 DWORD PTR tv72[rsp], eax
  0007a	eb 08		 jmp	 SHORT $LN6@gzeof
$LN5@gzeof:
  0007c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN6@gzeof:
  00084	8b 44 24 28	 mov	 eax, DWORD PTR tv72[rsp]
$LN1@gzeof:

; 529  : }

  00088	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
gzeof	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzerror
_TEXT	SEGMENT
state$ = 32
tv77 = 40
tv76 = 48
file$ = 80
errnum$ = 88
gzerror	PROC						; COMDAT

; 535  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 536  :     gz_statep state;
; 537  : 
; 538  :     /* get internal structure and check integrity */
; 539  :     if (file == NULL)

  0002f	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  00035	75 07		 jne	 SHORT $LN2@gzerror

; 540  :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	e9 91 00 00 00	 jmp	 $LN1@gzerror
$LN2@gzerror:

; 541  :     state = (gz_statep)file;

  0003e	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  00043	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 542  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0004d	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00054	74 12		 je	 SHORT $LN3@gzerror
  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005b	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  00062	74 04		 je	 SHORT $LN3@gzerror

; 543  :         return NULL;

  00064	33 c0		 xor	 eax, eax
  00066	eb 67		 jmp	 SHORT $LN1@gzerror
$LN3@gzerror:

; 544  : 
; 545  :     /* return error information */
; 546  :     if (errnum != NULL)

  00068	48 83 7c 24 58
	00		 cmp	 QWORD PTR errnum$[rsp], 0
  0006e	74 0f		 je	 SHORT $LN4@gzerror

; 547  :         *errnum = state->err;

  00070	48 8b 44 24 58	 mov	 rax, QWORD PTR errnum$[rsp]
  00075	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0007a	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]
  0007d	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@gzerror:

; 548  :     return state->err == Z_MEM_ERROR ? "out of memory" :

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00084	83 78 6c fc	 cmp	 DWORD PTR [rax+108], -4
  00088	75 0e		 jne	 SHORT $LN8@gzerror
  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  00091	48 89 44 24 28	 mov	 QWORD PTR tv77[rsp], rax
  00096	eb 32		 jmp	 SHORT $LN9@gzerror
$LN8@gzerror:
  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0009d	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  000a2	75 0e		 jne	 SHORT $LN6@gzerror
  000a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
  000ab	48 89 44 24 30	 mov	 QWORD PTR tv76[rsp], rax
  000b0	eb 0e		 jmp	 SHORT $LN7@gzerror
$LN6@gzerror:
  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000b7	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000bb	48 89 44 24 30	 mov	 QWORD PTR tv76[rsp], rax
$LN7@gzerror:
  000c0	48 8b 44 24 30	 mov	 rax, QWORD PTR tv76[rsp]
  000c5	48 89 44 24 28	 mov	 QWORD PTR tv77[rsp], rax
$LN9@gzerror:
  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR tv77[rsp]
$LN1@gzerror:

; 549  :                                        (state->msg == NULL ? "" : state->msg);
; 550  : }

  000cf	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
gzerror	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gzclearerr
_TEXT	SEGMENT
state$ = 32
file$ = 64
gzclearerr PROC						; COMDAT

; 555  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 556  :     gz_statep state;
; 557  : 
; 558  :     /* get internal structure and check integrity */
; 559  :     if (file == NULL)

  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00030	75 02		 jne	 SHORT $LN2@gzclearerr

; 560  :         return;

  00032	eb 5d		 jmp	 SHORT $LN1@gzclearerr
$LN2@gzclearerr:

; 561  :     state = (gz_statep)file;

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00039	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 562  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00043	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  0004a	74 10		 je	 SHORT $LN3@gzclearerr
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00051	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  00058	74 02		 je	 SHORT $LN3@gzclearerr

; 563  :         return;

  0005a	eb 35		 jmp	 SHORT $LN1@gzclearerr
$LN3@gzclearerr:

; 564  : 
; 565  :     /* clear error and end-of-file */
; 566  :     if (state->mode == GZ_READ) {

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00061	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00068	75 18		 jne	 SHORT $LN4@gzclearerr

; 567  :         state->eof = 0;

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006f	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [rax+80], 0

; 568  :         state->past = 0;

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0007b	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [rax+84], 0
$LN4@gzclearerr:

; 569  :     }
; 570  :     gz_error(state, Z_OK, NULL);

  00082	45 33 c0	 xor	 r8d, r8d
  00085	33 d2		 xor	 edx, edx
  00087	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0008c	e8 00 00 00 00	 call	 gz_error
$LN1@gzclearerr:

; 571  : }

  00091	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
gzclearerr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT gz_error
_TEXT	SEGMENT
tv81 = 48
tv78 = 56
tv130 = 64
state$ = 96
err$ = 104
msg$ = 112
gz_error PROC						; COMDAT

; 583  : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 14 00 00 00	 mov	 ecx, 20
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 584  :     /* free previously allocated message and clear */
; 585  :     if (state->msg != NULL) {

  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00038	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0003d	74 27		 je	 SHORT $LN2@gz_error

; 586  :         if (state->err != Z_MEM_ERROR)

  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00044	83 78 6c fc	 cmp	 DWORD PTR [rax+108], -4
  00048	74 0f		 je	 SHORT $LN3@gz_error

; 587  :             free(state->msg);

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0004f	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@gz_error:

; 588  :         state->msg = NULL;

  00059	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0005e	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
$LN2@gz_error:

; 589  :     }
; 590  : 
; 591  :     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
; 592  :     if (err != Z_OK && err != Z_BUF_ERROR)

  00066	83 7c 24 68 00	 cmp	 DWORD PTR err$[rsp], 0
  0006b	74 12		 je	 SHORT $LN4@gz_error
  0006d	83 7c 24 68 fb	 cmp	 DWORD PTR err$[rsp], -5
  00072	74 0b		 je	 SHORT $LN4@gz_error

; 593  :         state->x.have = 0;

  00074	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00079	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN4@gz_error:

; 594  : 
; 595  :     /* set error code, and if no message, then done */
; 596  :     state->err = err;

  0007f	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00084	8b 4c 24 68	 mov	 ecx, DWORD PTR err$[rsp]
  00088	89 48 6c	 mov	 DWORD PTR [rax+108], ecx

; 597  :     if (msg == NULL)

  0008b	48 83 7c 24 70
	00		 cmp	 QWORD PTR msg$[rsp], 0
  00091	75 05		 jne	 SHORT $LN5@gz_error

; 598  :         return;

  00093	e9 c7 00 00 00	 jmp	 $LN1@gz_error
$LN5@gz_error:

; 599  : 
; 600  :     /* for an out of memory error, return literal string when requested */
; 601  :     if (err == Z_MEM_ERROR)

  00098	83 7c 24 68 fc	 cmp	 DWORD PTR err$[rsp], -4
  0009d	75 05		 jne	 SHORT $LN6@gz_error

; 602  :         return;

  0009f	e9 bb 00 00 00	 jmp	 $LN1@gz_error
$LN6@gz_error:

; 603  : 
; 604  :     /* construct error message with path */
; 605  :     if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==

  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000a9	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlen
  000b3	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  000b8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR msg$[rsp]
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlen
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  000c8	48 8d 44 01 03	 lea	 rax, QWORD PTR [rcx+rax+3]
  000cd	48 8b c8	 mov	 rcx, rax
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000d6	48 89 44 24 38	 mov	 QWORD PTR tv78[rsp], rax
  000db	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000e0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv78[rsp]
  000e5	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
  000e9	48 83 7c 24 38
	00		 cmp	 QWORD PTR tv78[rsp], 0
  000ef	75 0e		 jne	 SHORT $LN7@gz_error

; 606  :             NULL) {
; 607  :         state->err = Z_MEM_ERROR;

  000f1	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000f6	c7 40 6c fc ff
	ff ff		 mov	 DWORD PTR [rax+108], -4

; 608  :         return;

  000fd	eb 60		 jmp	 SHORT $LN1@gz_error
$LN7@gz_error:

; 609  :     }
; 610  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 611  :     (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,

  000ff	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00104	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlen
  0010e	48 89 44 24 40	 mov	 QWORD PTR tv130[rsp], rax
  00113	48 8b 4c 24 70	 mov	 rcx, QWORD PTR msg$[rsp]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlen
  0011e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv130[rsp]
  00123	48 8d 44 01 03	 lea	 rax, QWORD PTR [rcx+rax+3]
  00128	48 8b 4c 24 70	 mov	 rcx, QWORD PTR msg$[rsp]
  0012d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5@
  00139	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0013e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00143	4c 8b 49 20	 mov	 r9, QWORD PTR [rcx+32]
  00147	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
  0014e	48 8b d0	 mov	 rdx, rax
  00151	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00156	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0015a	e8 00 00 00 00	 call	 snprintf
$LN1@gz_error:

; 612  :                    "%s%s%s", state->path, ": ", msg);
; 613  : #else
; 614  :     strcpy(state->msg, state->path);
; 615  :     strcat(state->msg, ": ");
; 616  :     strcat(state->msg, msg);
; 617  : #endif
; 618  : }

  0015f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00163	5f		 pop	 rdi
  00164	c3		 ret	 0
gz_error ENDP
_TEXT	ENDS
END
