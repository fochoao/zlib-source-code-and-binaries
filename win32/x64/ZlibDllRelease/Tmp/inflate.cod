; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+10
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__55962C33_inffixed@h DB 01H
__4ACC5162_inflate@c DB 01H
PUBLIC	inflateCodesUsed
PUBLIC	inflateMark
PUBLIC	inflateValidate
PUBLIC	inflateUndermine
PUBLIC	inflateCopy
PUBLIC	inflateSyncPoint
PUBLIC	inflateSync
PUBLIC	inflateGetHeader
PUBLIC	inflateSetDictionary
PUBLIC	inflateGetDictionary
PUBLIC	inflatePrime
PUBLIC	inflateInit_
PUBLIC	inflateReset2
PUBLIC	inflateResetKeep
PUBLIC	inflateEnd
PUBLIC	inflate
PUBLIC	inflateInit2_
PUBLIC	inflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCodesUsed DD imagerel $LN5
	DD	imagerel $LN5+116
	DD	imagerel $unwind$inflateCodesUsed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateMark DD imagerel $LN9
	DD	imagerel $LN9+186
	DD	imagerel $unwind$inflateMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateValidate DD imagerel $LN7
	DD	imagerel $LN7+136
	DD	imagerel $unwind$inflateValidate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateUndermine DD imagerel $LN5
	DD	imagerel $LN5+107
	DD	imagerel $unwind$inflateUndermine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN12
	DD	imagerel $LN12+625
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSyncPoint DD imagerel $LN7
	DD	imagerel $LN7+130
	DD	imagerel $unwind$inflateSyncPoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN10
	DD	imagerel $LN10+567
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+217
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetHeader DD imagerel $LN6
	DD	imagerel $LN6+138
	DD	imagerel $unwind$inflateGetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN10
	DD	imagerel $LN10+282
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetDictionary DD imagerel $LN7
	DD	imagerel $LN7+250
	DD	imagerel $unwind$inflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+620
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fixedtables DD imagerel fixedtables
	DD	imagerel fixedtables+104
	DD	imagerel $unwind$fixedtables
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflatePrime DD imagerel $LN9
	DD	imagerel $LN9+252
	DD	imagerel $unwind$inflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit_ DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$inflateInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN11
	DD	imagerel $LN11+276
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateResetKeep DD imagerel $LN6
	DD	imagerel $LN6+343
	DD	imagerel $unwind$inflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateStateCheck DD imagerel inflateStateCheck
	DD	imagerel inflateStateCheck+161
	DD	imagerel $unwind$inflateStateCheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN6
	DD	imagerel $LN6+162
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN560
	DD	imagerel $LN560+12216
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN11
	DD	imagerel $LN11+393
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset DD imagerel $LN5
	DD	imagerel $LN5+129
	DD	imagerel $unwind$inflateReset
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 022c01H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 032801H
	DD	0280111H
	DD	0700aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
inflate$rtcName$0 DB 068H
	DB	065H
	DB	072H
	DB	065H
	DB	00H
	ORG $+3
inflate$rtcName$1 DB 06cH
	DB	061H
	DB	073H
	DB	074H
	DB	00H
	ORG $+3
inflate$rtcName$2 DB 068H
	DB	062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+3
inflate$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:inflate$rtcVarDesc
	ORG $+8
inflate$rtcVarDesc DD 0b4H
	DD	04H
	DQ	FLAT:inflate$rtcName$2
	DD	094H
	DD	04H
	DQ	FLAT:inflate$rtcName$1
	DD	074H
	DD	04H
	DQ	FLAT:inflate$rtcName$0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateStateCheck DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateResetKeep DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit_ DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflatePrime DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fixedtables DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 022801H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetDictionary DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetHeader DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 021e01H
	DD	07006b20aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
inflateSync$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+12
inflateSync$rtcVarDesc DD 034H
	DD	04H
	DQ	FLAT:inflateSync$rtcName$0
	ORG $+48
inflateSync$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:inflateSync$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSyncPoint DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 022301H
	DD	0700b920fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateUndermine DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateValidate DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateMark DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCodesUsed DD 021e01H
	DD	07006520aH
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateReset
_TEXT	SEGMENT
state$ = 32
strm$ = 64
inflateReset PROC					; COMDAT

; 146  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0002f	e8 00 00 00 00	 call	 inflateStateCheck
  00034	85 c0		 test	 eax, eax
  00036	74 07		 je	 SHORT $LN2@inflateRes
  00038	b8 fe ff ff ff	 mov	 eax, -2
  0003d	eb 3c		 jmp	 SHORT $LN1@inflateRes
$LN2@inflateRes:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00048	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 151  :     state->wsize = 0;

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00052	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 152  :     state->whave = 0;

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005e	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 153  :     state->wnext = 0;

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006a	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0

; 154  :     return inflateResetKeep(strm);

  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00076	e8 00 00 00 00	 call	 inflateResetKeep
$LN1@inflateRes:

; 155  : }

  0007b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateInit2_
_TEXT	SEGMENT
ret$ = 32
state$ = 40
strm$ = 64
windowBits$ = 72
version$ = 80
stream_size$ = 88
inflateInit2_ PROC					; COMDAT

; 200  : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 0c 00 00 00	 mov	 ecx, 12
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00033	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00038	48 83 7c 24 50
	00		 cmp	 QWORD PTR version$[rsp], 0
  0003e	74 31		 je	 SHORT $LN3@inflateIni
  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	48 6b c0 00	 imul	 rax, rax, 0
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR version$[rsp]
  0004e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00052	b9 01 00 00 00	 mov	 ecx, 1
  00057	48 6b c9 00	 imul	 rcx, rcx, 0
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411@
  00062	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00066	3b c1		 cmp	 eax, ecx
  00068	75 07		 jne	 SHORT $LN3@inflateIni
  0006a	83 7c 24 58 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0006f	74 0a		 je	 SHORT $LN2@inflateIni
$LN3@inflateIni:

; 205  :         stream_size != (int)(sizeof(z_stream)))
; 206  :         return Z_VERSION_ERROR;

  00071	b8 fa ff ff ff	 mov	 eax, -6
  00076	e9 08 01 00 00	 jmp	 $LN1@inflateIni
$LN2@inflateIni:

; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0007b	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00081	75 0a		 jne	 SHORT $LN4@inflateIni
  00083	b8 fe ff ff ff	 mov	 eax, -2
  00088	e9 f6 00 00 00	 jmp	 $LN1@inflateIni
$LN4@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */

  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00092	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 209  :     if (strm->zalloc == (alloc_func)0) {

  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0009f	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000a4	75 1d		 jne	 SHORT $LN5@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;

  000a6	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcalloc
  000b2	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 214  :         strm->opaque = (voidpf)0;

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000bb	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN5@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c8	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000cd	75 10		 jne	 SHORT $LN6@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree
  000db	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN6@inflateIni:

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)

  000df	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  000e5	ba 01 00 00 00	 mov	 edx, 1
  000ea	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ef	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000f3	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000f8	ff 50 30	 call	 QWORD PTR [rax+48]
  000fb	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00100	48 83 7c 24 28
	00		 cmp	 QWORD PTR state$[rsp], 0
  00106	75 07		 jne	 SHORT $LN7@inflateIni
  00108	b8 fc ff ff ff	 mov	 eax, -4
  0010d	eb 74		 jmp	 SHORT $LN1@inflateIni
$LN7@inflateIni:

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;

  0010f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00114	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00119	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 228  :     state->strm = strm;

  0011d	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00122	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00127	48 89 08	 mov	 QWORD PTR [rax], rcx

; 229  :     state->window = Z_NULL;

  0012a	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0012f	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */

  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0013c	c7 40 08 34 3f
	00 00		 mov	 DWORD PTR [rax+8], 16180 ; 00003f34H

; 231  :     ret = inflateReset2(strm, windowBits);

  00143	8b 54 24 48	 mov	 edx, DWORD PTR windowBits$[rsp]
  00147	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0014c	e8 00 00 00 00	 call	 inflateReset2
  00151	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 232  :     if (ret != Z_OK) {

  00155	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  0015a	74 23		 je	 SHORT $LN8@inflateIni

; 233  :         ZFREE(strm, state);

  0015c	48 8b 54 24 28	 mov	 rdx, QWORD PTR state$[rsp]
  00161	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00166	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0016a	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0016f	ff 50 38	 call	 QWORD PTR [rax+56]

; 234  :         strm->state = Z_NULL;

  00172	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00177	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
$LN8@inflateIni:

; 235  :     }
; 236  :     return ret;

  0017f	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
$LN1@inflateIni:

; 237  : }

  00183	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00187	5f		 pop	 rdi
  00188	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflate
_TEXT	SEGMENT
state$ = 48
next$ = 56
put$ = 64
have$ = 72
left$ = 76
hold$ = 80
bits$ = 84
in$ = 88
out$ = 92
copy$ = 96
from$ = 104
here$ = 116
last$ = 148
len$ = 164
ret$ = 168
hbuf$ = 180
tv85 = 196
tv1780 = 200
tv195 = 204
tv202 = 208
tv400 = 212
tv564 = 216
tv591 = 220
tv605 = 224
tv636 = 228
tv791 = 232
tv2245 = 240
tv928 = 244
tv961 = 248
tv983 = 256
tv2414 = 264
tv1045 = 268
tv2488 = 272
tv2512 = 276
tv1163 = 280
tv2582 = 284
tv1333 = 288
tv1350 = 292
tv1441 = 296
tv1446 = 300
tv1450 = 304
tv1456 = 308
strm$ = 336
flush$ = 344
inflate	PROC						; COMDAT

; 625  : {

$LN560:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR [rsp+336]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00034	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0003c	e8 00 00 00 00	 call	 inflateStateCheck
  00041	85 c0		 test	 eax, eax
  00043	75 2b		 jne	 SHORT $LN333@inflate
  00045	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0004d	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00052	74 1c		 je	 SHORT $LN333@inflate
  00054	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0005c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00060	75 18		 jne	 SHORT $LN332@inflate
  00062	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0006a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0006e	74 0a		 je	 SHORT $LN332@inflate
$LN333@inflate:

; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 647  :         return Z_STREAM_ERROR;

  00070	b8 fe ff ff ff	 mov	 eax, -2
  00075	e9 a4 2e 00 00	 jmp	 $LN1@inflate
$LN332@inflate:

; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  0007a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00082	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00086	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00090	81 78 08 3f 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16191 ; 00003f3fH
  00097	75 0c		 jne	 SHORT $LN334@inflate
  00099	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0009e	c7 40 08 40 3f
	00 00		 mov	 DWORD PTR [rax+8], 16192 ; 00003f40H
$LN334@inflate:
$LN4@inflate:

; 651  :     LOAD();

  000a5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000ad	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b1	48 89 44 24 40	 mov	 QWORD PTR put$[rsp], rax
  000b6	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000be	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000c1	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  000c5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000cd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d0	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  000d5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000dd	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000e0	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000e9	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000ec	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  000f0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000f5	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000f8	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 a3		 jne	 SHORT $LN4@inflate

; 652  :     in = have;

  00102	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  00106	89 44 24 58	 mov	 DWORD PTR in$[rsp], eax

; 653  :     out = left;

  0010a	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  0010e	89 44 24 5c	 mov	 DWORD PTR out$[rsp], eax

; 654  :     ret = Z_OK;

  00112	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ret$[rsp], 0
$LN5@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0011d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00122	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00125	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv85[rsp], eax
  0012c	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv85[rsp]
  00133	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00138	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv85[rsp], eax
  0013f	83 bc 24 c4 00
	00 00 1e	 cmp	 DWORD PTR tv85[rsp], 30
  00147	0f 87 db 2a 00
	00		 ja	 $LN499@inflate
  0014d	48 63 84 24 c4
	00 00 00	 movsxd	 rax, DWORD PTR tv85[rsp]
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0015c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN559@inflate[rcx+rax*4]
  00163	48 03 c1	 add	 rax, rcx
  00166	ff e0		 jmp	 rax
$LN335@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  00168	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0016d	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00171	75 11		 jne	 SHORT $LN336@inflate

; 659  :                 state->mode = TYPEDO;

  00173	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00178	c7 40 08 40 3f
	00 00		 mov	 DWORD PTR [rax+8], 16192 ; 00003f40H

; 660  :                 break;

  0017f	e9 ae 2a 00 00	 jmp	 $LN8@inflate
$LN336@inflate:
$LN12@inflate:
$LN13@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  00184	83 7c 24 54 10	 cmp	 DWORD PTR bits$[rsp], 16
  00189	73 50		 jae	 SHORT $LN14@inflate
$LN17@inflate:
  0018b	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  00190	75 05		 jne	 SHORT $LN337@inflate
  00192	e9 a0 2a 00 00	 jmp	 $inf_leave$561
$LN337@inflate:
  00197	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  0019b	ff c8		 dec	 eax
  0019d	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  001a1	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  001a6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a9	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  001ad	d3 e0		 shl	 eax, cl
  001af	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  001b3	03 c8		 add	 ecx, eax
  001b5	8b c1		 mov	 eax, ecx
  001b7	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  001bb	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  001c0	48 ff c0	 inc	 rax
  001c3	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  001c8	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  001cc	83 c0 08	 add	 eax, 8
  001cf	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  001d3	33 c0		 xor	 eax, eax
  001d5	85 c0		 test	 eax, eax
  001d7	75 b2		 jne	 SHORT $LN17@inflate
  001d9	eb a9		 jmp	 SHORT $LN13@inflate
$LN14@inflate:
  001db	33 c0		 xor	 eax, eax
  001dd	85 c0		 test	 eax, eax
  001df	75 a3		 jne	 SHORT $LN12@inflate

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  001e1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  001e6	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001e9	83 e0 02	 and	 eax, 2
  001ec	85 c0		 test	 eax, eax
  001ee	0f 84 b8 00 00
	00		 je	 $LN338@inflate
  001f4	81 7c 24 50 1f
	8b 00 00	 cmp	 DWORD PTR hold$[rsp], 35615 ; 00008b1fH
  001fc	0f 85 aa 00 00
	00		 jne	 $LN338@inflate

; 665  :                 if (state->wbits == 0)

  00202	0f ae e8	 lfence
  00205	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0020a	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0020e	75 0c		 jne	 SHORT $LN339@inflate

; 666  :                     state->wbits = 15;

  00210	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00215	c7 40 30 0f 00
	00 00		 mov	 DWORD PTR [rax+48], 15
$LN339@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  0021c	45 33 c0	 xor	 r8d, r8d
  0021f	33 d2		 xor	 edx, edx
  00221	33 c9		 xor	 ecx, ecx
  00223	e8 00 00 00 00	 call	 crc32
  00228	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0022d	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN20@inflate:

; 668  :                 CRC2(state->check, hold);

  00230	b8 01 00 00 00	 mov	 eax, 1
  00235	48 6b c0 00	 imul	 rax, rax, 0
  00239	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR hold$[rsp]
  0023e	88 8c 04 b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rax], cl
  00245	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  00249	c1 e8 08	 shr	 eax, 8
  0024c	b9 01 00 00 00	 mov	 ecx, 1
  00251	48 6b c9 01	 imul	 rcx, rcx, 1
  00255	88 84 0c b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rcx], al
  0025c	41 b8 02 00 00
	00		 mov	 r8d, 2
  00262	48 8d 94 24 b4
	00 00 00	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0026a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0026f	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00272	e8 00 00 00 00	 call	 crc32
  00277	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0027c	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  0027f	33 c0		 xor	 eax, eax
  00281	85 c0		 test	 eax, eax
  00283	75 ab		 jne	 SHORT $LN20@inflate
$LN23@inflate:

; 669  :                 INITBITS();

  00285	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  0028d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00295	33 c0		 xor	 eax, eax
  00297	85 c0		 test	 eax, eax
  00299	75 ea		 jne	 SHORT $LN23@inflate

; 670  :                 state->mode = FLAGS;

  0029b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  002a0	c7 40 08 35 3f
	00 00		 mov	 DWORD PTR [rax+8], 16181 ; 00003f35H

; 671  :                 break;

  002a7	e9 86 29 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */

  002ac	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  002b1	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 674  :             if (state->head != Z_NULL)

  002b8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  002bd	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  002c2	74 10		 je	 SHORT $LN340@inflate

; 675  :                 state->head->done = -1;

  002c4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  002c9	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  002cd	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN340@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  002d4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  002d9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  002dc	83 e0 01	 and	 eax, 1
  002df	85 c0		 test	 eax, eax
  002e1	74 24		 je	 SHORT $LN342@inflate
  002e3	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  002e7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002ec	c1 e0 08	 shl	 eax, 8
  002ef	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  002f3	c1 e9 08	 shr	 ecx, 8
  002f6	03 c1		 add	 eax, ecx
  002f8	33 d2		 xor	 edx, edx
  002fa	b9 1f 00 00 00	 mov	 ecx, 31
  002ff	f7 f1		 div	 ecx
  00301	8b c2		 mov	 eax, edx
  00303	85 c0		 test	 eax, eax
  00305	74 24		 je	 SHORT $LN341@inflate
$LN342@inflate:

; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 681  :                 strm->msg = (char *)"incorrect header check";

  00307	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0030f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
  00316	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 682  :                 state->mode = BAD;

  0031a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0031f	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 683  :                 break;

  00326	e9 07 29 00 00	 jmp	 $LN8@inflate
$LN341@inflate:

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  0032b	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  0032f	83 e0 0f	 and	 eax, 15
  00332	83 f8 08	 cmp	 eax, 8
  00335	74 24		 je	 SHORT $LN343@inflate

; 686  :                 strm->msg = (char *)"unknown compression method";

  00337	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0033f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  00346	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 687  :                 state->mode = BAD;

  0034a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0034f	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 688  :                 break;

  00356	e9 d7 28 00 00	 jmp	 $LN8@inflate
$LN343@inflate:
$LN26@inflate:

; 689  :             }
; 690  :             DROPBITS(4);

  0035b	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  0035f	c1 e8 04	 shr	 eax, 4
  00362	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  00366	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  0036a	83 e8 04	 sub	 eax, 4
  0036d	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  00371	33 c0		 xor	 eax, eax
  00373	85 c0		 test	 eax, eax
  00375	75 e4		 jne	 SHORT $LN26@inflate

; 691  :             len = BITS(4) + 8;

  00377	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  0037b	83 e0 0f	 and	 eax, 15
  0037e	83 c0 08	 add	 eax, 8
  00381	89 84 24 a4 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 692  :             if (state->wbits == 0)

  00388	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0038d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00391	75 0f		 jne	 SHORT $LN344@inflate

; 693  :                 state->wbits = len;

  00393	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00398	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  0039f	89 48 30	 mov	 DWORD PTR [rax+48], ecx
$LN344@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  003a2	83 bc 24 a4 00
	00 00 0f	 cmp	 DWORD PTR len$[rsp], 15
  003aa	77 11		 ja	 SHORT $LN346@inflate
  003ac	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  003b1	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  003b4	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR len$[rsp], eax
  003bb	76 24		 jbe	 SHORT $LN345@inflate
$LN346@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  003bd	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  003c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size@
  003cc	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 696  :                 state->mode = BAD;

  003d0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  003d5	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 697  :                 break;

  003dc	e9 51 28 00 00	 jmp	 $LN8@inflate
$LN345@inflate:

; 698  :             }
; 699  :             state->dmax = 1U << len;

  003e1	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  003e8	b9 01 00 00 00	 mov	 ecx, 1
  003ed	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR tv1780[rsp], ecx
  003f4	0f b6 c8	 movzx	 ecx, al
  003f7	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv1780[rsp]
  003fe	d3 e0		 shl	 eax, cl
  00400	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00405	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00408	45 33 c0	 xor	 r8d, r8d
  0040b	33 d2		 xor	 edx, edx
  0040d	33 c9		 xor	 ecx, ecx
  0040f	e8 00 00 00 00	 call	 adler32
  00414	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv195[rsp], eax
  0041b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00420	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv195[rsp]
  00427	89 48 20	 mov	 DWORD PTR [rax+32], ecx
  0042a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00432	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv195[rsp]
  00439	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  0043c	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  00440	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00445	85 c0		 test	 eax, eax
  00447	74 0d		 je	 SHORT $LN509@inflate
  00449	c7 84 24 d0 00
	00 00 3d 3f 00
	00		 mov	 DWORD PTR tv202[rsp], 16189 ; 00003f3dH
  00454	eb 0b		 jmp	 SHORT $LN510@inflate
$LN509@inflate:
  00456	c7 84 24 d0 00
	00 00 3f 3f 00
	00		 mov	 DWORD PTR tv202[rsp], 16191 ; 00003f3fH
$LN510@inflate:
  00461	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00466	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv202[rsp]
  0046d	89 48 08	 mov	 DWORD PTR [rax+8], ecx
$LN29@inflate:

; 703  :             INITBITS();

  00470	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00478	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00480	33 c0		 xor	 eax, eax
  00482	85 c0		 test	 eax, eax
  00484	75 ea		 jne	 SHORT $LN29@inflate

; 704  :             break;

  00486	e9 a7 27 00 00	 jmp	 $LN8@inflate
$LN347@inflate:
$LN32@inflate:
$LN33@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  0048b	83 7c 24 54 10	 cmp	 DWORD PTR bits$[rsp], 16
  00490	73 50		 jae	 SHORT $LN34@inflate
$LN37@inflate:
  00492	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  00497	75 05		 jne	 SHORT $LN348@inflate
  00499	e9 99 27 00 00	 jmp	 $inf_leave$561
$LN348@inflate:
  0049e	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  004a2	ff c8		 dec	 eax
  004a4	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  004a8	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  004ad	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004b0	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  004b4	d3 e0		 shl	 eax, cl
  004b6	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  004ba	03 c8		 add	 ecx, eax
  004bc	8b c1		 mov	 eax, ecx
  004be	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  004c2	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  004c7	48 ff c0	 inc	 rax
  004ca	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  004cf	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  004d3	83 c0 08	 add	 eax, 8
  004d6	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  004da	33 c0		 xor	 eax, eax
  004dc	85 c0		 test	 eax, eax
  004de	75 b2		 jne	 SHORT $LN37@inflate
  004e0	eb a9		 jmp	 SHORT $LN33@inflate
$LN34@inflate:
  004e2	33 c0		 xor	 eax, eax
  004e4	85 c0		 test	 eax, eax
  004e6	75 a3		 jne	 SHORT $LN32@inflate

; 708  :             state->flags = (int)(hold);

  004e8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  004ed	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  004f1	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  004f4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  004f9	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  004fc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00501	83 f8 08	 cmp	 eax, 8
  00504	74 24		 je	 SHORT $LN349@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";

  00506	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0050e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  00515	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 711  :                 state->mode = BAD;

  00519	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0051e	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 712  :                 break;

  00525	e9 08 27 00 00	 jmp	 $LN8@inflate
$LN349@inflate:

; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  0052a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0052f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00532	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  00537	85 c0		 test	 eax, eax
  00539	74 24		 je	 SHORT $LN350@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  0053b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00543	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
  0054a	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 716  :                 state->mode = BAD;

  0054e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00553	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 717  :                 break;

  0055a	e9 d3 26 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 718  :             }
; 719  :             if (state->head != Z_NULL)

  0055f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00564	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00569	74 15		 je	 SHORT $LN351@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  0056b	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  0056f	c1 e8 08	 shr	 eax, 8
  00572	83 e0 01	 and	 eax, 1
  00575	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0057a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0057e	89 01		 mov	 DWORD PTR [rcx], eax
$LN351@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00580	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00585	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00588	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0058d	85 c0		 test	 eax, eax
  0058f	74 64		 je	 SHORT $LN352@inflate
  00591	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00596	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00599	83 e0 04	 and	 eax, 4
  0059c	85 c0		 test	 eax, eax
  0059e	74 55		 je	 SHORT $LN352@inflate
$LN40@inflate:

; 722  :                 CRC2(state->check, hold);

  005a0	b8 01 00 00 00	 mov	 eax, 1
  005a5	48 6b c0 00	 imul	 rax, rax, 0
  005a9	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR hold$[rsp]
  005ae	88 8c 04 b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rax], cl
  005b5	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  005b9	c1 e8 08	 shr	 eax, 8
  005bc	b9 01 00 00 00	 mov	 ecx, 1
  005c1	48 6b c9 01	 imul	 rcx, rcx, 1
  005c5	88 84 0c b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rcx], al
  005cc	41 b8 02 00 00
	00		 mov	 r8d, 2
  005d2	48 8d 94 24 b4
	00 00 00	 lea	 rdx, QWORD PTR hbuf$[rsp]
  005da	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  005df	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  005e2	e8 00 00 00 00	 call	 crc32
  005e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  005ec	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  005ef	33 c0		 xor	 eax, eax
  005f1	85 c0		 test	 eax, eax
  005f3	75 ab		 jne	 SHORT $LN40@inflate
$LN352@inflate:
$LN43@inflate:

; 723  :             INITBITS();

  005f5	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  005fd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00605	33 c0		 xor	 eax, eax
  00607	85 c0		 test	 eax, eax
  00609	75 ea		 jne	 SHORT $LN43@inflate

; 724  :             state->mode = TIME;

  0060b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00610	c7 40 08 36 3f
	00 00		 mov	 DWORD PTR [rax+8], 16182 ; 00003f36H
$LN353@inflate:
$LN46@inflate:
$LN47@inflate:

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  00617	83 7c 24 54 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  0061c	73 50		 jae	 SHORT $LN48@inflate
$LN51@inflate:
  0061e	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  00623	75 05		 jne	 SHORT $LN354@inflate
  00625	e9 0d 26 00 00	 jmp	 $inf_leave$561
$LN354@inflate:
  0062a	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  0062e	ff c8		 dec	 eax
  00630	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  00634	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  00639	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0063c	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  00640	d3 e0		 shl	 eax, cl
  00642	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  00646	03 c8		 add	 ecx, eax
  00648	8b c1		 mov	 eax, ecx
  0064a	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  0064e	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  00653	48 ff c0	 inc	 rax
  00656	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  0065b	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  0065f	83 c0 08	 add	 eax, 8
  00662	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  00666	33 c0		 xor	 eax, eax
  00668	85 c0		 test	 eax, eax
  0066a	75 b2		 jne	 SHORT $LN51@inflate
  0066c	eb a9		 jmp	 SHORT $LN47@inflate
$LN48@inflate:
  0066e	33 c0		 xor	 eax, eax
  00670	85 c0		 test	 eax, eax
  00672	75 a3		 jne	 SHORT $LN46@inflate

; 727  :             if (state->head != Z_NULL)

  00674	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00679	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0067e	74 13		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  00680	0f ae e8	 lfence
  00683	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00688	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0068c	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  00690	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00693	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00698	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0069b	25 00 02 00 00	 and	 eax, 512		; 00000200H
  006a0	85 c0		 test	 eax, eax
  006a2	0f 84 9d 00 00
	00		 je	 $LN356@inflate
  006a8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  006ad	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  006b0	83 e0 04	 and	 eax, 4
  006b3	85 c0		 test	 eax, eax
  006b5	0f 84 8a 00 00
	00		 je	 $LN356@inflate
$LN54@inflate:

; 730  :                 CRC4(state->check, hold);

  006bb	0f ae e8	 lfence
  006be	b8 01 00 00 00	 mov	 eax, 1
  006c3	48 6b c0 00	 imul	 rax, rax, 0
  006c7	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR hold$[rsp]
  006cc	88 8c 04 b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rax], cl
  006d3	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  006d7	c1 e8 08	 shr	 eax, 8
  006da	b9 01 00 00 00	 mov	 ecx, 1
  006df	48 6b c9 01	 imul	 rcx, rcx, 1
  006e3	88 84 0c b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rcx], al
  006ea	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  006ee	c1 e8 10	 shr	 eax, 16
  006f1	b9 01 00 00 00	 mov	 ecx, 1
  006f6	48 6b c9 02	 imul	 rcx, rcx, 2
  006fa	88 84 0c b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rcx], al
  00701	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  00705	c1 e8 18	 shr	 eax, 24
  00708	b9 01 00 00 00	 mov	 ecx, 1
  0070d	48 6b c9 03	 imul	 rcx, rcx, 3
  00711	88 84 0c b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rcx], al
  00718	41 b8 04 00 00
	00		 mov	 r8d, 4
  0071e	48 8d 94 24 b4
	00 00 00	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00726	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0072b	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  0072e	e8 00 00 00 00	 call	 crc32
  00733	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00738	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  0073b	33 c0		 xor	 eax, eax
  0073d	85 c0		 test	 eax, eax
  0073f	0f 85 76 ff ff
	ff		 jne	 $LN54@inflate
$LN356@inflate:
$LN57@inflate:

; 731  :             INITBITS();

  00745	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  0074d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00755	33 c0		 xor	 eax, eax
  00757	85 c0		 test	 eax, eax
  00759	75 ea		 jne	 SHORT $LN57@inflate

; 732  :             state->mode = OS;

  0075b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00760	c7 40 08 37 3f
	00 00		 mov	 DWORD PTR [rax+8], 16183 ; 00003f37H
$LN357@inflate:
$LN60@inflate:
$LN61@inflate:

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  00767	83 7c 24 54 10	 cmp	 DWORD PTR bits$[rsp], 16
  0076c	73 50		 jae	 SHORT $LN62@inflate
$LN65@inflate:
  0076e	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  00773	75 05		 jne	 SHORT $LN358@inflate
  00775	e9 bd 24 00 00	 jmp	 $inf_leave$561
$LN358@inflate:
  0077a	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  0077e	ff c8		 dec	 eax
  00780	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  00784	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  00789	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0078c	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  00790	d3 e0		 shl	 eax, cl
  00792	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  00796	03 c8		 add	 ecx, eax
  00798	8b c1		 mov	 eax, ecx
  0079a	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  0079e	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  007a3	48 ff c0	 inc	 rax
  007a6	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  007ab	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  007af	83 c0 08	 add	 eax, 8
  007b2	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  007b6	33 c0		 xor	 eax, eax
  007b8	85 c0		 test	 eax, eax
  007ba	75 b2		 jne	 SHORT $LN65@inflate
  007bc	eb a9		 jmp	 SHORT $LN61@inflate
$LN62@inflate:
  007be	33 c0		 xor	 eax, eax
  007c0	85 c0		 test	 eax, eax
  007c2	75 a3		 jne	 SHORT $LN60@inflate

; 735  :             if (state->head != Z_NULL) {

  007c4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  007c9	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  007ce	74 2b		 je	 SHORT $LN359@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  007d0	0f ae e8	 lfence
  007d3	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  007d7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  007e1	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  007e5	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 737  :                 state->head->os = (int)(hold >> 8);

  007e8	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  007ec	c1 e8 08	 shr	 eax, 8
  007ef	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  007f4	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  007f8	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
$LN359@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  007fb	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00800	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00803	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00808	85 c0		 test	 eax, eax
  0080a	74 67		 je	 SHORT $LN360@inflate
  0080c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00811	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00814	83 e0 04	 and	 eax, 4
  00817	85 c0		 test	 eax, eax
  00819	74 58		 je	 SHORT $LN360@inflate
$LN68@inflate:

; 740  :                 CRC2(state->check, hold);

  0081b	0f ae e8	 lfence
  0081e	b8 01 00 00 00	 mov	 eax, 1
  00823	48 6b c0 00	 imul	 rax, rax, 0
  00827	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR hold$[rsp]
  0082c	88 8c 04 b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rax], cl
  00833	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  00837	c1 e8 08	 shr	 eax, 8
  0083a	b9 01 00 00 00	 mov	 ecx, 1
  0083f	48 6b c9 01	 imul	 rcx, rcx, 1
  00843	88 84 0c b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rcx], al
  0084a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00850	48 8d 94 24 b4
	00 00 00	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00858	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0085d	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00860	e8 00 00 00 00	 call	 crc32
  00865	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0086a	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  0086d	33 c0		 xor	 eax, eax
  0086f	85 c0		 test	 eax, eax
  00871	75 a8		 jne	 SHORT $LN68@inflate
$LN360@inflate:
$LN71@inflate:

; 741  :             INITBITS();

  00873	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  0087b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00883	33 c0		 xor	 eax, eax
  00885	85 c0		 test	 eax, eax
  00887	75 ea		 jne	 SHORT $LN71@inflate

; 742  :             state->mode = EXLEN;

  00889	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0088e	c7 40 08 38 3f
	00 00		 mov	 DWORD PTR [rax+8], 16184 ; 00003f38H
$LN361@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  00895	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0089a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0089d	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  008a2	85 c0		 test	 eax, eax
  008a4	0f 84 18 01 00
	00		 je	 $LN362@inflate
$LN74@inflate:
$LN75@inflate:

; 745  :                 NEEDBITS(16);

  008aa	83 7c 24 54 10	 cmp	 DWORD PTR bits$[rsp], 16
  008af	73 50		 jae	 SHORT $LN76@inflate
$LN79@inflate:
  008b1	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  008b6	75 05		 jne	 SHORT $LN364@inflate
  008b8	e9 7a 23 00 00	 jmp	 $inf_leave$561
$LN364@inflate:
  008bd	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  008c1	ff c8		 dec	 eax
  008c3	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  008c7	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  008cc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  008cf	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  008d3	d3 e0		 shl	 eax, cl
  008d5	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  008d9	03 c8		 add	 ecx, eax
  008db	8b c1		 mov	 eax, ecx
  008dd	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  008e1	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  008e6	48 ff c0	 inc	 rax
  008e9	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  008ee	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  008f2	83 c0 08	 add	 eax, 8
  008f5	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  008f9	33 c0		 xor	 eax, eax
  008fb	85 c0		 test	 eax, eax
  008fd	75 b2		 jne	 SHORT $LN79@inflate
  008ff	eb a9		 jmp	 SHORT $LN75@inflate
$LN76@inflate:
  00901	33 c0		 xor	 eax, eax
  00903	85 c0		 test	 eax, eax
  00905	75 a3		 jne	 SHORT $LN74@inflate

; 746  :                 state->length = (unsigned)(hold);

  00907	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0090c	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  00910	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 747  :                 if (state->head != Z_NULL)

  00913	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00918	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0091d	74 13		 je	 SHORT $LN365@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  0091f	0f ae e8	 lfence
  00922	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00927	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0092b	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  0092f	89 48 18	 mov	 DWORD PTR [rax+24], ecx
$LN365@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00932	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00937	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0093a	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0093f	85 c0		 test	 eax, eax
  00941	74 67		 je	 SHORT $LN366@inflate
  00943	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00948	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0094b	83 e0 04	 and	 eax, 4
  0094e	85 c0		 test	 eax, eax
  00950	74 58		 je	 SHORT $LN366@inflate
$LN82@inflate:

; 750  :                     CRC2(state->check, hold);

  00952	0f ae e8	 lfence
  00955	b8 01 00 00 00	 mov	 eax, 1
  0095a	48 6b c0 00	 imul	 rax, rax, 0
  0095e	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR hold$[rsp]
  00963	88 8c 04 b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rax], cl
  0096a	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  0096e	c1 e8 08	 shr	 eax, 8
  00971	b9 01 00 00 00	 mov	 ecx, 1
  00976	48 6b c9 01	 imul	 rcx, rcx, 1
  0097a	88 84 0c b4 00
	00 00		 mov	 BYTE PTR hbuf$[rsp+rcx], al
  00981	41 b8 02 00 00
	00		 mov	 r8d, 2
  00987	48 8d 94 24 b4
	00 00 00	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0098f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00994	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00997	e8 00 00 00 00	 call	 crc32
  0099c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  009a1	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  009a4	33 c0		 xor	 eax, eax
  009a6	85 c0		 test	 eax, eax
  009a8	75 a8		 jne	 SHORT $LN82@inflate
$LN366@inflate:
$LN85@inflate:

; 751  :                 INITBITS();

  009aa	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  009b2	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  009ba	33 c0		 xor	 eax, eax
  009bc	85 c0		 test	 eax, eax
  009be	75 ea		 jne	 SHORT $LN85@inflate

; 752  :             }

  009c0	eb 1d		 jmp	 SHORT $LN363@inflate
$LN362@inflate:

; 753  :             else if (state->head != Z_NULL)

  009c2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  009c7	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  009cc	74 11		 je	 SHORT $LN367@inflate

; 754  :                 state->head->extra = Z_NULL;

  009ce	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  009d3	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  009d7	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN367@inflate:
$LN363@inflate:

; 755  :             state->mode = EXTRA;

  009df	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  009e4	c7 40 08 39 3f
	00 00		 mov	 DWORD PTR [rax+8], 16185 ; 00003f39H
$LN368@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  009eb	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  009f0	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  009f3	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  009f8	85 c0		 test	 eax, eax
  009fa	0f 84 68 01 00
	00		 je	 $LN369@inflate

; 758  :                 copy = state->length;

  00a00	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00a05	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00a08	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 759  :                 if (copy > have) copy = have;

  00a0c	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  00a10	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  00a14	76 08		 jbe	 SHORT $LN370@inflate
  00a16	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  00a1a	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN370@inflate:

; 760  :                 if (copy) {

  00a1e	83 7c 24 60 00	 cmp	 DWORD PTR copy$[rsp], 0
  00a23	0f 84 2f 01 00
	00		 je	 $LN371@inflate

; 761  :                     if (state->head != Z_NULL &&

  00a29	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00a2e	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00a33	0f 84 a6 00 00
	00		 je	 $LN372@inflate
  00a39	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00a3e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00a42	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00a47	0f 84 92 00 00
	00		 je	 $LN372@inflate

; 762  :                         state->head->extra != Z_NULL) {
; 763  :                         len = state->head->extra_len - state->length;

  00a4d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00a52	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00a56	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00a5b	8b 49 50	 mov	 ecx, DWORD PTR [rcx+80]
  00a5e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00a61	2b c1		 sub	 eax, ecx
  00a63	89 84 24 a4 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 764  :                         zmemcpy(state->head->extra + len, next,

  00a6a	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00a6e	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00a75	03 c8		 add	 ecx, eax
  00a77	8b c1		 mov	 eax, ecx
  00a79	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00a7e	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00a82	3b 41 1c	 cmp	 eax, DWORD PTR [rcx+28]
  00a85	76 21		 jbe	 SHORT $LN511@inflate
  00a87	0f ae e8	 lfence
  00a8a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00a8f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00a93	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00a9a	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00a9d	2b c1		 sub	 eax, ecx
  00a9f	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv400[rsp], eax
  00aa6	eb 0b		 jmp	 SHORT $LN512@inflate
$LN511@inflate:
  00aa8	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00aac	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv400[rsp], eax
$LN512@inflate:
  00ab3	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv400[rsp]
  00aba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00abf	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00ac3	8b 94 24 a4 00
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00aca	48 03 51 10	 add	 rdx, QWORD PTR [rcx+16]
  00ace	48 8b ca	 mov	 rcx, rdx
  00ad1	44 8b c0	 mov	 r8d, eax
  00ad4	48 8b 54 24 38	 mov	 rdx, QWORD PTR next$[rsp]
  00ad9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy
$LN372@inflate:

; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);
; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00adf	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00ae4	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00ae7	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00aec	85 c0		 test	 eax, eax
  00aee	74 2e		 je	 SHORT $LN373@inflate
  00af0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00af5	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00af8	83 e0 04	 and	 eax, 4
  00afb	85 c0		 test	 eax, eax
  00afd	74 1f		 je	 SHORT $LN373@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  00aff	44 8b 44 24 60	 mov	 r8d, DWORD PTR copy$[rsp]
  00b04	48 8b 54 24 38	 mov	 rdx, QWORD PTR next$[rsp]
  00b09	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00b0e	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00b11	e8 00 00 00 00	 call	 crc32
  00b16	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00b1b	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN373@inflate:

; 770  :                     have -= copy;

  00b1e	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00b22	8b 4c 24 48	 mov	 ecx, DWORD PTR have$[rsp]
  00b26	2b c8		 sub	 ecx, eax
  00b28	8b c1		 mov	 eax, ecx
  00b2a	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax

; 771  :                     next += copy;

  00b2e	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00b32	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  00b37	48 03 c8	 add	 rcx, rax
  00b3a	48 8b c1	 mov	 rax, rcx
  00b3d	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 772  :                     state->length -= copy;

  00b42	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00b47	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  00b4b	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00b4e	2b c1		 sub	 eax, ecx
  00b50	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00b55	89 41 50	 mov	 DWORD PTR [rcx+80], eax
$LN371@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  00b58	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00b5d	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  00b61	74 05		 je	 SHORT $LN374@inflate
  00b63	e9 cf 20 00 00	 jmp	 $inf_leave$561
$LN374@inflate:
$LN369@inflate:

; 775  :             }
; 776  :             state->length = 0;

  00b68	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00b6d	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [rax+80], 0

; 777  :             state->mode = NAME;

  00b74	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00b79	c7 40 08 3a 3f
	00 00		 mov	 DWORD PTR [rax+8], 16186 ; 00003f3aH
$LN375@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  00b80	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00b85	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00b88	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00b8d	85 c0		 test	 eax, eax
  00b8f	0f 84 22 01 00
	00		 je	 $LN376@inflate

; 780  :                 if (have == 0) goto inf_leave;

  00b95	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  00b9a	75 05		 jne	 SHORT $LN378@inflate
  00b9c	e9 96 20 00 00	 jmp	 $inf_leave$561
$LN378@inflate:

; 781  :                 copy = 0;

  00ba1	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR copy$[rsp], 0
$LN88@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  00ba9	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00bad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  00bb2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00bb6	89 84 24 a4 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
  00bbd	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00bc1	ff c0		 inc	 eax
  00bc3	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&

  00bc7	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00bcc	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00bd1	74 58		 je	 SHORT $LN379@inflate
  00bd3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00bd8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00bdc	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00be1	74 48		 je	 SHORT $LN379@inflate
  00be3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00be8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00bec	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00bf1	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00bf4	39 41 50	 cmp	 DWORD PTR [rcx+80], eax
  00bf7	73 32		 jae	 SHORT $LN379@inflate

; 786  :                             state->length < state->head->name_max)
; 787  :                         state->head->name[state->length++] = (Bytef)len;

  00bf9	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00bfe	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00c02	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00c07	8b 49 50	 mov	 ecx, DWORD PTR [rcx+80]
  00c0a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00c0e	0f b6 94 24 a4
	00 00 00	 movzx	 edx, BYTE PTR len$[rsp]
  00c16	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00c19	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00c1e	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00c21	ff c0		 inc	 eax
  00c23	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00c28	89 41 50	 mov	 DWORD PTR [rcx+80], eax
$LN379@inflate:

; 788  :                 } while (len && copy < have);

  00c2b	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00c33	74 0e		 je	 SHORT $LN380@inflate
  00c35	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  00c39	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  00c3d	0f 82 66 ff ff
	ff		 jb	 $LN88@inflate
$LN380@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00c43	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00c48	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00c4b	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00c50	85 c0		 test	 eax, eax
  00c52	74 2e		 je	 SHORT $LN381@inflate
  00c54	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00c59	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00c5c	83 e0 04	 and	 eax, 4
  00c5f	85 c0		 test	 eax, eax
  00c61	74 1f		 je	 SHORT $LN381@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  00c63	44 8b 44 24 60	 mov	 r8d, DWORD PTR copy$[rsp]
  00c68	48 8b 54 24 38	 mov	 rdx, QWORD PTR next$[rsp]
  00c6d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00c72	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00c75	e8 00 00 00 00	 call	 crc32
  00c7a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00c7f	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN381@inflate:

; 791  :                 have -= copy;

  00c82	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00c86	8b 4c 24 48	 mov	 ecx, DWORD PTR have$[rsp]
  00c8a	2b c8		 sub	 ecx, eax
  00c8c	8b c1		 mov	 eax, ecx
  00c8e	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax

; 792  :                 next += copy;

  00c92	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00c96	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  00c9b	48 03 c8	 add	 rcx, rax
  00c9e	48 8b c1	 mov	 rax, rcx
  00ca1	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 793  :                 if (len) goto inf_leave;

  00ca6	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00cae	74 05		 je	 SHORT $LN382@inflate
  00cb0	e9 82 1f 00 00	 jmp	 $inf_leave$561
$LN382@inflate:

; 794  :             }

  00cb5	eb 1d		 jmp	 SHORT $LN377@inflate
$LN376@inflate:

; 795  :             else if (state->head != Z_NULL)

  00cb7	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00cbc	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00cc1	74 11		 je	 SHORT $LN383@inflate

; 796  :                 state->head->name = Z_NULL;

  00cc3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00cc8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00ccc	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN383@inflate:
$LN377@inflate:

; 797  :             state->length = 0;

  00cd4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00cd9	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [rax+80], 0

; 798  :             state->mode = COMMENT;

  00ce0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00ce5	c7 40 08 3b 3f
	00 00		 mov	 DWORD PTR [rax+8], 16187 ; 00003f3bH
$LN384@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  00cec	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00cf1	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00cf4	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00cf9	85 c0		 test	 eax, eax
  00cfb	0f 84 22 01 00
	00		 je	 $LN385@inflate

; 801  :                 if (have == 0) goto inf_leave;

  00d01	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  00d06	75 05		 jne	 SHORT $LN387@inflate
  00d08	e9 2a 1f 00 00	 jmp	 $inf_leave$561
$LN387@inflate:

; 802  :                 copy = 0;

  00d0d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR copy$[rsp], 0
$LN91@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  00d15	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00d19	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  00d1e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d22	89 84 24 a4 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
  00d29	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00d2d	ff c0		 inc	 eax
  00d2f	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&

  00d33	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00d38	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00d3d	74 58		 je	 SHORT $LN388@inflate
  00d3f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00d44	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00d48	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00d4d	74 48		 je	 SHORT $LN388@inflate
  00d4f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00d54	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00d58	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00d5d	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00d60	39 41 50	 cmp	 DWORD PTR [rcx+80], eax
  00d63	73 32		 jae	 SHORT $LN388@inflate

; 807  :                             state->length < state->head->comm_max)
; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  00d65	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00d6a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00d6e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00d73	8b 49 50	 mov	 ecx, DWORD PTR [rcx+80]
  00d76	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00d7a	0f b6 94 24 a4
	00 00 00	 movzx	 edx, BYTE PTR len$[rsp]
  00d82	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00d85	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00d8a	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00d8d	ff c0		 inc	 eax
  00d8f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00d94	89 41 50	 mov	 DWORD PTR [rcx+80], eax
$LN388@inflate:

; 809  :                 } while (len && copy < have);

  00d97	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00d9f	74 0e		 je	 SHORT $LN389@inflate
  00da1	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  00da5	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  00da9	0f 82 66 ff ff
	ff		 jb	 $LN91@inflate
$LN389@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00daf	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00db4	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00db7	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00dbc	85 c0		 test	 eax, eax
  00dbe	74 2e		 je	 SHORT $LN390@inflate
  00dc0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00dc5	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00dc8	83 e0 04	 and	 eax, 4
  00dcb	85 c0		 test	 eax, eax
  00dcd	74 1f		 je	 SHORT $LN390@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  00dcf	44 8b 44 24 60	 mov	 r8d, DWORD PTR copy$[rsp]
  00dd4	48 8b 54 24 38	 mov	 rdx, QWORD PTR next$[rsp]
  00dd9	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00dde	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00de1	e8 00 00 00 00	 call	 crc32
  00de6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00deb	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN390@inflate:

; 812  :                 have -= copy;

  00dee	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00df2	8b 4c 24 48	 mov	 ecx, DWORD PTR have$[rsp]
  00df6	2b c8		 sub	 ecx, eax
  00df8	8b c1		 mov	 eax, ecx
  00dfa	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax

; 813  :                 next += copy;

  00dfe	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00e02	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  00e07	48 03 c8	 add	 rcx, rax
  00e0a	48 8b c1	 mov	 rax, rcx
  00e0d	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 814  :                 if (len) goto inf_leave;

  00e12	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00e1a	74 05		 je	 SHORT $LN391@inflate
  00e1c	e9 16 1e 00 00	 jmp	 $inf_leave$561
$LN391@inflate:

; 815  :             }

  00e21	eb 1d		 jmp	 SHORT $LN386@inflate
$LN385@inflate:

; 816  :             else if (state->head != Z_NULL)

  00e23	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00e28	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00e2d	74 11		 je	 SHORT $LN392@inflate

; 817  :                 state->head->comment = Z_NULL;

  00e2f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00e34	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00e38	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0
$LN392@inflate:
$LN386@inflate:

; 818  :             state->mode = HCRC;

  00e40	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00e45	c7 40 08 3c 3f
	00 00		 mov	 DWORD PTR [rax+8], 16188 ; 00003f3cH
$LN393@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  00e4c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00e51	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00e54	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00e59	85 c0		 test	 eax, eax
  00e5b	0f 84 b9 00 00
	00		 je	 $LN394@inflate
$LN94@inflate:
$LN95@inflate:

; 821  :                 NEEDBITS(16);

  00e61	83 7c 24 54 10	 cmp	 DWORD PTR bits$[rsp], 16
  00e66	73 50		 jae	 SHORT $LN96@inflate
$LN99@inflate:
  00e68	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  00e6d	75 05		 jne	 SHORT $LN395@inflate
  00e6f	e9 c3 1d 00 00	 jmp	 $inf_leave$561
$LN395@inflate:
  00e74	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  00e78	ff c8		 dec	 eax
  00e7a	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  00e7e	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  00e83	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e86	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  00e8a	d3 e0		 shl	 eax, cl
  00e8c	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  00e90	03 c8		 add	 ecx, eax
  00e92	8b c1		 mov	 eax, ecx
  00e94	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  00e98	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  00e9d	48 ff c0	 inc	 rax
  00ea0	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  00ea5	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  00ea9	83 c0 08	 add	 eax, 8
  00eac	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  00eb0	33 c0		 xor	 eax, eax
  00eb2	85 c0		 test	 eax, eax
  00eb4	75 b2		 jne	 SHORT $LN99@inflate
  00eb6	eb a9		 jmp	 SHORT $LN95@inflate
$LN96@inflate:
  00eb8	33 c0		 xor	 eax, eax
  00eba	85 c0		 test	 eax, eax
  00ebc	75 a3		 jne	 SHORT $LN94@inflate

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  00ebe	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00ec3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00ec6	83 e0 04	 and	 eax, 4
  00ec9	85 c0		 test	 eax, eax
  00ecb	74 37		 je	 SHORT $LN396@inflate
  00ecd	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00ed2	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00ed5	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00eda	39 44 24 50	 cmp	 DWORD PTR hold$[rsp], eax
  00ede	74 24		 je	 SHORT $LN396@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  00ee0	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00ee8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
  00eef	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 824  :                     state->mode = BAD;

  00ef3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00ef8	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 825  :                     break;

  00eff	e9 2e 1d 00 00	 jmp	 $LN8@inflate
$LN396@inflate:
$LN102@inflate:

; 826  :                 }
; 827  :                 INITBITS();

  00f04	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00f0c	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00f14	33 c0		 xor	 eax, eax
  00f16	85 c0		 test	 eax, eax
  00f18	75 ea		 jne	 SHORT $LN102@inflate
$LN394@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  00f1a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00f1f	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00f24	74 2a		 je	 SHORT $LN397@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00f26	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00f2b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00f2e	c1 f8 09	 sar	 eax, 9
  00f31	83 e0 01	 and	 eax, 1
  00f34	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00f39	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00f3d	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 831  :                 state->head->done = 1;

  00f40	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00f45	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00f49	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN397@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00f50	45 33 c0	 xor	 r8d, r8d
  00f53	33 d2		 xor	 edx, edx
  00f55	33 c9		 xor	 ecx, ecx
  00f57	e8 00 00 00 00	 call	 crc32
  00f5c	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv564[rsp], eax
  00f63	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00f68	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv564[rsp]
  00f6f	89 48 20	 mov	 DWORD PTR [rax+32], ecx
  00f72	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00f7a	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv564[rsp]
  00f81	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 834  :             state->mode = TYPE;

  00f84	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00f89	c7 40 08 3f 3f
	00 00		 mov	 DWORD PTR [rax+8], 16191 ; 00003f3fH

; 835  :             break;

  00f90	e9 9d 1c 00 00	 jmp	 $LN8@inflate
$LN398@inflate:
$LN105@inflate:
$LN106@inflate:

; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  00f95	83 7c 24 54 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  00f9a	73 50		 jae	 SHORT $LN107@inflate
$LN110@inflate:
  00f9c	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  00fa1	75 05		 jne	 SHORT $LN399@inflate
  00fa3	e9 8f 1c 00 00	 jmp	 $inf_leave$561
$LN399@inflate:
  00fa8	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  00fac	ff c8		 dec	 eax
  00fae	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  00fb2	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  00fb7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00fba	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  00fbe	d3 e0		 shl	 eax, cl
  00fc0	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  00fc4	03 c8		 add	 ecx, eax
  00fc6	8b c1		 mov	 eax, ecx
  00fc8	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  00fcc	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  00fd1	48 ff c0	 inc	 rax
  00fd4	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  00fd9	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  00fdd	83 c0 08	 add	 eax, 8
  00fe0	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  00fe4	33 c0		 xor	 eax, eax
  00fe6	85 c0		 test	 eax, eax
  00fe8	75 b2		 jne	 SHORT $LN110@inflate
  00fea	eb a9		 jmp	 SHORT $LN106@inflate
$LN107@inflate:
  00fec	33 c0		 xor	 eax, eax
  00fee	85 c0		 test	 eax, eax
  00ff0	75 a3		 jne	 SHORT $LN105@inflate

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  00ff2	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  00ff6	c1 e8 18	 shr	 eax, 24
  00ff9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ffe	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01002	c1 e9 08	 shr	 ecx, 8
  01005	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  0100b	03 c1		 add	 eax, ecx
  0100d	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01011	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  01017	c1 e1 08	 shl	 ecx, 8
  0101a	03 c1		 add	 eax, ecx
  0101c	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01020	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01026	c1 e1 18	 shl	 ecx, 24
  01029	03 c1		 add	 eax, ecx
  0102b	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv591[rsp], eax
  01032	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01037	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv591[rsp]
  0103e	89 48 20	 mov	 DWORD PTR [rax+32], ecx
  01041	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01049	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv591[rsp]
  01050	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
$LN113@inflate:

; 840  :             INITBITS();

  01053	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  0105b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  01063	33 c0		 xor	 eax, eax
  01065	85 c0		 test	 eax, eax
  01067	75 ea		 jne	 SHORT $LN113@inflate

; 841  :             state->mode = DICT;

  01069	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0106e	c7 40 08 3e 3f
	00 00		 mov	 DWORD PTR [rax+8], 16190 ; 00003f3eH
$LN400@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  01075	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0107a	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0107e	75 67		 jne	 SHORT $LN401@inflate
$LN116@inflate:

; 844  :                 RESTORE();

  01080	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01088	48 8b 4c 24 40	 mov	 rcx, QWORD PTR put$[rsp]
  0108d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  01091	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01099	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  0109d	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  010a0	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  010a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  010ad	48 89 08	 mov	 QWORD PTR [rax], rcx
  010b0	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  010b8	8b 4c 24 48	 mov	 ecx, DWORD PTR have$[rsp]
  010bc	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  010bf	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  010c4	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  010c8	89 48 48	 mov	 DWORD PTR [rax+72], ecx
  010cb	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  010d0	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  010d4	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
  010d7	33 c0		 xor	 eax, eax
  010d9	85 c0		 test	 eax, eax
  010db	75 a3		 jne	 SHORT $LN116@inflate

; 845  :                 return Z_NEED_DICT;

  010dd	b8 02 00 00 00	 mov	 eax, 2
  010e2	e9 37 1e 00 00	 jmp	 $LN1@inflate
$LN401@inflate:

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  010e7	45 33 c0	 xor	 r8d, r8d
  010ea	33 d2		 xor	 edx, edx
  010ec	33 c9		 xor	 ecx, ecx
  010ee	e8 00 00 00 00	 call	 adler32
  010f3	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv605[rsp], eax
  010fa	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  010ff	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv605[rsp]
  01106	89 48 20	 mov	 DWORD PTR [rax+32], ecx
  01109	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01111	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv605[rsp]
  01118	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 848  :             state->mode = TYPE;

  0111b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01120	c7 40 08 3f 3f
	00 00		 mov	 DWORD PTR [rax+8], 16191 ; 00003f3fH
$LN402@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  01127	83 bc 24 58 01
	00 00 05	 cmp	 DWORD PTR flush$[rsp], 5
  0112f	74 0a		 je	 SHORT $LN404@inflate
  01131	83 bc 24 58 01
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  01139	75 05		 jne	 SHORT $LN403@inflate
$LN404@inflate:
  0113b	e9 f7 1a 00 00	 jmp	 $inf_leave$561
$LN403@inflate:
$LN405@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  01140	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01145	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  01149	74 3e		 je	 SHORT $LN406@inflate
$LN119@inflate:

; 853  :                 BYTEBITS();

  0114b	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  0114f	83 e0 07	 and	 eax, 7
  01152	0f b6 c8	 movzx	 ecx, al
  01155	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01159	d3 e8		 shr	 eax, cl
  0115b	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  0115f	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01163	83 e0 07	 and	 eax, 7
  01166	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  0116a	2b c8		 sub	 ecx, eax
  0116c	8b c1		 mov	 eax, ecx
  0116e	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01172	33 c0		 xor	 eax, eax
  01174	85 c0		 test	 eax, eax
  01176	75 d3		 jne	 SHORT $LN119@inflate

; 854  :                 state->mode = CHECK;

  01178	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0117d	c7 40 08 4e 3f
	00 00		 mov	 DWORD PTR [rax+8], 16206 ; 00003f4eH

; 855  :                 break;

  01184	e9 a9 1a 00 00	 jmp	 $LN8@inflate
$LN406@inflate:
$LN122@inflate:
$LN123@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  01189	83 7c 24 54 03	 cmp	 DWORD PTR bits$[rsp], 3
  0118e	73 50		 jae	 SHORT $LN124@inflate
$LN127@inflate:
  01190	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  01195	75 05		 jne	 SHORT $LN407@inflate
  01197	e9 9b 1a 00 00	 jmp	 $inf_leave$561
$LN407@inflate:
  0119c	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  011a0	ff c8		 dec	 eax
  011a2	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  011a6	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  011ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  011ae	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  011b2	d3 e0		 shl	 eax, cl
  011b4	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  011b8	03 c8		 add	 ecx, eax
  011ba	8b c1		 mov	 eax, ecx
  011bc	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  011c0	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  011c5	48 ff c0	 inc	 rax
  011c8	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  011cd	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  011d1	83 c0 08	 add	 eax, 8
  011d4	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  011d8	33 c0		 xor	 eax, eax
  011da	85 c0		 test	 eax, eax
  011dc	75 b2		 jne	 SHORT $LN127@inflate
  011de	eb a9		 jmp	 SHORT $LN123@inflate
$LN124@inflate:
  011e0	33 c0		 xor	 eax, eax
  011e2	85 c0		 test	 eax, eax
  011e4	75 a3		 jne	 SHORT $LN122@inflate

; 858  :             state->last = BITS(1);

  011e6	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  011ea	83 e0 01	 and	 eax, 1
  011ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  011f2	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
$LN130@inflate:

; 859  :             DROPBITS(1);

  011f5	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  011f9	d1 e8		 shr	 eax, 1
  011fb	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  011ff	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01203	ff c8		 dec	 eax
  01205	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01209	33 c0		 xor	 eax, eax
  0120b	85 c0		 test	 eax, eax
  0120d	75 e6		 jne	 SHORT $LN130@inflate

; 860  :             switch (BITS(2)) {

  0120f	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01213	83 e0 03	 and	 eax, 3
  01216	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv636[rsp], eax
  0121d	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR tv636[rsp], 0
  01225	74 23		 je	 SHORT $LN408@inflate
  01227	83 bc 24 e4 00
	00 00 01	 cmp	 DWORD PTR tv636[rsp], 1
  0122f	74 27		 je	 SHORT $LN409@inflate
  01231	83 bc 24 e4 00
	00 00 02	 cmp	 DWORD PTR tv636[rsp], 2
  01239	74 63		 je	 SHORT $LN411@inflate
  0123b	83 bc 24 e4 00
	00 00 03	 cmp	 DWORD PTR tv636[rsp], 3
  01243	74 67		 je	 SHORT $LN412@inflate
  01245	e9 81 00 00 00	 jmp	 $LN131@inflate
$LN408@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;

  0124a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0124f	c7 40 08 41 3f
	00 00		 mov	 DWORD PTR [rax+8], 16193 ; 00003f41H

; 865  :                 break;

  01256	eb 73		 jmp	 SHORT $LN131@inflate
$LN409@inflate:

; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  01258	0f ae e8	 lfence
  0125b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01260	e8 00 00 00 00	 call	 fixedtables

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */

  01265	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0126a	c7 40 08 47 3f
	00 00		 mov	 DWORD PTR [rax+8], 16199 ; 00003f47H

; 871  :                 if (flush == Z_TREES) {

  01271	83 bc 24 58 01
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  01279	75 21		 jne	 SHORT $LN410@inflate
$LN135@inflate:

; 872  :                     DROPBITS(2);

  0127b	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  0127f	c1 e8 02	 shr	 eax, 2
  01282	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01286	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  0128a	83 e8 02	 sub	 eax, 2
  0128d	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01291	33 c0		 xor	 eax, eax
  01293	85 c0		 test	 eax, eax
  01295	75 e4		 jne	 SHORT $LN135@inflate

; 873  :                     goto inf_leave;

  01297	e9 9b 19 00 00	 jmp	 $inf_leave$561
$LN410@inflate:

; 874  :                 }
; 875  :                 break;

  0129c	eb 2d		 jmp	 SHORT $LN131@inflate
$LN411@inflate:

; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;

  0129e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  012a3	c7 40 08 44 3f
	00 00		 mov	 DWORD PTR [rax+8], 16196 ; 00003f44H

; 880  :                 break;

  012aa	eb 1f		 jmp	 SHORT $LN131@inflate
$LN412@inflate:

; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  012ac	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  012b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@
  012bb	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 883  :                 state->mode = BAD;

  012bf	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  012c4	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H
$LN131@inflate:
$LN138@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  012cb	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  012cf	c1 e8 02	 shr	 eax, 2
  012d2	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  012d6	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  012da	83 e8 02	 sub	 eax, 2
  012dd	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  012e1	33 c0		 xor	 eax, eax
  012e3	85 c0		 test	 eax, eax
  012e5	75 e4		 jne	 SHORT $LN138@inflate

; 886  :             break;

  012e7	e9 46 19 00 00	 jmp	 $LN8@inflate
$LN413@inflate:
$LN141@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  012ec	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  012f0	83 e0 07	 and	 eax, 7
  012f3	0f b6 c8	 movzx	 ecx, al
  012f6	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  012fa	d3 e8		 shr	 eax, cl
  012fc	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01300	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01304	83 e0 07	 and	 eax, 7
  01307	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  0130b	2b c8		 sub	 ecx, eax
  0130d	8b c1		 mov	 eax, ecx
  0130f	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01313	33 c0		 xor	 eax, eax
  01315	85 c0		 test	 eax, eax
  01317	75 d3		 jne	 SHORT $LN141@inflate
$LN144@inflate:
$LN145@inflate:

; 889  :             NEEDBITS(32);

  01319	83 7c 24 54 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  0131e	73 50		 jae	 SHORT $LN146@inflate
$LN149@inflate:
  01320	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  01325	75 05		 jne	 SHORT $LN414@inflate
  01327	e9 0b 19 00 00	 jmp	 $inf_leave$561
$LN414@inflate:
  0132c	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  01330	ff c8		 dec	 eax
  01332	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  01336	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  0133b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0133e	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  01342	d3 e0		 shl	 eax, cl
  01344	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01348	03 c8		 add	 ecx, eax
  0134a	8b c1		 mov	 eax, ecx
  0134c	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01350	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  01355	48 ff c0	 inc	 rax
  01358	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  0135d	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01361	83 c0 08	 add	 eax, 8
  01364	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01368	33 c0		 xor	 eax, eax
  0136a	85 c0		 test	 eax, eax
  0136c	75 b2		 jne	 SHORT $LN149@inflate
  0136e	eb a9		 jmp	 SHORT $LN145@inflate
$LN146@inflate:
  01370	33 c0		 xor	 eax, eax
  01372	85 c0		 test	 eax, eax
  01374	75 a3		 jne	 SHORT $LN144@inflate

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  01376	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  0137a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0137f	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01383	c1 e9 10	 shr	 ecx, 16
  01386	81 f1 ff ff 00
	00		 xor	 ecx, 65535		; 0000ffffH
  0138c	3b c1		 cmp	 eax, ecx
  0138e	74 24		 je	 SHORT $LN415@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  01390	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01398	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  0139f	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 892  :                 state->mode = BAD;

  013a3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  013a8	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 893  :                 break;

  013af	e9 7e 18 00 00	 jmp	 $LN8@inflate
$LN415@inflate:

; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  013b4	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  013b8	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  013bd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  013c2	89 41 50	 mov	 DWORD PTR [rcx+80], eax
$LN152@inflate:

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  013c5	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  013cd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  013d5	33 c0		 xor	 eax, eax
  013d7	85 c0		 test	 eax, eax
  013d9	75 ea		 jne	 SHORT $LN152@inflate

; 899  :             state->mode = COPY_;

  013db	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  013e0	c7 40 08 42 3f
	00 00		 mov	 DWORD PTR [rax+8], 16194 ; 00003f42H

; 900  :             if (flush == Z_TREES) goto inf_leave;

  013e7	83 bc 24 58 01
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  013ef	75 05		 jne	 SHORT $LN416@inflate
  013f1	e9 41 18 00 00	 jmp	 $inf_leave$561
$LN416@inflate:
$LN417@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  013f6	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  013fb	c7 40 08 43 3f
	00 00		 mov	 DWORD PTR [rax+8], 16195 ; 00003f43H
$LN418@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  01402	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01407	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0140a	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 905  :             if (copy) {

  0140e	83 7c 24 60 00	 cmp	 DWORD PTR copy$[rsp], 0
  01413	0f 84 aa 00 00
	00		 je	 $LN419@inflate

; 906  :                 if (copy > have) copy = have;

  01419	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  0141d	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  01421	76 08		 jbe	 SHORT $LN420@inflate
  01423	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  01427	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN420@inflate:

; 907  :                 if (copy > left) copy = left;

  0142b	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  0142f	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  01433	76 08		 jbe	 SHORT $LN421@inflate
  01435	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01439	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN421@inflate:

; 908  :                 if (copy == 0) goto inf_leave;

  0143d	83 7c 24 60 00	 cmp	 DWORD PTR copy$[rsp], 0
  01442	75 05		 jne	 SHORT $LN422@inflate
  01444	e9 ee 17 00 00	 jmp	 $inf_leave$561
$LN422@inflate:

; 909  :                 zmemcpy(put, next, copy);

  01449	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  0144d	44 8b c0	 mov	 r8d, eax
  01450	48 8b 54 24 38	 mov	 rdx, QWORD PTR next$[rsp]
  01455	48 8b 4c 24 40	 mov	 rcx, QWORD PTR put$[rsp]
  0145a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 910  :                 have -= copy;

  01460	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01464	8b 4c 24 48	 mov	 ecx, DWORD PTR have$[rsp]
  01468	2b c8		 sub	 ecx, eax
  0146a	8b c1		 mov	 eax, ecx
  0146c	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax

; 911  :                 next += copy;

  01470	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01474	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  01479	48 03 c8	 add	 rcx, rax
  0147c	48 8b c1	 mov	 rax, rcx
  0147f	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 912  :                 left -= copy;

  01484	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01488	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  0148c	2b c8		 sub	 ecx, eax
  0148e	8b c1		 mov	 eax, ecx
  01490	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax

; 913  :                 put += copy;

  01494	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01498	48 8b 4c 24 40	 mov	 rcx, QWORD PTR put$[rsp]
  0149d	48 03 c8	 add	 rcx, rax
  014a0	48 8b c1	 mov	 rax, rcx
  014a3	48 89 44 24 40	 mov	 QWORD PTR put$[rsp], rax

; 914  :                 state->length -= copy;

  014a8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  014ad	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  014b1	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  014b4	2b c1		 sub	 eax, ecx
  014b6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  014bb	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 915  :                 break;

  014be	e9 6f 17 00 00	 jmp	 $LN8@inflate
$LN419@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;

  014c3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  014c8	c7 40 08 3f 3f
	00 00		 mov	 DWORD PTR [rax+8], 16191 ; 00003f3fH

; 919  :             break;

  014cf	e9 5e 17 00 00	 jmp	 $LN8@inflate
$LN423@inflate:
$LN155@inflate:
$LN156@inflate:

; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  014d4	83 7c 24 54 0e	 cmp	 DWORD PTR bits$[rsp], 14
  014d9	73 50		 jae	 SHORT $LN157@inflate
$LN160@inflate:
  014db	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  014e0	75 05		 jne	 SHORT $LN424@inflate
  014e2	e9 50 17 00 00	 jmp	 $inf_leave$561
$LN424@inflate:
  014e7	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  014eb	ff c8		 dec	 eax
  014ed	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  014f1	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  014f6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  014f9	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  014fd	d3 e0		 shl	 eax, cl
  014ff	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01503	03 c8		 add	 ecx, eax
  01505	8b c1		 mov	 eax, ecx
  01507	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  0150b	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  01510	48 ff c0	 inc	 rax
  01513	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  01518	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  0151c	83 c0 08	 add	 eax, 8
  0151f	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01523	33 c0		 xor	 eax, eax
  01525	85 c0		 test	 eax, eax
  01527	75 b2		 jne	 SHORT $LN160@inflate
  01529	eb a9		 jmp	 SHORT $LN156@inflate
$LN157@inflate:
  0152b	33 c0		 xor	 eax, eax
  0152d	85 c0		 test	 eax, eax
  0152f	75 a3		 jne	 SHORT $LN155@inflate

; 922  :             state->nlen = BITS(5) + 257;

  01531	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01535	83 e0 1f	 and	 eax, 31
  01538	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0153d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01542	89 41 7c	 mov	 DWORD PTR [rcx+124], eax
$LN163@inflate:

; 923  :             DROPBITS(5);

  01545	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01549	c1 e8 05	 shr	 eax, 5
  0154c	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01550	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01554	83 e8 05	 sub	 eax, 5
  01557	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  0155b	33 c0		 xor	 eax, eax
  0155d	85 c0		 test	 eax, eax
  0155f	75 e4		 jne	 SHORT $LN163@inflate

; 924  :             state->ndist = BITS(5) + 1;

  01561	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01565	83 e0 1f	 and	 eax, 31
  01568	ff c0		 inc	 eax
  0156a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0156f	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax
$LN166@inflate:

; 925  :             DROPBITS(5);

  01575	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01579	c1 e8 05	 shr	 eax, 5
  0157c	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01580	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01584	83 e8 05	 sub	 eax, 5
  01587	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  0158b	33 c0		 xor	 eax, eax
  0158d	85 c0		 test	 eax, eax
  0158f	75 e4		 jne	 SHORT $LN166@inflate

; 926  :             state->ncode = BITS(4) + 4;

  01591	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01595	83 e0 0f	 and	 eax, 15
  01598	83 c0 04	 add	 eax, 4
  0159b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  015a0	89 41 78	 mov	 DWORD PTR [rcx+120], eax
$LN169@inflate:

; 927  :             DROPBITS(4);

  015a3	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  015a7	c1 e8 04	 shr	 eax, 4
  015aa	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  015ae	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  015b2	83 e8 04	 sub	 eax, 4
  015b5	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  015b9	33 c0		 xor	 eax, eax
  015bb	85 c0		 test	 eax, eax
  015bd	75 e4		 jne	 SHORT $LN169@inflate

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  015bf	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  015c4	81 78 7c 1e 01
	00 00		 cmp	 DWORD PTR [rax+124], 286 ; 0000011eH
  015cb	77 0e		 ja	 SHORT $LN426@inflate
  015cd	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  015d2	83 b8 80 00 00
	00 1e		 cmp	 DWORD PTR [rax+128], 30
  015d9	76 24		 jbe	 SHORT $LN425@inflate
$LN426@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  015db	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  015e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  015ea	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 931  :                 state->mode = BAD;

  015ee	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  015f3	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 932  :                 break;

  015fa	e9 33 16 00 00	 jmp	 $LN8@inflate
$LN425@inflate:

; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  015ff	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01604	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0

; 937  :             state->mode = LENLENS;

  0160e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01613	c7 40 08 45 3f
	00 00		 mov	 DWORD PTR [rax+8], 16197 ; 00003f45H
$LN427@inflate:
$LN170@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  0161a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0161f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01624	8b 49 78	 mov	 ecx, DWORD PTR [rcx+120]
  01627	39 88 84 00 00
	00		 cmp	 DWORD PTR [rax+132], ecx
  0162d	0f 83 c3 00 00
	00		 jae	 $LN171@inflate
$LN174@inflate:
$LN175@inflate:

; 940  :                 NEEDBITS(3);

  01633	83 7c 24 54 03	 cmp	 DWORD PTR bits$[rsp], 3
  01638	73 50		 jae	 SHORT $LN176@inflate
$LN179@inflate:
  0163a	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  0163f	75 05		 jne	 SHORT $LN428@inflate
  01641	e9 f1 15 00 00	 jmp	 $inf_leave$561
$LN428@inflate:
  01646	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  0164a	ff c8		 dec	 eax
  0164c	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  01650	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  01655	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01658	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  0165c	d3 e0		 shl	 eax, cl
  0165e	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01662	03 c8		 add	 ecx, eax
  01664	8b c1		 mov	 eax, ecx
  01666	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  0166a	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  0166f	48 ff c0	 inc	 rax
  01672	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  01677	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  0167b	83 c0 08	 add	 eax, 8
  0167e	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01682	33 c0		 xor	 eax, eax
  01684	85 c0		 test	 eax, eax
  01686	75 b2		 jne	 SHORT $LN179@inflate
  01688	eb a9		 jmp	 SHORT $LN175@inflate
$LN176@inflate:
  0168a	33 c0		 xor	 eax, eax
  0168c	85 c0		 test	 eax, eax
  0168e	75 a3		 jne	 SHORT $LN174@inflate

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  01690	0f ae e8	 lfence
  01693	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01697	83 e0 07	 and	 eax, 7
  0169a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0169f	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  016a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?order@?1??inflate@@9@9
  016ac	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  016b0	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  016b5	66 89 84 4a 90
	00 00 00	 mov	 WORD PTR [rdx+rcx*2+144], ax
  016bd	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  016c2	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  016c8	ff c0		 inc	 eax
  016ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  016cf	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax
$LN182@inflate:

; 942  :                 DROPBITS(3);

  016d5	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  016d9	c1 e8 03	 shr	 eax, 3
  016dc	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  016e0	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  016e4	83 e8 03	 sub	 eax, 3
  016e7	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  016eb	33 c0		 xor	 eax, eax
  016ed	85 c0		 test	 eax, eax
  016ef	75 e4		 jne	 SHORT $LN182@inflate

; 943  :             }

  016f1	e9 24 ff ff ff	 jmp	 $LN170@inflate
$LN171@inflate:
$LN183@inflate:

; 944  :             while (state->have < 19)

  016f6	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  016fb	83 b8 84 00 00
	00 13		 cmp	 DWORD PTR [rax+132], 19
  01702	73 3f		 jae	 SHORT $LN184@inflate

; 945  :                 state->lens[order[state->have++]] = 0;

  01704	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01709	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0170f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?order@?1??inflate@@9@9
  01716	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0171a	33 c9		 xor	 ecx, ecx
  0171c	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  01721	66 89 8c 42 90
	00 00 00	 mov	 WORD PTR [rdx+rax*2+144], cx
  01729	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0172e	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  01734	ff c0		 inc	 eax
  01736	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0173b	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax
  01741	eb b3		 jmp	 SHORT $LN183@inflate
$LN184@inflate:

; 946  :             state->next = state->codes;

  01743	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01748	48 05 50 05 00
	00		 add	 rax, 1360		; 00000550H
  0174e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01753	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 947  :             state->lencode = (const code FAR *)(state->next);

  0175a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0175f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01764	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  0176b	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 948  :             state->lenbits = 7;

  0176f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01774	c7 40 70 07 00
	00 00		 mov	 DWORD PTR [rax+112], 7

; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  0177b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01780	48 05 10 03 00
	00		 add	 rax, 784		; 00000310H
  01786	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0178b	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0178f	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  01794	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  0179b	4c 8b 44 24 30	 mov	 r8, QWORD PTR state$[rsp]
  017a0	49 81 c0 90 00
	00 00		 add	 r8, 144			; 00000090H
  017a7	4c 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv791[rsp], r8
  017af	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  017b4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  017b9	4c 8b ca	 mov	 r9, rdx
  017bc	41 b8 13 00 00
	00		 mov	 r8d, 19
  017c2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv791[rsp]
  017ca	48 8b d0	 mov	 rdx, rax
  017cd	33 c9		 xor	 ecx, ecx
  017cf	e8 00 00 00 00	 call	 inflate_table
  017d4	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$[rsp], eax

; 950  :                                 &(state->lenbits), state->work);
; 951  :             if (ret) {

  017db	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR ret$[rsp], 0
  017e3	74 24		 je	 SHORT $LN429@inflate

; 952  :                 strm->msg = (char *)"invalid code lengths set";

  017e5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  017ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  017f4	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 953  :                 state->mode = BAD;

  017f8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  017fd	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 954  :                 break;

  01804	e9 29 14 00 00	 jmp	 $LN8@inflate
$LN429@inflate:

; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  01809	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0180e	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0

; 958  :             state->mode = CODELENS;

  01818	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0181d	c7 40 08 46 3f
	00 00		 mov	 DWORD PTR [rax+8], 16198 ; 00003f46H
$LN430@inflate:
$LN185@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  01824	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01829	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  0182c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01831	03 81 80 00 00
	00		 add	 eax, DWORD PTR [rcx+128]
  01837	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0183c	39 81 84 00 00
	00		 cmp	 DWORD PTR [rcx+132], eax
  01842	0f 83 67 04 00
	00		 jae	 $LN186@inflate
$LN187@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  01848	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0184d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01850	b9 01 00 00 00	 mov	 ecx, 1
  01855	89 8c 24 f0 00
	00 00		 mov	 DWORD PTR tv2245[rsp], ecx
  0185c	0f b6 c8	 movzx	 ecx, al
  0185f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv2245[rsp]
  01866	d3 e0		 shl	 eax, cl
  01868	ff c8		 dec	 eax
  0186a	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  0186e	23 c8		 and	 ecx, eax
  01870	8b c1		 mov	 eax, ecx
  01872	8b c0		 mov	 eax, eax
  01874	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01879	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0187d	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  01880	89 44 24 74	 mov	 DWORD PTR here$[rsp], eax

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  01884	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  01889	3b 44 24 54	 cmp	 eax, DWORD PTR bits$[rsp]
  0188d	77 02		 ja	 SHORT $LN431@inflate
  0188f	eb 53		 jmp	 SHORT $LN188@inflate
$LN431@inflate:
$LN192@inflate:

; 964  :                     PULLBYTE();

  01891	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  01896	75 05		 jne	 SHORT $LN432@inflate
  01898	e9 9a 13 00 00	 jmp	 $inf_leave$561
$LN432@inflate:
  0189d	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  018a1	ff c8		 dec	 eax
  018a3	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  018a7	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  018ac	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  018af	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  018b3	d3 e0		 shl	 eax, cl
  018b5	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  018b9	03 c8		 add	 ecx, eax
  018bb	8b c1		 mov	 eax, ecx
  018bd	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  018c1	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  018c6	48 ff c0	 inc	 rax
  018c9	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  018ce	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  018d2	83 c0 08	 add	 eax, 8
  018d5	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  018d9	33 c0		 xor	 eax, eax
  018db	85 c0		 test	 eax, eax
  018dd	75 b2		 jne	 SHORT $LN192@inflate

; 965  :                 }

  018df	e9 64 ff ff ff	 jmp	 $LN187@inflate
$LN188@inflate:

; 966  :                 if (here.val < 16) {

  018e4	0f b7 44 24 76	 movzx	 eax, WORD PTR here$[rsp+2]
  018e9	83 f8 10	 cmp	 eax, 16
  018ec	7d 66		 jge	 SHORT $LN433@inflate
  018ee	0f ae e8	 lfence
$LN195@inflate:

; 967  :                     DROPBITS(here.bits);

  018f1	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  018f6	0f b6 c8	 movzx	 ecx, al
  018f9	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  018fd	d3 e8		 shr	 eax, cl
  018ff	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01903	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  01908	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  0190c	2b c8		 sub	 ecx, eax
  0190e	8b c1		 mov	 eax, ecx
  01910	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01914	33 c0		 xor	 eax, eax
  01916	85 c0		 test	 eax, eax
  01918	75 d7		 jne	 SHORT $LN195@inflate

; 968  :                     state->lens[state->have++] = here.val;

  0191a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0191f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  01925	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0192a	0f b7 54 24 76	 movzx	 edx, WORD PTR here$[rsp+2]
  0192f	66 89 94 41 90
	00 00 00	 mov	 WORD PTR [rcx+rax*2+144], dx
  01937	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0193c	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  01942	ff c0		 inc	 eax
  01944	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01949	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 969  :                 }

  0194f	e9 56 03 00 00	 jmp	 $LN434@inflate
$LN433@inflate:

; 970  :                 else {
; 971  :                     if (here.val == 16) {

  01954	0f b7 44 24 76	 movzx	 eax, WORD PTR here$[rsp+2]
  01959	83 f8 10	 cmp	 eax, 16
  0195c	0f 85 11 01 00
	00		 jne	 $LN435@inflate
$LN198@inflate:
$LN199@inflate:

; 972  :                         NEEDBITS(here.bits + 2);

  01962	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  01967	83 c0 02	 add	 eax, 2
  0196a	39 44 24 54	 cmp	 DWORD PTR bits$[rsp], eax
  0196e	73 50		 jae	 SHORT $LN200@inflate
$LN203@inflate:
  01970	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  01975	75 05		 jne	 SHORT $LN437@inflate
  01977	e9 bb 12 00 00	 jmp	 $inf_leave$561
$LN437@inflate:
  0197c	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  01980	ff c8		 dec	 eax
  01982	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  01986	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  0198b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0198e	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  01992	d3 e0		 shl	 eax, cl
  01994	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01998	03 c8		 add	 ecx, eax
  0199a	8b c1		 mov	 eax, ecx
  0199c	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  019a0	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  019a5	48 ff c0	 inc	 rax
  019a8	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  019ad	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  019b1	83 c0 08	 add	 eax, 8
  019b4	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  019b8	33 c0		 xor	 eax, eax
  019ba	85 c0		 test	 eax, eax
  019bc	75 b2		 jne	 SHORT $LN203@inflate
  019be	eb a2		 jmp	 SHORT $LN199@inflate
$LN200@inflate:
  019c0	33 c0		 xor	 eax, eax
  019c2	85 c0		 test	 eax, eax
  019c4	75 9c		 jne	 SHORT $LN198@inflate
$LN206@inflate:

; 973  :                         DROPBITS(here.bits);

  019c6	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  019cb	0f b6 c8	 movzx	 ecx, al
  019ce	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  019d2	d3 e8		 shr	 eax, cl
  019d4	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  019d8	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  019dd	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  019e1	2b c8		 sub	 ecx, eax
  019e3	8b c1		 mov	 eax, ecx
  019e5	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  019e9	33 c0		 xor	 eax, eax
  019eb	85 c0		 test	 eax, eax
  019ed	75 d7		 jne	 SHORT $LN206@inflate

; 974  :                         if (state->have == 0) {

  019ef	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  019f4	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  019fb	75 24		 jne	 SHORT $LN438@inflate

; 975  :                             strm->msg = (char *)"invalid bit length repeat";

  019fd	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01a05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  01a0c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 976  :                             state->mode = BAD;

  01a10	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01a15	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 977  :                             break;

  01a1c	e9 8e 02 00 00	 jmp	 $LN186@inflate
$LN438@inflate:

; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];

  01a21	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01a26	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  01a2c	ff c8		 dec	 eax
  01a2e	8b c0		 mov	 eax, eax
  01a30	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01a35	0f b7 84 41 90
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+144]
  01a3d	89 84 24 a4 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 980  :                         copy = 3 + BITS(2);

  01a44	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01a48	83 e0 03	 and	 eax, 3
  01a4b	83 c0 03	 add	 eax, 3
  01a4e	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN209@inflate:

; 981  :                         DROPBITS(2);

  01a52	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01a56	c1 e8 02	 shr	 eax, 2
  01a59	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01a5d	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01a61	83 e8 02	 sub	 eax, 2
  01a64	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01a68	33 c0		 xor	 eax, eax
  01a6a	85 c0		 test	 eax, eax
  01a6c	75 e4		 jne	 SHORT $LN209@inflate

; 982  :                     }

  01a6e	e9 97 01 00 00	 jmp	 $LN436@inflate
$LN435@inflate:

; 983  :                     else if (here.val == 17) {

  01a73	0f b7 44 24 76	 movzx	 eax, WORD PTR here$[rsp+2]
  01a78	83 f8 11	 cmp	 eax, 17
  01a7b	0f 85 c7 00 00
	00		 jne	 $LN439@inflate
$LN212@inflate:
$LN213@inflate:

; 984  :                         NEEDBITS(here.bits + 3);

  01a81	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  01a86	83 c0 03	 add	 eax, 3
  01a89	39 44 24 54	 cmp	 DWORD PTR bits$[rsp], eax
  01a8d	73 50		 jae	 SHORT $LN214@inflate
$LN217@inflate:
  01a8f	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  01a94	75 05		 jne	 SHORT $LN441@inflate
  01a96	e9 9c 11 00 00	 jmp	 $inf_leave$561
$LN441@inflate:
  01a9b	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  01a9f	ff c8		 dec	 eax
  01aa1	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  01aa5	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  01aaa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01aad	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  01ab1	d3 e0		 shl	 eax, cl
  01ab3	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01ab7	03 c8		 add	 ecx, eax
  01ab9	8b c1		 mov	 eax, ecx
  01abb	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01abf	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  01ac4	48 ff c0	 inc	 rax
  01ac7	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  01acc	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01ad0	83 c0 08	 add	 eax, 8
  01ad3	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01ad7	33 c0		 xor	 eax, eax
  01ad9	85 c0		 test	 eax, eax
  01adb	75 b2		 jne	 SHORT $LN217@inflate
  01add	eb a2		 jmp	 SHORT $LN213@inflate
$LN214@inflate:
  01adf	33 c0		 xor	 eax, eax
  01ae1	85 c0		 test	 eax, eax
  01ae3	75 9c		 jne	 SHORT $LN212@inflate
$LN220@inflate:

; 985  :                         DROPBITS(here.bits);

  01ae5	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  01aea	0f b6 c8	 movzx	 ecx, al
  01aed	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01af1	d3 e8		 shr	 eax, cl
  01af3	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01af7	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  01afc	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  01b00	2b c8		 sub	 ecx, eax
  01b02	8b c1		 mov	 eax, ecx
  01b04	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01b08	33 c0		 xor	 eax, eax
  01b0a	85 c0		 test	 eax, eax
  01b0c	75 d7		 jne	 SHORT $LN220@inflate

; 986  :                         len = 0;

  01b0e	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR len$[rsp], 0

; 987  :                         copy = 3 + BITS(3);

  01b19	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01b1d	83 e0 07	 and	 eax, 7
  01b20	83 c0 03	 add	 eax, 3
  01b23	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN223@inflate:

; 988  :                         DROPBITS(3);

  01b27	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01b2b	c1 e8 03	 shr	 eax, 3
  01b2e	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01b32	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01b36	83 e8 03	 sub	 eax, 3
  01b39	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01b3d	33 c0		 xor	 eax, eax
  01b3f	85 c0		 test	 eax, eax
  01b41	75 e4		 jne	 SHORT $LN223@inflate

; 989  :                     }

  01b43	e9 c2 00 00 00	 jmp	 $LN440@inflate
$LN439@inflate:
$LN226@inflate:
$LN227@inflate:

; 990  :                     else {
; 991  :                         NEEDBITS(here.bits + 7);

  01b48	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  01b4d	83 c0 07	 add	 eax, 7
  01b50	39 44 24 54	 cmp	 DWORD PTR bits$[rsp], eax
  01b54	73 50		 jae	 SHORT $LN228@inflate
$LN231@inflate:
  01b56	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  01b5b	75 05		 jne	 SHORT $LN442@inflate
  01b5d	e9 d5 10 00 00	 jmp	 $inf_leave$561
$LN442@inflate:
  01b62	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  01b66	ff c8		 dec	 eax
  01b68	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  01b6c	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  01b71	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01b74	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  01b78	d3 e0		 shl	 eax, cl
  01b7a	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01b7e	03 c8		 add	 ecx, eax
  01b80	8b c1		 mov	 eax, ecx
  01b82	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01b86	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  01b8b	48 ff c0	 inc	 rax
  01b8e	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  01b93	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01b97	83 c0 08	 add	 eax, 8
  01b9a	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01b9e	33 c0		 xor	 eax, eax
  01ba0	85 c0		 test	 eax, eax
  01ba2	75 b2		 jne	 SHORT $LN231@inflate
  01ba4	eb a2		 jmp	 SHORT $LN227@inflate
$LN228@inflate:
  01ba6	33 c0		 xor	 eax, eax
  01ba8	85 c0		 test	 eax, eax
  01baa	75 9c		 jne	 SHORT $LN226@inflate
$LN234@inflate:

; 992  :                         DROPBITS(here.bits);

  01bac	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  01bb1	0f b6 c8	 movzx	 ecx, al
  01bb4	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01bb8	d3 e8		 shr	 eax, cl
  01bba	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01bbe	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  01bc3	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  01bc7	2b c8		 sub	 ecx, eax
  01bc9	8b c1		 mov	 eax, ecx
  01bcb	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01bcf	33 c0		 xor	 eax, eax
  01bd1	85 c0		 test	 eax, eax
  01bd3	75 d7		 jne	 SHORT $LN234@inflate

; 993  :                         len = 0;

  01bd5	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR len$[rsp], 0

; 994  :                         copy = 11 + BITS(7);

  01be0	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01be4	83 e0 7f	 and	 eax, 127		; 0000007fH
  01be7	83 c0 0b	 add	 eax, 11
  01bea	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN237@inflate:

; 995  :                         DROPBITS(7);

  01bee	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  01bf2	c1 e8 07	 shr	 eax, 7
  01bf5	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01bf9	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  01bfd	83 e8 07	 sub	 eax, 7
  01c00	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01c04	33 c0		 xor	 eax, eax
  01c06	85 c0		 test	 eax, eax
  01c08	75 e4		 jne	 SHORT $LN237@inflate
$LN440@inflate:
$LN436@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  01c0a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01c0f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  01c15	03 44 24 60	 add	 eax, DWORD PTR copy$[rsp]
  01c19	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01c1e	8b 49 7c	 mov	 ecx, DWORD PTR [rcx+124]
  01c21	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  01c26	03 8a 80 00 00
	00		 add	 ecx, DWORD PTR [rdx+128]
  01c2c	3b c1		 cmp	 eax, ecx
  01c2e	76 21		 jbe	 SHORT $LN443@inflate

; 998  :                         strm->msg = (char *)"invalid bit length repeat";

  01c30	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01c38	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  01c3f	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 999  :                         state->mode = BAD;

  01c43	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01c48	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 1000 :                         break;

  01c4f	eb 5e		 jmp	 SHORT $LN186@inflate
$LN443@inflate:
$LN238@inflate:

; 1001 :                     }
; 1002 :                     while (copy--)

  01c51	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01c55	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv928[rsp], eax
  01c5c	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  01c60	ff c8		 dec	 eax
  01c62	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
  01c66	83 bc 24 f4 00
	00 00 00	 cmp	 DWORD PTR tv928[rsp], 0
  01c6e	74 3a		 je	 SHORT $LN239@inflate

; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  01c70	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01c75	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  01c7b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01c80	0f b7 94 24 a4
	00 00 00	 movzx	 edx, WORD PTR len$[rsp]
  01c88	66 89 94 41 90
	00 00 00	 mov	 WORD PTR [rcx+rax*2+144], dx
  01c90	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01c95	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  01c9b	ff c0		 inc	 eax
  01c9d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01ca2	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax
  01ca8	eb a7		 jmp	 SHORT $LN238@inflate
$LN239@inflate:
$LN434@inflate:

; 1004 :                 }
; 1005 :             }

  01caa	e9 75 fb ff ff	 jmp	 $LN185@inflate
$LN186@inflate:

; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  01caf	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01cb4	81 78 08 51 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16209 ; 00003f51H
  01cbb	75 05		 jne	 SHORT $LN444@inflate
  01cbd	e9 70 0f 00 00	 jmp	 $LN8@inflate
$LN444@inflate:

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  01cc2	b8 02 00 00 00	 mov	 eax, 2
  01cc7	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  01cce	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01cd3	0f b7 84 01 90
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax+144]
  01cdb	85 c0		 test	 eax, eax
  01cdd	75 24		 jne	 SHORT $LN445@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  01cdf	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01ce7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  01cee	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1013 :                 state->mode = BAD;

  01cf2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01cf7	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 1014 :                 break;

  01cfe	e9 2f 0f 00 00	 jmp	 $LN8@inflate
$LN445@inflate:

; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  01d03	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01d08	48 05 50 05 00
	00		 add	 rax, 1360		; 00000550H
  01d0e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01d13	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 1021 :             state->lencode = (const code FAR *)(state->next);

  01d1a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01d1f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01d24	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  01d2b	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1022 :             state->lenbits = 9;

  01d2f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01d34	c7 40 70 09 00
	00 00		 mov	 DWORD PTR [rax+112], 9

; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  01d3b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01d40	48 05 10 03 00
	00		 add	 rax, 784		; 00000310H
  01d46	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01d4b	48 83 c1 70	 add	 rcx, 112		; 00000070H
  01d4f	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  01d54	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  01d5b	4c 8b 44 24 30	 mov	 r8, QWORD PTR state$[rsp]
  01d60	49 81 c0 90 00
	00 00		 add	 r8, 144			; 00000090H
  01d67	4c 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv961[rsp], r8
  01d6f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01d74	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01d79	4c 8b ca	 mov	 r9, rdx
  01d7c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01d81	44 8b 40 7c	 mov	 r8d, DWORD PTR [rax+124]
  01d85	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv961[rsp]
  01d8d	48 8b d0	 mov	 rdx, rax
  01d90	b9 01 00 00 00	 mov	 ecx, 1
  01d95	e8 00 00 00 00	 call	 inflate_table
  01d9a	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$[rsp], eax

; 1024 :                                 &(state->lenbits), state->work);
; 1025 :             if (ret) {

  01da1	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR ret$[rsp], 0
  01da9	74 24		 je	 SHORT $LN446@inflate

; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  01dab	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01db3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  01dba	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1027 :                 state->mode = BAD;

  01dbe	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01dc3	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 1028 :                 break;

  01dca	e9 63 0e 00 00	 jmp	 $LN8@inflate
$LN446@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  01dcf	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01dd4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01dd9	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  01de0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1031 :             state->distbits = 6;

  01de4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01de9	c7 40 74 06 00
	00 00		 mov	 DWORD PTR [rax+116], 6

; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  01df0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01df5	48 05 10 03 00
	00		 add	 rax, 784		; 00000310H
  01dfb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01e00	48 83 c1 74	 add	 rcx, 116		; 00000074H
  01e04	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  01e09	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  01e10	4c 8b 44 24 30	 mov	 r8, QWORD PTR state$[rsp]
  01e15	45 8b 40 7c	 mov	 r8d, DWORD PTR [r8+124]
  01e19	4c 8b 4c 24 30	 mov	 r9, QWORD PTR state$[rsp]
  01e1e	4f 8d 84 41 90
	00 00 00	 lea	 r8, QWORD PTR [r9+r8*2+144]
  01e26	4c 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv983[rsp], r8
  01e2e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01e33	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01e38	4c 8b ca	 mov	 r9, rdx
  01e3b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01e40	44 8b 80 80 00
	00 00		 mov	 r8d, DWORD PTR [rax+128]
  01e47	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv983[rsp]
  01e4f	48 8b d0	 mov	 rdx, rax
  01e52	b9 02 00 00 00	 mov	 ecx, 2
  01e57	e8 00 00 00 00	 call	 inflate_table
  01e5c	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$[rsp], eax

; 1033 :                             &(state->next), &(state->distbits), state->work);
; 1034 :             if (ret) {

  01e63	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR ret$[rsp], 0
  01e6b	74 24		 je	 SHORT $LN447@inflate

; 1035 :                 strm->msg = (char *)"invalid distances set";

  01e6d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01e75	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  01e7c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1036 :                 state->mode = BAD;

  01e80	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01e85	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 1037 :                 break;

  01e8c	e9 a1 0d 00 00	 jmp	 $LN8@inflate
$LN447@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;

  01e91	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01e96	c7 40 08 47 3f
	00 00		 mov	 DWORD PTR [rax+8], 16199 ; 00003f47H

; 1041 :             if (flush == Z_TREES) goto inf_leave;

  01e9d	83 bc 24 58 01
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  01ea5	75 05		 jne	 SHORT $LN448@inflate
  01ea7	e9 8b 0d 00 00	 jmp	 $inf_leave$561
$LN448@inflate:
$LN449@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  01eac	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01eb1	c7 40 08 48 3f
	00 00		 mov	 DWORD PTR [rax+8], 16200 ; 00003f48H
$LN450@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  01eb8	83 7c 24 48 06	 cmp	 DWORD PTR have$[rsp], 6
  01ebd	0f 82 fe 00 00
	00		 jb	 $LN451@inflate
  01ec3	81 7c 24 4c 02
	01 00 00	 cmp	 DWORD PTR left$[rsp], 258 ; 00000102H
  01ecb	0f 82 f0 00 00
	00		 jb	 $LN451@inflate
  01ed1	0f ae e8	 lfence
$LN242@inflate:

; 1046 :                 RESTORE();

  01ed4	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01edc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR put$[rsp]
  01ee1	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  01ee5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01eed	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  01ef1	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  01ef4	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01efc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  01f01	48 89 08	 mov	 QWORD PTR [rax], rcx
  01f04	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f0c	8b 4c 24 48	 mov	 ecx, DWORD PTR have$[rsp]
  01f10	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  01f13	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01f18	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01f1c	89 48 48	 mov	 DWORD PTR [rax+72], ecx
  01f1f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01f24	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  01f28	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
  01f2b	33 c0		 xor	 eax, eax
  01f2d	85 c0		 test	 eax, eax
  01f2f	75 a3		 jne	 SHORT $LN242@inflate

; 1047 :                 inflate_fast(strm, out);

  01f31	8b 54 24 5c	 mov	 edx, DWORD PTR out$[rsp]
  01f35	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01f3d	e8 00 00 00 00	 call	 inflate_fast
$LN245@inflate:

; 1048 :                 LOAD();

  01f42	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f4a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01f4e	48 89 44 24 40	 mov	 QWORD PTR put$[rsp], rax
  01f53	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f5b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01f5e	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  01f62	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f6a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01f6d	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  01f72	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f7a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01f7d	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  01f81	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01f86	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01f89	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  01f8d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01f92	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01f95	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  01f99	33 c0		 xor	 eax, eax
  01f9b	85 c0		 test	 eax, eax
  01f9d	75 a3		 jne	 SHORT $LN245@inflate

; 1049 :                 if (state->mode == TYPE)

  01f9f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01fa4	81 78 08 3f 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16191 ; 00003f3fH
  01fab	75 0f		 jne	 SHORT $LN452@inflate

; 1050 :                     state->back = -1;

  01fad	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01fb2	c7 80 e4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+7140], -1
$LN452@inflate:

; 1051 :                 break;

  01fbc	e9 71 0c 00 00	 jmp	 $LN8@inflate
$LN451@inflate:

; 1052 :             }
; 1053 :             state->back = 0;

  01fc1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01fc6	c7 80 e4 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+7140], 0
$LN246@inflate:

; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  01fd0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01fd5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01fd8	b9 01 00 00 00	 mov	 ecx, 1
  01fdd	89 8c 24 08 01
	00 00		 mov	 DWORD PTR tv2414[rsp], ecx
  01fe4	0f b6 c8	 movzx	 ecx, al
  01fe7	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR tv2414[rsp]
  01fee	d3 e0		 shl	 eax, cl
  01ff0	ff c8		 dec	 eax
  01ff2	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  01ff6	23 c8		 and	 ecx, eax
  01ff8	8b c1		 mov	 eax, ecx
  01ffa	8b c0		 mov	 eax, eax
  01ffc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  02001	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  02005	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  02008	89 44 24 74	 mov	 DWORD PTR here$[rsp], eax

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  0200c	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  02011	3b 44 24 54	 cmp	 eax, DWORD PTR bits$[rsp]
  02015	77 02		 ja	 SHORT $LN453@inflate
  02017	eb 53		 jmp	 SHORT $LN247@inflate
$LN453@inflate:
$LN251@inflate:

; 1057 :                 PULLBYTE();

  02019	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  0201e	75 05		 jne	 SHORT $LN454@inflate
  02020	e9 12 0c 00 00	 jmp	 $inf_leave$561
$LN454@inflate:
  02025	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  02029	ff c8		 dec	 eax
  0202b	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  0202f	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  02034	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02037	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  0203b	d3 e0		 shl	 eax, cl
  0203d	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  02041	03 c8		 add	 ecx, eax
  02043	8b c1		 mov	 eax, ecx
  02045	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  02049	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  0204e	48 ff c0	 inc	 rax
  02051	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  02056	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  0205a	83 c0 08	 add	 eax, 8
  0205d	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  02061	33 c0		 xor	 eax, eax
  02063	85 c0		 test	 eax, eax
  02065	75 b2		 jne	 SHORT $LN251@inflate

; 1058 :             }

  02067	e9 64 ff ff ff	 jmp	 $LN246@inflate
$LN247@inflate:

; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  0206c	0f b6 44 24 74	 movzx	 eax, BYTE PTR here$[rsp]
  02071	85 c0		 test	 eax, eax
  02073	0f 84 35 01 00
	00		 je	 $LN455@inflate
  02079	0f b6 44 24 74	 movzx	 eax, BYTE PTR here$[rsp]
  0207e	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  02083	85 c0		 test	 eax, eax
  02085	0f 85 23 01 00
	00		 jne	 $LN455@inflate

; 1060 :                 last = here;

  0208b	0f ae e8	 lfence
  0208e	8b 44 24 74	 mov	 eax, DWORD PTR here$[rsp]
  02092	89 84 24 94 00
	00 00		 mov	 DWORD PTR last$[rsp], eax
$LN252@inflate:

; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +

  02099	0f b7 84 24 96
	00 00 00	 movzx	 eax, WORD PTR last$[rsp+2]
  020a1	0f b6 8c 24 95
	00 00 00	 movzx	 ecx, BYTE PTR last$[rsp+1]
  020a9	0f b6 94 24 94
	00 00 00	 movzx	 edx, BYTE PTR last$[rsp]
  020b1	03 ca		 add	 ecx, edx
  020b3	ba 01 00 00 00	 mov	 edx, 1
  020b8	d3 e2		 shl	 edx, cl
  020ba	8b ca		 mov	 ecx, edx
  020bc	ff c9		 dec	 ecx
  020be	8b 54 24 50	 mov	 edx, DWORD PTR hold$[rsp]
  020c2	23 d1		 and	 edx, ecx
  020c4	8b ca		 mov	 ecx, edx
  020c6	89 8c 24 0c 01
	00 00		 mov	 DWORD PTR tv1045[rsp], ecx
  020cd	0f b6 94 24 95
	00 00 00	 movzx	 edx, BYTE PTR last$[rsp+1]
  020d5	0f b6 ca	 movzx	 ecx, dl
  020d8	8b 94 24 0c 01
	00 00		 mov	 edx, DWORD PTR tv1045[rsp]
  020df	d3 ea		 shr	 edx, cl
  020e1	8b ca		 mov	 ecx, edx
  020e3	03 c1		 add	 eax, ecx
  020e5	8b c0		 mov	 eax, eax
  020e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  020ec	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  020f0	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  020f3	89 44 24 74	 mov	 DWORD PTR here$[rsp], eax

; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  020f7	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  020ff	0f b6 4c 24 75	 movzx	 ecx, BYTE PTR here$[rsp+1]
  02104	03 c1		 add	 eax, ecx
  02106	3b 44 24 54	 cmp	 eax, DWORD PTR bits$[rsp]
  0210a	77 02		 ja	 SHORT $LN456@inflate
  0210c	eb 53		 jmp	 SHORT $LN253@inflate
$LN456@inflate:
$LN257@inflate:

; 1065 :                     PULLBYTE();

  0210e	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  02113	75 05		 jne	 SHORT $LN457@inflate
  02115	e9 1d 0b 00 00	 jmp	 $inf_leave$561
$LN457@inflate:
  0211a	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  0211e	ff c8		 dec	 eax
  02120	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  02124	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  02129	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0212c	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  02130	d3 e0		 shl	 eax, cl
  02132	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  02136	03 c8		 add	 ecx, eax
  02138	8b c1		 mov	 eax, ecx
  0213a	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  0213e	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  02143	48 ff c0	 inc	 rax
  02146	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  0214b	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  0214f	83 c0 08	 add	 eax, 8
  02152	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  02156	33 c0		 xor	 eax, eax
  02158	85 c0		 test	 eax, eax
  0215a	75 b2		 jne	 SHORT $LN257@inflate

; 1066 :                 }

  0215c	e9 38 ff ff ff	 jmp	 $LN252@inflate
$LN253@inflate:
$LN260@inflate:

; 1067 :                 DROPBITS(last.bits);

  02161	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  02169	0f b6 c8	 movzx	 ecx, al
  0216c	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  02170	d3 e8		 shr	 eax, cl
  02172	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  02176	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  0217e	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  02182	2b c8		 sub	 ecx, eax
  02184	8b c1		 mov	 eax, ecx
  02186	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  0218a	33 c0		 xor	 eax, eax
  0218c	85 c0		 test	 eax, eax
  0218e	75 d1		 jne	 SHORT $LN260@inflate

; 1068 :                 state->back += last.bits;

  02190	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  02198	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0219d	03 81 e4 1b 00
	00		 add	 eax, DWORD PTR [rcx+7140]
  021a3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  021a8	89 81 e4 1b 00
	00		 mov	 DWORD PTR [rcx+7140], eax
$LN455@inflate:
$LN263@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);

  021ae	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  021b3	0f b6 c8	 movzx	 ecx, al
  021b6	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  021ba	d3 e8		 shr	 eax, cl
  021bc	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  021c0	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  021c5	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  021c9	2b c8		 sub	 ecx, eax
  021cb	8b c1		 mov	 eax, ecx
  021cd	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  021d1	33 c0		 xor	 eax, eax
  021d3	85 c0		 test	 eax, eax
  021d5	75 d7		 jne	 SHORT $LN263@inflate

; 1071 :             state->back += here.bits;

  021d7	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  021dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  021e1	03 81 e4 1b 00
	00		 add	 eax, DWORD PTR [rcx+7140]
  021e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  021ec	89 81 e4 1b 00
	00		 mov	 DWORD PTR [rcx+7140], eax

; 1072 :             state->length = (unsigned)here.val;

  021f2	0f b7 44 24 76	 movzx	 eax, WORD PTR here$[rsp+2]
  021f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  021fc	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 1073 :             if ((int)(here.op) == 0) {

  021ff	0f b6 44 24 74	 movzx	 eax, BYTE PTR here$[rsp]
  02204	85 c0		 test	 eax, eax
  02206	75 11		 jne	 SHORT $LN458@inflate

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  02208	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0220d	c7 40 08 4d 3f
	00 00		 mov	 DWORD PTR [rax+8], 16205 ; 00003f4dH

; 1078 :                 break;

  02214	e9 19 0a 00 00	 jmp	 $LN8@inflate
$LN458@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  02219	0f b6 44 24 74	 movzx	 eax, BYTE PTR here$[rsp]
  0221e	83 e0 20	 and	 eax, 32			; 00000020H
  02221	85 c0		 test	 eax, eax
  02223	74 20		 je	 SHORT $LN459@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  02225	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0222a	c7 80 e4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+7140], -1

; 1083 :                 state->mode = TYPE;

  02234	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02239	c7 40 08 3f 3f
	00 00		 mov	 DWORD PTR [rax+8], 16191 ; 00003f3fH

; 1084 :                 break;

  02240	e9 ed 09 00 00	 jmp	 $LN8@inflate
$LN459@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  02245	0f b6 44 24 74	 movzx	 eax, BYTE PTR here$[rsp]
  0224a	83 e0 40	 and	 eax, 64			; 00000040H
  0224d	85 c0		 test	 eax, eax
  0224f	74 24		 je	 SHORT $LN460@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  02251	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02259	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  02260	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1088 :                 state->mode = BAD;

  02264	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02269	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 1089 :                 break;

  02270	e9 bd 09 00 00	 jmp	 $LN8@inflate
$LN460@inflate:

; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  02275	0f b6 44 24 74	 movzx	 eax, BYTE PTR here$[rsp]
  0227a	83 e0 0f	 and	 eax, 15
  0227d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  02282	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1092 :             state->mode = LENEXT;

  02285	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0228a	c7 40 08 49 3f
	00 00		 mov	 DWORD PTR [rax+8], 16201 ; 00003f49H
$LN461@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  02291	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02296	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  0229a	0f 84 eb 00 00
	00		 je	 $LN462@inflate
$LN266@inflate:
$LN267@inflate:

; 1095 :                 NEEDBITS(state->extra);

  022a0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  022a5	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  022a8	39 44 24 54	 cmp	 DWORD PTR bits$[rsp], eax
  022ac	73 50		 jae	 SHORT $LN268@inflate
$LN271@inflate:
  022ae	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  022b3	75 05		 jne	 SHORT $LN463@inflate
  022b5	e9 7d 09 00 00	 jmp	 $inf_leave$561
$LN463@inflate:
  022ba	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  022be	ff c8		 dec	 eax
  022c0	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  022c4	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  022c9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  022cc	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  022d0	d3 e0		 shl	 eax, cl
  022d2	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  022d6	03 c8		 add	 ecx, eax
  022d8	8b c1		 mov	 eax, ecx
  022da	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  022de	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  022e3	48 ff c0	 inc	 rax
  022e6	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  022eb	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  022ef	83 c0 08	 add	 eax, 8
  022f2	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  022f6	33 c0		 xor	 eax, eax
  022f8	85 c0		 test	 eax, eax
  022fa	75 b2		 jne	 SHORT $LN271@inflate
  022fc	eb a2		 jmp	 SHORT $LN267@inflate
$LN268@inflate:
  022fe	33 c0		 xor	 eax, eax
  02300	85 c0		 test	 eax, eax
  02302	75 9c		 jne	 SHORT $LN266@inflate

; 1096 :                 state->length += BITS(state->extra);

  02304	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02309	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0230c	b9 01 00 00 00	 mov	 ecx, 1
  02311	89 8c 24 10 01
	00 00		 mov	 DWORD PTR tv2488[rsp], ecx
  02318	0f b6 c8	 movzx	 ecx, al
  0231b	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR tv2488[rsp]
  02322	d3 e0		 shl	 eax, cl
  02324	ff c8		 dec	 eax
  02326	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  0232a	23 c8		 and	 ecx, eax
  0232c	8b c1		 mov	 eax, ecx
  0232e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  02333	03 41 50	 add	 eax, DWORD PTR [rcx+80]
  02336	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0233b	89 41 50	 mov	 DWORD PTR [rcx+80], eax
$LN274@inflate:

; 1097 :                 DROPBITS(state->extra);

  0233e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02343	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  02346	0f b6 c8	 movzx	 ecx, al
  02349	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  0234d	d3 e8		 shr	 eax, cl
  0234f	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  02353	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02358	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0235b	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  0235f	2b c8		 sub	 ecx, eax
  02361	8b c1		 mov	 eax, ecx
  02363	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  02367	33 c0		 xor	 eax, eax
  02369	85 c0		 test	 eax, eax
  0236b	75 d1		 jne	 SHORT $LN274@inflate

; 1098 :                 state->back += state->extra;

  0236d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02372	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  02378	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0237d	03 41 58	 add	 eax, DWORD PTR [rcx+88]
  02380	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  02385	89 81 e4 1b 00
	00		 mov	 DWORD PTR [rcx+7140], eax
$LN462@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  0238b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02390	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  02395	8b 49 50	 mov	 ecx, DWORD PTR [rcx+80]
  02398	89 88 e8 1b 00
	00		 mov	 DWORD PTR [rax+7144], ecx

; 1102 :             state->mode = DIST;

  0239e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  023a3	c7 40 08 4a 3f
	00 00		 mov	 DWORD PTR [rax+8], 16202 ; 00003f4aH
$LN464@inflate:
$LN275@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  023aa	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  023af	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  023b2	b9 01 00 00 00	 mov	 ecx, 1
  023b7	89 8c 24 14 01
	00 00		 mov	 DWORD PTR tv2512[rsp], ecx
  023be	0f b6 c8	 movzx	 ecx, al
  023c1	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR tv2512[rsp]
  023c8	d3 e0		 shl	 eax, cl
  023ca	ff c8		 dec	 eax
  023cc	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  023d0	23 c8		 and	 ecx, eax
  023d2	8b c1		 mov	 eax, ecx
  023d4	8b c0		 mov	 eax, eax
  023d6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  023db	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  023df	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  023e2	89 44 24 74	 mov	 DWORD PTR here$[rsp], eax

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  023e6	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  023eb	3b 44 24 54	 cmp	 eax, DWORD PTR bits$[rsp]
  023ef	77 02		 ja	 SHORT $LN465@inflate
  023f1	eb 53		 jmp	 SHORT $LN276@inflate
$LN465@inflate:
$LN280@inflate:

; 1107 :                 PULLBYTE();

  023f3	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  023f8	75 05		 jne	 SHORT $LN466@inflate
  023fa	e9 38 08 00 00	 jmp	 $inf_leave$561
$LN466@inflate:
  023ff	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  02403	ff c8		 dec	 eax
  02405	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  02409	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  0240e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02411	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  02415	d3 e0		 shl	 eax, cl
  02417	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  0241b	03 c8		 add	 ecx, eax
  0241d	8b c1		 mov	 eax, ecx
  0241f	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  02423	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  02428	48 ff c0	 inc	 rax
  0242b	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  02430	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  02434	83 c0 08	 add	 eax, 8
  02437	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  0243b	33 c0		 xor	 eax, eax
  0243d	85 c0		 test	 eax, eax
  0243f	75 b2		 jne	 SHORT $LN280@inflate

; 1108 :             }

  02441	e9 64 ff ff ff	 jmp	 $LN275@inflate
$LN276@inflate:

; 1109 :             if ((here.op & 0xf0) == 0) {

  02446	0f b6 44 24 74	 movzx	 eax, BYTE PTR here$[rsp]
  0244b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  02450	85 c0		 test	 eax, eax
  02452	0f 85 23 01 00
	00		 jne	 $LN467@inflate

; 1110 :                 last = here;

  02458	0f ae e8	 lfence
  0245b	8b 44 24 74	 mov	 eax, DWORD PTR here$[rsp]
  0245f	89 84 24 94 00
	00 00		 mov	 DWORD PTR last$[rsp], eax
$LN281@inflate:

; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +

  02466	0f b7 84 24 96
	00 00 00	 movzx	 eax, WORD PTR last$[rsp+2]
  0246e	0f b6 8c 24 95
	00 00 00	 movzx	 ecx, BYTE PTR last$[rsp+1]
  02476	0f b6 94 24 94
	00 00 00	 movzx	 edx, BYTE PTR last$[rsp]
  0247e	03 ca		 add	 ecx, edx
  02480	ba 01 00 00 00	 mov	 edx, 1
  02485	d3 e2		 shl	 edx, cl
  02487	8b ca		 mov	 ecx, edx
  02489	ff c9		 dec	 ecx
  0248b	8b 54 24 50	 mov	 edx, DWORD PTR hold$[rsp]
  0248f	23 d1		 and	 edx, ecx
  02491	8b ca		 mov	 ecx, edx
  02493	89 8c 24 18 01
	00 00		 mov	 DWORD PTR tv1163[rsp], ecx
  0249a	0f b6 94 24 95
	00 00 00	 movzx	 edx, BYTE PTR last$[rsp+1]
  024a2	0f b6 ca	 movzx	 ecx, dl
  024a5	8b 94 24 18 01
	00 00		 mov	 edx, DWORD PTR tv1163[rsp]
  024ac	d3 ea		 shr	 edx, cl
  024ae	8b ca		 mov	 ecx, edx
  024b0	03 c1		 add	 eax, ecx
  024b2	8b c0		 mov	 eax, eax
  024b4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  024b9	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  024bd	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  024c0	89 44 24 74	 mov	 DWORD PTR here$[rsp], eax

; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  024c4	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  024cc	0f b6 4c 24 75	 movzx	 ecx, BYTE PTR here$[rsp+1]
  024d1	03 c1		 add	 eax, ecx
  024d3	3b 44 24 54	 cmp	 eax, DWORD PTR bits$[rsp]
  024d7	77 02		 ja	 SHORT $LN468@inflate
  024d9	eb 53		 jmp	 SHORT $LN282@inflate
$LN468@inflate:
$LN286@inflate:

; 1115 :                     PULLBYTE();

  024db	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  024e0	75 05		 jne	 SHORT $LN469@inflate
  024e2	e9 50 07 00 00	 jmp	 $inf_leave$561
$LN469@inflate:
  024e7	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  024eb	ff c8		 dec	 eax
  024ed	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  024f1	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  024f6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  024f9	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  024fd	d3 e0		 shl	 eax, cl
  024ff	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  02503	03 c8		 add	 ecx, eax
  02505	8b c1		 mov	 eax, ecx
  02507	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  0250b	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  02510	48 ff c0	 inc	 rax
  02513	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  02518	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  0251c	83 c0 08	 add	 eax, 8
  0251f	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  02523	33 c0		 xor	 eax, eax
  02525	85 c0		 test	 eax, eax
  02527	75 b2		 jne	 SHORT $LN286@inflate

; 1116 :                 }

  02529	e9 38 ff ff ff	 jmp	 $LN281@inflate
$LN282@inflate:
$LN289@inflate:

; 1117 :                 DROPBITS(last.bits);

  0252e	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  02536	0f b6 c8	 movzx	 ecx, al
  02539	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  0253d	d3 e8		 shr	 eax, cl
  0253f	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  02543	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  0254b	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  0254f	2b c8		 sub	 ecx, eax
  02551	8b c1		 mov	 eax, ecx
  02553	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  02557	33 c0		 xor	 eax, eax
  02559	85 c0		 test	 eax, eax
  0255b	75 d1		 jne	 SHORT $LN289@inflate

; 1118 :                 state->back += last.bits;

  0255d	0f b6 84 24 95
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  02565	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0256a	03 81 e4 1b 00
	00		 add	 eax, DWORD PTR [rcx+7140]
  02570	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  02575	89 81 e4 1b 00
	00		 mov	 DWORD PTR [rcx+7140], eax
$LN467@inflate:
$LN292@inflate:

; 1119 :             }
; 1120 :             DROPBITS(here.bits);

  0257b	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  02580	0f b6 c8	 movzx	 ecx, al
  02583	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  02587	d3 e8		 shr	 eax, cl
  02589	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  0258d	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  02592	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  02596	2b c8		 sub	 ecx, eax
  02598	8b c1		 mov	 eax, ecx
  0259a	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  0259e	33 c0		 xor	 eax, eax
  025a0	85 c0		 test	 eax, eax
  025a2	75 d7		 jne	 SHORT $LN292@inflate

; 1121 :             state->back += here.bits;

  025a4	0f b6 44 24 75	 movzx	 eax, BYTE PTR here$[rsp+1]
  025a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  025ae	03 81 e4 1b 00
	00		 add	 eax, DWORD PTR [rcx+7140]
  025b4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  025b9	89 81 e4 1b 00
	00		 mov	 DWORD PTR [rcx+7140], eax

; 1122 :             if (here.op & 64) {

  025bf	0f b6 44 24 74	 movzx	 eax, BYTE PTR here$[rsp]
  025c4	83 e0 40	 and	 eax, 64			; 00000040H
  025c7	85 c0		 test	 eax, eax
  025c9	74 24		 je	 SHORT $LN470@inflate

; 1123 :                 strm->msg = (char *)"invalid distance code";

  025cb	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  025d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  025da	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1124 :                 state->mode = BAD;

  025de	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  025e3	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 1125 :                 break;

  025ea	e9 43 06 00 00	 jmp	 $LN8@inflate
$LN470@inflate:

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  025ef	0f b7 44 24 76	 movzx	 eax, WORD PTR here$[rsp+2]
  025f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  025f9	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  025fc	0f b6 44 24 74	 movzx	 eax, BYTE PTR here$[rsp]
  02601	83 e0 0f	 and	 eax, 15
  02604	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  02609	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1129 :             state->mode = DISTEXT;

  0260c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02611	c7 40 08 4b 3f
	00 00		 mov	 DWORD PTR [rax+8], 16203 ; 00003f4bH
$LN471@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  02618	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0261d	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  02621	0f 84 eb 00 00
	00		 je	 $LN472@inflate
$LN295@inflate:
$LN296@inflate:

; 1132 :                 NEEDBITS(state->extra);

  02627	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0262c	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0262f	39 44 24 54	 cmp	 DWORD PTR bits$[rsp], eax
  02633	73 50		 jae	 SHORT $LN297@inflate
$LN300@inflate:
  02635	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  0263a	75 05		 jne	 SHORT $LN473@inflate
  0263c	e9 f6 05 00 00	 jmp	 $inf_leave$561
$LN473@inflate:
  02641	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  02645	ff c8		 dec	 eax
  02647	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  0264b	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  02650	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02653	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  02657	d3 e0		 shl	 eax, cl
  02659	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  0265d	03 c8		 add	 ecx, eax
  0265f	8b c1		 mov	 eax, ecx
  02661	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  02665	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  0266a	48 ff c0	 inc	 rax
  0266d	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  02672	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  02676	83 c0 08	 add	 eax, 8
  02679	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  0267d	33 c0		 xor	 eax, eax
  0267f	85 c0		 test	 eax, eax
  02681	75 b2		 jne	 SHORT $LN300@inflate
  02683	eb a2		 jmp	 SHORT $LN296@inflate
$LN297@inflate:
  02685	33 c0		 xor	 eax, eax
  02687	85 c0		 test	 eax, eax
  02689	75 9c		 jne	 SHORT $LN295@inflate

; 1133 :                 state->offset += BITS(state->extra);

  0268b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02690	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  02693	b9 01 00 00 00	 mov	 ecx, 1
  02698	89 8c 24 1c 01
	00 00		 mov	 DWORD PTR tv2582[rsp], ecx
  0269f	0f b6 c8	 movzx	 ecx, al
  026a2	8b 84 24 1c 01
	00 00		 mov	 eax, DWORD PTR tv2582[rsp]
  026a9	d3 e0		 shl	 eax, cl
  026ab	ff c8		 dec	 eax
  026ad	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  026b1	23 c8		 and	 ecx, eax
  026b3	8b c1		 mov	 eax, ecx
  026b5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  026ba	03 41 54	 add	 eax, DWORD PTR [rcx+84]
  026bd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  026c2	89 41 54	 mov	 DWORD PTR [rcx+84], eax
$LN303@inflate:

; 1134 :                 DROPBITS(state->extra);

  026c5	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  026ca	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  026cd	0f b6 c8	 movzx	 ecx, al
  026d0	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  026d4	d3 e8		 shr	 eax, cl
  026d6	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  026da	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  026df	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  026e2	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  026e6	2b c8		 sub	 ecx, eax
  026e8	8b c1		 mov	 eax, ecx
  026ea	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  026ee	33 c0		 xor	 eax, eax
  026f0	85 c0		 test	 eax, eax
  026f2	75 d1		 jne	 SHORT $LN303@inflate

; 1135 :                 state->back += state->extra;

  026f4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  026f9	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  026ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  02704	03 41 58	 add	 eax, DWORD PTR [rcx+88]
  02707	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0270c	89 81 e4 1b 00
	00		 mov	 DWORD PTR [rcx+7140], eax
$LN472@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  02712	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02717	c7 40 08 4c 3f
	00 00		 mov	 DWORD PTR [rax+8], 16204 ; 00003f4cH
$LN474@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  0271e	83 7c 24 4c 00	 cmp	 DWORD PTR left$[rsp], 0
  02723	75 05		 jne	 SHORT $LN475@inflate
  02725	e9 0d 05 00 00	 jmp	 $inf_leave$561
$LN475@inflate:

; 1148 :             copy = out - left;

  0272a	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  0272e	8b 4c 24 5c	 mov	 ecx, DWORD PTR out$[rsp]
  02732	2b c8		 sub	 ecx, eax
  02734	8b c1		 mov	 eax, ecx
  02736	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 1149 :             if (state->offset > copy) {         /* copy from window */

  0273a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0273f	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  02743	39 48 54	 cmp	 DWORD PTR [rax+84], ecx
  02746	0f 86 d7 00 00
	00		 jbe	 $LN476@inflate

; 1150 :                 copy = state->offset - copy;

  0274c	0f ae e8	 lfence
  0274f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02754	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  02758	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0275b	2b c1		 sub	 eax, ecx
  0275d	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 1151 :                 if (copy > state->whave) {

  02761	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02766	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  02769	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  0276d	76 32		 jbe	 SHORT $LN478@inflate

; 1152 :                     if (state->sane) {

  0276f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02774	83 b8 e0 1b 00
	00 00		 cmp	 DWORD PTR [rax+7136], 0
  0277b	74 24		 je	 SHORT $LN479@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  0277d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02785	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
  0278c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1154 :                         state->mode = BAD;

  02790	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02795	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 1155 :                         break;

  0279c	e9 91 04 00 00	 jmp	 $LN8@inflate
$LN479@inflate:
$LN478@inflate:

; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  027a1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  027a6	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  027a9	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  027ad	76 37		 jbe	 SHORT $LN480@inflate

; 1172 :                     copy -= state->wnext;

  027af	0f ae e8	 lfence
  027b2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  027b7	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  027ba	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  027be	2b c8		 sub	 ecx, eax
  027c0	8b c1		 mov	 eax, ecx
  027c2	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 1173 :                     from = state->window + (state->wsize - copy);

  027c6	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  027cb	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  027cf	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  027d2	2b c1		 sub	 eax, ecx
  027d4	8b c0		 mov	 eax, eax
  027d6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  027db	48 03 41 40	 add	 rax, QWORD PTR [rcx+64]
  027df	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 1174 :                 }

  027e4	eb 21		 jmp	 SHORT $LN481@inflate
$LN480@inflate:

; 1175 :                 else
; 1176 :                     from = state->window + (state->wnext - copy);

  027e6	0f ae e8	 lfence
  027e9	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  027ee	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  027f2	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  027f5	2b c1		 sub	 eax, ecx
  027f7	8b c0		 mov	 eax, eax
  027f9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  027fe	48 03 41 40	 add	 rax, QWORD PTR [rcx+64]
  02802	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax
$LN481@inflate:

; 1177 :                 if (copy > state->length) copy = state->length;

  02807	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0280c	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0280f	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  02813	76 0c		 jbe	 SHORT $LN482@inflate
  02815	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0281a	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0281d	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN482@inflate:

; 1178 :             }

  02821	eb 27		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1179 :             else {                              /* copy from output */
; 1180 :                 from = put - state->offset;

  02823	0f ae e8	 lfence
  02826	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0282b	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0282e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR put$[rsp]
  02833	48 2b c8	 sub	 rcx, rax
  02836	48 8b c1	 mov	 rax, rcx
  02839	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 1181 :                 copy = state->length;

  0283e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02843	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  02846	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN477@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;

  0284a	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  0284e	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  02852	76 08		 jbe	 SHORT $LN483@inflate
  02854	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  02858	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
$LN483@inflate:

; 1184 :             left -= copy;

  0285c	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  02860	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  02864	2b c8		 sub	 ecx, eax
  02866	8b c1		 mov	 eax, ecx
  02868	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax

; 1185 :             state->length -= copy;

  0286c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02871	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  02875	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  02878	2b c1		 sub	 eax, ecx
  0287a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0287f	89 41 50	 mov	 DWORD PTR [rcx+80], eax
$LN306@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  02882	48 8b 44 24 40	 mov	 rax, QWORD PTR put$[rsp]
  02887	48 8b 4c 24 68	 mov	 rcx, QWORD PTR from$[rsp]
  0288c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0288f	88 08		 mov	 BYTE PTR [rax], cl
  02891	48 8b 44 24 40	 mov	 rax, QWORD PTR put$[rsp]
  02896	48 ff c0	 inc	 rax
  02899	48 89 44 24 40	 mov	 QWORD PTR put$[rsp], rax
  0289e	48 8b 44 24 68	 mov	 rax, QWORD PTR from$[rsp]
  028a3	48 ff c0	 inc	 rax
  028a6	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 1188 :             } while (--copy);

  028ab	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  028af	ff c8		 dec	 eax
  028b1	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax
  028b5	83 7c 24 60 00	 cmp	 DWORD PTR copy$[rsp], 0
  028ba	75 c6		 jne	 SHORT $LN306@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  028bc	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  028c1	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  028c5	75 0c		 jne	 SHORT $LN484@inflate
  028c7	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  028cc	c7 40 08 48 3f
	00 00		 mov	 DWORD PTR [rax+8], 16200 ; 00003f48H
$LN484@inflate:

; 1190 :             break;

  028d3	e9 5a 03 00 00	 jmp	 $LN8@inflate
$LN485@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  028d8	83 7c 24 4c 00	 cmp	 DWORD PTR left$[rsp], 0
  028dd	75 05		 jne	 SHORT $LN486@inflate
  028df	e9 53 03 00 00	 jmp	 $inf_leave$561
$LN486@inflate:

; 1193 :             *put++ = (unsigned char)(state->length);

  028e4	48 8b 44 24 40	 mov	 rax, QWORD PTR put$[rsp]
  028e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  028ee	0f b6 49 50	 movzx	 ecx, BYTE PTR [rcx+80]
  028f2	88 08		 mov	 BYTE PTR [rax], cl
  028f4	48 8b 44 24 40	 mov	 rax, QWORD PTR put$[rsp]
  028f9	48 ff c0	 inc	 rax
  028fc	48 89 44 24 40	 mov	 QWORD PTR put$[rsp], rax

; 1194 :             left--;

  02901	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  02905	ff c8		 dec	 eax
  02907	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax

; 1195 :             state->mode = LEN;

  0290b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02910	c7 40 08 48 3f
	00 00		 mov	 DWORD PTR [rax+8], 16200 ; 00003f48H

; 1196 :             break;

  02917	e9 16 03 00 00	 jmp	 $LN8@inflate
$LN487@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  0291c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02921	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02925	0f 84 01 02 00
	00		 je	 $LN488@inflate
$LN309@inflate:
$LN310@inflate:

; 1199 :                 NEEDBITS(32);

  0292b	83 7c 24 54 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  02930	73 50		 jae	 SHORT $LN311@inflate
$LN314@inflate:
  02932	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  02937	75 05		 jne	 SHORT $LN489@inflate
  02939	e9 f9 02 00 00	 jmp	 $inf_leave$561
$LN489@inflate:
  0293e	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  02942	ff c8		 dec	 eax
  02944	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  02948	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  0294d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02950	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  02954	d3 e0		 shl	 eax, cl
  02956	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  0295a	03 c8		 add	 ecx, eax
  0295c	8b c1		 mov	 eax, ecx
  0295e	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  02962	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  02967	48 ff c0	 inc	 rax
  0296a	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  0296f	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  02973	83 c0 08	 add	 eax, 8
  02976	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  0297a	33 c0		 xor	 eax, eax
  0297c	85 c0		 test	 eax, eax
  0297e	75 b2		 jne	 SHORT $LN314@inflate
  02980	eb a9		 jmp	 SHORT $LN310@inflate
$LN311@inflate:
  02982	33 c0		 xor	 eax, eax
  02984	85 c0		 test	 eax, eax
  02986	75 a3		 jne	 SHORT $LN309@inflate

; 1200 :                 out -= left;

  02988	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  0298c	8b 4c 24 5c	 mov	 ecx, DWORD PTR out$[rsp]
  02990	2b c8		 sub	 ecx, eax
  02992	8b c1		 mov	 eax, ecx
  02994	89 44 24 5c	 mov	 DWORD PTR out$[rsp], eax

; 1201 :                 strm->total_out += out;

  02998	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  029a0	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  029a3	03 44 24 5c	 add	 eax, DWORD PTR out$[rsp]
  029a7	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  029af	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1202 :                 state->total += out;

  029b2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  029b7	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  029ba	03 44 24 5c	 add	 eax, DWORD PTR out$[rsp]
  029be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  029c3	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 1203 :                 if ((state->wrap & 4) && out)

  029c6	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  029cb	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  029ce	83 e0 04	 and	 eax, 4
  029d1	85 c0		 test	 eax, eax
  029d3	0f 84 95 00 00
	00		 je	 $LN490@inflate
  029d9	83 7c 24 5c 00	 cmp	 DWORD PTR out$[rsp], 0
  029de	0f 84 8a 00 00
	00		 je	 $LN490@inflate

; 1204 :                     strm->adler = state->check =

  029e4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  029e9	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  029ed	74 30		 je	 SHORT $LN513@inflate
  029ef	0f ae e8	 lfence
  029f2	8b 44 24 5c	 mov	 eax, DWORD PTR out$[rsp]
  029f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR put$[rsp]
  029fb	48 2b c8	 sub	 rcx, rax
  029fe	48 8b c1	 mov	 rax, rcx
  02a01	44 8b 44 24 5c	 mov	 r8d, DWORD PTR out$[rsp]
  02a06	48 8b d0	 mov	 rdx, rax
  02a09	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02a0e	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  02a11	e8 00 00 00 00	 call	 crc32
  02a16	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv1333[rsp], eax
  02a1d	eb 2e		 jmp	 SHORT $LN514@inflate
$LN513@inflate:
  02a1f	0f ae e8	 lfence
  02a22	8b 44 24 5c	 mov	 eax, DWORD PTR out$[rsp]
  02a26	48 8b 4c 24 40	 mov	 rcx, QWORD PTR put$[rsp]
  02a2b	48 2b c8	 sub	 rcx, rax
  02a2e	48 8b c1	 mov	 rax, rcx
  02a31	44 8b 44 24 5c	 mov	 r8d, DWORD PTR out$[rsp]
  02a36	48 8b d0	 mov	 rdx, rax
  02a39	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02a3e	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  02a41	e8 00 00 00 00	 call	 adler32
  02a46	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv1333[rsp], eax
$LN514@inflate:
  02a4d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02a52	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv1333[rsp]
  02a59	89 48 20	 mov	 DWORD PTR [rax+32], ecx
  02a5c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02a64	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv1333[rsp]
  02a6b	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
$LN490@inflate:

; 1205 :                         UPDATE(state->check, put - out, out);
; 1206 :                 out = left;

  02a6e	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  02a72	89 44 24 5c	 mov	 DWORD PTR out$[rsp], eax

; 1207 :                 if ((state->wrap & 4) && (

  02a76	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02a7b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  02a7e	83 e0 04	 and	 eax, 4
  02a81	85 c0		 test	 eax, eax
  02a83	0f 84 8d 00 00
	00		 je	 $LN491@inflate
  02a89	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02a8e	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  02a92	74 0d		 je	 SHORT $LN515@inflate
  02a94	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  02a98	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv1350[rsp], eax
  02a9f	eb 40		 jmp	 SHORT $LN516@inflate
$LN515@inflate:
  02aa1	8b 44 24 50	 mov	 eax, DWORD PTR hold$[rsp]
  02aa5	c1 e8 18	 shr	 eax, 24
  02aa8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02aad	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  02ab1	c1 e9 08	 shr	 ecx, 8
  02ab4	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  02aba	03 c1		 add	 eax, ecx
  02abc	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  02ac0	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  02ac6	c1 e1 08	 shl	 ecx, 8
  02ac9	03 c1		 add	 eax, ecx
  02acb	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  02acf	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  02ad5	c1 e1 18	 shl	 ecx, 24
  02ad8	03 c1		 add	 eax, ecx
  02ada	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv1350[rsp], eax
$LN516@inflate:
  02ae1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02ae6	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  02ae9	39 84 24 24 01
	00 00		 cmp	 DWORD PTR tv1350[rsp], eax
  02af0	74 24		 je	 SHORT $LN491@inflate

; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {
; 1212 :                     strm->msg = (char *)"incorrect data check";

  02af2	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02afa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
  02b01	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1213 :                     state->mode = BAD;

  02b05	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02b0a	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 1214 :                     break;

  02b11	e9 1c 01 00 00	 jmp	 $LN8@inflate
$LN491@inflate:
$LN317@inflate:

; 1215 :                 }
; 1216 :                 INITBITS();

  02b16	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  02b1e	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  02b26	33 c0		 xor	 eax, eax
  02b28	85 c0		 test	 eax, eax
  02b2a	75 ea		 jne	 SHORT $LN317@inflate
$LN488@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  02b2c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02b31	c7 40 08 4f 3f
	00 00		 mov	 DWORD PTR [rax+8], 16207 ; 00003f4fH
$LN492@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  02b38	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02b3d	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02b41	0f 84 b1 00 00
	00		 je	 $LN493@inflate
  02b47	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02b4c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  02b50	0f 84 a2 00 00
	00		 je	 $LN493@inflate
$LN320@inflate:
$LN321@inflate:

; 1223 :                 NEEDBITS(32);

  02b56	83 7c 24 54 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  02b5b	73 50		 jae	 SHORT $LN322@inflate
$LN325@inflate:
  02b5d	83 7c 24 48 00	 cmp	 DWORD PTR have$[rsp], 0
  02b62	75 05		 jne	 SHORT $LN494@inflate
  02b64	e9 ce 00 00 00	 jmp	 $inf_leave$561
$LN494@inflate:
  02b69	8b 44 24 48	 mov	 eax, DWORD PTR have$[rsp]
  02b6d	ff c8		 dec	 eax
  02b6f	89 44 24 48	 mov	 DWORD PTR have$[rsp], eax
  02b73	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  02b78	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02b7b	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  02b7f	d3 e0		 shl	 eax, cl
  02b81	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  02b85	03 c8		 add	 ecx, eax
  02b87	8b c1		 mov	 eax, ecx
  02b89	89 44 24 50	 mov	 DWORD PTR hold$[rsp], eax
  02b8d	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  02b92	48 ff c0	 inc	 rax
  02b95	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax
  02b9a	8b 44 24 54	 mov	 eax, DWORD PTR bits$[rsp]
  02b9e	83 c0 08	 add	 eax, 8
  02ba1	89 44 24 54	 mov	 DWORD PTR bits$[rsp], eax
  02ba5	33 c0		 xor	 eax, eax
  02ba7	85 c0		 test	 eax, eax
  02ba9	75 b2		 jne	 SHORT $LN325@inflate
  02bab	eb a9		 jmp	 SHORT $LN321@inflate
$LN322@inflate:
  02bad	33 c0		 xor	 eax, eax
  02baf	85 c0		 test	 eax, eax
  02bb1	75 a3		 jne	 SHORT $LN320@inflate

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  02bb3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02bb8	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  02bbb	39 44 24 50	 cmp	 DWORD PTR hold$[rsp], eax
  02bbf	74 21		 je	 SHORT $LN495@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  02bc1	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02bc9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
  02bd0	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1226 :                     state->mode = BAD;

  02bd4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02bd9	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 1227 :                     break;

  02be0	eb 50		 jmp	 SHORT $LN8@inflate
$LN495@inflate:
$LN328@inflate:

; 1228 :                 }
; 1229 :                 INITBITS();

  02be2	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  02bea	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  02bf2	33 c0		 xor	 eax, eax
  02bf4	85 c0		 test	 eax, eax
  02bf6	75 ea		 jne	 SHORT $LN328@inflate
$LN493@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  02bf8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02bfd	c7 40 08 50 3f
	00 00		 mov	 DWORD PTR [rax+8], 16208 ; 00003f50H
$LN496@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  02c04	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ret$[rsp], 1

; 1236 :             goto inf_leave;

  02c0f	eb 26		 jmp	 SHORT $inf_leave$561
$LN497@inflate:

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  02c11	c7 84 24 a8 00
	00 00 fd ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -3

; 1239 :             goto inf_leave;

  02c1c	eb 19		 jmp	 SHORT $inf_leave$561
$LN498@inflate:

; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;

  02c1e	b8 fc ff ff ff	 mov	 eax, -4
  02c23	e9 f6 02 00 00	 jmp	 $LN1@inflate
$LN499@inflate:

; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;

  02c28	b8 fe ff ff ff	 mov	 eax, -2
  02c2d	e9 ec 02 00 00	 jmp	 $LN1@inflate
$LN8@inflate:

; 1245 :         }

  02c32	e9 e6 d4 ff ff	 jmp	 $LN5@inflate
$inf_leave$561:
$LN331@inflate:

; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  02c37	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02c3f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR put$[rsp]
  02c44	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  02c48	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02c50	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  02c54	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  02c57	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02c5f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  02c64	48 89 08	 mov	 QWORD PTR [rax], rcx
  02c67	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02c6f	8b 4c 24 48	 mov	 ecx, DWORD PTR have$[rsp]
  02c73	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  02c76	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02c7b	8b 4c 24 50	 mov	 ecx, DWORD PTR hold$[rsp]
  02c7f	89 48 48	 mov	 DWORD PTR [rax+72], ecx
  02c82	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02c87	8b 4c 24 54	 mov	 ecx, DWORD PTR bits$[rsp]
  02c8b	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
  02c8e	33 c0		 xor	 eax, eax
  02c90	85 c0		 test	 eax, eax
  02c92	75 a3		 jne	 SHORT $LN331@inflate

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  02c94	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02c99	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  02c9d	75 37		 jne	 SHORT $LN501@inflate
  02c9f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02ca7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02caa	39 44 24 5c	 cmp	 DWORD PTR out$[rsp], eax
  02cae	74 6f		 je	 SHORT $LN500@inflate
  02cb0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02cb5	81 78 08 51 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16209 ; 00003f51H
  02cbc	7d 61		 jge	 SHORT $LN500@inflate
  02cbe	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02cc3	81 78 08 4e 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16206 ; 00003f4eH
  02cca	7c 0a		 jl	 SHORT $LN502@inflate
  02ccc	83 bc 24 58 01
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  02cd4	74 49		 je	 SHORT $LN500@inflate
$LN502@inflate:
$LN501@inflate:

; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  02cd6	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02cde	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02ce1	8b 4c 24 5c	 mov	 ecx, DWORD PTR out$[rsp]
  02ce5	2b c8		 sub	 ecx, eax
  02ce7	8b c1		 mov	 eax, ecx
  02ce9	44 8b c0	 mov	 r8d, eax
  02cec	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02cf4	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  02cf8	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02d00	e8 00 00 00 00	 call	 updatewindow
  02d05	85 c0		 test	 eax, eax
  02d07	74 16		 je	 SHORT $LN503@inflate

; 1258 :             state->mode = MEM;

  02d09	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02d0e	c7 40 08 52 3f
	00 00		 mov	 DWORD PTR [rax+8], 16210 ; 00003f52H

; 1259 :             return Z_MEM_ERROR;

  02d15	b8 fc ff ff ff	 mov	 eax, -4
  02d1a	e9 ff 01 00 00	 jmp	 $LN1@inflate
$LN503@inflate:
$LN500@inflate:

; 1260 :         }
; 1261 :     in -= strm->avail_in;

  02d1f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02d27	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  02d2a	8b 4c 24 58	 mov	 ecx, DWORD PTR in$[rsp]
  02d2e	2b c8		 sub	 ecx, eax
  02d30	8b c1		 mov	 eax, ecx
  02d32	89 44 24 58	 mov	 DWORD PTR in$[rsp], eax

; 1262 :     out -= strm->avail_out;

  02d36	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02d3e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02d41	8b 4c 24 5c	 mov	 ecx, DWORD PTR out$[rsp]
  02d45	2b c8		 sub	 ecx, eax
  02d47	8b c1		 mov	 eax, ecx
  02d49	89 44 24 5c	 mov	 DWORD PTR out$[rsp], eax

; 1263 :     strm->total_in += in;

  02d4d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02d55	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  02d58	03 44 24 58	 add	 eax, DWORD PTR in$[rsp]
  02d5c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02d64	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 1264 :     strm->total_out += out;

  02d67	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02d6f	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  02d72	03 44 24 5c	 add	 eax, DWORD PTR out$[rsp]
  02d76	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02d7e	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1265 :     state->total += out;

  02d81	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02d86	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  02d89	03 44 24 5c	 add	 eax, DWORD PTR out$[rsp]
  02d8d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  02d92	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 1266 :     if ((state->wrap & 4) && out)

  02d95	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02d9a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  02d9d	83 e0 04	 and	 eax, 4
  02da0	85 c0		 test	 eax, eax
  02da2	0f 84 9d 00 00
	00		 je	 $LN504@inflate
  02da8	83 7c 24 5c 00	 cmp	 DWORD PTR out$[rsp], 0
  02dad	0f 84 92 00 00
	00		 je	 $LN504@inflate

; 1267 :         strm->adler = state->check =

  02db3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02db8	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  02dbc	74 34		 je	 SHORT $LN517@inflate
  02dbe	8b 44 24 5c	 mov	 eax, DWORD PTR out$[rsp]
  02dc2	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02dca	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  02dce	48 2b c8	 sub	 rcx, rax
  02dd1	48 8b c1	 mov	 rax, rcx
  02dd4	44 8b 44 24 5c	 mov	 r8d, DWORD PTR out$[rsp]
  02dd9	48 8b d0	 mov	 rdx, rax
  02ddc	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02de1	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  02de4	e8 00 00 00 00	 call	 crc32
  02de9	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv1441[rsp], eax
  02df0	eb 32		 jmp	 SHORT $LN518@inflate
$LN517@inflate:
  02df2	8b 44 24 5c	 mov	 eax, DWORD PTR out$[rsp]
  02df6	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02dfe	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  02e02	48 2b c8	 sub	 rcx, rax
  02e05	48 8b c1	 mov	 rax, rcx
  02e08	44 8b 44 24 5c	 mov	 r8d, DWORD PTR out$[rsp]
  02e0d	48 8b d0	 mov	 rdx, rax
  02e10	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02e15	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  02e18	e8 00 00 00 00	 call	 adler32
  02e1d	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv1441[rsp], eax
$LN518@inflate:
  02e24	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02e29	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv1441[rsp]
  02e30	89 48 20	 mov	 DWORD PTR [rax+32], ecx
  02e33	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02e3b	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv1441[rsp]
  02e42	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
$LN504@inflate:

; 1268 :             UPDATE(state->check, strm->next_out - out, out);
; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  02e45	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02e4a	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  02e4e	74 0d		 je	 SHORT $LN519@inflate
  02e50	c7 84 24 2c 01
	00 00 40 00 00
	00		 mov	 DWORD PTR tv1446[rsp], 64 ; 00000040H
  02e5b	eb 0b		 jmp	 SHORT $LN520@inflate
$LN519@inflate:
  02e5d	c7 84 24 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1446[rsp], 0
$LN520@inflate:
  02e68	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02e6d	81 78 08 3f 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16191 ; 00003f3fH
  02e74	75 0d		 jne	 SHORT $LN521@inflate
  02e76	c7 84 24 30 01
	00 00 80 00 00
	00		 mov	 DWORD PTR tv1450[rsp], 128 ; 00000080H
  02e81	eb 0b		 jmp	 SHORT $LN522@inflate
$LN521@inflate:
  02e83	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1450[rsp], 0
$LN522@inflate:
  02e8e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02e93	81 78 08 47 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16199 ; 00003f47H
  02e9a	74 1b		 je	 SHORT $LN523@inflate
  02e9c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02ea1	81 78 08 42 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16194 ; 00003f42H
  02ea8	74 0d		 je	 SHORT $LN523@inflate
  02eaa	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1456[rsp], 0
  02eb5	eb 0b		 jmp	 SHORT $LN524@inflate
$LN523@inflate:
  02eb7	c7 84 24 34 01
	00 00 00 01 00
	00		 mov	 DWORD PTR tv1456[rsp], 256 ; 00000100H
$LN524@inflate:
  02ec2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  02ec7	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  02eca	03 84 24 2c 01
	00 00		 add	 eax, DWORD PTR tv1446[rsp]
  02ed1	03 84 24 30 01
	00 00		 add	 eax, DWORD PTR tv1450[rsp]
  02ed8	03 84 24 34 01
	00 00		 add	 eax, DWORD PTR tv1456[rsp]
  02edf	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02ee7	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  02eea	83 7c 24 58 00	 cmp	 DWORD PTR in$[rsp], 0
  02eef	75 07		 jne	 SHORT $LN507@inflate
  02ef1	83 7c 24 5c 00	 cmp	 DWORD PTR out$[rsp], 0
  02ef6	74 0a		 je	 SHORT $LN506@inflate
$LN507@inflate:
  02ef8	83 bc 24 58 01
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  02f00	75 15		 jne	 SHORT $LN505@inflate
$LN506@inflate:
  02f02	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR ret$[rsp], 0
  02f0a	75 0b		 jne	 SHORT $LN505@inflate

; 1273 :         ret = Z_BUF_ERROR;

  02f0c	c7 84 24 a8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
$LN505@inflate:

; 1274 :     return ret;

  02f17	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ret$[rsp]
$LN1@inflate:

; 1275 : }

  02f1e	48 8b f8	 mov	 rdi, rax
  02f21	48 8b cc	 mov	 rcx, rsp
  02f24	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:inflate$rtcFrameData
  02f2b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  02f30	48 8b c7	 mov	 rax, rdi
  02f33	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  02f3a	5f		 pop	 rdi
  02f3b	c3		 ret	 0
$LN559@inflate:
  02f3c	00 00 00 00	 DD	 $LN335@inflate
  02f40	00 00 00 00	 DD	 $LN347@inflate
  02f44	00 00 00 00	 DD	 $LN353@inflate
  02f48	00 00 00 00	 DD	 $LN357@inflate
  02f4c	00 00 00 00	 DD	 $LN361@inflate
  02f50	00 00 00 00	 DD	 $LN368@inflate
  02f54	00 00 00 00	 DD	 $LN375@inflate
  02f58	00 00 00 00	 DD	 $LN384@inflate
  02f5c	00 00 00 00	 DD	 $LN393@inflate
  02f60	00 00 00 00	 DD	 $LN398@inflate
  02f64	00 00 00 00	 DD	 $LN400@inflate
  02f68	00 00 00 00	 DD	 $LN402@inflate
  02f6c	00 00 00 00	 DD	 $LN405@inflate
  02f70	00 00 00 00	 DD	 $LN413@inflate
  02f74	00 00 00 00	 DD	 $LN417@inflate
  02f78	00 00 00 00	 DD	 $LN418@inflate
  02f7c	00 00 00 00	 DD	 $LN423@inflate
  02f80	00 00 00 00	 DD	 $LN427@inflate
  02f84	00 00 00 00	 DD	 $LN430@inflate
  02f88	00 00 00 00	 DD	 $LN449@inflate
  02f8c	00 00 00 00	 DD	 $LN450@inflate
  02f90	00 00 00 00	 DD	 $LN461@inflate
  02f94	00 00 00 00	 DD	 $LN464@inflate
  02f98	00 00 00 00	 DD	 $LN471@inflate
  02f9c	00 00 00 00	 DD	 $LN474@inflate
  02fa0	00 00 00 00	 DD	 $LN485@inflate
  02fa4	00 00 00 00	 DD	 $LN487@inflate
  02fa8	00 00 00 00	 DD	 $LN492@inflate
  02fac	00 00 00 00	 DD	 $LN496@inflate
  02fb0	00 00 00 00	 DD	 $LN497@inflate
  02fb4	00 00 00 00	 DD	 $LN498@inflate
inflate	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateEnd
_TEXT	SEGMENT
state$ = 32
strm$ = 64
inflateEnd PROC						; COMDAT

; 1279 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0002f	e8 00 00 00 00	 call	 inflateStateCheck
  00034	85 c0		 test	 eax, eax
  00036	74 07		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00038	b8 fe ff ff ff	 mov	 eax, -2
  0003d	eb 5d		 jmp	 SHORT $LN1@inflateEnd
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00048	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00052	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00057	74 1a		 je	 SHORT $LN3@inflateEnd
  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005e	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00067	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00070	ff 50 38	 call	 QWORD PTR [rax+56]
$LN3@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00078	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00081	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0008a	ff 50 38	 call	 QWORD PTR [rax+56]

; 1286 :     strm->state = Z_NULL;

  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00092	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  0009a	33 c0		 xor	 eax, eax
$LN1@inflateEnd:

; 1289 : }

  0009c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateStateCheck
_TEXT	SEGMENT
state$ = 32
strm$ = 64
inflateStateCheck PROC					; COMDAT

; 107  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00030	74 18		 je	 SHORT $LN3@inflateSta
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00037	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0003c	74 0c		 je	 SHORT $LN3@inflateSta
  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00043	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00048	75 07		 jne	 SHORT $LN2@inflateSta
$LN3@inflateSta:

; 111  :         return 1;

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	eb 4a		 jmp	 SHORT $LN1@inflateSta
$LN2@inflateSta:

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00056	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005a	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  0005f	48 83 7c 24 20
	00		 cmp	 QWORD PTR state$[rsp], 0
  00065	74 2b		 je	 SHORT $LN5@inflateSta
  00067	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00071	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00074	75 1c		 jne	 SHORT $LN5@inflateSta
  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0007b	81 78 08 34 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16180 ; 00003f34H
  00082	7c 0e		 jl	 SHORT $LN5@inflateSta
  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00089	81 78 08 53 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16211 ; 00003f53H
  00090	7e 07		 jle	 SHORT $LN4@inflateSta
$LN5@inflateSta:

; 115  :         return 1;

  00092	b8 01 00 00 00	 mov	 eax, 1
  00097	eb 02		 jmp	 SHORT $LN1@inflateSta
$LN4@inflateSta:

; 116  :     return 0;

  00099	33 c0		 xor	 eax, eax
$LN1@inflateSta:

; 117  : }

  0009b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateResetKeep
_TEXT	SEGMENT
state$ = 32
tv87 = 40
strm$ = 64
inflateResetKeep PROC					; COMDAT

; 121  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0002f	e8 00 00 00 00	 call	 inflateStateCheck
  00034	85 c0		 test	 eax, eax
  00036	74 0a		 je	 SHORT $LN2@inflateRes
  00038	b8 fe ff ff ff	 mov	 eax, -2
  0003d	e9 0f 01 00 00	 jmp	 $LN1@inflateRes
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00047	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004b	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00055	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00061	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0006d	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 127  :     strm->msg = Z_NULL;

  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00079	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00086	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  0008a	74 13		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  0008c	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00091	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00094	83 e0 01	 and	 eax, 1
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0009c	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;

  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000a4	c7 40 08 34 3f
	00 00		 mov	 DWORD PTR [rax+8], 16180 ; 00003f34H

; 131  :     state->last = 0;

  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000b0	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 132  :     state->havedict = 0;

  000b7	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000bc	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 133  :     state->dmax = 32768U;

  000c3	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000c8	c7 40 1c 00 80
	00 00		 mov	 DWORD PTR [rax+28], 32768 ; 00008000H

; 134  :     state->head = Z_NULL;

  000cf	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000d4	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 135  :     state->hold = 0;

  000dc	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000e1	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 136  :     state->bits = 0;

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000ed	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [rax+76], 0

; 137  :     state->lencode = state->distcode = state->next = state->codes;

  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000f9	48 05 50 05 00
	00		 add	 rax, 1360		; 00000550H
  000ff	48 89 44 24 28	 mov	 QWORD PTR tv87[rsp], rax
  00104	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00109	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv87[rsp]
  0010e	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx
  00115	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0011a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv87[rsp]
  0011f	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
  00123	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00128	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv87[rsp]
  0012d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 138  :     state->sane = 1;

  00131	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00136	c7 80 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7136], 1

; 139  :     state->back = -1;

  00140	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00145	c7 80 e4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+7140], -1

; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  0014f	33 c0		 xor	 eax, eax
$LN1@inflateRes:

; 142  : }

  00151	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00155	5f		 pop	 rdi
  00156	c3		 ret	 0
inflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateReset2
_TEXT	SEGMENT
wrap$ = 32
state$ = 40
strm$ = 64
windowBits$ = 72
inflateReset2 PROC					; COMDAT

; 160  : {

$LN11:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00033	e8 00 00 00 00	 call	 inflateStateCheck
  00038	85 c0		 test	 eax, eax
  0003a	74 0a		 je	 SHORT $LN2@inflateRes
  0003c	b8 fe ff ff ff	 mov	 eax, -2
  00041	e9 c8 00 00 00	 jmp	 $LN1@inflateRes
$LN2@inflateRes:

; 166  :     state = (struct inflate_state FAR *)strm->state;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0004b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004f	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00054	83 7c 24 48 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  00059	7d 14		 jge	 SHORT $LN3@inflateRes

; 170  :         wrap = 0;

  0005b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 0

; 171  :         windowBits = -windowBits;

  00063	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  00067	f7 d8		 neg	 eax
  00069	89 44 24 48	 mov	 DWORD PTR windowBits$[rsp], eax

; 172  :     }

  0006d	eb 20		 jmp	 SHORT $LN4@inflateRes
$LN3@inflateRes:

; 173  :     else {
; 174  :         wrap = (windowBits >> 4) + 5;

  0006f	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  00073	c1 f8 04	 sar	 eax, 4
  00076	83 c0 05	 add	 eax, 5
  00079	89 44 24 20	 mov	 DWORD PTR wrap$[rsp], eax

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  0007d	83 7c 24 48 30	 cmp	 DWORD PTR windowBits$[rsp], 48 ; 00000030H
  00082	7d 0b		 jge	 SHORT $LN5@inflateRes

; 177  :             windowBits &= 15;

  00084	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  00088	83 e0 0f	 and	 eax, 15
  0008b	89 44 24 48	 mov	 DWORD PTR windowBits$[rsp], eax
$LN5@inflateRes:
$LN4@inflateRes:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  0008f	83 7c 24 48 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  00094	74 15		 je	 SHORT $LN6@inflateRes
  00096	83 7c 24 48 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  0009b	7c 07		 jl	 SHORT $LN7@inflateRes
  0009d	83 7c 24 48 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  000a2	7e 07		 jle	 SHORT $LN6@inflateRes
$LN7@inflateRes:

; 183  :         return Z_STREAM_ERROR;

  000a4	b8 fe ff ff ff	 mov	 eax, -2
  000a9	eb 63		 jmp	 SHORT $LN1@inflateRes
$LN6@inflateRes:

; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000b0	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  000b5	74 35		 je	 SHORT $LN8@inflateRes
  000b7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000bc	8b 4c 24 48	 mov	 ecx, DWORD PTR windowBits$[rsp]
  000c0	39 48 30	 cmp	 DWORD PTR [rax+48], ecx
  000c3	74 27		 je	 SHORT $LN8@inflateRes

; 185  :         ZFREE(strm, state->window);

  000c5	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ca	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  000ce	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d3	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000dc	ff 50 38	 call	 QWORD PTR [rax+56]

; 186  :         state->window = Z_NULL;

  000df	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e4	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN8@inflateRes:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;

  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000f1	8b 4c 24 20	 mov	 ecx, DWORD PTR wrap$[rsp]
  000f5	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 191  :     state->wbits = (unsigned)windowBits;

  000f8	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000fd	8b 4c 24 48	 mov	 ecx, DWORD PTR windowBits$[rsp]
  00101	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 192  :     return inflateReset(strm);

  00104	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00109	e8 00 00 00 00	 call	 inflateReset
$LN1@inflateRes:

; 193  : }

  0010e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00112	5f		 pop	 rdi
  00113	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 48
version$ = 56
stream_size$ = 64
inflateInit_ PROC					; COMDAT

; 243  : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00034	44 8b 4c 24 40	 mov	 r9d, DWORD PTR stream_size$[rsp]
  00039	4c 8b 44 24 38	 mov	 r8, QWORD PTR version$[rsp]
  0003e	ba 0f 00 00 00	 mov	 edx, 15
  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strm$[rsp]
  00048	e8 00 00 00 00	 call	 inflateInit2_

; 245  : }

  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflatePrime
_TEXT	SEGMENT
state$ = 32
tv136 = 40
strm$ = 64
bits$ = 72
value$ = 80
inflatePrime PROC					; COMDAT

; 251  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00038	e8 00 00 00 00	 call	 inflateStateCheck
  0003d	85 c0		 test	 eax, eax
  0003f	74 0a		 je	 SHORT $LN2@inflatePri
  00041	b8 fe ff ff ff	 mov	 eax, -2
  00046	e9 ab 00 00 00	 jmp	 $LN1@inflatePri
$LN2@inflatePri:

; 255  :     state = (struct inflate_state FAR *)strm->state;

  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00050	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00054	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 256  :     if (bits < 0) {

  00059	83 7c 24 48 00	 cmp	 DWORD PTR bits$[rsp], 0
  0005e	7d 1c		 jge	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00065	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 258  :         state->bits = 0;

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00071	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [rax+76], 0

; 259  :         return Z_OK;

  00078	33 c0		 xor	 eax, eax
  0007a	eb 7a		 jmp	 SHORT $LN1@inflatePri
$LN3@inflatePri:

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  0007c	83 7c 24 48 10	 cmp	 DWORD PTR bits$[rsp], 16
  00081	7f 11		 jg	 SHORT $LN5@inflatePri
  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00088	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008b	03 44 24 48	 add	 eax, DWORD PTR bits$[rsp]
  0008f	83 f8 20	 cmp	 eax, 32			; 00000020H
  00092	76 07		 jbe	 SHORT $LN4@inflatePri
$LN5@inflatePri:
  00094	b8 fe ff ff ff	 mov	 eax, -2
  00099	eb 5b		 jmp	 SHORT $LN1@inflatePri
$LN4@inflatePri:

; 262  :     value &= (1L << bits) - 1;

  0009b	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0009f	b9 01 00 00 00	 mov	 ecx, 1
  000a4	89 4c 24 28	 mov	 DWORD PTR tv136[rsp], ecx
  000a8	0f b6 c8	 movzx	 ecx, al
  000ab	8b 44 24 28	 mov	 eax, DWORD PTR tv136[rsp]
  000af	d3 e0		 shl	 eax, cl
  000b1	ff c8		 dec	 eax
  000b3	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000b7	23 c8		 and	 ecx, eax
  000b9	8b c1		 mov	 eax, ecx
  000bb	89 44 24 50	 mov	 DWORD PTR value$[rsp], eax

; 263  :     state->hold += (unsigned)value << state->bits;

  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000c4	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000c7	0f b6 c8	 movzx	 ecx, al
  000ca	8b 44 24 50	 mov	 eax, DWORD PTR value$[rsp]
  000ce	d3 e0		 shl	 eax, cl
  000d0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000d5	03 41 48	 add	 eax, DWORD PTR [rcx+72]
  000d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000dd	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 264  :     state->bits += (uInt)bits;

  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000e5	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000e8	03 44 24 48	 add	 eax, DWORD PTR bits$[rsp]
  000ec	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000f1	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 265  :     return Z_OK;

  000f4	33 c0		 xor	 eax, eax
$LN1@inflatePri:

; 266  : }

  000f6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fa	5f		 pop	 rdi
  000fb	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 48
fixedtables PROC					; COMDAT

; 280  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9
  00036	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 316  :     state->lenbits = 9;

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0003f	c7 40 70 09 00
	00 00		 mov	 DWORD PTR [rax+112], 9

; 317  :     state->distcode = distfix;

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00052	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 318  :     state->distbits = 5;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0005b	c7 40 74 05 00
	00 00		 mov	 DWORD PTR [rax+116], 5

; 319  : }

  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT updatewindow
_TEXT	SEGMENT
state$ = 32
dist$ = 40
tv184 = 44
tv193 = 48
tv144 = 56
strm$ = 80
end$ = 88
copy$ = 96
updatewindow PROC					; COMDAT

; 400  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 10 00 00 00	 mov	 ecx, 16
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;

  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00039	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003d	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00047	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  0004c	75 52		 jne	 SHORT $LN2@updatewind

; 408  :         state->window = (unsigned char FAR *)

  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00053	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00056	b9 01 00 00 00	 mov	 ecx, 1
  0005b	89 4c 24 2c	 mov	 DWORD PTR tv184[rsp], ecx
  0005f	0f b6 c8	 movzx	 ecx, al
  00062	8b 44 24 2c	 mov	 eax, DWORD PTR tv184[rsp]
  00066	d3 e0		 shl	 eax, cl
  00068	41 b8 01 00 00
	00		 mov	 r8d, 1
  0006e	8b d0		 mov	 edx, eax
  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00075	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0007e	ff 50 30	 call	 QWORD PTR [rax+48]
  00081	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00086	48 89 41 40	 mov	 QWORD PTR [rcx+64], rax

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  0008a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0008f	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00094	75 0a		 jne	 SHORT $LN3@updatewind
  00096	b8 01 00 00 00	 mov	 eax, 1
  0009b	e9 c6 01 00 00	 jmp	 $LN1@updatewind
$LN3@updatewind:
$LN2@updatewind:

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000a5	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  000a9	75 3a		 jne	 SHORT $LN4@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  000ab	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000b0	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000b3	b9 01 00 00 00	 mov	 ecx, 1
  000b8	89 4c 24 30	 mov	 DWORD PTR tv193[rsp], ecx
  000bc	0f b6 c8	 movzx	 ecx, al
  000bf	8b 44 24 30	 mov	 eax, DWORD PTR tv193[rsp]
  000c3	d3 e0		 shl	 eax, cl
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000ca	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 417  :         state->wnext = 0;

  000cd	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000d2	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0

; 418  :         state->whave = 0;

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000de	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0
$LN4@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000ea	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  000ed	39 44 24 60	 cmp	 DWORD PTR copy$[rsp], eax
  000f1	72 51		 jb	 SHORT $LN5@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  000f3	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000f8	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  000fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00100	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  00103	48 8b 54 24 58	 mov	 rdx, QWORD PTR end$[rsp]
  00108	48 2b d1	 sub	 rdx, rcx
  0010b	48 8b ca	 mov	 rcx, rdx
  0010e	44 8b c0	 mov	 r8d, eax
  00111	48 8b d1	 mov	 rdx, rcx
  00114	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00119	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 424  :         state->wnext = 0;

  00123	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00128	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0

; 425  :         state->whave = state->wsize;

  0012f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00134	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00139	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  0013c	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 426  :     }

  0013f	e9 20 01 00 00	 jmp	 $LN6@updatewind
$LN5@updatewind:

; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  00144	0f ae e8	 lfence
  00147	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0014c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00151	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00154	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00157	2b c1		 sub	 eax, ecx
  00159	89 44 24 28	 mov	 DWORD PTR dist$[rsp], eax

; 429  :         if (dist > copy) dist = copy;

  0015d	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  00161	39 44 24 28	 cmp	 DWORD PTR dist$[rsp], eax
  00165	76 08		 jbe	 SHORT $LN7@updatewind
  00167	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  0016b	89 44 24 28	 mov	 DWORD PTR dist$[rsp], eax
$LN7@updatewind:

; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  0016f	8b 44 24 28	 mov	 eax, DWORD PTR dist$[rsp]
  00173	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  00177	48 8b 54 24 58	 mov	 rdx, QWORD PTR end$[rsp]
  0017c	48 2b d1	 sub	 rdx, rcx
  0017f	48 8b ca	 mov	 rcx, rdx
  00182	48 8b 54 24 20	 mov	 rdx, QWORD PTR state$[rsp]
  00187	8b 52 3c	 mov	 edx, DWORD PTR [rdx+60]
  0018a	4c 8b 44 24 20	 mov	 r8, QWORD PTR state$[rsp]
  0018f	49 03 50 40	 add	 rdx, QWORD PTR [r8+64]
  00193	48 89 54 24 38	 mov	 QWORD PTR tv144[rsp], rdx
  00198	44 8b c0	 mov	 r8d, eax
  0019b	48 8b d1	 mov	 rdx, rcx
  0019e	48 8b 44 24 38	 mov	 rax, QWORD PTR tv144[rsp]
  001a3	48 8b c8	 mov	 rcx, rax
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 431  :         copy -= dist;

  001ac	8b 44 24 28	 mov	 eax, DWORD PTR dist$[rsp]
  001b0	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  001b4	2b c8		 sub	 ecx, eax
  001b6	8b c1		 mov	 eax, ecx
  001b8	89 44 24 60	 mov	 DWORD PTR copy$[rsp], eax

; 432  :         if (copy) {

  001bc	83 7c 24 60 00	 cmp	 DWORD PTR copy$[rsp], 0
  001c1	74 49		 je	 SHORT $LN8@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  001c3	0f ae e8	 lfence
  001c6	8b 44 24 60	 mov	 eax, DWORD PTR copy$[rsp]
  001ca	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  001ce	48 8b 54 24 58	 mov	 rdx, QWORD PTR end$[rsp]
  001d3	48 2b d1	 sub	 rdx, rcx
  001d6	48 8b ca	 mov	 rcx, rdx
  001d9	44 8b c0	 mov	 r8d, eax
  001dc	48 8b d1	 mov	 rdx, rcx
  001df	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001e4	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  001e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 434  :             state->wnext = copy;

  001ee	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001f3	8b 4c 24 60	 mov	 ecx, DWORD PTR copy$[rsp]
  001f7	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 435  :             state->whave = state->wsize;

  001fa	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001ff	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00204	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  00207	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 436  :         }

  0020a	eb 58		 jmp	 SHORT $LN9@updatewind
$LN8@updatewind:

; 437  :         else {
; 438  :             state->wnext += dist;

  0020c	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00211	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00214	03 44 24 28	 add	 eax, DWORD PTR dist$[rsp]
  00218	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0021d	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  00220	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00225	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0022a	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  0022d	39 48 3c	 cmp	 DWORD PTR [rax+60], ecx
  00230	75 0c		 jne	 SHORT $LN10@updatewind
  00232	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00237	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0
$LN10@updatewind:

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  0023e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00243	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00248	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  0024b	39 48 38	 cmp	 DWORD PTR [rax+56], ecx
  0024e	73 14		 jae	 SHORT $LN11@updatewind
  00250	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00255	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00258	03 44 24 28	 add	 eax, DWORD PTR dist$[rsp]
  0025c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00261	89 41 38	 mov	 DWORD PTR [rcx+56], eax
$LN11@updatewind:
$LN9@updatewind:
$LN6@updatewind:

; 441  :         }
; 442  :     }
; 443  :     return 0;

  00264	33 c0		 xor	 eax, eax
$LN1@updatewind:

; 444  : }

  00266	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0026a	5f		 pop	 rdi
  0026b	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateGetDictionary
_TEXT	SEGMENT
state$ = 32
strm$ = 64
dictionary$ = 72
dictLength$ = 80
inflateGetDictionary PROC				; COMDAT

; 1295 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00039	e8 00 00 00 00	 call	 inflateStateCheck
  0003e	85 c0		 test	 eax, eax
  00040	74 0a		 je	 SHORT $LN2@inflateGet
  00042	b8 fe ff ff ff	 mov	 eax, -2
  00047	e9 a8 00 00 00	 jmp	 $LN1@inflateGet
$LN2@inflateGet:

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00051	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00055	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005f	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00063	74 76		 je	 SHORT $LN3@inflateGet
  00065	48 83 7c 24 48
	00		 cmp	 QWORD PTR dictionary$[rsp], 0
  0006b	74 6e		 je	 SHORT $LN3@inflateGet

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,

  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00077	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  0007a	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0007d	2b c1		 sub	 eax, ecx
  0007f	8b c0		 mov	 eax, eax
  00081	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00086	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00089	48 8b 54 24 20	 mov	 rdx, QWORD PTR state$[rsp]
  0008e	48 03 4a 40	 add	 rcx, QWORD PTR [rdx+64]
  00092	44 8b c0	 mov	 r8d, eax
  00095	48 8b d1	 mov	 rdx, rcx
  00098	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dictionary$[rsp]
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1305 :                 state->whave - state->wnext);
; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,

  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000a8	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  000ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000b0	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  000b3	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  000b8	48 03 d1	 add	 rdx, rcx
  000bb	48 8b ca	 mov	 rcx, rdx
  000be	48 8b 54 24 20	 mov	 rdx, QWORD PTR state$[rsp]
  000c3	8b 52 3c	 mov	 edx, DWORD PTR [rdx+60]
  000c6	48 2b ca	 sub	 rcx, rdx
  000c9	44 8b c0	 mov	 r8d, eax
  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000d1	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy
$LN3@inflateGet:

; 1307 :                 state->window, state->wnext);
; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  000db	48 83 7c 24 50
	00		 cmp	 QWORD PTR dictLength$[rsp], 0
  000e1	74 0f		 je	 SHORT $LN4@inflateGet

; 1310 :         *dictLength = state->whave;

  000e3	48 8b 44 24 50	 mov	 rax, QWORD PTR dictLength$[rsp]
  000e8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000ed	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  000f0	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@inflateGet:

; 1311 :     return Z_OK;

  000f2	33 c0		 xor	 eax, eax
$LN1@inflateGet:

; 1312 : }

  000f4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0
inflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
state$ = 32
dictid$ = 40
ret$ = 44
strm$ = 64
dictionary$ = 72
dictLength$ = 80
inflateSetDictionary PROC				; COMDAT

; 1318 : {

$LN10:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00039	e8 00 00 00 00	 call	 inflateStateCheck
  0003e	85 c0		 test	 eax, eax
  00040	74 0a		 je	 SHORT $LN2@inflateSet
  00042	b8 fe ff ff ff	 mov	 eax, -2
  00047	e9 c8 00 00 00	 jmp	 $LN1@inflateSet
$LN2@inflateSet:

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00051	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00055	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005f	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00063	74 18		 je	 SHORT $LN3@inflateSet
  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006a	81 78 08 3e 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16190 ; 00003f3eH
  00071	74 0a		 je	 SHORT $LN3@inflateSet

; 1327 :         return Z_STREAM_ERROR;

  00073	b8 fe ff ff ff	 mov	 eax, -2
  00078	e9 97 00 00 00	 jmp	 $LN1@inflateSet
$LN3@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00082	81 78 08 3e 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16190 ; 00003f3eH
  00089	75 3c		 jne	 SHORT $LN4@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);

  0008b	45 33 c0	 xor	 r8d, r8d
  0008e	33 d2		 xor	 edx, edx
  00090	33 c9		 xor	 ecx, ecx
  00092	e8 00 00 00 00	 call	 adler32
  00097	89 44 24 28	 mov	 DWORD PTR dictid$[rsp], eax

; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  0009b	44 8b 44 24 50	 mov	 r8d, DWORD PTR dictLength$[rsp]
  000a0	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  000a5	8b 4c 24 28	 mov	 ecx, DWORD PTR dictid$[rsp]
  000a9	e8 00 00 00 00	 call	 adler32
  000ae	89 44 24 28	 mov	 DWORD PTR dictid$[rsp], eax

; 1333 :         if (dictid != state->check)

  000b2	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000b7	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  000ba	39 44 24 28	 cmp	 DWORD PTR dictid$[rsp], eax
  000be	74 07		 je	 SHORT $LN5@inflateSet

; 1334 :             return Z_DATA_ERROR;

  000c0	b8 fd ff ff ff	 mov	 eax, -3
  000c5	eb 4d		 jmp	 SHORT $LN1@inflateSet
$LN5@inflateSet:
$LN4@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  000c7	8b 44 24 50	 mov	 eax, DWORD PTR dictLength$[rsp]
  000cb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dictionary$[rsp]
  000d0	48 03 c8	 add	 rcx, rax
  000d3	48 8b c1	 mov	 rax, rcx
  000d6	44 8b 44 24 50	 mov	 r8d, DWORD PTR dictLength$[rsp]
  000db	48 8b d0	 mov	 rdx, rax
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000e3	e8 00 00 00 00	 call	 updatewindow
  000e8	89 44 24 2c	 mov	 DWORD PTR ret$[rsp], eax

; 1340 :     if (ret) {

  000ec	83 7c 24 2c 00	 cmp	 DWORD PTR ret$[rsp], 0
  000f1	74 13		 je	 SHORT $LN6@inflateSet

; 1341 :         state->mode = MEM;

  000f3	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000f8	c7 40 08 52 3f
	00 00		 mov	 DWORD PTR [rax+8], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  000ff	b8 fc ff ff ff	 mov	 eax, -4
  00104	eb 0e		 jmp	 SHORT $LN1@inflateSet
$LN6@inflateSet:

; 1343 :     }
; 1344 :     state->havedict = 1;

  00106	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0010b	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  00112	33 c0		 xor	 eax, eax
$LN1@inflateSet:

; 1347 : }

  00114	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00118	5f		 pop	 rdi
  00119	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
state$ = 32
strm$ = 64
head$ = 72
inflateGetHeader PROC					; COMDAT

; 1352 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00034	e8 00 00 00 00	 call	 inflateStateCheck
  00039	85 c0		 test	 eax, eax
  0003b	74 07		 je	 SHORT $LN2@inflateGet
  0003d	b8 fe ff ff ff	 mov	 eax, -2
  00042	eb 40		 jmp	 SHORT $LN1@inflateGet
$LN2@inflateGet:

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00049	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004d	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00057	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0005a	83 e0 02	 and	 eax, 2
  0005d	85 c0		 test	 eax, eax
  0005f	75 07		 jne	 SHORT $LN3@inflateGet
  00061	b8 fe ff ff ff	 mov	 eax, -2
  00066	eb 1c		 jmp	 SHORT $LN1@inflateGet
$LN3@inflateGet:

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR head$[rsp]
  00072	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1362 :     head->done = 0;

  00076	48 8b 44 24 48	 mov	 rax, QWORD PTR head$[rsp]
  0007b	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1363 :     return Z_OK;

  00082	33 c0		 xor	 eax, eax
$LN1@inflateGet:

; 1364 : }

  00084	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT syncsearch
_TEXT	SEGMENT
got$ = 32
next$ = 36
tv71 = 40
have$ = 64
buf$ = 72
len$ = 80
syncsearch PROC						; COMDAT

; 1381 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR have$[rsp]
  00039	8b 00		 mov	 eax, DWORD PTR [rax]
  0003b	89 44 24 20	 mov	 DWORD PTR got$[rsp], eax

; 1386 :     next = 0;

  0003f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR next$[rsp], 0
$LN2@syncsearch:

; 1387 :     while (next < len && got < 4) {

  00047	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  0004b	39 44 24 24	 cmp	 DWORD PTR next$[rsp], eax
  0004f	73 73		 jae	 SHORT $LN3@syncsearch
  00051	83 7c 24 20 04	 cmp	 DWORD PTR got$[rsp], 4
  00056	73 6c		 jae	 SHORT $LN3@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00058	83 7c 24 20 02	 cmp	 DWORD PTR got$[rsp], 2
  0005d	73 0a		 jae	 SHORT $LN9@syncsearch
  0005f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  00067	eb 08		 jmp	 SHORT $LN10@syncsearch
$LN9@syncsearch:
  00069	c7 44 24 28 ff
	00 00 00	 mov	 DWORD PTR tv71[rsp], 255 ; 000000ffH
$LN10@syncsearch:
  00071	8b 44 24 24	 mov	 eax, DWORD PTR next$[rsp]
  00075	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  0007a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007e	3b 44 24 28	 cmp	 eax, DWORD PTR tv71[rsp]
  00082	75 0c		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00084	8b 44 24 20	 mov	 eax, DWORD PTR got$[rsp]
  00088	ff c0		 inc	 eax
  0008a	89 44 24 20	 mov	 DWORD PTR got$[rsp], eax
  0008e	eb 28		 jmp	 SHORT $LN5@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])

  00090	8b 44 24 24	 mov	 eax, DWORD PTR next$[rsp]
  00094	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  00099	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009d	85 c0		 test	 eax, eax
  0009f	74 0a		 je	 SHORT $LN6@syncsearch

; 1391 :             got = 0;

  000a1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR got$[rsp], 0
  000a9	eb 0d		 jmp	 SHORT $LN7@syncsearch
$LN6@syncsearch:

; 1392 :         else
; 1393 :             got = 4 - got;

  000ab	b8 04 00 00 00	 mov	 eax, 4
  000b0	2b 44 24 20	 sub	 eax, DWORD PTR got$[rsp]
  000b4	89 44 24 20	 mov	 DWORD PTR got$[rsp], eax
$LN7@syncsearch:
$LN5@syncsearch:

; 1394 :         next++;

  000b8	8b 44 24 24	 mov	 eax, DWORD PTR next$[rsp]
  000bc	ff c0		 inc	 eax
  000be	89 44 24 24	 mov	 DWORD PTR next$[rsp], eax

; 1395 :     }

  000c2	eb 83		 jmp	 SHORT $LN2@syncsearch
$LN3@syncsearch:

; 1396 :     *have = got;

  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR have$[rsp]
  000c9	8b 4c 24 20	 mov	 ecx, DWORD PTR got$[rsp]
  000cd	89 08		 mov	 DWORD PTR [rax], ecx

; 1397 :     return next;

  000cf	8b 44 24 24	 mov	 eax, DWORD PTR next$[rsp]

; 1398 : }

  000d3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSync
_TEXT	SEGMENT
len$ = 32
in$ = 36
out$ = 40
buf$ = 52
state$ = 72
tv179 = 80
strm$ = 112
inflateSync PROC					; COMDAT

; 1402 : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 18 00 00 00	 mov	 ecx, 24
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0002a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR strm$[rsp]
  0002f	e8 00 00 00 00	 call	 inflateStateCheck
  00034	85 c0		 test	 eax, eax
  00036	74 0a		 je	 SHORT $LN4@inflateSyn
  00038	b8 fe ff ff ff	 mov	 eax, -2
  0003d	e9 da 01 00 00	 jmp	 $LN1@inflateSyn
$LN4@inflateSyn:

; 1410 :     state = (struct inflate_state FAR *)strm->state;

  00042	48 8b 44 24 70	 mov	 rax, QWORD PTR strm$[rsp]
  00047	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004b	48 89 44 24 48	 mov	 QWORD PTR state$[rsp], rax

; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00050	48 8b 44 24 70	 mov	 rax, QWORD PTR strm$[rsp]
  00055	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00059	75 15		 jne	 SHORT $LN5@inflateSyn
  0005b	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00060	83 78 4c 08	 cmp	 DWORD PTR [rax+76], 8
  00064	73 0a		 jae	 SHORT $LN5@inflateSyn
  00066	b8 fb ff ff ff	 mov	 eax, -5
  0006b	e9 ac 01 00 00	 jmp	 $LN1@inflateSyn
$LN5@inflateSyn:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00070	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00075	81 78 08 53 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16211 ; 00003f53H
  0007c	0f 84 d7 00 00
	00		 je	 $LN6@inflateSyn

; 1415 :         state->mode = SYNC;

  00082	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00087	c7 40 08 53 3f
	00 00		 mov	 DWORD PTR [rax+8], 16211 ; 00003f53H

; 1416 :         state->hold <<= state->bits & 7;

  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00093	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00096	83 e0 07	 and	 eax, 7
  00099	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  0009e	48 89 4c 24 50	 mov	 QWORD PTR tv179[rsp], rcx
  000a3	0f b6 c8	 movzx	 ecx, al
  000a6	48 8b 44 24 50	 mov	 rax, QWORD PTR tv179[rsp]
  000ab	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000ae	d3 e0		 shl	 eax, cl
  000b0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  000b5	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1417 :         state->bits -= state->bits & 7;

  000b8	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  000bd	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000c0	83 e0 07	 and	 eax, 7
  000c3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  000c8	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000cb	2b c8		 sub	 ecx, eax
  000cd	8b c1		 mov	 eax, ecx
  000cf	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  000d4	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 1418 :         len = 0;

  000d7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN2@inflateSyn:

; 1419 :         while (state->bits >= 8) {

  000df	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  000e4	83 78 4c 08	 cmp	 DWORD PTR [rax+76], 8
  000e8	72 43		 jb	 SHORT $LN3@inflateSyn

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  000ea	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000ee	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  000f3	0f b6 49 48	 movzx	 ecx, BYTE PTR [rcx+72]
  000f7	88 4c 04 34	 mov	 BYTE PTR buf$[rsp+rax], cl
  000fb	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000ff	ff c0		 inc	 eax
  00101	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 1421 :             state->hold >>= 8;

  00105	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  0010a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0010d	c1 e8 08	 shr	 eax, 8
  00110	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00115	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1422 :             state->bits -= 8;

  00118	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  0011d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00120	83 e8 08	 sub	 eax, 8
  00123	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00128	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 1423 :         }

  0012b	eb b2		 jmp	 SHORT $LN2@inflateSyn
$LN3@inflateSyn:

; 1424 :         state->have = 0;

  0012d	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00132	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0

; 1425 :         syncsearch(&(state->have), buf, len);

  0013c	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00141	48 05 84 00 00
	00		 add	 rax, 132		; 00000084H
  00147	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  0014c	48 8d 54 24 34	 lea	 rdx, QWORD PTR buf$[rsp]
  00151	48 8b c8	 mov	 rcx, rax
  00154	e8 00 00 00 00	 call	 syncsearch
$LN6@inflateSyn:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  00159	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  0015e	48 05 84 00 00
	00		 add	 rax, 132		; 00000084H
  00164	48 8b 4c 24 70	 mov	 rcx, QWORD PTR strm$[rsp]
  00169	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  0016d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR strm$[rsp]
  00172	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00175	48 8b c8	 mov	 rcx, rax
  00178	e8 00 00 00 00	 call	 syncsearch
  0017d	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 1430 :     strm->avail_in -= len;

  00181	48 8b 44 24 70	 mov	 rax, QWORD PTR strm$[rsp]
  00186	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0018a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0018d	2b c1		 sub	 eax, ecx
  0018f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR strm$[rsp]
  00194	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1431 :     strm->next_in += len;

  00197	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0019b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR strm$[rsp]
  001a0	48 03 01	 add	 rax, QWORD PTR [rcx]
  001a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR strm$[rsp]
  001a8	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1432 :     strm->total_in += len;

  001ab	48 8b 44 24 70	 mov	 rax, QWORD PTR strm$[rsp]
  001b0	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  001b3	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  001b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR strm$[rsp]
  001bc	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  001bf	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  001c4	83 b8 84 00 00
	00 04		 cmp	 DWORD PTR [rax+132], 4
  001cb	74 07		 je	 SHORT $LN7@inflateSyn
  001cd	b8 fd ff ff ff	 mov	 eax, -3
  001d2	eb 48		 jmp	 SHORT $LN1@inflateSyn
$LN7@inflateSyn:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  001d4	48 8b 44 24 70	 mov	 rax, QWORD PTR strm$[rsp]
  001d9	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  001dc	89 44 24 24	 mov	 DWORD PTR in$[rsp], eax
  001e0	48 8b 44 24 70	 mov	 rax, QWORD PTR strm$[rsp]
  001e5	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  001e8	89 44 24 28	 mov	 DWORD PTR out$[rsp], eax

; 1437 :     inflateReset(strm);

  001ec	48 8b 4c 24 70	 mov	 rcx, QWORD PTR strm$[rsp]
  001f1	e8 00 00 00 00	 call	 inflateReset

; 1438 :     strm->total_in = in;  strm->total_out = out;

  001f6	48 8b 44 24 70	 mov	 rax, QWORD PTR strm$[rsp]
  001fb	8b 4c 24 24	 mov	 ecx, DWORD PTR in$[rsp]
  001ff	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
  00202	48 8b 44 24 70	 mov	 rax, QWORD PTR strm$[rsp]
  00207	8b 4c 24 28	 mov	 ecx, DWORD PTR out$[rsp]
  0020b	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1439 :     state->mode = TYPE;

  0020e	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00213	c7 40 08 3f 3f
	00 00		 mov	 DWORD PTR [rax+8], 16191 ; 00003f3fH

; 1440 :     return Z_OK;

  0021a	33 c0		 xor	 eax, eax
$LN1@inflateSyn:

; 1441 : }

  0021c	48 8b f8	 mov	 rdi, rax
  0021f	48 8b cc	 mov	 rcx, rsp
  00222	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:inflateSync$rtcFrameData
  00229	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0022e	48 8b c7	 mov	 rax, rdi
  00231	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00235	5f		 pop	 rdi
  00236	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
state$ = 32
tv72 = 40
strm$ = 64
inflateSyncPoint PROC					; COMDAT

; 1453 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0002f	e8 00 00 00 00	 call	 inflateStateCheck
  00034	85 c0		 test	 eax, eax
  00036	74 07		 je	 SHORT $LN2@inflateSyn
  00038	b8 fe ff ff ff	 mov	 eax, -2
  0003d	eb 3d		 jmp	 SHORT $LN1@inflateSyn
$LN2@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00048	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1458 :     return state->mode == STORED && state->bits == 0;

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00052	81 78 08 41 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16193 ; 00003f41H
  00059	75 15		 jne	 SHORT $LN4@inflateSyn
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00060	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00064	75 0a		 jne	 SHORT $LN4@inflateSyn
  00066	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN5@inflateSyn
$LN4@inflateSyn:
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN5@inflateSyn:
  00078	8b 44 24 28	 mov	 eax, DWORD PTR tv72[rsp]
$LN1@inflateSyn:

; 1459 : }

  0007c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateCopy
_TEXT	SEGMENT
state$ = 32
copy$ = 40
window$ = 48
wsize$ = 56
tv189 = 60
tv221 = 64
dest$ = 96
source$ = 104
inflateCopy PROC					; COMDAT

; 1464 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 14 00 00 00	 mov	 ecx, 20
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  0002f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR source$[rsp]
  00034	e8 00 00 00 00	 call	 inflateStateCheck
  00039	85 c0		 test	 eax, eax
  0003b	75 08		 jne	 SHORT $LN3@inflateCop
  0003d	48 83 7c 24 60
	00		 cmp	 QWORD PTR dest$[rsp], 0
  00043	75 0a		 jne	 SHORT $LN2@inflateCop
$LN3@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  00045	b8 fe ff ff ff	 mov	 eax, -2
  0004a	e9 1c 02 00 00	 jmp	 $LN1@inflateCop
$LN2@inflateCop:

; 1473 :     state = (struct inflate_state FAR *)source->state;

  0004f	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  00054	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00058	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)

  0005d	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  00063	ba 01 00 00 00	 mov	 edx, 1
  00068	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  0006d	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00071	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  00076	ff 50 30	 call	 QWORD PTR [rax+48]
  00079	48 89 44 24 28	 mov	 QWORD PTR copy$[rsp], rax

; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0007e	48 83 7c 24 28
	00		 cmp	 QWORD PTR copy$[rsp], 0
  00084	75 0a		 jne	 SHORT $LN4@inflateCop
  00086	b8 fc ff ff ff	 mov	 eax, -4
  0008b	e9 db 01 00 00	 jmp	 $LN1@inflateCop
$LN4@inflateCop:

; 1479 :     window = Z_NULL;

  00090	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR window$[rsp], 0

; 1480 :     if (state->window != Z_NULL) {

  00099	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0009e	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  000a3	74 60		 je	 SHORT $LN5@inflateCop

; 1481 :         window = (unsigned char FAR *)

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000aa	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000ad	b9 01 00 00 00	 mov	 ecx, 1
  000b2	89 4c 24 3c	 mov	 DWORD PTR tv189[rsp], ecx
  000b6	0f b6 c8	 movzx	 ecx, al
  000b9	8b 44 24 3c	 mov	 eax, DWORD PTR tv189[rsp]
  000bd	d3 e0		 shl	 eax, cl
  000bf	41 b8 01 00 00
	00		 mov	 r8d, 1
  000c5	8b d0		 mov	 edx, eax
  000c7	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  000cc	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000d0	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  000d5	ff 50 30	 call	 QWORD PTR [rax+48]
  000d8	48 89 44 24 30	 mov	 QWORD PTR window$[rsp], rax

; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1483 :         if (window == Z_NULL) {

  000dd	48 83 7c 24 30
	00		 cmp	 QWORD PTR window$[rsp], 0
  000e3	75 20		 jne	 SHORT $LN6@inflateCop

; 1484 :             ZFREE(source, copy);

  000e5	48 8b 54 24 28	 mov	 rdx, QWORD PTR copy$[rsp]
  000ea	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  000ef	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000f3	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  000f8	ff 50 38	 call	 QWORD PTR [rax+56]

; 1485 :             return Z_MEM_ERROR;

  000fb	b8 fc ff ff ff	 mov	 eax, -4
  00100	e9 66 01 00 00	 jmp	 $LN1@inflateCop
$LN6@inflateCop:
$LN5@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00105	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  0010b	48 8b 54 24 68	 mov	 rdx, QWORD PTR source$[rsp]
  00110	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dest$[rsp]
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  0011b	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  00121	48 8b 54 24 20	 mov	 rdx, QWORD PTR state$[rsp]
  00126	48 8b 4c 24 28	 mov	 rcx, QWORD PTR copy$[rsp]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1492 :     copy->strm = dest;

  00131	48 8b 44 24 28	 mov	 rax, QWORD PTR copy$[rsp]
  00136	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dest$[rsp]
  0013b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1493 :     if (state->lencode >= state->codes &&

  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00143	48 05 50 05 00
	00		 add	 rax, 1360		; 00000550H
  00149	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0014e	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00152	72 7e		 jb	 SHORT $LN7@inflateCop
  00154	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00159	48 05 dc 1b 00
	00		 add	 rax, 7132		; 00001bdcH
  0015f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00164	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00168	77 68		 ja	 SHORT $LN7@inflateCop

; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  0016a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0016f	48 05 50 05 00
	00		 add	 rax, 1360		; 00000550H
  00175	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0017a	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0017e	48 2b c8	 sub	 rcx, rax
  00181	48 8b c1	 mov	 rax, rcx
  00184	48 c1 f8 02	 sar	 rax, 2
  00188	48 8b 4c 24 28	 mov	 rcx, QWORD PTR copy$[rsp]
  0018d	48 8d 84 81 50
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+1360]
  00195	48 8b 4c 24 28	 mov	 rcx, QWORD PTR copy$[rsp]
  0019a	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  0019e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001a3	48 05 50 05 00
	00		 add	 rax, 1360		; 00000550H
  001a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001ae	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  001b2	48 2b c8	 sub	 rcx, rax
  001b5	48 8b c1	 mov	 rax, rcx
  001b8	48 c1 f8 02	 sar	 rax, 2
  001bc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR copy$[rsp]
  001c1	48 8d 84 81 50
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+1360]
  001c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR copy$[rsp]
  001ce	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN7@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  001d2	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001d7	48 05 50 05 00
	00		 add	 rax, 1360		; 00000550H
  001dd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001e2	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  001e9	48 2b c8	 sub	 rcx, rax
  001ec	48 8b c1	 mov	 rax, rcx
  001ef	48 c1 f8 02	 sar	 rax, 2
  001f3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR copy$[rsp]
  001f8	48 8d 84 81 50
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+1360]
  00200	48 8b 4c 24 28	 mov	 rcx, QWORD PTR copy$[rsp]
  00205	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 1499 :     if (window != Z_NULL) {

  0020c	48 83 7c 24 30
	00		 cmp	 QWORD PTR window$[rsp], 0
  00212	74 39		 je	 SHORT $LN8@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  00214	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00219	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0021c	b9 01 00 00 00	 mov	 ecx, 1
  00221	89 4c 24 40	 mov	 DWORD PTR tv221[rsp], ecx
  00225	0f b6 c8	 movzx	 ecx, al
  00228	8b 44 24 40	 mov	 eax, DWORD PTR tv221[rsp]
  0022c	d3 e0		 shl	 eax, cl
  0022e	89 44 24 38	 mov	 DWORD PTR wsize$[rsp], eax

; 1501 :         zmemcpy(window, state->window, wsize);

  00232	8b 44 24 38	 mov	 eax, DWORD PTR wsize$[rsp]
  00236	44 8b c0	 mov	 r8d, eax
  00239	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0023e	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  00242	48 8b 4c 24 30	 mov	 rcx, QWORD PTR window$[rsp]
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy
$LN8@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  0024d	48 8b 44 24 28	 mov	 rax, QWORD PTR copy$[rsp]
  00252	48 8b 4c 24 30	 mov	 rcx, QWORD PTR window$[rsp]
  00257	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 1504 :     dest->state = (struct internal_state FAR *)copy;

  0025b	48 8b 44 24 60	 mov	 rax, QWORD PTR dest$[rsp]
  00260	48 8b 4c 24 28	 mov	 rcx, QWORD PTR copy$[rsp]
  00265	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1505 :     return Z_OK;

  00269	33 c0		 xor	 eax, eax
$LN1@inflateCop:

; 1506 : }

  0026b	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0026f	5f		 pop	 rdi
  00270	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateUndermine
_TEXT	SEGMENT
state$ = 32
strm$ = 64
subvert$ = 72
inflateUndermine PROC					; COMDAT

; 1511 : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00033	e8 00 00 00 00	 call	 inflateStateCheck
  00038	85 c0		 test	 eax, eax
  0003a	74 07		 je	 SHORT $LN2@inflateUnd
  0003c	b8 fe ff ff ff	 mov	 eax, -2
  00041	eb 22		 jmp	 SHORT $LN1@inflateUnd
$LN2@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;

  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00048	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004c	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00056	c7 80 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7136], 1

; 1522 :     return Z_DATA_ERROR;

  00060	b8 fd ff ff ff	 mov	 eax, -3
$LN1@inflateUnd:

; 1523 : #endif
; 1524 : }

  00065	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateValidate
_TEXT	SEGMENT
state$ = 32
strm$ = 64
check$ = 72
inflateValidate PROC					; COMDAT

; 1529 : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00033	e8 00 00 00 00	 call	 inflateStateCheck
  00038	85 c0		 test	 eax, eax
  0003a	74 07		 je	 SHORT $LN2@inflateVal
  0003c	b8 fe ff ff ff	 mov	 eax, -2
  00041	eb 3f		 jmp	 SHORT $LN1@inflateVal
$LN2@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;

  00043	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00048	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004c	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1534 :     if (check)

  00051	83 7c 24 48 00	 cmp	 DWORD PTR check$[rsp], 0
  00056	74 15		 je	 SHORT $LN3@inflateVal

; 1535 :         state->wrap |= 4;

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00060	83 c8 04	 or	 eax, 4
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00068	89 41 10	 mov	 DWORD PTR [rcx+16], eax
  0006b	eb 13		 jmp	 SHORT $LN4@inflateVal
$LN3@inflateVal:

; 1536 :     else
; 1537 :         state->wrap &= ~4;

  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00072	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00075	83 e0 fb	 and	 eax, -5
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0007d	89 41 10	 mov	 DWORD PTR [rcx+16], eax
$LN4@inflateVal:

; 1538 :     return Z_OK;

  00080	33 c0		 xor	 eax, eax
$LN1@inflateVal:

; 1539 : }

  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
inflateValidate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateMark
_TEXT	SEGMENT
state$ = 32
tv79 = 40
tv78 = 44
strm$ = 64
inflateMark PROC					; COMDAT

; 1543 : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0002f	e8 00 00 00 00	 call	 inflateStateCheck
  00034	85 c0		 test	 eax, eax
  00036	74 07		 je	 SHORT $LN2@inflateMar

; 1547 :         return -(1L << 16);

  00038	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H
  0003d	eb 75		 jmp	 SHORT $LN1@inflateMar
$LN2@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00048	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00052	81 78 08 43 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16195 ; 00003f43H
  00059	75 0e		 jne	 SHORT $LN6@inflateMar
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00060	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00063	89 44 24 28	 mov	 DWORD PTR tv79[rsp], eax
  00067	eb 39		 jmp	 SHORT $LN7@inflateMar
$LN6@inflateMar:
  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006e	81 78 08 4c 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16204 ; 00003f4cH
  00075	75 1b		 jne	 SHORT $LN4@inflateMar
  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00081	8b 49 50	 mov	 ecx, DWORD PTR [rcx+80]
  00084	8b 80 e8 1b 00
	00		 mov	 eax, DWORD PTR [rax+7144]
  0008a	2b c1		 sub	 eax, ecx
  0008c	89 44 24 2c	 mov	 DWORD PTR tv78[rsp], eax
  00090	eb 08		 jmp	 SHORT $LN5@inflateMar
$LN4@inflateMar:
  00092	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN5@inflateMar:
  0009a	8b 44 24 2c	 mov	 eax, DWORD PTR tv78[rsp]
  0009e	89 44 24 28	 mov	 DWORD PTR tv79[rsp], eax
$LN7@inflateMar:
  000a2	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000a7	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  000ad	c1 e0 10	 shl	 eax, 16
  000b0	03 44 24 28	 add	 eax, DWORD PTR tv79[rsp]
$LN1@inflateMar:

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT inflateCodesUsed
_TEXT	SEGMENT
state$ = 32
strm$ = 64
inflateCodesUsed PROC					; COMDAT

; 1556 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0002f	e8 00 00 00 00	 call	 inflateStateCheck
  00034	85 c0		 test	 eax, eax
  00036	74 07		 je	 SHORT $LN2@inflateCod
  00038	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0003d	eb 2f		 jmp	 SHORT $LN1@inflateCod
$LN2@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00048	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1560 :     return (unsigned long)(state->next - state->codes);

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00052	48 05 50 05 00
	00		 add	 rax, 1360		; 00000550H
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0005d	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00064	48 2b c8	 sub	 rcx, rax
  00067	48 8b c1	 mov	 rax, rcx
  0006a	48 c1 f8 02	 sar	 rax, 2
$LN1@inflateCod:

; 1561 : }

  0006e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
inflateCodesUsed ENDP
_TEXT	ENDS
END
