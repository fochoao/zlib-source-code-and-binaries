; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

	TITLE	e:\cpython\externals\zlib-1.2.11\gzwrite.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ ; `string'
EXTRN	__write:PROC
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ DB 'requested le'
	DB	'ngth does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@ DB 'internal err'
	DB	'or: deflate stream corrupt', 00H		; `string'
__DB664BEB_corecrt_stdio_config@h DB 01H
__E28BBA23_corecrt_wstdio@h DB 01H
__4A1C29A8_stdio@h DB 01H
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__B2FA0A71_gzwrite@c DB 01H
PUBLIC	_gzsetparams@12
PUBLIC	_gzflush@8
PUBLIC	_gzprintf
PUBLIC	_gzvprintf
PUBLIC	_gzputs@8
PUBLIC	_gzputc@8
PUBLIC	_gzfwrite@16
PUBLIC	_gzwrite@12
PUBLIC	_gzclose_w@4
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gzclose_w@4
_TEXT	SEGMENT
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclose_w@4 PROC					; COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 630  :     int ret = Z_OK;

  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  00025	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00029	75 0a		 jne	 SHORT $LN2@gzclose_w

; 635  :         return Z_STREAM_ERROR;

  0002b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00030	e9 f5 00 00 00	 jmp	 $LN1@gzclose_w
$LN2@gzclose_w:

; 636  :     state = (gz_statep)file;

  00035	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 637  : 
; 638  :     /* check that we're writing */
; 639  :     if (state->mode != GZ_WRITE)

  0003b	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0003e	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  00045	74 0a		 je	 SHORT $LN3@gzclose_w

; 640  :         return Z_STREAM_ERROR;

  00047	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004c	e9 d9 00 00 00	 jmp	 $LN1@gzclose_w
$LN3@gzclose_w:

; 641  : 
; 642  :     /* check for seek request */
; 643  :     if (state->seek) {

  00051	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00054	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00058	74 2f		 je	 SHORT $LN4@gzclose_w

; 644  :         state->seek = 0;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0005d	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 645  :         if (gz_zero(state, state->skip) == -1)

  00064	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00067	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  0006a	52		 push	 edx
  0006b	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  0006e	50		 push	 eax
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _gz_zero
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	83 f8 ff	 cmp	 eax, -1
  0007e	75 09		 jne	 SHORT $LN4@gzclose_w

; 646  :             ret = state->err;

  00080	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00083	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  00086	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
$LN4@gzclose_w:

; 647  :     }
; 648  : 
; 649  :     /* flush, free memory, and close file */
; 650  :     if (gz_comp(state, Z_FINISH) == -1)

  00089	6a 04		 push	 4
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 _gz_comp
  00094	83 c4 08	 add	 esp, 8
  00097	83 f8 ff	 cmp	 eax, -1
  0009a	75 09		 jne	 SHORT $LN6@gzclose_w

; 651  :         ret = state->err;

  0009c	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0009f	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  000a2	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax
$LN6@gzclose_w:

; 652  :     if (state->size) {

  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000a8	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  000ac	74 33		 je	 SHORT $LN7@gzclose_w

; 653  :         if (!state->direct) {

  000ae	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000b1	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  000b5	75 1b		 jne	 SHORT $LN8@gzclose_w

; 654  :             (void)deflateEnd(&(state->strm));

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000ba	83 c0 64	 add	 eax, 100		; 00000064H
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _deflateEnd@4

; 655  :             free(state->out);

  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000c6	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _free
  000cf	83 c4 04	 add	 esp, 4
$LN8@gzclose_w:

; 656  :         }
; 657  :         free(state->in);

  000d2	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000d5	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 _free
  000de	83 c4 04	 add	 esp, 4
$LN7@gzclose_w:

; 658  :     }
; 659  :     gz_error(state, Z_OK, NULL);

  000e1	6a 00		 push	 0
  000e3	6a 00		 push	 0
  000e5	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 _gz_error
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 660  :     free(state->path);

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000f4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000f7	51		 push	 ecx
  000f8	e8 00 00 00 00	 call	 _free
  000fd	83 c4 04	 add	 esp, 4

; 661  :     if (close(state->fd) == -1)

  00100	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00103	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 __close
  0010c	83 c4 04	 add	 esp, 4
  0010f	83 f8 ff	 cmp	 eax, -1
  00112	75 07		 jne	 SHORT $LN9@gzclose_w

; 662  :         ret = Z_ERRNO;

  00114	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
$LN9@gzclose_w:

; 663  :     free(state);

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0011e	51		 push	 ecx
  0011f	e8 00 00 00 00	 call	 _free
  00124	83 c4 04	 add	 esp, 4

; 664  :     return ret;

  00127	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@gzclose_w:

; 665  : }

  0012a	83 c4 08	 add	 esp, 8
  0012d	3b ec		 cmp	 ebp, esp
  0012f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c2 04 00	 ret	 4
_gzclose_w@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gz_init
_TEXT	SEGMENT
_strm$ = -8						; size = 4
_ret$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_init PROC						; COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 20   :     int ret;
; 21   :     z_streamp strm = &(state->strm);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00021	83 c0 64	 add	 eax, 100		; 00000064H
  00024	89 45 f8	 mov	 DWORD PTR _strm$[ebp], eax

; 22   : 
; 23   :     /* allocate input buffer (double size for gzprintf) */
; 24   :     state->in = (unsigned char *)malloc(state->want << 1);

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002a	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0002d	d1 e2		 shl	 edx, 1
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _malloc
  00035	83 c4 04	 add	 esp, 4
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0003b	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 25   :     if (state->in == NULL) {

  0003e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00041	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  00045	75 1b		 jne	 SHORT $LN2@gz_init

; 26   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  0004c	6a fc		 push	 -4			; fffffffcH
  0004e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _gz_error
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 27   :         return -1;

  0005a	83 c8 ff	 or	 eax, -1
  0005d	e9 1a 01 00 00	 jmp	 $LN1@gz_init
$LN2@gz_init:

; 28   :     }
; 29   : 
; 30   :     /* only need output buffer and deflate state if compressing */
; 31   :     if (!state->direct) {

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00065	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  00069	0f 85 d2 00 00
	00		 jne	 $LN3@gz_init

; 32   :         /* allocate output buffer */
; 33   :         state->out = (unsigned char *)malloc(state->want);

  0006f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00072	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 _malloc
  0007b	83 c4 04	 add	 esp, 4
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00081	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 34   :         if (state->out == NULL) {

  00084	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00087	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  0008b	75 2a		 jne	 SHORT $LN4@gz_init

; 35   :             free(state->in);

  0008d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00090	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _free
  00099	83 c4 04	 add	 esp, 4

; 36   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  000a1	6a fc		 push	 -4			; fffffffcH
  000a3	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 _gz_error
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 37   :             return -1;

  000af	83 c8 ff	 or	 eax, -1
  000b2	e9 c5 00 00 00	 jmp	 $LN1@gz_init
$LN4@gz_init:

; 38   :         }
; 39   : 
; 40   :         /* allocate deflate memory, set up for gzip compression */
; 41   :         strm->zalloc = Z_NULL;

  000b7	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  000ba	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 42   :         strm->zfree = Z_NULL;

  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000c4	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 43   :         strm->opaque = Z_NULL;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _strm$[ebp]
  000ce	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0

; 44   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,

  000d5	6a 38		 push	 56			; 00000038H
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411@
  000dc	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000df	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000e2	51		 push	 ecx
  000e3	6a 08		 push	 8
  000e5	6a 1f		 push	 31			; 0000001fH
  000e7	6a 08		 push	 8
  000e9	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ec	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  000ef	50		 push	 eax
  000f0	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 _deflateInit2_@32
  000f9	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 45   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
; 46   :         if (ret != Z_OK) {

  000fc	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00100	74 36		 je	 SHORT $LN5@gz_init

; 47   :             free(state->out);

  00102	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00105	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _free
  0010e	83 c4 04	 add	 esp, 4

; 48   :             free(state->in);

  00111	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00114	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00117	52		 push	 edx
  00118	e8 00 00 00 00	 call	 _free
  0011d	83 c4 04	 add	 esp, 4

; 49   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  00125	6a fc		 push	 -4			; fffffffcH
  00127	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0012a	50		 push	 eax
  0012b	e8 00 00 00 00	 call	 _gz_error
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH

; 50   :             return -1;

  00133	83 c8 ff	 or	 eax, -1
  00136	eb 44		 jmp	 SHORT $LN1@gz_init
$LN5@gz_init:

; 51   :         }
; 52   :         strm->next_in = NULL;

  00138	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0013b	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN3@gz_init:

; 53   :     }
; 54   : 
; 55   :     /* mark state as initialized */
; 56   :     state->size = state->want;

  00141	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00144	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00147	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0014a	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 57   : 
; 58   :     /* initialize write buffer if compressing */
; 59   :     if (!state->direct) {

  0014d	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00150	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  00154	75 24		 jne	 SHORT $LN6@gz_init

; 60   :         strm->avail_out = state->size;

  00156	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00159	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0015c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0015f	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 61   :         strm->next_out = state->out;

  00162	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  00165	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00168	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0016b	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 62   :         state->x.next = strm->next_out;

  0016e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00171	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00174	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00177	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN6@gz_init:

; 63   :     }
; 64   :     return 0;

  0017a	33 c0		 xor	 eax, eax
$LN1@gz_init:

; 65   : }

  0017c	83 c4 08	 add	 esp, 8
  0017f	3b ec		 cmp	 ebp, esp
  00181	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c3		 ret	 0
_gz_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gz_comp
_TEXT	SEGMENT
tv144 = -32						; size = 4
tv77 = -28						; size = 4
_strm$ = -24						; size = 4
_max$ = -20						; size = 4
_put$ = -16						; size = 4
_have$ = -12						; size = 4
_writ$ = -8						; size = 4
_ret$ = -4						; size = 4
_state$ = 8						; size = 4
_flush$ = 12						; size = 4
_gz_comp PROC						; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000e	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00011	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00014	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00017	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001a	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001d	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00020	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 77   :     int ret, writ;
; 78   :     unsigned have, put, max = ((unsigned)-1 >> 2) + 1;

  0002d	c7 45 ec 00 00
	00 40		 mov	 DWORD PTR _max$[ebp], 1073741824 ; 40000000H

; 79   :     z_streamp strm = &(state->strm);

  00034	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00037	83 c0 64	 add	 eax, 100		; 00000064H
  0003a	89 45 e8	 mov	 DWORD PTR _strm$[ebp], eax

; 80   : 
; 81   :     /* allocate memory if this is the first time through */
; 82   :     if (state->size == 0 && gz_init(state) == -1)

  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00040	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00044	75 19		 jne	 SHORT $LN9@gz_comp
  00046	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 _gz_init
  0004f	83 c4 04	 add	 esp, 4
  00052	83 f8 ff	 cmp	 eax, -1
  00055	75 08		 jne	 SHORT $LN9@gz_comp

; 83   :         return -1;

  00057	83 c8 ff	 or	 eax, -1
  0005a	e9 02 02 00 00	 jmp	 $LN1@gz_comp
$LN9@gz_comp:

; 84   : 
; 85   :     /* write directly if requested */
; 86   :     if (state->direct) {

  0005f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00062	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  00066	0f 84 a3 00 00
	00		 je	 $LN10@gz_comp
$LN2@gz_comp:

; 87   :         while (strm->avail_in) {

  0006c	8b 4d e8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0006f	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00073	0f 84 8f 00 00
	00		 je	 $LN3@gz_comp

; 88   :             put = strm->avail_in > max ? max : strm->avail_in;

  00079	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  0007c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0007f	3b 45 ec	 cmp	 eax, DWORD PTR _max$[ebp]
  00082	76 08		 jbe	 SHORT $LN20@gz_comp
  00084	8b 4d ec	 mov	 ecx, DWORD PTR _max$[ebp]
  00087	89 4d e4	 mov	 DWORD PTR tv77[ebp], ecx
  0008a	eb 0c		 jmp	 SHORT $LN21@gz_comp
$LN20@gz_comp:
  0008c	0f ae e8	 lfence
  0008f	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  00092	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00095	89 45 e4	 mov	 DWORD PTR tv77[ebp], eax
$LN21@gz_comp:
  00098	8b 4d e4	 mov	 ecx, DWORD PTR tv77[ebp]
  0009b	89 4d f0	 mov	 DWORD PTR _put$[ebp], ecx

; 89   :             writ = write(state->fd, strm->next_in, put);

  0009e	8b 55 f0	 mov	 edx, DWORD PTR _put$[ebp]
  000a1	52		 push	 edx
  000a2	8b 45 e8	 mov	 eax, DWORD PTR _strm$[ebp]
  000a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a7	51		 push	 ecx
  000a8	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ab	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 __write
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b7	89 45 f8	 mov	 DWORD PTR _writ$[ebp], eax

; 90   :             if (writ < 0) {

  000ba	83 7d f8 00	 cmp	 DWORD PTR _writ$[ebp], 0
  000be	7d 27		 jge	 SHORT $LN11@gz_comp

; 91   :                 gz_error(state, Z_ERRNO, zstrerror());

  000c0	e8 00 00 00 00	 call	 __errno
  000c5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 _strerror
  000cd	83 c4 04	 add	 esp, 4
  000d0	50		 push	 eax
  000d1	6a ff		 push	 -1
  000d3	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d6	52		 push	 edx
  000d7	e8 00 00 00 00	 call	 _gz_error
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 92   :                 return -1;

  000df	83 c8 ff	 or	 eax, -1
  000e2	e9 7a 01 00 00	 jmp	 $LN1@gz_comp
$LN11@gz_comp:

; 93   :             }
; 94   :             strm->avail_in -= (unsigned)writ;

  000e7	8b 45 e8	 mov	 eax, DWORD PTR _strm$[ebp]
  000ea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000ed	2b 4d f8	 sub	 ecx, DWORD PTR _writ$[ebp]
  000f0	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  000f3	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 95   :             strm->next_in += writ;

  000f6	8b 45 e8	 mov	 eax, DWORD PTR _strm$[ebp]
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	03 4d f8	 add	 ecx, DWORD PTR _writ$[ebp]
  000fe	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  00101	89 0a		 mov	 DWORD PTR [edx], ecx

; 96   :         }

  00103	e9 64 ff ff ff	 jmp	 $LN2@gz_comp
$LN3@gz_comp:

; 97   :         return 0;

  00108	33 c0		 xor	 eax, eax
  0010a	e9 52 01 00 00	 jmp	 $LN1@gz_comp
$LN10@gz_comp:

; 98   :     }
; 99   : 
; 100  :     /* run deflate() on provided input until it produces no more output */
; 101  :     ret = Z_OK;

  0010f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN6@gz_comp:

; 102  :     do {
; 103  :         /* write out current buffer contents if full, or if flushing, but if
; 104  :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 105  :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&

  00116	8b 45 e8	 mov	 eax, DWORD PTR _strm$[ebp]
  00119	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0011d	74 1a		 je	 SHORT $LN7@gz_comp
  0011f	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  00123	0f 84 de 00 00
	00		 je	 $LN12@gz_comp
  00129	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0012d	75 0a		 jne	 SHORT $LN7@gz_comp
  0012f	83 7d fc 01	 cmp	 DWORD PTR _ret$[ebp], 1
  00133	0f 85 ce 00 00
	00		 jne	 $LN12@gz_comp
$LN7@gz_comp:

; 106  :             (flush != Z_FINISH || ret == Z_STREAM_END))) {
; 107  :             while (strm->next_out > state->x.next) {

  00139	8b 4d e8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0013c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0013f	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00142	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00145	0f 86 8f 00 00
	00		 jbe	 $LN8@gz_comp

; 108  :                 put = strm->next_out - state->x.next > (int)max ? max :

  0014b	8b 4d e8	 mov	 ecx, DWORD PTR _strm$[ebp]
  0014e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00151	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00154	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00157	3b 45 ec	 cmp	 eax, DWORD PTR _max$[ebp]
  0015a	7e 08		 jle	 SHORT $LN22@gz_comp
  0015c	8b 4d ec	 mov	 ecx, DWORD PTR _max$[ebp]
  0015f	89 4d e0	 mov	 DWORD PTR tv144[ebp], ecx
  00162	eb 12		 jmp	 SHORT $LN23@gz_comp
$LN22@gz_comp:
  00164	0f ae e8	 lfence
  00167	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  0016a	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0016d	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00170	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  00173	89 4d e0	 mov	 DWORD PTR tv144[ebp], ecx
$LN23@gz_comp:
  00176	8b 55 e0	 mov	 edx, DWORD PTR tv144[ebp]
  00179	89 55 f0	 mov	 DWORD PTR _put$[ebp], edx

; 109  :                       (unsigned)(strm->next_out - state->x.next);
; 110  :                 writ = write(state->fd, state->x.next, put);

  0017c	8b 45 f0	 mov	 eax, DWORD PTR _put$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00183	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00186	52		 push	 edx
  00187	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0018a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0018d	51		 push	 ecx
  0018e	e8 00 00 00 00	 call	 __write
  00193	83 c4 0c	 add	 esp, 12			; 0000000cH
  00196	89 45 f8	 mov	 DWORD PTR _writ$[ebp], eax

; 111  :                 if (writ < 0) {

  00199	83 7d f8 00	 cmp	 DWORD PTR _writ$[ebp], 0
  0019d	7d 27		 jge	 SHORT $LN15@gz_comp

; 112  :                     gz_error(state, Z_ERRNO, zstrerror());

  0019f	e8 00 00 00 00	 call	 __errno
  001a4	8b 10		 mov	 edx, DWORD PTR [eax]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 _strerror
  001ac	83 c4 04	 add	 esp, 4
  001af	50		 push	 eax
  001b0	6a ff		 push	 -1
  001b2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 _gz_error
  001bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 113  :                     return -1;

  001be	83 c8 ff	 or	 eax, -1
  001c1	e9 9b 00 00 00	 jmp	 $LN1@gz_comp
$LN15@gz_comp:

; 114  :                 }
; 115  :                 state->x.next += writ;

  001c6	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001c9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001cc	03 55 f8	 add	 edx, DWORD PTR _writ$[ebp]
  001cf	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001d2	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 116  :             }

  001d5	e9 5f ff ff ff	 jmp	 $LN7@gz_comp
$LN8@gz_comp:

; 117  :             if (strm->avail_out == 0) {

  001da	8b 4d e8	 mov	 ecx, DWORD PTR _strm$[ebp]
  001dd	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  001e1	75 24		 jne	 SHORT $LN12@gz_comp

; 118  :                 strm->avail_out = state->size;

  001e3	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  001e6	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001e9	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001ec	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 119  :                 strm->next_out = state->out;

  001ef	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  001f2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001f5	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  001f8	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 120  :                 state->x.next = state->out;

  001fb	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001fe	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00201	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00204	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN12@gz_comp:

; 121  :             }
; 122  :         }
; 123  : 
; 124  :         /* compress */
; 125  :         have = strm->avail_out;

  00207	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  0020a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0020d	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax

; 126  :         ret = deflate(strm, flush);

  00210	8b 4d 0c	 mov	 ecx, DWORD PTR _flush$[ebp]
  00213	51		 push	 ecx
  00214	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  00217	52		 push	 edx
  00218	e8 00 00 00 00	 call	 _deflate@8
  0021d	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 127  :         if (ret == Z_STREAM_ERROR) {

  00220	83 7d fc fe	 cmp	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  00224	75 18		 jne	 SHORT $LN17@gz_comp

; 128  :             gz_error(state, Z_STREAM_ERROR,

  00226	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@
  0022b	6a fe		 push	 -2			; fffffffeH
  0022d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00230	50		 push	 eax
  00231	e8 00 00 00 00	 call	 _gz_error
  00236	83 c4 0c	 add	 esp, 12			; 0000000cH

; 129  :                       "internal error: deflate stream corrupt");
; 130  :             return -1;

  00239	83 c8 ff	 or	 eax, -1
  0023c	eb 23		 jmp	 SHORT $LN1@gz_comp
$LN17@gz_comp:

; 131  :         }
; 132  :         have -= strm->avail_out;

  0023e	8b 4d e8	 mov	 ecx, DWORD PTR _strm$[ebp]
  00241	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  00244	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  00247	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx

; 133  :     } while (have);

  0024a	0f 85 c6 fe ff
	ff		 jne	 $LN6@gz_comp

; 134  : 
; 135  :     /* if that completed a deflate stream, allow another to start */
; 136  :     if (flush == Z_FINISH)

  00250	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  00254	75 09		 jne	 SHORT $LN18@gz_comp

; 137  :         deflateReset(strm);

  00256	8b 45 e8	 mov	 eax, DWORD PTR _strm$[ebp]
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 _deflateReset@4
$LN18@gz_comp:

; 138  : 
; 139  :     /* all done, no errors */
; 140  :     return 0;

  0025f	33 c0		 xor	 eax, eax
$LN1@gz_comp:

; 141  : }

  00261	83 c4 20	 add	 esp, 32			; 00000020H
  00264	3b ec		 cmp	 ebp, esp
  00266	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0026b	8b e5		 mov	 esp, ebp
  0026d	5d		 pop	 ebp
  0026e	c3		 ret	 0
_gz_comp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gz_zero
_TEXT	SEGMENT
tv78 = -24						; size = 4
tv143 = -20						; size = 8
_strm$ = -12						; size = 4
_n$ = -8						; size = 4
_first$ = -4						; size = 4
_state$ = 8						; size = 4
_len$ = 12						; size = 8
_gz_zero PROC						; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00022	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 149  :     int first;
; 150  :     unsigned n;
; 151  :     z_streamp strm = &(state->strm);

  00027	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002a	83 c0 64	 add	 eax, 100		; 00000064H
  0002d	89 45 f4	 mov	 DWORD PTR _strm$[ebp], eax

; 152  : 
; 153  :     /* consume whatever's left in the input buffer */
; 154  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00030	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00033	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00037	74 1b		 je	 SHORT $LN4@gz_zero
  00039	6a 00		 push	 0
  0003b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _gz_comp
  00044	83 c4 08	 add	 esp, 8
  00047	83 f8 ff	 cmp	 eax, -1
  0004a	75 08		 jne	 SHORT $LN4@gz_zero

; 155  :         return -1;

  0004c	83 c8 ff	 or	 eax, -1
  0004f	e9 cd 00 00 00	 jmp	 $LN1@gz_zero
$LN4@gz_zero:

; 156  : 
; 157  :     /* compress len zeros (len guaranteed > 0) */
; 158  :     first = 1;

  00054	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _first$[ebp], 1
$LN2@gz_zero:

; 159  :     while (len) {

  0005b	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  0005e	0b 45 10	 or	 eax, DWORD PTR _len$[ebp+4]
  00061	0f 84 b8 00 00
	00		 je	 $LN3@gz_zero

; 160  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?

  00067	33 c9		 xor	 ecx, ecx
  00069	75 2b		 jne	 SHORT $LN8@gz_zero
  0006b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0006e	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00071	33 c9		 xor	 ecx, ecx
  00073	89 45 ec	 mov	 DWORD PTR tv143[ebp], eax
  00076	89 4d f0	 mov	 DWORD PTR tv143[ebp+4], ecx
  00079	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp+4]
  0007c	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp+4]
  0007f	7f 15		 jg	 SHORT $LN8@gz_zero
  00081	7c 08		 jl	 SHORT $LN11@gz_zero
  00083	8b 45 ec	 mov	 eax, DWORD PTR tv143[ebp]
  00086	3b 45 0c	 cmp	 eax, DWORD PTR _len$[ebp]
  00089	77 0b		 ja	 SHORT $LN8@gz_zero
$LN11@gz_zero:
  0008b	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0008e	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00091	89 55 e8	 mov	 DWORD PTR tv78[ebp], edx
  00094	eb 06		 jmp	 SHORT $LN9@gz_zero
$LN8@gz_zero:
  00096	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00099	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
$LN9@gz_zero:
  0009c	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  0009f	89 4d f8	 mov	 DWORD PTR _n$[ebp], ecx

; 161  :             (unsigned)len : state->size;
; 162  :         if (first) {

  000a2	83 7d fc 00	 cmp	 DWORD PTR _first$[ebp], 0
  000a6	74 1c		 je	 SHORT $LN5@gz_zero

; 163  :             memset(state->in, 0, n);

  000a8	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  000ab	52		 push	 edx
  000ac	6a 00		 push	 0
  000ae	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000b1	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _memset
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 164  :             first = 0;

  000bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _first$[ebp], 0
$LN5@gz_zero:

; 165  :         }
; 166  :         strm->avail_in = n;

  000c4	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000ca	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 167  :         strm->next_in = state->in;

  000cd	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  000d0	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d3	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000d6	89 01		 mov	 DWORD PTR [ecx], eax

; 168  :         state->x.pos += n;

  000d8	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000db	33 d2		 xor	 edx, edx
  000dd	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000e0	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  000e3	13 50 0c	 adc	 edx, DWORD PTR [eax+12]
  000e6	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000e9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000ec	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 169  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000ef	6a 00		 push	 0
  000f1	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000f4	51		 push	 ecx
  000f5	e8 00 00 00 00	 call	 _gz_comp
  000fa	83 c4 08	 add	 esp, 8
  000fd	83 f8 ff	 cmp	 eax, -1
  00100	75 05		 jne	 SHORT $LN6@gz_zero

; 170  :             return -1;

  00102	83 c8 ff	 or	 eax, -1
  00105	eb 1a		 jmp	 SHORT $LN1@gz_zero
$LN6@gz_zero:

; 171  :         len -= n;

  00107	33 d2		 xor	 edx, edx
  00109	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  0010c	2b 45 f8	 sub	 eax, DWORD PTR _n$[ebp]
  0010f	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp+4]
  00112	1b ca		 sbb	 ecx, edx
  00114	89 45 0c	 mov	 DWORD PTR _len$[ebp], eax
  00117	89 4d 10	 mov	 DWORD PTR _len$[ebp+4], ecx

; 172  :     }

  0011a	e9 3c ff ff ff	 jmp	 $LN2@gz_zero
$LN3@gz_zero:

; 173  :     return 0;

  0011f	33 c0		 xor	 eax, eax
$LN1@gz_zero:

; 174  : }

  00121	83 c4 18	 add	 esp, 24			; 00000018H
  00124	3b ec		 cmp	 ebp, esp
  00126	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c3		 ret	 0
_gz_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gz_write
_TEXT	SEGMENT
_n$1 = -16						; size = 4
_copy$2 = -12						; size = 4
_have$3 = -8						; size = 4
_put$ = -4						; size = 4
_state$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gz_write PROC						; COMDAT

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 183  :     z_size_t put = len;

  00021	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00024	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax

; 184  : 
; 185  :     /* if len is zero, avoid unnecessary operations */
; 186  :     if (len == 0)

  00027	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  0002b	75 07		 jne	 SHORT $LN8@gz_write

; 187  :         return 0;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 ad 01 00 00	 jmp	 $LN1@gz_write
$LN8@gz_write:

; 188  : 
; 189  :     /* allocate memory if this is the first time through */
; 190  :     if (state->size == 0 && gz_init(state) == -1)

  00034	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00037	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  0003b	75 18		 jne	 SHORT $LN9@gz_write
  0003d	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _gz_init
  00046	83 c4 04	 add	 esp, 4
  00049	83 f8 ff	 cmp	 eax, -1
  0004c	75 07		 jne	 SHORT $LN9@gz_write

; 191  :         return 0;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 8c 01 00 00	 jmp	 $LN1@gz_write
$LN9@gz_write:

; 192  : 
; 193  :     /* check for seek request */
; 194  :     if (state->seek) {

  00055	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00058	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  0005c	74 2d		 je	 SHORT $LN10@gz_write

; 195  :         state->seek = 0;

  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00061	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 196  :         if (gz_zero(state, state->skip) == -1)

  00068	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0006b	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  0006e	50		 push	 eax
  0006f	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00072	51		 push	 ecx
  00073	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 _gz_zero
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007f	83 f8 ff	 cmp	 eax, -1
  00082	75 07		 jne	 SHORT $LN10@gz_write

; 197  :             return 0;

  00084	33 c0		 xor	 eax, eax
  00086	e9 56 01 00 00	 jmp	 $LN1@gz_write
$LN10@gz_write:

; 198  :     }
; 199  : 
; 200  :     /* for small len, copy to input buffer, otherwise compress directly */
; 201  :     if (len < state->size) {

  0008b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0008e	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  00091	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  00094	0f 83 c4 00 00
	00		 jae	 $LN12@gz_write
  0009a	0f ae e8	 lfence
$LN4@gz_write:

; 202  :         /* copy to input buffer, compress when full */
; 203  :         do {
; 204  :             unsigned have, copy;
; 205  : 
; 206  :             if (state->strm.avail_in == 0)

  0009d	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000a0	83 7a 68 00	 cmp	 DWORD PTR [edx+104], 0
  000a4	75 0c		 jne	 SHORT $LN14@gz_write

; 207  :                 state->strm.next_in = state->in;

  000a6	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a9	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000ac	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000af	89 50 64	 mov	 DWORD PTR [eax+100], edx
$LN14@gz_write:

; 208  :             have = (unsigned)((state->strm.next_in + state->strm.avail_in) -

  000b2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000b5	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000bb	03 4a 68	 add	 ecx, DWORD PTR [edx+104]
  000be	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c1	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  000c4	89 4d f8	 mov	 DWORD PTR _have$3[ebp], ecx

; 209  :                               state->in);
; 210  :             copy = state->size - have;

  000c7	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000ca	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  000cd	2b 55 f8	 sub	 edx, DWORD PTR _have$3[ebp]
  000d0	89 55 f4	 mov	 DWORD PTR _copy$2[ebp], edx

; 211  :             if (copy > len)

  000d3	8b 45 f4	 mov	 eax, DWORD PTR _copy$2[ebp]
  000d6	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  000d9	76 06		 jbe	 SHORT $LN15@gz_write

; 212  :                 copy = len;

  000db	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  000de	89 4d f4	 mov	 DWORD PTR _copy$2[ebp], ecx
$LN15@gz_write:

; 213  :             memcpy(state->in + have, buf, copy);

  000e1	8b 55 f4	 mov	 edx, DWORD PTR _copy$2[ebp]
  000e4	52		 push	 edx
  000e5	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000ec	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000ef	03 55 f8	 add	 edx, DWORD PTR _have$3[ebp]
  000f2	52		 push	 edx
  000f3	e8 00 00 00 00	 call	 _memcpy
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 214  :             state->strm.avail_in += copy;

  000fb	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000fe	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00101	03 4d f4	 add	 ecx, DWORD PTR _copy$2[ebp]
  00104	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00107	89 4a 68	 mov	 DWORD PTR [edx+104], ecx

; 215  :             state->x.pos += copy;

  0010a	8b 45 f4	 mov	 eax, DWORD PTR _copy$2[ebp]
  0010d	33 c9		 xor	 ecx, ecx
  0010f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00112	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00115	13 4a 0c	 adc	 ecx, DWORD PTR [edx+12]
  00118	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0011b	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0011e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 216  :             buf = (const char *)buf + copy;

  00121	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00124	03 45 f4	 add	 eax, DWORD PTR _copy$2[ebp]
  00127	89 45 0c	 mov	 DWORD PTR _buf$[ebp], eax

; 217  :             len -= copy;

  0012a	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0012d	2b 4d f4	 sub	 ecx, DWORD PTR _copy$2[ebp]
  00130	89 4d 10	 mov	 DWORD PTR _len$[ebp], ecx

; 218  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  00133	74 1a		 je	 SHORT $LN2@gz_write
  00135	6a 00		 push	 0
  00137	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0013a	52		 push	 edx
  0013b	e8 00 00 00 00	 call	 _gz_comp
  00140	83 c4 08	 add	 esp, 8
  00143	83 f8 ff	 cmp	 eax, -1
  00146	75 07		 jne	 SHORT $LN2@gz_write

; 219  :                 return 0;

  00148	33 c0		 xor	 eax, eax
  0014a	e9 92 00 00 00	 jmp	 $LN1@gz_write
$LN2@gz_write:

; 220  :         } while (len);

  0014f	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00153	0f 85 44 ff ff
	ff		 jne	 $LN4@gz_write

; 221  :     }

  00159	e9 80 00 00 00	 jmp	 $LN13@gz_write
$LN12@gz_write:

; 222  :     else {
; 223  :         /* consume whatever's left in the input buffer */
; 224  :         if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0015e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00161	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  00165	74 17		 je	 SHORT $LN17@gz_write
  00167	6a 00		 push	 0
  00169	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 _gz_comp
  00172	83 c4 08	 add	 esp, 8
  00175	83 f8 ff	 cmp	 eax, -1
  00178	75 04		 jne	 SHORT $LN17@gz_write

; 225  :             return 0;

  0017a	33 c0		 xor	 eax, eax
  0017c	eb 63		 jmp	 SHORT $LN1@gz_write
$LN17@gz_write:

; 226  : 
; 227  :         /* directly compress user buffer to file */
; 228  :         state->strm.next_in = (z_const Bytef *)buf;

  0017e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00181	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00184	89 42 64	 mov	 DWORD PTR [edx+100], eax
$LN7@gz_write:

; 229  :         do {
; 230  :             unsigned n = (unsigned)-1;

  00187	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _n$1[ebp], -1

; 231  :             if (n > len)

  0018e	8b 4d f0	 mov	 ecx, DWORD PTR _n$1[ebp]
  00191	3b 4d 10	 cmp	 ecx, DWORD PTR _len$[ebp]
  00194	76 06		 jbe	 SHORT $LN18@gz_write

; 232  :                 n = len;

  00196	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00199	89 55 f0	 mov	 DWORD PTR _n$1[ebp], edx
$LN18@gz_write:

; 233  :             state->strm.avail_in = n;

  0019c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0019f	8b 4d f0	 mov	 ecx, DWORD PTR _n$1[ebp]
  001a2	89 48 68	 mov	 DWORD PTR [eax+104], ecx

; 234  :             state->x.pos += n;

  001a5	8b 55 f0	 mov	 edx, DWORD PTR _n$1[ebp]
  001a8	33 c0		 xor	 eax, eax
  001aa	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001ad	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  001b0	13 41 0c	 adc	 eax, DWORD PTR [ecx+12]
  001b3	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001b6	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  001b9	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 235  :             if (gz_comp(state, Z_NO_FLUSH) == -1)

  001bc	6a 00		 push	 0
  001be	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001c1	52		 push	 edx
  001c2	e8 00 00 00 00	 call	 _gz_comp
  001c7	83 c4 08	 add	 esp, 8
  001ca	83 f8 ff	 cmp	 eax, -1
  001cd	75 04		 jne	 SHORT $LN19@gz_write

; 236  :                 return 0;

  001cf	33 c0		 xor	 eax, eax
  001d1	eb 0e		 jmp	 SHORT $LN1@gz_write
$LN19@gz_write:

; 237  :             len -= n;

  001d3	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  001d6	2b 45 f0	 sub	 eax, DWORD PTR _n$1[ebp]
  001d9	89 45 10	 mov	 DWORD PTR _len$[ebp], eax

; 238  :         } while (len);

  001dc	75 a9		 jne	 SHORT $LN7@gz_write
$LN13@gz_write:

; 239  :     }
; 240  : 
; 241  :     /* input was all buffered or compressed */
; 242  :     return put;

  001de	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
$LN1@gz_write:

; 243  : }

  001e1	83 c4 10	 add	 esp, 16			; 00000010H
  001e4	3b ec		 cmp	 ebp, esp
  001e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c3		 ret	 0
_gz_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gzwrite@12
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzwrite@12 PROC					; COMDAT

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 251  :     gz_statep state;
; 252  : 
; 253  :     /* get internal structure */
; 254  :     if (file == NULL)

  00015	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00019	75 04		 jne	 SHORT $LN2@gzwrite

; 255  :         return 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 50		 jmp	 SHORT $LN1@gzwrite
$LN2@gzwrite:

; 256  :     state = (gz_statep)file;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00022	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 257  : 
; 258  :     /* check that we're writing and that there's no error */
; 259  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00028	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  0002f	75 09		 jne	 SHORT $LN4@gzwrite
  00031	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00034	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00038	74 04		 je	 SHORT $LN3@gzwrite
$LN4@gzwrite:

; 260  :         return 0;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 31		 jmp	 SHORT $LN1@gzwrite
$LN3@gzwrite:

; 261  : 
; 262  :     /* since an int is returned, make sure len fits in one, otherwise return
; 263  :        with an error (this avoids a flaw in the interface) */
; 264  :     if ((int)len < 0) {

  0003e	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00042	7d 17		 jge	 SHORT $LN5@gzwrite

; 265  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
  00049	6a fd		 push	 -3			; fffffffdH
  0004b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 _gz_error
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 266  :         return 0;

  00057	33 c0		 xor	 eax, eax
  00059	eb 14		 jmp	 SHORT $LN1@gzwrite
$LN5@gzwrite:

; 267  :     }
; 268  : 
; 269  :     /* write len bytes from buf (the return value will fit in an int) */
; 270  :     return (int)gz_write(state, buf, len);

  0005b	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00062	52		 push	 edx
  00063	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _gz_write
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gzwrite:

; 271  : }

  0006f	83 c4 04	 add	 esp, 4
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
_gzwrite@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gzfwrite@16
_TEXT	SEGMENT
tv82 = -12						; size = 4
_state$ = -8						; size = 4
_len$ = -4						; size = 4
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_nitems$ = 16						; size = 4
_file$ = 20						; size = 4
_gzfwrite@16 PROC					; COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 280  :     z_size_t len;
; 281  :     gz_statep state;
; 282  : 
; 283  :     /* get internal structure */
; 284  :     if (file == NULL)

  00025	83 7d 14 00	 cmp	 DWORD PTR _file$[ebp], 0
  00029	75 07		 jne	 SHORT $LN2@gzfwrite

; 285  :         return 0;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 81 00 00 00	 jmp	 $LN1@gzfwrite
$LN2@gzfwrite:

; 286  :     state = (gz_statep)file;

  00032	8b 45 14	 mov	 eax, DWORD PTR _file$[ebp]
  00035	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 287  : 
; 288  :     /* check that we're writing and that there's no error */
; 289  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0003b	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  00042	75 09		 jne	 SHORT $LN4@gzfwrite
  00044	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00047	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0004b	74 04		 je	 SHORT $LN3@gzfwrite
$LN4@gzfwrite:

; 290  :         return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 62		 jmp	 SHORT $LN1@gzfwrite
$LN3@gzfwrite:

; 291  : 
; 292  :     /* compute bytes to read -- error on overflow */
; 293  :     len = nitems * size;

  00051	8b 45 10	 mov	 eax, DWORD PTR _nitems$[ebp]
  00054	0f af 45 0c	 imul	 eax, DWORD PTR _size$[ebp]
  00058	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 294  :     if (size && len / size != nitems) {

  0005b	83 7d 0c 00	 cmp	 DWORD PTR _size$[ebp], 0
  0005f	74 24		 je	 SHORT $LN5@gzfwrite
  00061	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00064	33 d2		 xor	 edx, edx
  00066	f7 75 0c	 div	 DWORD PTR _size$[ebp]
  00069	3b 45 10	 cmp	 eax, DWORD PTR _nitems$[ebp]
  0006c	74 17		 je	 SHORT $LN5@gzfwrite

; 295  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");

  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@
  00073	6a fe		 push	 -2			; fffffffeH
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 _gz_error
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 296  :         return 0;

  00081	33 c0		 xor	 eax, eax
  00083	eb 2e		 jmp	 SHORT $LN1@gzfwrite
$LN5@gzfwrite:

; 297  :     }
; 298  : 
; 299  :     /* write len bytes to buf, return the number of full items written */
; 300  :     return len ? gz_write(state, buf, len) / size : 0;

  00085	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00089	74 1e		 je	 SHORT $LN7@gzfwrite
  0008b	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  0008e	52		 push	 edx
  0008f	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00092	50		 push	 eax
  00093	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _gz_write
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009f	33 d2		 xor	 edx, edx
  000a1	f7 75 0c	 div	 DWORD PTR _size$[ebp]
  000a4	89 45 f4	 mov	 DWORD PTR tv82[ebp], eax
  000a7	eb 07		 jmp	 SHORT $LN8@gzfwrite
$LN7@gzfwrite:
  000a9	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN8@gzfwrite:
  000b0	8b 45 f4	 mov	 eax, DWORD PTR tv82[ebp]
$LN1@gzfwrite:

; 301  : }

  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 10 00	 ret	 16			; 00000010H
_gzfwrite@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gzputc@8
_TEXT	SEGMENT
_strm$ = -24						; size = 4
_state$ = -20						; size = 4
_buf$ = -9						; size = 1
_have$ = -4						; size = 4
_file$ = 8						; size = 4
_c$ = 12						; size = 4
_gzputc@8 PROC						; COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00022	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 308  :     unsigned have;
; 309  :     unsigned char buf[1];
; 310  :     gz_statep state;
; 311  :     z_streamp strm;
; 312  : 
; 313  :     /* get internal structure */
; 314  :     if (file == NULL)

  00027	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0002b	75 08		 jne	 SHORT $LN2@gzputc

; 315  :         return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	e9 12 01 00 00	 jmp	 $LN1@gzputc
$LN2@gzputc:

; 316  :     state = (gz_statep)file;

  00035	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00038	89 45 ec	 mov	 DWORD PTR _state$[ebp], eax

; 317  :     strm = &(state->strm);

  0003b	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0003e	83 c1 64	 add	 ecx, 100		; 00000064H
  00041	89 4d e8	 mov	 DWORD PTR _strm$[ebp], ecx

; 318  : 
; 319  :     /* check that we're writing and that there's no error */
; 320  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00044	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00047	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0004e	75 09		 jne	 SHORT $LN4@gzputc
  00050	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00053	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00057	74 08		 je	 SHORT $LN3@gzputc
$LN4@gzputc:

; 321  :         return -1;

  00059	83 c8 ff	 or	 eax, -1
  0005c	e9 e6 00 00 00	 jmp	 $LN1@gzputc
$LN3@gzputc:

; 322  : 
; 323  :     /* check for seek request */
; 324  :     if (state->seek) {

  00061	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00064	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00068	74 2e		 je	 SHORT $LN5@gzputc

; 325  :         state->seek = 0;

  0006a	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0006d	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 326  :         if (gz_zero(state, state->skip) == -1)

  00074	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00077	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0007a	51		 push	 ecx
  0007b	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  0007e	52		 push	 edx
  0007f	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _gz_zero
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008b	83 f8 ff	 cmp	 eax, -1
  0008e	75 08		 jne	 SHORT $LN5@gzputc

; 327  :             return -1;

  00090	83 c8 ff	 or	 eax, -1
  00093	e9 af 00 00 00	 jmp	 $LN1@gzputc
$LN5@gzputc:

; 328  :     }
; 329  : 
; 330  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 331  :        initialized) */
; 332  :     if (state->size) {

  00098	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0009b	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  0009f	74 73		 je	 SHORT $LN7@gzputc

; 333  :         if (strm->avail_in == 0)

  000a1	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  000a4	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000a8	75 0b		 jne	 SHORT $LN8@gzputc

; 334  :             strm->next_in = state->in;

  000aa	8b 45 e8	 mov	 eax, DWORD PTR _strm$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000b0	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000b3	89 10		 mov	 DWORD PTR [eax], edx
$LN8@gzputc:

; 335  :         have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  000b5	8b 45 e8	 mov	 eax, DWORD PTR _strm$[ebp]
  000b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ba	8b 55 e8	 mov	 edx, DWORD PTR _strm$[ebp]
  000bd	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000c0	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000c3	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  000c6	89 4d fc	 mov	 DWORD PTR _have$[ebp], ecx

; 336  :         if (have < state->size) {

  000c9	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000cc	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  000cf	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  000d2	73 40		 jae	 SHORT $LN7@gzputc

; 337  :             state->in[have] = (unsigned char)c;

  000d4	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000d7	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000da	8b 55 fc	 mov	 edx, DWORD PTR _have$[ebp]
  000dd	8a 45 0c	 mov	 al, BYTE PTR _c$[ebp]
  000e0	88 04 11	 mov	 BYTE PTR [ecx+edx], al

; 338  :             strm->avail_in++;

  000e3	8b 4d e8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000e6	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000e9	83 c2 01	 add	 edx, 1
  000ec	8b 45 e8	 mov	 eax, DWORD PTR _strm$[ebp]
  000ef	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 339  :             state->x.pos++;

  000f2	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000f5	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000f8	83 c2 01	 add	 edx, 1
  000fb	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000fe	83 d0 00	 adc	 eax, 0
  00101	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00104	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00107	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 340  :             return c & 0xff;

  0010a	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  0010d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00112	eb 33		 jmp	 SHORT $LN1@gzputc
$LN7@gzputc:

; 341  :         }
; 342  :     }
; 343  : 
; 344  :     /* no room in buffer or not initialized, use gz_write() */
; 345  :     buf[0] = (unsigned char)c;

  00114	ba 01 00 00 00	 mov	 edx, 1
  00119	6b c2 00	 imul	 eax, edx, 0
  0011c	8a 4d 0c	 mov	 cl, BYTE PTR _c$[ebp]
  0011f	88 4c 05 f7	 mov	 BYTE PTR _buf$[ebp+eax], cl

; 346  :     if (gz_write(state, buf, 1) != 1)

  00123	6a 01		 push	 1
  00125	8d 55 f7	 lea	 edx, DWORD PTR _buf$[ebp]
  00128	52		 push	 edx
  00129	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 _gz_write
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
  00135	83 f8 01	 cmp	 eax, 1
  00138	74 05		 je	 SHORT $LN10@gzputc

; 347  :         return -1;

  0013a	83 c8 ff	 or	 eax, -1
  0013d	eb 08		 jmp	 SHORT $LN1@gzputc
$LN10@gzputc:

; 348  :     return c & 0xff;

  0013f	8b 45 0c	 mov	 eax, DWORD PTR _c$[ebp]
  00142	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
$LN1@gzputc:

; 349  : }

  00147	52		 push	 edx
  00148	8b cd		 mov	 ecx, ebp
  0014a	50		 push	 eax
  0014b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@gzputc
  00151	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00156	58		 pop	 eax
  00157	5a		 pop	 edx
  00158	83 c4 18	 add	 esp, 24			; 00000018H
  0015b	3b ec		 cmp	 ebp, esp
  0015d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c2 08 00	 ret	 8
$LN16@gzputc:
  00168	01 00 00 00	 DD	 1
  0016c	00 00 00 00	 DD	 $LN15@gzputc
$LN15@gzputc:
  00170	f7 ff ff ff	 DD	 -9			; fffffff7H
  00174	01 00 00 00	 DD	 1
  00178	00 00 00 00	 DD	 $LN14@gzputc
$LN14@gzputc:
  0017c	62		 DB	 98			; 00000062H
  0017d	75		 DB	 117			; 00000075H
  0017e	66		 DB	 102			; 00000066H
  0017f	00		 DB	 0
_gzputc@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gzputs@8
_TEXT	SEGMENT
tv77 = -16						; size = 4
_state$ = -12						; size = 4
_len$ = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_str$ = 12						; size = 4
_gzputs@8 PROC						; COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 356  :     int ret;
; 357  :     z_size_t len;
; 358  :     gz_statep state;
; 359  : 
; 360  :     /* get internal structure */
; 361  :     if (file == NULL)

  00021	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00025	75 05		 jne	 SHORT $LN2@gzputs

; 362  :         return -1;

  00027	83 c8 ff	 or	 eax, -1
  0002a	eb 64		 jmp	 SHORT $LN1@gzputs
$LN2@gzputs:

; 363  :     state = (gz_statep)file;

  0002c	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0002f	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 364  : 
; 365  :     /* check that we're writing and that there's no error */
; 366  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00032	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  0003c	75 09		 jne	 SHORT $LN4@gzputs
  0003e	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00041	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00045	74 05		 je	 SHORT $LN3@gzputs
$LN4@gzputs:

; 367  :         return -1;

  00047	83 c8 ff	 or	 eax, -1
  0004a	eb 44		 jmp	 SHORT $LN1@gzputs
$LN3@gzputs:

; 368  : 
; 369  :     /* write string */
; 370  :     len = strlen(str);

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _strlen
  00055	83 c4 04	 add	 esp, 4
  00058	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 371  :     ret = gz_write(state, str, len);

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 0c	 mov	 edx, DWORD PTR _str$[ebp]
  00062	52		 push	 edx
  00063	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _gz_write
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006f	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 372  :     return ret == 0 && len != 0 ? -1 : ret;

  00072	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00076	75 0f		 jne	 SHORT $LN6@gzputs
  00078	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  0007c	74 09		 je	 SHORT $LN6@gzputs
  0007e	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR tv77[ebp], -1
  00085	eb 06		 jmp	 SHORT $LN7@gzputs
$LN6@gzputs:
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _ret$[ebp]
  0008a	89 4d f0	 mov	 DWORD PTR tv77[ebp], ecx
$LN7@gzputs:
  0008d	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
$LN1@gzputs:

; 373  : }

  00090	83 c4 10	 add	 esp, 16			; 00000010H
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
_gzputs@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\stdio.h
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gzvprintf
_TEXT	SEGMENT
tv188 = -32						; size = 4
__Result$1 = -28					; size = 4
__BufferCount$ = -24					; size = 4
_strm$ = -20						; size = 4
_state$ = -16						; size = 4
_next$ = -12						; size = 4
_left$ = -8						; size = 4
_len$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_va$ = 16						; size = 4
_gzvprintf PROC						; COMDAT

; 380  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000e	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00011	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00014	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00017	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001a	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001d	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00020	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 381  :     int len;
; 382  :     unsigned left;
; 383  :     char *next;
; 384  :     gz_statep state;
; 385  :     z_streamp strm;
; 386  : 
; 387  :     /* get internal structure */
; 388  :     if (file == NULL)

  0002d	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00031	75 0a		 jne	 SHORT $LN2@gzvprintf

; 389  :         return Z_STREAM_ERROR;

  00033	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00038	e9 e8 01 00 00	 jmp	 $LN1@gzvprintf
$LN2@gzvprintf:

; 390  :     state = (gz_statep)file;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00040	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 391  :     strm = &(state->strm);

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00046	83 c1 64	 add	 ecx, 100		; 00000064H
  00049	89 4d ec	 mov	 DWORD PTR _strm$[ebp], ecx

; 392  : 
; 393  :     /* check that we're writing and that there's no error */
; 394  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0004c	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0004f	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00056	75 09		 jne	 SHORT $LN4@gzvprintf
  00058	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0005b	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  0005f	74 0a		 je	 SHORT $LN3@gzvprintf
$LN4@gzvprintf:

; 395  :         return Z_STREAM_ERROR;

  00061	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00066	e9 ba 01 00 00	 jmp	 $LN1@gzvprintf
$LN3@gzvprintf:

; 396  : 
; 397  :     /* make sure we have some buffer space */
; 398  :     if (state->size == 0 && gz_init(state) == -1)

  0006b	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0006e	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00072	75 1c		 jne	 SHORT $LN5@gzvprintf
  00074	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 _gz_init
  0007d	83 c4 04	 add	 esp, 4
  00080	83 f8 ff	 cmp	 eax, -1
  00083	75 0b		 jne	 SHORT $LN5@gzvprintf

; 399  :         return state->err;

  00085	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00088	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  0008b	e9 95 01 00 00	 jmp	 $LN1@gzvprintf
$LN5@gzvprintf:

; 400  : 
; 401  :     /* check for seek request */
; 402  :     if (state->seek) {

  00090	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00093	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00097	74 31		 je	 SHORT $LN6@gzvprintf

; 403  :         state->seek = 0;

  00099	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0009c	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 404  :         if (gz_zero(state, state->skip) == -1)

  000a3	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000a6	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  000a9	51		 push	 ecx
  000aa	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  000ad	52		 push	 edx
  000ae	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 _gz_zero
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ba	83 f8 ff	 cmp	 eax, -1
  000bd	75 0b		 jne	 SHORT $LN6@gzvprintf

; 405  :             return state->err;

  000bf	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000c2	8b 41 5c	 mov	 eax, DWORD PTR [ecx+92]
  000c5	e9 5b 01 00 00	 jmp	 $LN1@gzvprintf
$LN6@gzvprintf:

; 406  :     }
; 407  : 
; 408  :     /* do the printf() into the input buffer, put length in len -- the input
; 409  :        buffer is double-sized just for this function, so there is guaranteed to
; 410  :        be state->size bytes available after the current contents */
; 411  :     if (strm->avail_in == 0)

  000ca	8b 55 ec	 mov	 edx, DWORD PTR _strm$[ebp]
  000cd	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000d1	75 0b		 jne	 SHORT $LN8@gzvprintf

; 412  :         strm->next_in = state->in;

  000d3	8b 45 ec	 mov	 eax, DWORD PTR _strm$[ebp]
  000d6	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000d9	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000dc	89 10		 mov	 DWORD PTR [eax], edx
$LN8@gzvprintf:

; 413  :     next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);

  000de	8b 45 ec	 mov	 eax, DWORD PTR _strm$[ebp]
  000e1	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000e4	8b 10		 mov	 edx, DWORD PTR [eax]
  000e6	2b 51 24	 sub	 edx, DWORD PTR [ecx+36]
  000e9	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000ec	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000ef	03 ca		 add	 ecx, edx
  000f1	8b 55 ec	 mov	 edx, DWORD PTR _strm$[ebp]
  000f4	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000f7	89 4d f4	 mov	 DWORD PTR _next$[ebp], ecx

; 414  :     next[state->size - 1] = 0;

  000fa	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000fd	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00100	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  00103	c6 44 0a ff 00	 mov	 BYTE PTR [edx+ecx-1], 0

; 428  :     len = vsnprintf(next, state->size, format, va);

  00108	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0010b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0010e	89 4d e8	 mov	 DWORD PTR __BufferCount$[ebp], ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\stdio.h

; 1438 :         int const _Result = __stdio_common_vsprintf(

  00111	8b 55 10	 mov	 edx, DWORD PTR _va$[ebp]
  00114	52		 push	 edx
  00115	6a 00		 push	 0
  00117	8b 45 0c	 mov	 eax, DWORD PTR _format$[ebp]
  0011a	50		 push	 eax
  0011b	8b 4d e8	 mov	 ecx, DWORD PTR __BufferCount$[ebp]
  0011e	51		 push	 ecx
  0011f	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00128	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012a	83 c9 02	 or	 ecx, 2
  0012d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00130	52		 push	 edx
  00131	51		 push	 ecx
  00132	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00137	83 c4 1c	 add	 esp, 28			; 0000001cH
  0013a	89 45 e4	 mov	 DWORD PTR __Result$1[ebp], eax

; 1439 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1440 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1441 : 
; 1442 :         return _Result < 0 ? -1 : _Result;

  0013d	83 7d e4 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  00141	7d 09		 jge	 SHORT $LN16@gzvprintf
  00143	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR tv188[ebp], -1
  0014a	eb 06		 jmp	 SHORT $LN14@gzvprintf
$LN16@gzvprintf:
  0014c	8b 45 e4	 mov	 eax, DWORD PTR __Result$1[ebp]
  0014f	89 45 e0	 mov	 DWORD PTR tv188[ebp], eax
$LN14@gzvprintf:
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c

; 428  :     len = vsnprintf(next, state->size, format, va);

  00152	8b 4d e0	 mov	 ecx, DWORD PTR tv188[ebp]
  00155	89 4d fc	 mov	 DWORD PTR _len$[ebp], ecx

; 429  : #  endif
; 430  : #endif
; 431  : 
; 432  :     /* check that printf() results fit in buffer */
; 433  :     if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)

  00158	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  0015c	74 1d		 je	 SHORT $LN10@gzvprintf
  0015e	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00161	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00164	3b 42 1c	 cmp	 eax, DWORD PTR [edx+28]
  00167	73 12		 jae	 SHORT $LN10@gzvprintf
  00169	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0016c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0016f	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  00172	0f be 4c 10 ff	 movsx	 ecx, BYTE PTR [eax+edx-1]
  00177	85 c9		 test	 ecx, ecx
  00179	74 07		 je	 SHORT $LN9@gzvprintf
$LN10@gzvprintf:

; 434  :         return 0;

  0017b	33 c0		 xor	 eax, eax
  0017d	e9 a3 00 00 00	 jmp	 $LN1@gzvprintf
$LN9@gzvprintf:

; 435  : 
; 436  :     /* update buffer and position, compress first half if past that */
; 437  :     strm->avail_in += (unsigned)len;

  00182	8b 55 ec	 mov	 edx, DWORD PTR _strm$[ebp]
  00185	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00188	03 45 fc	 add	 eax, DWORD PTR _len$[ebp]
  0018b	8b 4d ec	 mov	 ecx, DWORD PTR _strm$[ebp]
  0018e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 438  :     state->x.pos += len;

  00191	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00194	99		 cdq
  00195	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00198	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  0019b	13 51 0c	 adc	 edx, DWORD PTR [ecx+12]
  0019e	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001a1	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  001a4	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 439  :     if (strm->avail_in >= state->size) {

  001a7	8b 55 ec	 mov	 edx, DWORD PTR _strm$[ebp]
  001aa	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001ad	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001b0	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  001b3	72 6a		 jb	 SHORT $LN11@gzvprintf

; 440  :         left = strm->avail_in - state->size;

  001b5	8b 55 ec	 mov	 edx, DWORD PTR _strm$[ebp]
  001b8	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001bb	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001be	2b 48 1c	 sub	 ecx, DWORD PTR [eax+28]
  001c1	89 4d f8	 mov	 DWORD PTR _left$[ebp], ecx

; 441  :         strm->avail_in = state->size;

  001c4	8b 55 ec	 mov	 edx, DWORD PTR _strm$[ebp]
  001c7	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001ca	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001cd	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 442  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  001d0	6a 00		 push	 0
  001d2	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  001d5	52		 push	 edx
  001d6	e8 00 00 00 00	 call	 _gz_comp
  001db	83 c4 08	 add	 esp, 8
  001de	83 f8 ff	 cmp	 eax, -1
  001e1	75 08		 jne	 SHORT $LN12@gzvprintf

; 443  :             return state->err;

  001e3	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001e6	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  001e9	eb 3a		 jmp	 SHORT $LN1@gzvprintf
$LN12@gzvprintf:

; 444  :         memcpy(state->in, state->in + state->size, left);

  001eb	8b 4d f8	 mov	 ecx, DWORD PTR _left$[ebp]
  001ee	51		 push	 ecx
  001ef	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  001f2	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  001f5	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001f8	03 41 1c	 add	 eax, DWORD PTR [ecx+28]
  001fb	50		 push	 eax
  001fc	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  001ff	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 _memcpy
  00208	83 c4 0c	 add	 esp, 12			; 0000000cH

; 445  :         strm->next_in = state->in;

  0020b	8b 4d ec	 mov	 ecx, DWORD PTR _strm$[ebp]
  0020e	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00211	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00214	89 01		 mov	 DWORD PTR [ecx], eax

; 446  :         strm->avail_in = left;

  00216	8b 4d ec	 mov	 ecx, DWORD PTR _strm$[ebp]
  00219	8b 55 f8	 mov	 edx, DWORD PTR _left$[ebp]
  0021c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN11@gzvprintf:

; 447  :     }
; 448  :     return len;

  0021f	0f ae e8	 lfence
  00222	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
$LN1@gzvprintf:

; 449  : }

  00225	83 c4 20	 add	 esp, 32			; 00000020H
  00228	3b ec		 cmp	 ebp, esp
  0022a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c3		 ret	 0
_gzvprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gzprintf
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_va$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 453  :     va_list va;
; 454  :     int ret;
; 455  : 
; 456  :     va_start(va, format);

  0001e	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  00021	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 457  :     ret = gzvprintf(file, format, va);

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR _format$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _gzvprintf
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
  00038	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 458  :     va_end(va);

  0003b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 459  :     return ret;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 460  : }

  00045	83 c4 08	 add	 esp, 8
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gzflush@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush@8 PROC						; COMDAT

; 556  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 557  :     gz_statep state;
; 558  : 
; 559  :     /* get internal structure */
; 560  :     if (file == NULL)

  00015	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00019	75 0a		 jne	 SHORT $LN2@gzflush

; 561  :         return Z_STREAM_ERROR;

  0001b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00020	e9 85 00 00 00	 jmp	 $LN1@gzflush
$LN2@gzflush:

; 562  :     state = (gz_statep)file;

  00025	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 563  : 
; 564  :     /* check that we're writing and that there's no error */
; 565  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0002e	81 79 10 b1 79
	00 00		 cmp	 DWORD PTR [ecx+16], 31153 ; 000079b1H
  00035	75 09		 jne	 SHORT $LN4@gzflush
  00037	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0003a	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0003e	74 07		 je	 SHORT $LN3@gzflush
$LN4@gzflush:

; 566  :         return Z_STREAM_ERROR;

  00040	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00045	eb 63		 jmp	 SHORT $LN1@gzflush
$LN3@gzflush:

; 567  : 
; 568  :     /* check flush parameter */
; 569  :     if (flush < 0 || flush > Z_FINISH)

  00047	83 7d 0c 00	 cmp	 DWORD PTR _flush$[ebp], 0
  0004b	7c 06		 jl	 SHORT $LN6@gzflush
  0004d	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  00051	7e 07		 jle	 SHORT $LN5@gzflush
$LN6@gzflush:

; 570  :         return Z_STREAM_ERROR;

  00053	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00058	eb 50		 jmp	 SHORT $LN1@gzflush
$LN5@gzflush:

; 571  : 
; 572  :     /* check for seek request */
; 573  :     if (state->seek) {

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0005d	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00061	74 2e		 je	 SHORT $LN7@gzflush

; 574  :         state->seek = 0;

  00063	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00066	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 575  :         if (gz_zero(state, state->skip) == -1)

  0006d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00070	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00073	50		 push	 eax
  00074	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  00077	51		 push	 ecx
  00078	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 _gz_zero
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	83 f8 ff	 cmp	 eax, -1
  00087	75 08		 jne	 SHORT $LN7@gzflush

; 576  :             return state->err;

  00089	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0008c	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  0008f	eb 19		 jmp	 SHORT $LN1@gzflush
$LN7@gzflush:

; 577  :     }
; 578  : 
; 579  :     /* compress remaining data with requested flush */
; 580  :     (void)gz_comp(state, flush);

  00091	0f ae e8	 lfence
  00094	8b 4d 0c	 mov	 ecx, DWORD PTR _flush$[ebp]
  00097	51		 push	 ecx
  00098	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0009b	52		 push	 edx
  0009c	e8 00 00 00 00	 call	 _gz_comp
  000a1	83 c4 08	 add	 esp, 8

; 581  :     return state->err;

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000a7	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
$LN1@gzflush:

; 582  : }

  000aa	83 c4 04	 add	 esp, 4
  000ad	3b ec		 cmp	 ebp, esp
  000af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 08 00	 ret	 8
_gzflush@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT _gzsetparams@12
_TEXT	SEGMENT
_strm$ = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams@12 PROC					; COMDAT

; 589  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 590  :     gz_statep state;
; 591  :     z_streamp strm;
; 592  : 
; 593  :     /* get internal structure */
; 594  :     if (file == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00022	75 0a		 jne	 SHORT $LN2@gzsetparam

; 595  :         return Z_STREAM_ERROR;

  00024	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00029	e9 d4 00 00 00	 jmp	 $LN1@gzsetparam
$LN2@gzsetparam:

; 596  :     state = (gz_statep)file;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 597  :     strm = &(state->strm);

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00037	83 c1 64	 add	 ecx, 100		; 00000064H
  0003a	89 4d f8	 mov	 DWORD PTR _strm$[ebp], ecx

; 598  : 
; 599  :     /* check that we're writing and that there's no error */
; 600  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00040	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00047	75 09		 jne	 SHORT $LN4@gzsetparam
  00049	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0004c	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00050	74 0a		 je	 SHORT $LN3@gzsetparam
$LN4@gzsetparam:

; 601  :         return Z_STREAM_ERROR;

  00052	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00057	e9 a6 00 00 00	 jmp	 $LN1@gzsetparam
$LN3@gzsetparam:

; 602  : 
; 603  :     /* if no change is requested, then do nothing */
; 604  :     if (level == state->level && strategy == state->strategy)

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0005f	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  00062	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  00065	75 12		 jne	 SHORT $LN5@gzsetparam
  00067	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0006a	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  0006d	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  00070	75 07		 jne	 SHORT $LN5@gzsetparam

; 605  :         return Z_OK;

  00072	33 c0		 xor	 eax, eax
  00074	e9 89 00 00 00	 jmp	 $LN1@gzsetparam
$LN5@gzsetparam:

; 606  : 
; 607  :     /* check for seek request */
; 608  :     if (state->seek) {

  00079	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0007c	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00080	74 2e		 je	 SHORT $LN6@gzsetparam

; 609  :         state->seek = 0;

  00082	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00085	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 610  :         if (gz_zero(state, state->skip) == -1)

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0008f	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  00092	52		 push	 edx
  00093	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00096	50		 push	 eax
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 _gz_zero
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	83 f8 ff	 cmp	 eax, -1
  000a6	75 08		 jne	 SHORT $LN6@gzsetparam

; 611  :             return state->err;

  000a8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000ab	8b 42 5c	 mov	 eax, DWORD PTR [edx+92]
  000ae	eb 52		 jmp	 SHORT $LN1@gzsetparam
$LN6@gzsetparam:

; 612  :     }
; 613  : 
; 614  :     /* change compression parameters for subsequent input */
; 615  :     if (state->size) {

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000b3	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  000b7	74 35		 je	 SHORT $LN8@gzsetparam

; 616  :         /* flush previous input with previous parameters before changing */
; 617  :         if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)

  000b9	8b 4d f8	 mov	 ecx, DWORD PTR _strm$[ebp]
  000bc	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  000c0	74 1b		 je	 SHORT $LN9@gzsetparam
  000c2	6a 05		 push	 5
  000c4	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 _gz_comp
  000cd	83 c4 08	 add	 esp, 8
  000d0	83 f8 ff	 cmp	 eax, -1
  000d3	75 08		 jne	 SHORT $LN9@gzsetparam

; 618  :             return state->err;

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000d8	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  000db	eb 25		 jmp	 SHORT $LN1@gzsetparam
$LN9@gzsetparam:

; 619  :         deflateParams(strm, level, strategy);

  000dd	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  000e0	51		 push	 ecx
  000e1	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  000e4	52		 push	 edx
  000e5	8b 45 f8	 mov	 eax, DWORD PTR _strm$[ebp]
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 _deflateParams@12
$LN8@gzsetparam:

; 620  :     }
; 621  :     state->level = level;

  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000f1	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  000f4	89 51 48	 mov	 DWORD PTR [ecx+72], edx

; 622  :     state->strategy = strategy;

  000f7	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000fa	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  000fd	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 623  :     return Z_OK;

  00100	33 c0		 xor	 eax, eax
$LN1@gzsetparam:

; 624  : }

  00102	83 c4 08	 add	 esp, 8
  00105	3b ec		 cmp	 ebp, esp
  00107	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010c	8b e5		 mov	 esp, ebp
  0010e	5d		 pop	 ebp
  0010f	c2 0c 00	 ret	 12			; 0000000cH
_gzsetparams@12 ENDP
_TEXT	ENDS
END
