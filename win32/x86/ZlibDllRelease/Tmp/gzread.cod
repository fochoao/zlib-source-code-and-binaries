; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

	TITLE	e:\cpython\externals\zlib-1.2.11\gzread.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@	; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error@	; `string'
PUBLIC	??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@ ; `string'
PUBLIC	??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@ ; `string'
EXTRN	_strerror:PROC
EXTRN	_memchr:PROC
EXTRN	__errno:PROC
EXTRN	__close:PROC
EXTRN	__read:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@ DB 'out of room t'
	DB	'o push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@
CONST	SEGMENT
??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@ DB 'request doe'
	DB	's not fit in a size_t', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@
CONST	SEGMENT
??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@ DB 'request does'
	DB	' not fit in an int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error@ DB 'compressed data error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ DB 'internal err'
	DB	'or: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@ DB 'unexpected end of file', 00H ; `string'
__DB664BEB_corecrt_stdio_config@h DB 01H
__E28BBA23_corecrt_wstdio@h DB 01H
__4A1C29A8_stdio@h DB 01H
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__077EA387_gzread@c DB 01H
PUBLIC	_gzdirect@4
PUBLIC	_gzgets@12
PUBLIC	_gzungetc@8
PUBLIC	_gzgetc_@4
PUBLIC	_gzgetc@4
PUBLIC	_gzfread@16
PUBLIC	_gzread@12
PUBLIC	_gzclose_r@4
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gzclose_r@4
_TEXT	SEGMENT
tv88 = -20						; size = 4
tv77 = -16						; size = 4
_state$ = -12						; size = 4
_err$ = -8						; size = 4
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclose_r@4 PROC					; COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 630  :     int ret, err;
; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  00024	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00028	75 0a		 jne	 SHORT $LN2@gzclose_r

; 635  :         return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002f	e9 c3 00 00 00	 jmp	 $LN1@gzclose_r
$LN2@gzclose_r:

; 636  :     state = (gz_statep)file;

  00034	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00037	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 637  : 
; 638  :     /* check that we're reading */
; 639  :     if (state->mode != GZ_READ)

  0003a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0003d	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00044	74 0a		 je	 SHORT $LN3@gzclose_r

; 640  :         return Z_STREAM_ERROR;

  00046	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0004b	e9 a7 00 00 00	 jmp	 $LN1@gzclose_r
$LN3@gzclose_r:

; 641  : 
; 642  :     /* free memory and close file */
; 643  :     if (state->size) {

  00050	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00053	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  00057	74 2a		 je	 SHORT $LN4@gzclose_r

; 644  :         inflateEnd(&(state->strm));

  00059	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	83 c0 64	 add	 eax, 100		; 00000064H
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _inflateEnd@4

; 645  :         free(state->out);

  00065	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00068	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 _free
  00071	83 c4 04	 add	 esp, 4

; 646  :         free(state->in);

  00074	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00077	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _free
  00080	83 c4 04	 add	 esp, 4
$LN4@gzclose_r:

; 647  :     }
; 648  :     err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;

  00083	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00086	83 7a 5c fb	 cmp	 DWORD PTR [edx+92], -5	; fffffffbH
  0008a	75 09		 jne	 SHORT $LN6@gzclose_r
  0008c	c7 45 f0 fb ff
	ff ff		 mov	 DWORD PTR tv77[ebp], -5	; fffffffbH
  00093	eb 07		 jmp	 SHORT $LN7@gzclose_r
$LN6@gzclose_r:
  00095	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN7@gzclose_r:
  0009c	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  0009f	89 45 f8	 mov	 DWORD PTR _err$[ebp], eax

; 649  :     gz_error(state, Z_OK, NULL);

  000a2	6a 00		 push	 0
  000a4	6a 00		 push	 0
  000a6	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000a9	51		 push	 ecx
  000aa	e8 00 00 00 00	 call	 _gz_error
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 650  :     free(state->path);

  000b2	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000b5	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _free
  000be	83 c4 04	 add	 esp, 4

; 651  :     ret = close(state->fd);

  000c1	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000c4	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 __close
  000cd	83 c4 04	 add	 esp, 4
  000d0	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 652  :     free(state);

  000d3	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _free
  000dc	83 c4 04	 add	 esp, 4

; 653  :     return ret ? Z_ERRNO : err;

  000df	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000e3	74 09		 je	 SHORT $LN8@gzclose_r
  000e5	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv88[ebp], -1
  000ec	eb 06		 jmp	 SHORT $LN9@gzclose_r
$LN8@gzclose_r:
  000ee	8b 4d f8	 mov	 ecx, DWORD PTR _err$[ebp]
  000f1	89 4d ec	 mov	 DWORD PTR tv88[ebp], ecx
$LN9@gzclose_r:
  000f4	8b 45 ec	 mov	 eax, DWORD PTR tv88[ebp]
$LN1@gzclose_r:

; 654  : }

  000f7	83 c4 14	 add	 esp, 20			; 00000014H
  000fa	3b ec		 cmp	 ebp, esp
  000fc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 04 00	 ret	 4
_gzclose_r@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gz_load
_TEXT	SEGMENT
_max$ = -12						; size = 4
_get$ = -8						; size = 4
_ret$ = -4						; size = 4
_state$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_have$ = 20						; size = 4
_gz_load PROC						; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 27   :     int ret;
; 28   :     unsigned get, max = ((unsigned)-1 >> 2) + 1;

  00025	c7 45 f4 00 00
	00 40		 mov	 DWORD PTR _max$[ebp], 1073741824 ; 40000000H

; 29   : 
; 30   :     *have = 0;

  0002c	8b 45 14	 mov	 eax, DWORD PTR _have$[ebp]
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN4@gz_load:

; 31   :     do {
; 32   :         get = len - *have;

  00035	8b 4d 14	 mov	 ecx, DWORD PTR _have$[ebp]
  00038	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  0003b	2b 11		 sub	 edx, DWORD PTR [ecx]
  0003d	89 55 f8	 mov	 DWORD PTR _get$[ebp], edx

; 33   :         if (get > max)

  00040	8b 45 f8	 mov	 eax, DWORD PTR _get$[ebp]
  00043	3b 45 f4	 cmp	 eax, DWORD PTR _max$[ebp]
  00046	76 06		 jbe	 SHORT $LN5@gz_load

; 34   :             get = max;

  00048	8b 4d f4	 mov	 ecx, DWORD PTR _max$[ebp]
  0004b	89 4d f8	 mov	 DWORD PTR _get$[ebp], ecx
$LN5@gz_load:

; 35   :         ret = read(state->fd, buf + *have, get);

  0004e	8b 55 f8	 mov	 edx, DWORD PTR _get$[ebp]
  00051	52		 push	 edx
  00052	8b 45 14	 mov	 eax, DWORD PTR _have$[ebp]
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00058	03 08		 add	 ecx, DWORD PTR [eax]
  0005a	51		 push	 ecx
  0005b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0005e	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 __read
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 36   :         if (ret <= 0)

  0006d	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00071	7f 02		 jg	 SHORT $LN6@gz_load

; 37   :             break;

  00073	eb 17		 jmp	 SHORT $LN3@gz_load
$LN6@gz_load:

; 38   :         *have += (unsigned)ret;

  00075	8b 4d 14	 mov	 ecx, DWORD PTR _have$[ebp]
  00078	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007a	03 55 fc	 add	 edx, DWORD PTR _ret$[ebp]
  0007d	8b 45 14	 mov	 eax, DWORD PTR _have$[ebp]
  00080	89 10		 mov	 DWORD PTR [eax], edx

; 39   :     } while (*have < len);

  00082	8b 4d 14	 mov	 ecx, DWORD PTR _have$[ebp]
  00085	8b 11		 mov	 edx, DWORD PTR [ecx]
  00087	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  0008a	72 a9		 jb	 SHORT $LN4@gz_load
$LN3@gz_load:

; 40   :     if (ret < 0) {

  0008c	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00090	7d 24		 jge	 SHORT $LN7@gz_load

; 41   :         gz_error(state, Z_ERRNO, zstrerror());

  00092	e8 00 00 00 00	 call	 __errno
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _strerror
  0009f	83 c4 04	 add	 esp, 4
  000a2	50		 push	 eax
  000a3	6a ff		 push	 -1
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _gz_error
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 42   :         return -1;

  000b1	83 c8 ff	 or	 eax, -1
  000b4	eb 12		 jmp	 SHORT $LN1@gz_load
$LN7@gz_load:

; 43   :     }
; 44   :     if (ret == 0)

  000b6	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000ba	75 0a		 jne	 SHORT $LN8@gz_load

; 45   :         state->eof = 1;

  000bc	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000bf	c7 42 40 01 00
	00 00		 mov	 DWORD PTR [edx+64], 1
$LN8@gz_load:

; 46   :     return 0;

  000c6	33 c0		 xor	 eax, eax
$LN1@gz_load:

; 47   : }

  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cb	3b ec		 cmp	 ebp, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_gz_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gz_avail
_TEXT	SEGMENT
_n$1 = -28						; size = 4
_q$2 = -24						; size = 4
_p$3 = -20						; size = 4
_strm$ = -16						; size = 4
_got$ = -8						; size = 4
_state$ = 8						; size = 4
_gz_avail PROC						; COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 59   :     unsigned got;
; 60   :     z_streamp strm = &(state->strm);

  0002a	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002d	83 c0 64	 add	 eax, 100		; 00000064H
  00030	89 45 f0	 mov	 DWORD PTR _strm$[ebp], eax

; 61   : 
; 62   :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00033	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00036	83 79 5c 00	 cmp	 DWORD PTR [ecx+92], 0
  0003a	74 11		 je	 SHORT $LN5@gz_avail
  0003c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0003f	83 7a 5c fb	 cmp	 DWORD PTR [edx+92], -5	; fffffffbH
  00043	74 08		 je	 SHORT $LN5@gz_avail

; 63   :         return -1;

  00045	83 c8 ff	 or	 eax, -1
  00048	e9 a7 00 00 00	 jmp	 $LN1@gz_avail
$LN5@gz_avail:

; 64   :     if (state->eof == 0) {

  0004d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00050	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00054	0f 85 98 00 00
	00		 jne	 $LN6@gz_avail

; 65   :         if (strm->avail_in) {       /* copy what's there to the start */

  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005d	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00061	74 41		 je	 SHORT $LN7@gz_avail

; 66   :             unsigned char *p = state->in;

  00063	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00066	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00069	89 45 ec	 mov	 DWORD PTR _p$3[ebp], eax

; 67   :             unsigned const char *q = strm->next_in;

  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _strm$[ebp]
  0006f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00071	89 55 e8	 mov	 DWORD PTR _q$2[ebp], edx

; 68   :             unsigned n = strm->avail_in;

  00074	8b 45 f0	 mov	 eax, DWORD PTR _strm$[ebp]
  00077	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007a	89 4d e4	 mov	 DWORD PTR _n$1[ebp], ecx
$LN4@gz_avail:

; 69   :             do {
; 70   :                 *p++ = *q++;

  0007d	8b 55 ec	 mov	 edx, DWORD PTR _p$3[ebp]
  00080	8b 45 e8	 mov	 eax, DWORD PTR _q$2[ebp]
  00083	8a 08		 mov	 cl, BYTE PTR [eax]
  00085	88 0a		 mov	 BYTE PTR [edx], cl
  00087	8b 55 ec	 mov	 edx, DWORD PTR _p$3[ebp]
  0008a	83 c2 01	 add	 edx, 1
  0008d	89 55 ec	 mov	 DWORD PTR _p$3[ebp], edx
  00090	8b 45 e8	 mov	 eax, DWORD PTR _q$2[ebp]
  00093	83 c0 01	 add	 eax, 1
  00096	89 45 e8	 mov	 DWORD PTR _q$2[ebp], eax

; 71   :             } while (--n);

  00099	8b 4d e4	 mov	 ecx, DWORD PTR _n$1[ebp]
  0009c	83 e9 01	 sub	 ecx, 1
  0009f	89 4d e4	 mov	 DWORD PTR _n$1[ebp], ecx
  000a2	75 d9		 jne	 SHORT $LN4@gz_avail
$LN7@gz_avail:

; 72   :         }
; 73   :         if (gz_load(state, state->in + strm->avail_in,
; 74   :                     state->size - strm->avail_in, &got) == -1)

  000a4	8d 55 f8	 lea	 edx, DWORD PTR _got$[ebp]
  000a7	52		 push	 edx
  000a8	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000ab	8b 4d f0	 mov	 ecx, DWORD PTR _strm$[ebp]
  000ae	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  000b1	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  000b4	52		 push	 edx
  000b5	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000b8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000bb	8b 55 f0	 mov	 edx, DWORD PTR _strm$[ebp]
  000be	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000c1	51		 push	 ecx
  000c2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 _gz_load
  000cb	83 c4 10	 add	 esp, 16			; 00000010H
  000ce	83 f8 ff	 cmp	 eax, -1
  000d1	75 05		 jne	 SHORT $LN8@gz_avail

; 75   :             return -1;

  000d3	83 c8 ff	 or	 eax, -1
  000d6	eb 1c		 jmp	 SHORT $LN1@gz_avail
$LN8@gz_avail:

; 76   :         strm->avail_in += got;

  000d8	8b 4d f0	 mov	 ecx, DWORD PTR _strm$[ebp]
  000db	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000de	03 55 f8	 add	 edx, DWORD PTR _got$[ebp]
  000e1	8b 45 f0	 mov	 eax, DWORD PTR _strm$[ebp]
  000e4	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 77   :         strm->next_in = state->in;

  000e7	8b 4d f0	 mov	 ecx, DWORD PTR _strm$[ebp]
  000ea	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000ed	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000f0	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@gz_avail:

; 78   :     }
; 79   :     return 0;

  000f2	33 c0		 xor	 eax, eax
$LN1@gz_avail:

; 80   : }

  000f4	52		 push	 edx
  000f5	8b cd		 mov	 ecx, ebp
  000f7	50		 push	 eax
  000f8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@gz_avail
  000fe	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00103	58		 pop	 eax
  00104	5a		 pop	 edx
  00105	83 c4 1c	 add	 esp, 28			; 0000001cH
  00108	3b ec		 cmp	 ebp, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c3		 ret	 0
  00113	90		 npad	 1
$LN13@gz_avail:
  00114	01 00 00 00	 DD	 1
  00118	00 00 00 00	 DD	 $LN12@gz_avail
$LN12@gz_avail:
  0011c	f8 ff ff ff	 DD	 -8			; fffffff8H
  00120	04 00 00 00	 DD	 4
  00124	00 00 00 00	 DD	 $LN11@gz_avail
$LN11@gz_avail:
  00128	67		 DB	 103			; 00000067H
  00129	6f		 DB	 111			; 0000006fH
  0012a	74		 DB	 116			; 00000074H
  0012b	00		 DB	 0
_gz_avail ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gz_look
_TEXT	SEGMENT
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_look PROC						; COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 94   :     z_streamp strm = &(state->strm);

  00015	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00018	83 c0 64	 add	 eax, 100		; 00000064H
  0001b	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax

; 95   : 
; 96   :     /* allocate read buffers and inflate memory */
; 97   :     if (state->size == 0) {

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00021	83 79 1c 00	 cmp	 DWORD PTR [ecx+28], 0
  00025	0f 85 1a 01 00
	00		 jne	 $LN2@gz_look

; 98   :         /* allocate buffers */
; 99   :         state->in = (unsigned char *)malloc(state->want);

  0002b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0002e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _malloc
  00037	83 c4 04	 add	 esp, 4
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0003d	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 100  :         state->out = (unsigned char *)malloc(state->want << 1);

  00040	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00043	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00046	d1 e0		 shl	 eax, 1
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _malloc
  0004e	83 c4 04	 add	 esp, 4
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00054	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 101  :         if (state->in == NULL || state->out == NULL) {

  00057	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0005a	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0005e	74 09		 je	 SHORT $LN4@gz_look
  00060	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00063	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00067	75 39		 jne	 SHORT $LN3@gz_look
$LN4@gz_look:

; 102  :             free(state->out);

  00069	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0006c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0006f	52		 push	 edx
  00070	e8 00 00 00 00	 call	 _free
  00075	83 c4 04	 add	 esp, 4

; 103  :             free(state->in);

  00078	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0007b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 _free
  00084	83 c4 04	 add	 esp, 4

; 104  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00087	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  0008c	6a fc		 push	 -4			; fffffffcH
  0008e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 _gz_error
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH

; 105  :             return -1;

  0009a	83 c8 ff	 or	 eax, -1
  0009d	e9 b6 01 00 00	 jmp	 $LN1@gz_look
$LN3@gz_look:

; 106  :         }
; 107  :         state->size = state->want;

  000a2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000a8	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000ab	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 108  : 
; 109  :         /* allocate inflate memory */
; 110  :         state->strm.zalloc = Z_NULL;

  000ae	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000b1	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+132], 0

; 111  :         state->strm.zfree = Z_NULL;

  000bb	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000be	c7 81 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+136], 0

; 112  :         state->strm.opaque = Z_NULL;

  000c8	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000cb	c7 82 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [edx+140], 0

; 113  :         state->strm.avail_in = 0;

  000d5	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000d8	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 114  :         state->strm.next_in = Z_NULL;

  000df	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000e2	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0

; 115  :         if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */

  000e9	6a 38		 push	 56			; 00000038H
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411@
  000f0	6a 1f		 push	 31			; 0000001fH
  000f2	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000f5	83 c2 64	 add	 edx, 100		; 00000064H
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 _inflateInit2_@16
  000fe	85 c0		 test	 eax, eax
  00100	74 43		 je	 SHORT $LN2@gz_look

; 116  :             free(state->out);

  00102	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00105	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00108	51		 push	 ecx
  00109	e8 00 00 00 00	 call	 _free
  0010e	83 c4 04	 add	 esp, 4

; 117  :             free(state->in);

  00111	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00114	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _free
  0011d	83 c4 04	 add	 esp, 4

; 118  :             state->size = 0;

  00120	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00123	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 119  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  0012f	6a fc		 push	 -4			; fffffffcH
  00131	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00134	52		 push	 edx
  00135	e8 00 00 00 00	 call	 _gz_error
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 120  :             return -1;

  0013d	83 c8 ff	 or	 eax, -1
  00140	e9 13 01 00 00	 jmp	 $LN1@gz_look
$LN2@gz_look:

; 121  :         }
; 122  :     }
; 123  : 
; 124  :     /* get at least the magic bytes in the input buffer */
; 125  :     if (strm->avail_in < 2) {

  00145	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00148	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  0014c	73 29		 jae	 SHORT $LN6@gz_look

; 126  :         if (gz_avail(state) == -1)

  0014e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00151	51		 push	 ecx
  00152	e8 00 00 00 00	 call	 _gz_avail
  00157	83 c4 04	 add	 esp, 4
  0015a	83 f8 ff	 cmp	 eax, -1
  0015d	75 08		 jne	 SHORT $LN7@gz_look

; 127  :             return -1;

  0015f	83 c8 ff	 or	 eax, -1
  00162	e9 f1 00 00 00	 jmp	 $LN1@gz_look
$LN7@gz_look:

; 128  :         if (strm->avail_in == 0)

  00167	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0016a	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0016e	75 07		 jne	 SHORT $LN6@gz_look

; 129  :             return 0;

  00170	33 c0		 xor	 eax, eax
  00172	e9 e1 00 00 00	 jmp	 $LN1@gz_look
$LN6@gz_look:

; 130  :     }
; 131  : 
; 132  :     /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
; 133  :        a logical dilemma here when considering the case of a partially written
; 134  :        gzip file, to wit, if a single 31 byte is written, then we cannot tell
; 135  :        whether this is a single-byte file, or just a partially written gzip
; 136  :        file -- for here we assume that if a gzip file is being written, then
; 137  :        the header will be written in a single operation, so that reading a
; 138  :        single byte is sufficient indication that it is not a gzip file) */
; 139  :     if (strm->avail_in > 1 &&
; 140  :             strm->next_in[0] == 31 && strm->next_in[1] == 139) {

  00177	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  0017a	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  0017e	76 52		 jbe	 SHORT $LN9@gz_look
  00180	b9 01 00 00 00	 mov	 ecx, 1
  00185	6b d1 00	 imul	 edx, ecx, 0
  00188	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  0018b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018d	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  00191	83 fa 1f	 cmp	 edx, 31			; 0000001fH
  00194	75 3c		 jne	 SHORT $LN9@gz_look
  00196	b8 01 00 00 00	 mov	 eax, 1
  0019b	c1 e0 00	 shl	 eax, 0
  0019e	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  001a1	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a3	0f b6 04 02	 movzx	 eax, BYTE PTR [edx+eax]
  001a7	3d 8b 00 00 00	 cmp	 eax, 139		; 0000008bH
  001ac	75 24		 jne	 SHORT $LN9@gz_look

; 141  :         inflateReset(strm);

  001ae	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  001b1	51		 push	 ecx
  001b2	e8 00 00 00 00	 call	 _inflateReset@4

; 142  :         state->how = GZIP;

  001b7	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001ba	c7 42 30 02 00
	00 00		 mov	 DWORD PTR [edx+48], 2

; 143  :         state->direct = 0;

  001c1	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001c4	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 144  :         return 0;

  001cb	33 c0		 xor	 eax, eax
  001cd	e9 86 00 00 00	 jmp	 $LN1@gz_look
$LN9@gz_look:

; 145  :     }
; 146  : 
; 147  :     /* no gzip header -- if we were decoding gzip before, then this is trailing
; 148  :        garbage.  Ignore the trailing garbage and finish. */
; 149  :     if (state->direct == 0) {

  001d2	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001d5	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  001d9	75 21		 jne	 SHORT $LN10@gz_look

; 150  :         strm->avail_in = 0;

  001db	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  001de	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 151  :         state->eof = 1;

  001e5	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001e8	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [eax+64], 1

; 152  :         state->x.have = 0;

  001ef	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  001f2	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 153  :         return 0;

  001f8	33 c0		 xor	 eax, eax
  001fa	eb 5c		 jmp	 SHORT $LN1@gz_look
$LN10@gz_look:

; 154  :     }
; 155  : 
; 156  :     /* doing raw i/o, copy any leftover input to output -- this assumes that
; 157  :        the output buffer is larger than the input buffer, which also assures
; 158  :        space for gzungetc() */
; 159  :     state->x.next = state->out;

  001fc	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  001ff	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00202	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00205	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 160  :     if (strm->avail_in) {

  00208	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0020b	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0020f	74 31		 je	 SHORT $LN11@gz_look

; 161  :         memcpy(state->x.next, strm->next_in, strm->avail_in);

  00211	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  00214	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00217	51		 push	 ecx
  00218	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  0021b	8b 02		 mov	 eax, DWORD PTR [edx]
  0021d	50		 push	 eax
  0021e	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00221	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00224	52		 push	 edx
  00225	e8 00 00 00 00	 call	 _memcpy
  0022a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 162  :         state->x.have = strm->avail_in;

  0022d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00230	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  00233	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00236	89 10		 mov	 DWORD PTR [eax], edx

; 163  :         strm->avail_in = 0;

  00238	8b 45 fc	 mov	 eax, DWORD PTR _strm$[ebp]
  0023b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN11@gz_look:

; 164  :     }
; 165  :     state->how = COPY;

  00242	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00245	c7 41 30 01 00
	00 00		 mov	 DWORD PTR [ecx+48], 1

; 166  :     state->direct = 1;

  0024c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0024f	c7 42 2c 01 00
	00 00		 mov	 DWORD PTR [edx+44], 1

; 167  :     return 0;

  00256	33 c0		 xor	 eax, eax
$LN1@gz_look:

; 168  : }

  00258	83 c4 04	 add	 esp, 4
  0025b	3b ec		 cmp	 ebp, esp
  0025d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00262	8b e5		 mov	 esp, ebp
  00264	5d		 pop	 ebp
  00265	c3		 ret	 0
_gz_look ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gz_decomp
_TEXT	SEGMENT
tv92 = -16						; size = 4
_strm$ = -12						; size = 4
_had$ = -8						; size = 4
_ret$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_decomp PROC						; COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 178  :     int ret = Z_OK;

  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 179  :     unsigned had;
; 180  :     z_streamp strm = &(state->strm);

  00028	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	83 c0 64	 add	 eax, 100		; 00000064H
  0002e	89 45 f4	 mov	 DWORD PTR _strm$[ebp], eax

; 181  : 
; 182  :     /* fill output buffer up to end of deflate stream */
; 183  :     had = strm->avail_out;

  00031	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00034	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00037	89 55 f8	 mov	 DWORD PTR _had$[ebp], edx
$LN4@gz_decomp:

; 184  :     do {
; 185  :         /* get more input for inflate() */
; 186  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  0003a	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  0003d	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00041	75 19		 jne	 SHORT $LN5@gz_decomp
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 _gz_avail
  0004c	83 c4 04	 add	 esp, 4
  0004f	83 f8 ff	 cmp	 eax, -1
  00052	75 08		 jne	 SHORT $LN5@gz_decomp

; 187  :             return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	e9 f0 00 00 00	 jmp	 $LN1@gz_decomp
$LN5@gz_decomp:

; 188  :         if (strm->avail_in == 0) {

  0005c	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  0005f	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00063	75 18		 jne	 SHORT $LN6@gz_decomp

; 189  :             gz_error(state, Z_BUF_ERROR, "unexpected end of file");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
  0006a	6a fb		 push	 -5			; fffffffbH
  0006c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _gz_error
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 190  :             break;

  00078	e9 9e 00 00 00	 jmp	 $LN3@gz_decomp
$LN6@gz_decomp:

; 191  :         }
; 192  : 
; 193  :         /* decompress and handle errors */
; 194  :         ret = inflate(strm, Z_NO_FLUSH);

  0007d	6a 00		 push	 0
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _inflate@8
  00088	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 195  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  0008b	83 7d fc fe	 cmp	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  0008f	74 06		 je	 SHORT $LN8@gz_decomp
  00091	83 7d fc 02	 cmp	 DWORD PTR _ret$[ebp], 2
  00095	75 1b		 jne	 SHORT $LN7@gz_decomp
$LN8@gz_decomp:

; 196  :             gz_error(state, Z_STREAM_ERROR,

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
  0009c	6a fe		 push	 -2			; fffffffeH
  0009e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000a1	52		 push	 edx
  000a2	e8 00 00 00 00	 call	 _gz_error
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 197  :                      "internal error: inflate stream corrupt");
; 198  :             return -1;

  000aa	83 c8 ff	 or	 eax, -1
  000ad	e9 9a 00 00 00	 jmp	 $LN1@gz_decomp
$LN7@gz_decomp:

; 199  :         }
; 200  :         if (ret == Z_MEM_ERROR) {

  000b2	83 7d fc fc	 cmp	 DWORD PTR _ret$[ebp], -4 ; fffffffcH
  000b6	75 18		 jne	 SHORT $LN9@gz_decomp

; 201  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  000bd	6a fc		 push	 -4			; fffffffcH
  000bf	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 _gz_error
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  :             return -1;

  000cb	83 c8 ff	 or	 eax, -1
  000ce	eb 7c		 jmp	 SHORT $LN1@gz_decomp
$LN9@gz_decomp:

; 203  :         }
; 204  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  000d0	83 7d fc fd	 cmp	 DWORD PTR _ret$[ebp], -3 ; fffffffdH
  000d4	75 32		 jne	 SHORT $LN2@gz_decomp

; 205  :             gz_error(state, Z_DATA_ERROR,

  000d6	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  000d9	83 79 18 00	 cmp	 DWORD PTR [ecx+24], 0
  000dd	75 09		 jne	 SHORT $LN14@gz_decomp
  000df	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv92[ebp], OFFSET ??_C@_0BG@HCKBMIHF@compressed?5data?5error@
  000e6	eb 09		 jmp	 SHORT $LN15@gz_decomp
$LN14@gz_decomp:
  000e8	8b 55 f4	 mov	 edx, DWORD PTR _strm$[ebp]
  000eb	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  000ee	89 45 f0	 mov	 DWORD PTR tv92[ebp], eax
$LN15@gz_decomp:
  000f1	8b 4d f0	 mov	 ecx, DWORD PTR tv92[ebp]
  000f4	51		 push	 ecx
  000f5	6a fd		 push	 -3			; fffffffdH
  000f7	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 _gz_error
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 206  :                      strm->msg == NULL ? "compressed data error" : strm->msg);
; 207  :             return -1;

  00103	83 c8 ff	 or	 eax, -1
  00106	eb 44		 jmp	 SHORT $LN1@gz_decomp
$LN2@gz_decomp:

; 208  :         }
; 209  :     } while (strm->avail_out && ret != Z_STREAM_END);

  00108	8b 45 f4	 mov	 eax, DWORD PTR _strm$[ebp]
  0010b	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0010f	74 0a		 je	 SHORT $LN3@gz_decomp
  00111	83 7d fc 01	 cmp	 DWORD PTR _ret$[ebp], 1
  00115	0f 85 1f ff ff
	ff		 jne	 $LN4@gz_decomp
$LN3@gz_decomp:

; 210  : 
; 211  :     /* update available output */
; 212  :     state->x.have = had - strm->avail_out;

  0011b	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0011e	8b 55 f8	 mov	 edx, DWORD PTR _had$[ebp]
  00121	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  00124	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00127	89 10		 mov	 DWORD PTR [eax], edx

; 213  :     state->x.next = strm->next_out - state->x.have;

  00129	8b 4d f4	 mov	 ecx, DWORD PTR _strm$[ebp]
  0012c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0012f	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00132	2b 02		 sub	 eax, DWORD PTR [edx]
  00134	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00137	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 214  : 
; 215  :     /* if the gzip stream completed successfully, look for another */
; 216  :     if (ret == Z_STREAM_END)

  0013a	83 7d fc 01	 cmp	 DWORD PTR _ret$[ebp], 1
  0013e	75 0a		 jne	 SHORT $LN12@gz_decomp

; 217  :         state->how = LOOK;

  00140	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00143	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0
$LN12@gz_decomp:

; 218  : 
; 219  :     /* good decompression */
; 220  :     return 0;

  0014a	33 c0		 xor	 eax, eax
$LN1@gz_decomp:

; 221  : }

  0014c	83 c4 10	 add	 esp, 16			; 00000010H
  0014f	3b ec		 cmp	 ebp, esp
  00151	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c3		 ret	 0
_gz_decomp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gz_fetch
_TEXT	SEGMENT
tv66 = -8						; size = 4
_strm$ = -4						; size = 4
_state$ = 8						; size = 4
_gz_fetch PROC						; COMDAT

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 232  :     z_streamp strm = &(state->strm);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00021	83 c0 64	 add	 eax, 100		; 00000064H
  00024	89 45 fc	 mov	 DWORD PTR _strm$[ebp], eax
$LN4@gz_fetch:

; 233  : 
; 234  :     do {
; 235  :         switch(state->how) {

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0002a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0002d	89 55 f8	 mov	 DWORD PTR tv66[ebp], edx
  00030	83 7d f8 00	 cmp	 DWORD PTR tv66[ebp], 0
  00034	74 11		 je	 SHORT $LN7@gz_fetch
  00036	83 7d f8 01	 cmp	 DWORD PTR tv66[ebp], 1
  0003a	74 36		 je	 SHORT $LN10@gz_fetch
  0003c	83 7d f8 02	 cmp	 DWORD PTR tv66[ebp], 2
  00040	74 6a		 je	 SHORT $LN12@gz_fetch
  00042	e9 95 00 00 00	 jmp	 $LN2@gz_fetch
$LN7@gz_fetch:

; 236  :         case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
; 237  :             if (gz_look(state) == -1)

  00047	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _gz_look
  00050	83 c4 04	 add	 esp, 4
  00053	83 f8 ff	 cmp	 eax, -1
  00056	75 08		 jne	 SHORT $LN8@gz_fetch

; 238  :                 return -1;

  00058	83 c8 ff	 or	 eax, -1
  0005b	e9 a0 00 00 00	 jmp	 $LN1@gz_fetch
$LN8@gz_fetch:

; 239  :             if (state->how == LOOK)

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00063	83 79 30 00	 cmp	 DWORD PTR [ecx+48], 0
  00067	75 07		 jne	 SHORT $LN9@gz_fetch

; 240  :                 return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 90 00 00 00	 jmp	 $LN1@gz_fetch
$LN9@gz_fetch:

; 241  :             break;

  00070	eb 6a		 jmp	 SHORT $LN2@gz_fetch
$LN10@gz_fetch:

; 242  :         case COPY:      /* -> COPY */
; 243  :             if (gz_load(state, state->out, state->size << 1, &(state->x.have))
; 244  :                     == -1)

  00072	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00075	52		 push	 edx
  00076	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00079	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0007c	d1 e1		 shl	 ecx, 1
  0007e	51		 push	 ecx
  0007f	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00082	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00085	50		 push	 eax
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 _gz_load
  0008f	83 c4 10	 add	 esp, 16			; 00000010H
  00092	83 f8 ff	 cmp	 eax, -1
  00095	75 05		 jne	 SHORT $LN11@gz_fetch

; 245  :                 return -1;

  00097	83 c8 ff	 or	 eax, -1
  0009a	eb 64		 jmp	 SHORT $LN1@gz_fetch
$LN11@gz_fetch:

; 246  :             state->x.next = state->out;

  0009c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0009f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a2	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000a5	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 247  :             return 0;

  000a8	33 c0		 xor	 eax, eax
  000aa	eb 54		 jmp	 SHORT $LN1@gz_fetch
$LN12@gz_fetch:

; 248  :         case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
; 249  :             strm->avail_out = state->size << 1;

  000ac	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000af	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  000b2	d1 e0		 shl	 eax, 1
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b7	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 250  :             strm->next_out = state->out;

  000ba	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000bd	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000c0	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000c3	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 251  :             if (gz_decomp(state) == -1)

  000c6	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000c9	52		 push	 edx
  000ca	e8 00 00 00 00	 call	 _gz_decomp
  000cf	83 c4 04	 add	 esp, 4
  000d2	83 f8 ff	 cmp	 eax, -1
  000d5	75 05		 jne	 SHORT $LN2@gz_fetch

; 252  :                 return -1;

  000d7	83 c8 ff	 or	 eax, -1
  000da	eb 24		 jmp	 SHORT $LN1@gz_fetch
$LN2@gz_fetch:

; 253  :         }
; 254  :     } while (state->x.have == 0 && (!state->eof || strm->avail_in));

  000dc	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000df	83 38 00	 cmp	 DWORD PTR [eax], 0
  000e2	75 1a		 jne	 SHORT $LN3@gz_fetch
  000e4	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000e7	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  000eb	0f 84 36 ff ff
	ff		 je	 $LN4@gz_fetch
  000f1	8b 55 fc	 mov	 edx, DWORD PTR _strm$[ebp]
  000f4	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  000f8	0f 85 29 ff ff
	ff		 jne	 $LN4@gz_fetch
$LN3@gz_fetch:

; 255  :     return 0;

  000fe	33 c0		 xor	 eax, eax
$LN1@gz_fetch:

; 256  : }

  00100	83 c4 08	 add	 esp, 8
  00103	3b ec		 cmp	 ebp, esp
  00105	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
_gz_fetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gz_skip
_TEXT	SEGMENT
tv73 = -16						; size = 4
tv137 = -12						; size = 8
_n$ = -4						; size = 4
_state$ = 8						; size = 4
_len$ = 12						; size = 8
_gz_skip PROC						; COMDAT

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN2@gz_skip:

; 263  :     unsigned n;
; 264  : 
; 265  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 266  :     while (len)

  00021	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00024	0b 45 10	 or	 eax, DWORD PTR _len$[ebp+4]
  00027	0f 84 be 00 00
	00		 je	 $LN3@gz_skip

; 267  :         /* skip over whatever is in output buffer */
; 268  :         if (state->x.have) {

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00030	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00033	0f 84 81 00 00
	00		 je	 $LN4@gz_skip

; 269  :             n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?

  00039	33 d2		 xor	 edx, edx
  0003b	75 29		 jne	 SHORT $LN10@gz_skip
  0003d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	33 d2		 xor	 edx, edx
  00044	89 4d f4	 mov	 DWORD PTR tv137[ebp], ecx
  00047	89 55 f8	 mov	 DWORD PTR tv137[ebp+4], edx
  0004a	8b 45 f8	 mov	 eax, DWORD PTR tv137[ebp+4]
  0004d	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp+4]
  00050	7f 14		 jg	 SHORT $LN10@gz_skip
  00052	7c 08		 jl	 SHORT $LN14@gz_skip
  00054	8b 4d f4	 mov	 ecx, DWORD PTR tv137[ebp]
  00057	3b 4d 0c	 cmp	 ecx, DWORD PTR _len$[ebp]
  0005a	77 0a		 ja	 SHORT $LN10@gz_skip
$LN14@gz_skip:
  0005c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	89 45 f0	 mov	 DWORD PTR tv73[ebp], eax
  00064	eb 06		 jmp	 SHORT $LN11@gz_skip
$LN10@gz_skip:
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00069	89 4d f0	 mov	 DWORD PTR tv73[ebp], ecx
$LN11@gz_skip:
  0006c	8b 55 f0	 mov	 edx, DWORD PTR tv73[ebp]
  0006f	89 55 fc	 mov	 DWORD PTR _n$[ebp], edx

; 270  :                 (unsigned)len : state->x.have;
; 271  :             state->x.have -= n;

  00072	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00075	8b 08		 mov	 ecx, DWORD PTR [eax]
  00077	2b 4d fc	 sub	 ecx, DWORD PTR _n$[ebp]
  0007a	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0007d	89 0a		 mov	 DWORD PTR [edx], ecx

; 272  :             state->x.next += n;

  0007f	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00082	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00085	03 4d fc	 add	 ecx, DWORD PTR _n$[ebp]
  00088	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0008b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 273  :             state->x.pos += n;

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00091	33 c9		 xor	 ecx, ecx
  00093	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00096	03 42 08	 add	 eax, DWORD PTR [edx+8]
  00099	13 4a 0c	 adc	 ecx, DWORD PTR [edx+12]
  0009c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0009f	89 42 08	 mov	 DWORD PTR [edx+8], eax
  000a2	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 274  :             len -= n;

  000a5	33 c0		 xor	 eax, eax
  000a7	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  000aa	2b 4d fc	 sub	 ecx, DWORD PTR _n$[ebp]
  000ad	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp+4]
  000b0	1b d0		 sbb	 edx, eax
  000b2	89 4d 0c	 mov	 DWORD PTR _len$[ebp], ecx
  000b5	89 55 10	 mov	 DWORD PTR _len$[ebp+4], edx

; 275  :         }

  000b8	eb 2c		 jmp	 SHORT $LN5@gz_skip
$LN4@gz_skip:

; 276  : 
; 277  :         /* output buffer empty -- return if we're at the end of the input */
; 278  :         else if (state->eof && state->strm.avail_in == 0)

  000ba	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000bd	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  000c1	74 0d		 je	 SHORT $LN6@gz_skip
  000c3	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000c6	83 79 68 00	 cmp	 DWORD PTR [ecx+104], 0
  000ca	75 04		 jne	 SHORT $LN6@gz_skip

; 279  :             break;

  000cc	eb 1d		 jmp	 SHORT $LN3@gz_skip
  000ce	eb 16		 jmp	 SHORT $LN5@gz_skip
$LN6@gz_skip:

; 280  : 
; 281  :         /* need more data to skip -- load up output buffer */
; 282  :         else {
; 283  :             /* get more output, looking for header if required */
; 284  :             if (gz_fetch(state) == -1)

  000d0	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 _gz_fetch
  000d9	83 c4 04	 add	 esp, 4
  000dc	83 f8 ff	 cmp	 eax, -1
  000df	75 05		 jne	 SHORT $LN5@gz_skip

; 285  :                 return -1;

  000e1	83 c8 ff	 or	 eax, -1
  000e4	eb 07		 jmp	 SHORT $LN1@gz_skip
$LN5@gz_skip:

; 286  :         }

  000e6	e9 36 ff ff ff	 jmp	 $LN2@gz_skip
$LN3@gz_skip:

; 287  :     return 0;

  000eb	33 c0		 xor	 eax, eax
$LN1@gz_skip:

; 288  : }

  000ed	83 c4 10	 add	 esp, 16			; 00000010H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_gz_skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gz_read
_TEXT	SEGMENT
_n$ = -12						; size = 4
_got$ = -4						; size = 4
_state$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gz_read PROC						; COMDAT

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 299  :     z_size_t got;
; 300  :     unsigned n;
; 301  : 
; 302  :     /* if len is zero, avoid unnecessary operations */
; 303  :     if (len == 0)

  00021	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00025	75 07		 jne	 SHORT $LN5@gz_read

; 304  :         return 0;

  00027	33 c0		 xor	 eax, eax
  00029	e9 a2 01 00 00	 jmp	 $LN1@gz_read
$LN5@gz_read:

; 305  : 
; 306  :     /* process a skip request */
; 307  :     if (state->seek) {

  0002e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00031	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00035	74 2d		 je	 SHORT $LN6@gz_read

; 308  :         state->seek = 0;

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0003a	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 309  :         if (gz_skip(state, state->skip) == -1)

  00041	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00044	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  00047	50		 push	 eax
  00048	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]
  0004b	51		 push	 ecx
  0004c	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _gz_skip
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	83 f8 ff	 cmp	 eax, -1
  0005b	75 07		 jne	 SHORT $LN6@gz_read

; 310  :             return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	e9 6c 01 00 00	 jmp	 $LN1@gz_read
$LN6@gz_read:

; 311  :     }
; 312  : 
; 313  :     /* get len bytes to buf, or less than len if at the end */
; 314  :     got = 0;

  00064	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _got$[ebp], 0
$LN4@gz_read:

; 315  :     do {
; 316  :         /* set n to the maximum amount of len that fits in an unsigned int */
; 317  :         n = -1;

  0006b	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _n$[ebp], -1

; 318  :         if (n > len)

  00072	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  00075	3b 45 10	 cmp	 eax, DWORD PTR _len$[ebp]
  00078	76 06		 jbe	 SHORT $LN8@gz_read

; 319  :             n = len;

  0007a	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0007d	89 4d f4	 mov	 DWORD PTR _n$[ebp], ecx
$LN8@gz_read:

; 320  : 
; 321  :         /* first just try copying data from the output buffer */
; 322  :         if (state->x.have) {

  00080	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00083	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00086	74 4a		 je	 SHORT $LN9@gz_read

; 323  :             if (state->x.have < n)

  00088	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0008b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008d	3b 4d f4	 cmp	 ecx, DWORD PTR _n$[ebp]
  00090	73 08		 jae	 SHORT $LN11@gz_read

; 324  :                 n = state->x.have;

  00092	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00095	8b 02		 mov	 eax, DWORD PTR [edx]
  00097	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax
$LN11@gz_read:

; 325  :             memcpy(buf, state->x.next, n);

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  0009d	51		 push	 ecx
  0009e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000a1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a4	50		 push	 eax
  000a5	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 _memcpy
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 326  :             state->x.next += n;

  000b1	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b7	03 45 f4	 add	 eax, DWORD PTR _n$[ebp]
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000bd	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 327  :             state->x.have -= n;

  000c0	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000c3	8b 02		 mov	 eax, DWORD PTR [edx]
  000c5	2b 45 f4	 sub	 eax, DWORD PTR _n$[ebp]
  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000cb	89 01		 mov	 DWORD PTR [ecx], eax

; 328  :         }

  000cd	e9 bf 00 00 00	 jmp	 $LN10@gz_read
$LN9@gz_read:

; 329  : 
; 330  :         /* output buffer empty -- return if we're at the end of the input */
; 331  :         else if (state->eof && state->strm.avail_in == 0) {

  000d2	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000d5	83 7a 40 00	 cmp	 DWORD PTR [edx+64], 0
  000d9	74 1d		 je	 SHORT $LN12@gz_read
  000db	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000de	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  000e2	75 14		 jne	 SHORT $LN12@gz_read

; 332  :             state->past = 1;        /* tried to read past end */

  000e4	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000e7	c7 41 44 01 00
	00 00		 mov	 DWORD PTR [ecx+68], 1

; 333  :             break;

  000ee	e9 da 00 00 00	 jmp	 $LN3@gz_read

; 334  :         }

  000f3	e9 99 00 00 00	 jmp	 $LN10@gz_read
$LN12@gz_read:

; 335  : 
; 336  :         /* need output data -- for small len or new stream load up our output
; 337  :            buffer */
; 338  :         else if (state->how == LOOK || n < (state->size << 1)) {

  000f8	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000fb	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  000ff	74 0d		 je	 SHORT $LN16@gz_read
  00101	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00104	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00107	d1 e1		 shl	 ecx, 1
  00109	39 4d f4	 cmp	 DWORD PTR _n$[ebp], ecx
  0010c	73 1f		 jae	 SHORT $LN14@gz_read
$LN16@gz_read:

; 339  :             /* get more output, looking for header if required */
; 340  :             if (gz_fetch(state) == -1)

  0010e	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00111	52		 push	 edx
  00112	e8 00 00 00 00	 call	 _gz_fetch
  00117	83 c4 04	 add	 esp, 4
  0011a	83 f8 ff	 cmp	 eax, -1
  0011d	75 07		 jne	 SHORT $LN17@gz_read

; 341  :                 return 0;

  0011f	33 c0		 xor	 eax, eax
  00121	e9 aa 00 00 00	 jmp	 $LN1@gz_read
$LN17@gz_read:

; 342  :             continue;       /* no progress yet -- go back to copy above */

  00126	e9 98 00 00 00	 jmp	 $LN2@gz_read

; 343  :             /* the copy above assures that we will leave with space in the
; 344  :                output buffer, allowing at least one gzungetc() to succeed */
; 345  :         }

  0012b	eb 64		 jmp	 SHORT $LN10@gz_read
$LN14@gz_read:

; 346  : 
; 347  :         /* large len -- read directly into user buffer */
; 348  :         else if (state->how == COPY) {      /* read directly */

  0012d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00130	83 78 30 01	 cmp	 DWORD PTR [eax+48], 1
  00134	75 23		 jne	 SHORT $LN18@gz_read

; 349  :             if (gz_load(state, (unsigned char *)buf, n, &n) == -1)

  00136	8d 4d f4	 lea	 ecx, DWORD PTR _n$[ebp]
  00139	51		 push	 ecx
  0013a	8b 55 f4	 mov	 edx, DWORD PTR _n$[ebp]
  0013d	52		 push	 edx
  0013e	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00141	50		 push	 eax
  00142	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00145	51		 push	 ecx
  00146	e8 00 00 00 00	 call	 _gz_load
  0014b	83 c4 10	 add	 esp, 16			; 00000010H
  0014e	83 f8 ff	 cmp	 eax, -1
  00151	75 04		 jne	 SHORT $LN20@gz_read

; 350  :                 return 0;

  00153	33 c0		 xor	 eax, eax
  00155	eb 79		 jmp	 SHORT $LN1@gz_read
$LN20@gz_read:

; 351  :         }

  00157	eb 38		 jmp	 SHORT $LN10@gz_read
$LN18@gz_read:

; 352  : 
; 353  :         /* large len -- decompress directly into user buffer */
; 354  :         else {  /* state->how == GZIP */
; 355  :             state->strm.avail_out = n;

  00159	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0015c	8b 45 f4	 mov	 eax, DWORD PTR _n$[ebp]
  0015f	89 42 74	 mov	 DWORD PTR [edx+116], eax

; 356  :             state->strm.next_out = (unsigned char *)buf;

  00162	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00165	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00168	89 51 70	 mov	 DWORD PTR [ecx+112], edx

; 357  :             if (gz_decomp(state) == -1)

  0016b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 _gz_decomp
  00174	83 c4 04	 add	 esp, 4
  00177	83 f8 ff	 cmp	 eax, -1
  0017a	75 04		 jne	 SHORT $LN21@gz_read

; 358  :                 return 0;

  0017c	33 c0		 xor	 eax, eax
  0017e	eb 50		 jmp	 SHORT $LN1@gz_read
$LN21@gz_read:

; 359  :             n = state->x.have;

  00180	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00183	8b 11		 mov	 edx, DWORD PTR [ecx]
  00185	89 55 f4	 mov	 DWORD PTR _n$[ebp], edx

; 360  :             state->x.have = 0;

  00188	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0018b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN10@gz_read:

; 361  :         }
; 362  : 
; 363  :         /* update progress */
; 364  :         len -= n;

  00191	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  00194	2b 4d f4	 sub	 ecx, DWORD PTR _n$[ebp]
  00197	89 4d 10	 mov	 DWORD PTR _len$[ebp], ecx

; 365  :         buf = (char *)buf + n;

  0019a	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0019d	03 55 f4	 add	 edx, DWORD PTR _n$[ebp]
  001a0	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 366  :         got += n;

  001a3	8b 45 fc	 mov	 eax, DWORD PTR _got$[ebp]
  001a6	03 45 f4	 add	 eax, DWORD PTR _n$[ebp]
  001a9	89 45 fc	 mov	 DWORD PTR _got$[ebp], eax

; 367  :         state->x.pos += n;

  001ac	8b 4d f4	 mov	 ecx, DWORD PTR _n$[ebp]
  001af	33 d2		 xor	 edx, edx
  001b1	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001b4	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  001b7	13 50 0c	 adc	 edx, DWORD PTR [eax+12]
  001ba	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  001bd	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001c0	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN2@gz_read:

; 368  :     } while (len);

  001c3	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  001c7	0f 85 9e fe ff
	ff		 jne	 $LN4@gz_read
$LN3@gz_read:

; 369  : 
; 370  :     /* return number of bytes read into user buffer */
; 371  :     return got;

  001cd	8b 45 fc	 mov	 eax, DWORD PTR _got$[ebp]
$LN1@gz_read:

; 372  : }

  001d0	52		 push	 edx
  001d1	8b cd		 mov	 ecx, ebp
  001d3	50		 push	 eax
  001d4	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@gz_read
  001da	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001df	58		 pop	 eax
  001e0	5a		 pop	 edx
  001e1	83 c4 10	 add	 esp, 16			; 00000010H
  001e4	3b ec		 cmp	 ebp, esp
  001e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c3		 ret	 0
  001ef	90		 npad	 1
$LN28@gz_read:
  001f0	01 00 00 00	 DD	 1
  001f4	00 00 00 00	 DD	 $LN27@gz_read
$LN27@gz_read:
  001f8	f4 ff ff ff	 DD	 -12			; fffffff4H
  001fc	04 00 00 00	 DD	 4
  00200	00 00 00 00	 DD	 $LN26@gz_read
$LN26@gz_read:
  00204	6e		 DB	 110			; 0000006eH
  00205	00		 DB	 0
_gz_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gzread@12
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzread@12 PROC						; COMDAT

; 379  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 380  :     gz_statep state;
; 381  : 
; 382  :     /* get internal structure */
; 383  :     if (file == NULL)

  00015	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00019	75 05		 jne	 SHORT $LN2@gzread

; 384  :         return -1;

  0001b	83 c8 ff	 or	 eax, -1
  0001e	eb 7e		 jmp	 SHORT $LN1@gzread
$LN2@gzread:

; 385  :     state = (gz_statep)file;

  00020	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 386  : 
; 387  :     /* check that we're reading and that there's no (serious) error */
; 388  :     if (state->mode != GZ_READ ||

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00029	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00030	75 12		 jne	 SHORT $LN4@gzread
  00032	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00035	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00039	74 0e		 je	 SHORT $LN3@gzread
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003e	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00042	74 05		 je	 SHORT $LN3@gzread
$LN4@gzread:

; 389  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 390  :         return -1;

  00044	83 c8 ff	 or	 eax, -1
  00047	eb 55		 jmp	 SHORT $LN1@gzread
$LN3@gzread:

; 391  : 
; 392  :     /* since an int is returned, make sure len fits in one, otherwise return
; 393  :        with an error (this avoids a flaw in the interface) */
; 394  :     if ((int)len < 0) {

  00049	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  0004d	7d 18		 jge	 SHORT $LN5@gzread

; 395  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in an int");

  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@
  00054	6a fe		 push	 -2			; fffffffeH
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 _gz_error
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 396  :         return -1;

  00062	83 c8 ff	 or	 eax, -1
  00065	eb 37		 jmp	 SHORT $LN1@gzread
$LN5@gzread:

; 397  :     }
; 398  : 
; 399  :     /* read len or fewer bytes to buf */
; 400  :     len = gz_read(state, buf, len);

  00067	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  0006a	52		 push	 edx
  0006b	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _gz_read
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	89 45 10	 mov	 DWORD PTR _len$[ebp], eax

; 401  : 
; 402  :     /* check for an error */
; 403  :     if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)

  0007e	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00082	75 17		 jne	 SHORT $LN6@gzread
  00084	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00087	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0008b	74 0e		 je	 SHORT $LN6@gzread
  0008d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00090	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00094	74 05		 je	 SHORT $LN6@gzread

; 404  :         return -1;

  00096	83 c8 ff	 or	 eax, -1
  00099	eb 03		 jmp	 SHORT $LN1@gzread
$LN6@gzread:

; 405  : 
; 406  :     /* return the number of bytes read (this is assured to fit in an int) */
; 407  :     return (int)len;

  0009b	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
$LN1@gzread:

; 408  : }

  0009e	83 c4 04	 add	 esp, 4
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 0c 00	 ret	 12			; 0000000cH
_gzread@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gzfread@16
_TEXT	SEGMENT
tv84 = -12						; size = 4
_state$ = -8						; size = 4
_len$ = -4						; size = 4
_buf$ = 8						; size = 4
_size$ = 12						; size = 4
_nitems$ = 16						; size = 4
_file$ = 20						; size = 4
_gzfread@16 PROC					; COMDAT

; 416  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 417  :     z_size_t len;
; 418  :     gz_statep state;
; 419  : 
; 420  :     /* get internal structure */
; 421  :     if (file == NULL)

  00025	83 7d 14 00	 cmp	 DWORD PTR _file$[ebp], 0
  00029	75 07		 jne	 SHORT $LN2@gzfread

; 422  :         return 0;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 8a 00 00 00	 jmp	 $LN1@gzfread
$LN2@gzfread:

; 423  :     state = (gz_statep)file;

  00032	8b 45 14	 mov	 eax, DWORD PTR _file$[ebp]
  00035	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 424  : 
; 425  :     /* check that we're reading and that there's no (serious) error */
; 426  :     if (state->mode != GZ_READ ||

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  0003b	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00042	75 12		 jne	 SHORT $LN4@gzfread
  00044	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00047	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0004b	74 0d		 je	 SHORT $LN3@gzfread
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00050	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00054	74 04		 je	 SHORT $LN3@gzfread
$LN4@gzfread:

; 427  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 428  :         return 0;

  00056	33 c0		 xor	 eax, eax
  00058	eb 62		 jmp	 SHORT $LN1@gzfread
$LN3@gzfread:

; 429  : 
; 430  :     /* compute bytes to read -- error on overflow */
; 431  :     len = nitems * size;

  0005a	8b 4d 10	 mov	 ecx, DWORD PTR _nitems$[ebp]
  0005d	0f af 4d 0c	 imul	 ecx, DWORD PTR _size$[ebp]
  00061	89 4d fc	 mov	 DWORD PTR _len$[ebp], ecx

; 432  :     if (size && len / size != nitems) {

  00064	83 7d 0c 00	 cmp	 DWORD PTR _size$[ebp], 0
  00068	74 24		 je	 SHORT $LN5@gzfread
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  0006d	33 d2		 xor	 edx, edx
  0006f	f7 75 0c	 div	 DWORD PTR _size$[ebp]
  00072	3b 45 10	 cmp	 eax, DWORD PTR _nitems$[ebp]
  00075	74 17		 je	 SHORT $LN5@gzfread

; 433  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");

  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@
  0007c	6a fe		 push	 -2			; fffffffeH
  0007e	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00081	52		 push	 edx
  00082	e8 00 00 00 00	 call	 _gz_error
  00087	83 c4 0c	 add	 esp, 12			; 0000000cH

; 434  :         return 0;

  0008a	33 c0		 xor	 eax, eax
  0008c	eb 2e		 jmp	 SHORT $LN1@gzfread
$LN5@gzfread:

; 435  :     }
; 436  : 
; 437  :     /* read len or fewer bytes to buf, return the number of full items read */
; 438  :     return len ? gz_read(state, buf, len) / size : 0;

  0008e	83 7d fc 00	 cmp	 DWORD PTR _len$[ebp], 0
  00092	74 1e		 je	 SHORT $LN7@gzfread
  00094	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00097	50		 push	 eax
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _buf$[ebp]
  0009b	51		 push	 ecx
  0009c	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 _gz_read
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	33 d2		 xor	 edx, edx
  000aa	f7 75 0c	 div	 DWORD PTR _size$[ebp]
  000ad	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  000b0	eb 07		 jmp	 SHORT $LN8@gzfread
$LN7@gzfread:
  000b2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$LN8@gzfread:
  000b9	8b 45 f4	 mov	 eax, DWORD PTR tv84[ebp]
$LN1@gzfread:

; 439  : }

  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bf	3b ec		 cmp	 ebp, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 10 00	 ret	 16			; 00000010H
_gzfread@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gzgetc@4
_TEXT	SEGMENT
tv128 = -28						; size = 4
tv86 = -21						; size = 1
_state$ = -20						; size = 4
_buf$ = -9						; size = 1
_ret$ = -4						; size = 4
_file$ = 8						; size = 4
_gzgetc@4 PROC						; COMDAT

; 449  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 450  :     int ret;
; 451  :     unsigned char buf[1];
; 452  :     gz_statep state;
; 453  : 
; 454  :     /* get internal structure */
; 455  :     if (file == NULL)

  0002a	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0002e	75 08		 jne	 SHORT $LN2@gzgetc

; 456  :         return -1;

  00030	83 c8 ff	 or	 eax, -1
  00033	e9 b0 00 00 00	 jmp	 $LN1@gzgetc
$LN2@gzgetc:

; 457  :     state = (gz_statep)file;

  00038	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR _state$[ebp], eax

; 458  : 
; 459  :     /* check that we're reading and that there's no (serious) error */
; 460  :     if (state->mode != GZ_READ ||

  0003e	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00041	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00048	75 12		 jne	 SHORT $LN4@gzgetc
  0004a	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0004d	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00051	74 11		 je	 SHORT $LN3@gzgetc
  00053	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00056	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  0005a	74 08		 je	 SHORT $LN3@gzgetc
$LN4@gzgetc:

; 461  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 462  :         return -1;

  0005c	83 c8 ff	 or	 eax, -1
  0005f	e9 84 00 00 00	 jmp	 $LN1@gzgetc
$LN3@gzgetc:

; 463  : 
; 464  :     /* try output buffer (no need to check for skip request) */
; 465  :     if (state->x.have) {

  00064	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00067	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0006a	74 45		 je	 SHORT $LN5@gzgetc

; 466  :         state->x.have--;

  0006c	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0006f	8b 02		 mov	 eax, DWORD PTR [edx]
  00071	83 e8 01	 sub	 eax, 1
  00074	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00077	89 01		 mov	 DWORD PTR [ecx], eax

; 467  :         state->x.pos++;

  00079	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0007c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007f	83 c0 01	 add	 eax, 1
  00082	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00085	83 d1 00	 adc	 ecx, 0
  00088	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  0008b	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0008e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 468  :         return *(state->x.next)++;

  00091	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00094	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00097	8a 11		 mov	 dl, BYTE PTR [ecx]
  00099	88 55 eb	 mov	 BYTE PTR tv86[ebp], dl
  0009c	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0009f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a2	83 c1 01	 add	 ecx, 1
  000a5	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000a8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000ab	0f b6 45 eb	 movzx	 eax, BYTE PTR tv86[ebp]
  000af	eb 37		 jmp	 SHORT $LN1@gzgetc
$LN5@gzgetc:

; 469  :     }
; 470  : 
; 471  :     /* nothing there -- try gz_read() */
; 472  :     ret = gz_read(state, buf, 1);

  000b1	6a 01		 push	 1
  000b3	8d 45 f7	 lea	 eax, DWORD PTR _buf$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _gz_read
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c3	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 473  :     return ret < 1 ? -1 : buf[0];

  000c6	83 7d fc 01	 cmp	 DWORD PTR _ret$[ebp], 1
  000ca	7d 09		 jge	 SHORT $LN7@gzgetc
  000cc	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR tv128[ebp], -1
  000d3	eb 10		 jmp	 SHORT $LN8@gzgetc
$LN7@gzgetc:
  000d5	ba 01 00 00 00	 mov	 edx, 1
  000da	6b c2 00	 imul	 eax, edx, 0
  000dd	0f b6 4c 05 f7	 movzx	 ecx, BYTE PTR _buf$[ebp+eax]
  000e2	89 4d e4	 mov	 DWORD PTR tv128[ebp], ecx
$LN8@gzgetc:
  000e5	8b 45 e4	 mov	 eax, DWORD PTR tv128[ebp]
$LN1@gzgetc:

; 474  : }

  000e8	52		 push	 edx
  000e9	8b cd		 mov	 ecx, ebp
  000eb	50		 push	 eax
  000ec	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@gzgetc
  000f2	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000f7	58		 pop	 eax
  000f8	5a		 pop	 edx
  000f9	83 c4 1c	 add	 esp, 28			; 0000001cH
  000fc	3b ec		 cmp	 ebp, esp
  000fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c2 04 00	 ret	 4
  00109	0f 1f 00	 npad	 3
$LN13@gzgetc:
  0010c	01 00 00 00	 DD	 1
  00110	00 00 00 00	 DD	 $LN12@gzgetc
$LN12@gzgetc:
  00114	f7 ff ff ff	 DD	 -9			; fffffff7H
  00118	01 00 00 00	 DD	 1
  0011c	00 00 00 00	 DD	 $LN11@gzgetc
$LN11@gzgetc:
  00120	62		 DB	 98			; 00000062H
  00121	75		 DB	 117			; 00000075H
  00122	66		 DB	 102			; 00000066H
  00123	00		 DB	 0
_gzgetc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gzgetc_@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gzgetc_@4 PROC						; COMDAT

; 478  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 479  :     return gzgetc(file);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _gzgetc@4

; 480  : }

  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
_gzgetc_@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gzungetc@8
_TEXT	SEGMENT
_dest$1 = -12						; size = 4
_src$2 = -8						; size = 4
_state$ = -4						; size = 4
_c$ = 8							; size = 4
_file$ = 12						; size = 4
_gzungetc@8 PROC					; COMDAT

; 486  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 487  :     gz_statep state;
; 488  : 
; 489  :     /* get internal structure */
; 490  :     if (file == NULL)

  00025	83 7d 0c 00	 cmp	 DWORD PTR _file$[ebp], 0
  00029	75 08		 jne	 SHORT $LN4@gzungetc

; 491  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1
  0002e	e9 b5 01 00 00	 jmp	 $LN1@gzungetc
$LN4@gzungetc:

; 492  :     state = (gz_statep)file;

  00033	8b 45 0c	 mov	 eax, DWORD PTR _file$[ebp]
  00036	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 493  : 
; 494  :     /* check that we're reading and that there's no (serious) error */
; 495  :     if (state->mode != GZ_READ ||

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003c	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00043	75 12		 jne	 SHORT $LN6@gzungetc
  00045	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00048	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  0004c	74 11		 je	 SHORT $LN5@gzungetc
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00051	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00055	74 08		 je	 SHORT $LN5@gzungetc
$LN6@gzungetc:

; 496  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 497  :         return -1;

  00057	83 c8 ff	 or	 eax, -1
  0005a	e9 89 01 00 00	 jmp	 $LN1@gzungetc
$LN5@gzungetc:

; 498  : 
; 499  :     /* process a skip request */
; 500  :     if (state->seek) {

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00062	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00066	74 2e		 je	 SHORT $LN7@gzungetc

; 501  :         state->seek = 0;

  00068	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0006b	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 502  :         if (gz_skip(state, state->skip) == -1)

  00072	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00075	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00078	51		 push	 ecx
  00079	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  0007c	52		 push	 edx
  0007d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _gz_skip
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	83 f8 ff	 cmp	 eax, -1
  0008c	75 08		 jne	 SHORT $LN7@gzungetc

; 503  :             return -1;

  0008e	83 c8 ff	 or	 eax, -1
  00091	e9 52 01 00 00	 jmp	 $LN1@gzungetc
$LN7@gzungetc:

; 504  :     }
; 505  : 
; 506  :     /* can't push EOF */
; 507  :     if (c < 0)

  00096	83 7d 08 00	 cmp	 DWORD PTR _c$[ebp], 0
  0009a	7d 08		 jge	 SHORT $LN9@gzungetc

; 508  :         return -1;

  0009c	83 c8 ff	 or	 eax, -1
  0009f	e9 44 01 00 00	 jmp	 $LN1@gzungetc
$LN9@gzungetc:

; 509  : 
; 510  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 511  :     if (state->x.have == 0) {

  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000a7	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000aa	75 5d		 jne	 SHORT $LN10@gzungetc

; 512  :         state->x.have = 1;

  000ac	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000af	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 513  :         state->x.next = state->out + (state->size << 1) - 1;

  000b5	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000b8	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000bb	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000be	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000c1	8d 4c 48 ff	 lea	 ecx, DWORD PTR [eax+ecx*2-1]
  000c5	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000c8	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 514  :         state->x.next[0] = (unsigned char)c;

  000cb	b8 01 00 00 00	 mov	 eax, 1
  000d0	6b c8 00	 imul	 ecx, eax, 0
  000d3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000d6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d9	8a 55 08	 mov	 dl, BYTE PTR _c$[ebp]
  000dc	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 515  :         state->x.pos--;

  000df	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000e2	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000e5	83 e9 01	 sub	 ecx, 1
  000e8	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000eb	83 da 00	 sbb	 edx, 0
  000ee	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000f1	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000f4	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 516  :         state->past = 0;

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000fa	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 517  :         return c;

  00101	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00104	e9 df 00 00 00	 jmp	 $LN1@gzungetc
$LN10@gzungetc:

; 518  :     }
; 519  : 
; 520  :     /* if no room, give up (must have already done a gzungetc()) */
; 521  :     if (state->x.have == (state->size << 1)) {

  00109	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0010c	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0010f	d1 e0		 shl	 eax, 1
  00111	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00114	39 01		 cmp	 DWORD PTR [ecx], eax
  00116	75 1b		 jne	 SHORT $LN11@gzungetc

; 522  :         gz_error(state, Z_DATA_ERROR, "out of room to push characters");

  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@
  0011d	6a fd		 push	 -3			; fffffffdH
  0011f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 _gz_error
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH

; 523  :         return -1;

  0012b	83 c8 ff	 or	 eax, -1
  0012e	e9 b5 00 00 00	 jmp	 $LN1@gzungetc
$LN11@gzungetc:

; 524  :     }
; 525  : 
; 526  :     /* slide output data if needed and insert byte before existing data */
; 527  :     if (state->x.next == state->out) {

  00133	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00136	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00139	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0013c	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  0013f	75 52		 jne	 SHORT $LN12@gzungetc

; 528  :         unsigned char *src = state->out + state->x.have;

  00141	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00144	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00147	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0014a	03 0a		 add	 ecx, DWORD PTR [edx]
  0014c	89 4d f8	 mov	 DWORD PTR _src$2[ebp], ecx

; 529  :         unsigned char *dest = state->out + (state->size << 1);

  0014f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00152	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00155	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00158	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0015b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0015e	89 4d f4	 mov	 DWORD PTR _dest$1[ebp], ecx
$LN2@gzungetc:

; 530  :         while (src > state->out)

  00161	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00164	8b 45 f8	 mov	 eax, DWORD PTR _src$2[ebp]
  00167	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  0016a	76 1e		 jbe	 SHORT $LN3@gzungetc

; 531  :             *--dest = *--src;

  0016c	8b 4d f8	 mov	 ecx, DWORD PTR _src$2[ebp]
  0016f	83 e9 01	 sub	 ecx, 1
  00172	89 4d f8	 mov	 DWORD PTR _src$2[ebp], ecx
  00175	8b 55 f4	 mov	 edx, DWORD PTR _dest$1[ebp]
  00178	83 ea 01	 sub	 edx, 1
  0017b	89 55 f4	 mov	 DWORD PTR _dest$1[ebp], edx
  0017e	8b 45 f4	 mov	 eax, DWORD PTR _dest$1[ebp]
  00181	8b 4d f8	 mov	 ecx, DWORD PTR _src$2[ebp]
  00184	8a 11		 mov	 dl, BYTE PTR [ecx]
  00186	88 10		 mov	 BYTE PTR [eax], dl
  00188	eb d7		 jmp	 SHORT $LN2@gzungetc
$LN3@gzungetc:

; 532  :         state->x.next = dest;

  0018a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0018d	8b 4d f4	 mov	 ecx, DWORD PTR _dest$1[ebp]
  00190	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN12@gzungetc:

; 533  :     }
; 534  :     state->x.have++;

  00193	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00196	8b 02		 mov	 eax, DWORD PTR [edx]
  00198	83 c0 01	 add	 eax, 1
  0019b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0019e	89 01		 mov	 DWORD PTR [ecx], eax

; 535  :     state->x.next--;

  001a0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001a3	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001a6	83 e8 01	 sub	 eax, 1
  001a9	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  001ac	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 536  :     state->x.next[0] = (unsigned char)c;

  001af	ba 01 00 00 00	 mov	 edx, 1
  001b4	6b c2 00	 imul	 eax, edx, 0
  001b7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  001ba	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001bd	8a 4d 08	 mov	 cl, BYTE PTR _c$[ebp]
  001c0	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 537  :     state->x.pos--;

  001c3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001c6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001c9	83 e8 01	 sub	 eax, 1
  001cc	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  001cf	83 d9 00	 sbb	 ecx, 0
  001d2	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001d5	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001d8	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 538  :     state->past = 0;

  001db	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  001de	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 539  :     return c;

  001e5	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
$LN1@gzungetc:

; 540  : }

  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001eb	3b ec		 cmp	 ebp, esp
  001ed	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f2	8b e5		 mov	 esp, ebp
  001f4	5d		 pop	 ebp
  001f5	c2 08 00	 ret	 8
_gzungetc@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gzgets@12
_TEXT	SEGMENT
tv94 = -24						; size = 4
_state$ = -20						; size = 4
_eol$ = -16						; size = 4
_str$ = -12						; size = 4
_n$ = -8						; size = 4
_left$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzgets@12 PROC						; COMDAT

; 547  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0000e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00011	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00014	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00017	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001a	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00022	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 548  :     unsigned left, n;
; 549  :     char *str;
; 550  :     unsigned char *eol;
; 551  :     gz_statep state;
; 552  : 
; 553  :     /* check parameters and get internal structure */
; 554  :     if (file == NULL || buf == NULL || len < 1)

  00027	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  0002b	74 0c		 je	 SHORT $LN6@gzgets
  0002d	83 7d 0c 00	 cmp	 DWORD PTR _buf$[ebp], 0
  00031	74 06		 je	 SHORT $LN6@gzgets
  00033	83 7d 10 01	 cmp	 DWORD PTR _len$[ebp], 1
  00037	7d 07		 jge	 SHORT $LN5@gzgets
$LN6@gzgets:

; 555  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 87 01 00 00	 jmp	 $LN1@gzgets
$LN5@gzgets:

; 556  :     state = (gz_statep)file;

  00040	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00043	89 45 ec	 mov	 DWORD PTR _state$[ebp], eax

; 557  : 
; 558  :     /* check that we're reading and that there's no (serious) error */
; 559  :     if (state->mode != GZ_READ ||

  00046	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00049	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00050	75 12		 jne	 SHORT $LN8@gzgets
  00052	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00055	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00059	74 10		 je	 SHORT $LN7@gzgets
  0005b	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0005e	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00062	74 07		 je	 SHORT $LN7@gzgets
$LN8@gzgets:

; 560  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 561  :         return NULL;

  00064	33 c0		 xor	 eax, eax
  00066	e9 5c 01 00 00	 jmp	 $LN1@gzgets
$LN7@gzgets:

; 562  : 
; 563  :     /* process a skip request */
; 564  :     if (state->seek) {

  0006b	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0006e	83 79 58 00	 cmp	 DWORD PTR [ecx+88], 0
  00072	74 2d		 je	 SHORT $LN9@gzgets

; 565  :         state->seek = 0;

  00074	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00077	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 566  :         if (gz_skip(state, state->skip) == -1)

  0007e	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00081	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00084	51		 push	 ecx
  00085	8b 50 50	 mov	 edx, DWORD PTR [eax+80]
  00088	52		 push	 edx
  00089	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _gz_skip
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
  00095	83 f8 ff	 cmp	 eax, -1
  00098	75 07		 jne	 SHORT $LN9@gzgets

; 567  :             return NULL;

  0009a	33 c0		 xor	 eax, eax
  0009c	e9 26 01 00 00	 jmp	 $LN1@gzgets
$LN9@gzgets:

; 568  :     }
; 569  : 
; 570  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 571  :        append a terminating zero to the string (we don't check for a zero in
; 572  :        the contents, let the user worry about that) */
; 573  :     str = buf;

  000a1	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  000a4	89 4d f4	 mov	 DWORD PTR _str$[ebp], ecx

; 574  :     left = (unsigned)len - 1;

  000a7	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  000aa	83 ea 01	 sub	 edx, 1
  000ad	89 55 fc	 mov	 DWORD PTR _left$[ebp], edx

; 575  :     if (left) do {

  000b0	0f 84 f3 00 00
	00		 je	 $LN11@gzgets
$LN4@gzgets:

; 576  :         /* assure that something is in the output buffer */
; 577  :         if (state->x.have == 0 && gz_fetch(state) == -1)

  000b6	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000b9	83 38 00	 cmp	 DWORD PTR [eax], 0
  000bc	75 18		 jne	 SHORT $LN12@gzgets
  000be	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000c1	51		 push	 ecx
  000c2	e8 00 00 00 00	 call	 _gz_fetch
  000c7	83 c4 04	 add	 esp, 4
  000ca	83 f8 ff	 cmp	 eax, -1
  000cd	75 07		 jne	 SHORT $LN12@gzgets

; 578  :             return NULL;                /* error */

  000cf	33 c0		 xor	 eax, eax
  000d1	e9 f1 00 00 00	 jmp	 $LN1@gzgets
$LN12@gzgets:

; 579  :         if (state->x.have == 0) {       /* end of file */

  000d6	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000d9	83 3a 00	 cmp	 DWORD PTR [edx], 0
  000dc	75 0f		 jne	 SHORT $LN13@gzgets

; 580  :             state->past = 1;            /* read past end */

  000de	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000e1	c7 40 44 01 00
	00 00		 mov	 DWORD PTR [eax+68], 1

; 581  :             break;                      /* return what we have */

  000e8	e9 bc 00 00 00	 jmp	 $LN11@gzgets
$LN13@gzgets:

; 582  :         }
; 583  : 
; 584  :         /* look for end-of-line in current output buffer */
; 585  :         n = state->x.have > left ? left : state->x.have;

  000ed	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  000f0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f2	3b 55 fc	 cmp	 edx, DWORD PTR _left$[ebp]
  000f5	76 08		 jbe	 SHORT $LN18@gzgets
  000f7	8b 45 fc	 mov	 eax, DWORD PTR _left$[ebp]
  000fa	89 45 e8	 mov	 DWORD PTR tv94[ebp], eax
  000fd	eb 0b		 jmp	 SHORT $LN19@gzgets
$LN18@gzgets:
  000ff	0f ae e8	 lfence
  00102	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00105	8b 11		 mov	 edx, DWORD PTR [ecx]
  00107	89 55 e8	 mov	 DWORD PTR tv94[ebp], edx
$LN19@gzgets:
  0010a	8b 45 e8	 mov	 eax, DWORD PTR tv94[ebp]
  0010d	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 586  :         eol = (unsigned char *)memchr(state->x.next, '\n', n);

  00110	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00113	51		 push	 ecx
  00114	6a 0a		 push	 10			; 0000000aH
  00116	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00119	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _memchr
  00122	83 c4 0c	 add	 esp, 12			; 0000000cH
  00125	89 45 f0	 mov	 DWORD PTR _eol$[ebp], eax

; 587  :         if (eol != NULL)

  00128	83 7d f0 00	 cmp	 DWORD PTR _eol$[ebp], 0
  0012c	74 0f		 je	 SHORT $LN14@gzgets

; 588  :             n = (unsigned)(eol - state->x.next) + 1;

  0012e	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00131	8b 55 f0	 mov	 edx, DWORD PTR _eol$[ebp]
  00134	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  00137	83 c2 01	 add	 edx, 1
  0013a	89 55 f8	 mov	 DWORD PTR _n$[ebp], edx
$LN14@gzgets:

; 589  : 
; 590  :         /* copy through end-of-line, or remainder if not found */
; 591  :         memcpy(buf, state->x.next, n);

  0013d	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00140	50		 push	 eax
  00141	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00144	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00147	52		 push	 edx
  00148	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0014b	50		 push	 eax
  0014c	e8 00 00 00 00	 call	 _memcpy
  00151	83 c4 0c	 add	 esp, 12			; 0000000cH

; 592  :         state->x.have -= n;

  00154	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00157	8b 11		 mov	 edx, DWORD PTR [ecx]
  00159	2b 55 f8	 sub	 edx, DWORD PTR _n$[ebp]
  0015c	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0015f	89 10		 mov	 DWORD PTR [eax], edx

; 593  :         state->x.next += n;

  00161	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00164	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00167	03 55 f8	 add	 edx, DWORD PTR _n$[ebp]
  0016a	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0016d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 594  :         state->x.pos += n;

  00170	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00173	33 d2		 xor	 edx, edx
  00175	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00178	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  0017b	13 50 0c	 adc	 edx, DWORD PTR [eax+12]
  0017e	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00181	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00184	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 595  :         left -= n;

  00187	8b 4d fc	 mov	 ecx, DWORD PTR _left$[ebp]
  0018a	2b 4d f8	 sub	 ecx, DWORD PTR _n$[ebp]
  0018d	89 4d fc	 mov	 DWORD PTR _left$[ebp], ecx

; 596  :         buf += n;

  00190	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00193	03 55 f8	 add	 edx, DWORD PTR _n$[ebp]
  00196	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 597  :     } while (left && eol == NULL);

  00199	83 7d fc 00	 cmp	 DWORD PTR _left$[ebp], 0
  0019d	74 0a		 je	 SHORT $LN11@gzgets
  0019f	83 7d f0 00	 cmp	 DWORD PTR _eol$[ebp], 0
  001a3	0f 84 0d ff ff
	ff		 je	 $LN4@gzgets
$LN11@gzgets:

; 598  : 
; 599  :     /* return terminated string, or if nothing, end of file */
; 600  :     if (buf == str)

  001a9	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001ac	3b 45 f4	 cmp	 eax, DWORD PTR _str$[ebp]
  001af	75 04		 jne	 SHORT $LN16@gzgets

; 601  :         return NULL;

  001b1	33 c0		 xor	 eax, eax
  001b3	eb 12		 jmp	 SHORT $LN1@gzgets
$LN16@gzgets:

; 602  :     buf[0] = 0;

  001b5	b9 01 00 00 00	 mov	 ecx, 1
  001ba	6b d1 00	 imul	 edx, ecx, 0
  001bd	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001c0	c6 04 10 00	 mov	 BYTE PTR [eax+edx], 0

; 603  :     return str;

  001c4	8b 45 f4	 mov	 eax, DWORD PTR _str$[ebp]
$LN1@gzgets:

; 604  : }

  001c7	83 c4 18	 add	 esp, 24			; 00000018H
  001ca	3b ec		 cmp	 ebp, esp
  001cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d1	8b e5		 mov	 esp, ebp
  001d3	5d		 pop	 ebp
  001d4	c2 0c 00	 ret	 12			; 0000000cH
_gzgets@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT _gzdirect@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzdirect@4 PROC					; COMDAT

; 609  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 610  :     gz_statep state;
; 611  : 
; 612  :     /* get internal structure */
; 613  :     if (file == NULL)

  00015	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00019	75 04		 jne	 SHORT $LN2@gzdirect

; 614  :         return 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 35		 jmp	 SHORT $LN1@gzdirect
$LN2@gzdirect:

; 615  :     state = (gz_statep)file;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00022	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 616  : 
; 617  :     /* if the state is not known, but we can find out, then do so (this is
; 618  :        mainly for right after a gzopen() or gzdopen()) */
; 619  :     if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00028	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0002f	75 1d		 jne	 SHORT $LN3@gzdirect
  00031	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00034	83 7a 30 00	 cmp	 DWORD PTR [edx+48], 0
  00038	75 14		 jne	 SHORT $LN3@gzdirect
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00040	75 0c		 jne	 SHORT $LN3@gzdirect

; 620  :         (void)gz_look(state);

  00042	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 _gz_look
  0004b	83 c4 04	 add	 esp, 4
$LN3@gzdirect:

; 621  : 
; 622  :     /* return 1 if transparent, 0 if processing a gzip stream */
; 623  :     return state->direct;

  0004e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00051	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
$LN1@gzdirect:

; 624  : }

  00054	83 c4 04	 add	 esp, 4
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
_gzdirect@4 ENDP
_TEXT	ENDS
END
