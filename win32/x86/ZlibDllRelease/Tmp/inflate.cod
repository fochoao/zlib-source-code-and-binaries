; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

	TITLE	e:\cpython\externals\zlib-1.2.11\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__55962C33_inffixed@h DB 01H
__4ACC5162_inflate@c DB 01H
PUBLIC	_inflateCodesUsed@4
PUBLIC	_inflateMark@4
PUBLIC	_inflateValidate@8
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflateGetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateEnd@4
PUBLIC	_inflate@8
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00015	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _inflateStateCheck
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	74 07		 je	 SHORT $LN2@inflateRes
  00025	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002a	eb 30		 jmp	 SHORT $LN1@inflateRes
$LN2@inflateRes:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00032	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 151  :     state->wsize = 0;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00038	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 152  :     state->whave = 0;

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00042	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 153  :     state->wnext = 0;

  00049	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0004c	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 154  :     return inflateResetKeep(strm);

  00053	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _inflateResetKeep@4
$LN1@inflateRes:

; 155  : }

  0005c	83 c4 04	 add	 esp, 4
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_state$ = -8						; size = 4
_ret$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  0001f	83 7d 10 00	 cmp	 DWORD PTR _version$[ebp], 0
  00023	74 28		 je	 SHORT $LN3@inflateIni
  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	6b c8 00	 imul	 ecx, eax, 0
  0002d	8b 55 10	 mov	 edx, DWORD PTR _version$[ebp]
  00030	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00034	b9 01 00 00 00	 mov	 ecx, 1
  00039	6b d1 00	 imul	 edx, ecx, 0
  0003c	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_06CJNJFBNP@1?42?411@[edx]
  00043	3b c1		 cmp	 eax, ecx
  00045	75 06		 jne	 SHORT $LN3@inflateIni
  00047	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0004b	74 0a		 je	 SHORT $LN2@inflateIni
$LN3@inflateIni:

; 205  :         stream_size != (int)(sizeof(z_stream)))
; 206  :         return Z_VERSION_ERROR;

  0004d	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00052	e9 e3 00 00 00	 jmp	 $LN1@inflateIni
$LN2@inflateIni:

; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00057	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0005b	75 0a		 jne	 SHORT $LN4@inflateIni
  0005d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00062	e9 d3 00 00 00	 jmp	 $LN1@inflateIni
$LN4@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00067	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0006a	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 209  :     if (strm->zalloc == (alloc_func)0) {

  00071	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00074	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00078	75 14		 jne	 SHORT $LN5@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;

  0007a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0007d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _zcalloc

; 214  :         strm->opaque = (voidpf)0;

  00084	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00087	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0
$LN5@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  0008e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00091	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00095	75 0a		 jne	 SHORT $LN6@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  00097	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0009a	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _zcfree
$LN6@inflateIni:

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)

  000a1	8b f4		 mov	 esi, esp
  000a3	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  000a8	6a 01		 push	 1
  000aa	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000ad	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000b0	50		 push	 eax
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b4	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000b7	ff d2		 call	 edx
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c3	89 45 f8	 mov	 DWORD PTR _state$[ebp], eax

; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  000c6	83 7d f8 00	 cmp	 DWORD PTR _state$[ebp], 0
  000ca	75 07		 jne	 SHORT $LN7@inflateIni
  000cc	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000d1	eb 67		 jmp	 SHORT $LN1@inflateIni
$LN7@inflateIni:

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;

  000d3	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000d6	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000d9	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 228  :     state->strm = strm;

  000dc	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000df	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000e2	89 02		 mov	 DWORD PTR [edx], eax

; 229  :     state->window = Z_NULL;

  000e4	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000e7	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */

  000ee	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000f1	c7 42 04 34 3f
	00 00		 mov	 DWORD PTR [edx+4], 16180 ; 00003f34H

; 231  :     ret = inflateReset2(strm, windowBits);

  000f8	8b 45 0c	 mov	 eax, DWORD PTR _windowBits$[ebp]
  000fb	50		 push	 eax
  000fc	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 _inflateReset2@8
  00105	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 232  :     if (ret != Z_OK) {

  00108	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0010c	74 29		 je	 SHORT $LN8@inflateIni

; 233  :         ZFREE(strm, state);

  0010e	8b f4		 mov	 esi, esp
  00110	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00113	52		 push	 edx
  00114	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00117	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0011a	51		 push	 ecx
  0011b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0011e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00121	ff d0		 call	 eax
  00123	83 c4 08	 add	 esp, 8
  00126	3b f4		 cmp	 esi, esp
  00128	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 234  :         strm->state = Z_NULL;

  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00130	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
$LN8@inflateIni:

; 235  :     }
; 236  :     return ret;

  00137	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@inflateIni:

; 237  : }

  0013a	5e		 pop	 esi
  0013b	83 c4 08	 add	 esp, 8
  0013e	3b ec		 cmp	 ebp, esp
  00140	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv1423 = -148						; size = 4
tv1417 = -144						; size = 4
tv1413 = -140						; size = 4
tv1408 = -136						; size = 4
tv1319 = -132						; size = 4
tv1302 = -128						; size = 4
tv908 = -124						; size = 4
tv627 = -120						; size = 4
tv596 = -116						; size = 4
tv582 = -112						; size = 4
tv555 = -108						; size = 4
tv400 = -104						; size = 4
tv202 = -100						; size = 4
tv195 = -96						; size = 4
tv85 = -92						; size = 4
_hbuf$ = -84						; size = 4
_ret$ = -76						; size = 4
_len$ = -72						; size = 4
_last$ = -64						; size = 4
_here$ = -52						; size = 4
_from$ = -44						; size = 4
_copy$ = -40						; size = 4
_out$ = -36						; size = 4
_in$ = -32						; size = 4
_bits$ = -28						; size = 4
_hold$ = -24						; size = 4
_left$ = -20						; size = 4
_have$ = -16						; size = 4
_put$ = -12						; size = 4
_next$ = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00009	57		 push	 edi
  0000a	8d bd 6c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-148]
  00010	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00021	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00026	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _inflateStateCheck
  0002f	83 c4 04	 add	 esp, 4
  00032	85 c0		 test	 eax, eax
  00034	75 1a		 jne	 SHORT $LN333@inflate
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00039	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0003d	74 11		 je	 SHORT $LN333@inflate
  0003f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00042	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00045	75 13		 jne	 SHORT $LN332@inflate
  00047	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0004a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0004e	74 0a		 je	 SHORT $LN332@inflate
$LN333@inflate:

; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 647  :         return Z_STREAM_ERROR;

  00050	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00055	e9 55 21 00 00	 jmp	 $LN1@inflate
$LN332@inflate:

; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00060	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00063	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00066	81 78 04 3f 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16191 ; 00003f3fH
  0006d	75 0a		 jne	 SHORT $LN4@inflate
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00072	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H
$LN4@inflate:

; 651  :     LOAD();

  00079	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0007c	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0007f	89 45 f4	 mov	 DWORD PTR _put$[ebp], eax
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00085	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00088	89 55 ec	 mov	 DWORD PTR _left$[ebp], edx
  0008b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0008e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00090	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  00093	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00096	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00099	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  0009c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0009f	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  000a2	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000a8	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000ab	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  000ae	33 d2		 xor	 edx, edx
  000b0	75 c7		 jne	 SHORT $LN4@inflate

; 652  :     in = have;

  000b2	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  000b5	89 45 e0	 mov	 DWORD PTR _in$[ebp], eax

; 653  :     out = left;

  000b8	8b 4d ec	 mov	 ecx, DWORD PTR _left$[ebp]
  000bb	89 4d dc	 mov	 DWORD PTR _out$[ebp], ecx

; 654  :     ret = Z_OK;

  000be	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN7@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  000c5	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000c8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000cb	89 45 a4	 mov	 DWORD PTR tv85[ebp], eax
  000ce	8b 4d a4	 mov	 ecx, DWORD PTR tv85[ebp]
  000d1	81 e9 34 3f 00
	00		 sub	 ecx, 16180		; 00003f34H
  000d7	89 4d a4	 mov	 DWORD PTR tv85[ebp], ecx
  000da	83 7d a4 1e	 cmp	 DWORD PTR tv85[ebp], 30	; 0000001eH
  000de	0f 87 b4 1e 00
	00		 ja	 $LN499@inflate
  000e4	8b 55 a4	 mov	 edx, DWORD PTR tv85[ebp]
  000e7	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN559@inflate[edx*4]
$LN335@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  000ee	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000f1	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000f5	75 0f		 jne	 SHORT $LN13@inflate

; 659  :                 state->mode = TYPEDO;

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000fa	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H

; 660  :                 break;

  00101	e9 9c 1e 00 00	 jmp	 $LN8@inflate
$LN13@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  00106	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  0010a	73 3d		 jae	 SHORT $LN10@inflate
$LN17@inflate:
  0010c	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00110	75 05		 jne	 SHORT $LN337@inflate
  00112	e9 90 1e 00 00	 jmp	 $inf_leave$566
$LN337@inflate:
  00117	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  0011a	83 ea 01	 sub	 edx, 1
  0011d	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00120	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00123	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00126	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00129	d3 e2		 shl	 edx, cl
  0012b	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  0012e	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  00131	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00134	83 c0 01	 add	 eax, 1
  00137	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  0013a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0013d	83 c1 08	 add	 ecx, 8
  00140	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00143	33 d2		 xor	 edx, edx
  00145	75 c5		 jne	 SHORT $LN17@inflate
  00147	eb bd		 jmp	 SHORT $LN13@inflate
$LN10@inflate:
  00149	33 c0		 xor	 eax, eax
  0014b	75 b9		 jne	 SHORT $LN13@inflate

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  0014d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00150	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00153	83 e2 02	 and	 edx, 2
  00156	0f 84 92 00 00
	00		 je	 $LN338@inflate
  0015c	81 7d e8 1f 8b
	00 00		 cmp	 DWORD PTR _hold$[ebp], 35615 ; 00008b1fH
  00163	0f 85 85 00 00
	00		 jne	 $LN338@inflate

; 665  :                 if (state->wbits == 0)

  00169	0f ae e8	 lfence
  0016c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0016f	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  00173	75 0a		 jne	 SHORT $LN339@inflate

; 666  :                     state->wbits = 15;

  00175	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00178	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH
$LN339@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  0017f	6a 00		 push	 0
  00181	6a 00		 push	 0
  00183	6a 00		 push	 0
  00185	e8 00 00 00 00	 call	 _crc32@12
  0018a	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0018d	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$LN20@inflate:

; 668  :                 CRC2(state->check, hold);

  00190	b8 01 00 00 00	 mov	 eax, 1
  00195	6b c8 00	 imul	 ecx, eax, 0
  00198	8a 55 e8	 mov	 dl, BYTE PTR _hold$[ebp]
  0019b	88 54 0d ac	 mov	 BYTE PTR _hbuf$[ebp+ecx], dl
  0019f	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  001a2	c1 e8 08	 shr	 eax, 8
  001a5	b9 01 00 00 00	 mov	 ecx, 1
  001aa	c1 e1 00	 shl	 ecx, 0
  001ad	88 44 0d ac	 mov	 BYTE PTR _hbuf$[ebp+ecx], al
  001b1	6a 02		 push	 2
  001b3	8d 55 ac	 lea	 edx, DWORD PTR _hbuf$[ebp]
  001b6	52		 push	 edx
  001b7	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  001ba	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001bd	51		 push	 ecx
  001be	e8 00 00 00 00	 call	 _crc32@12
  001c3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001c6	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  001c9	33 c0		 xor	 eax, eax
  001cb	75 c3		 jne	 SHORT $LN20@inflate
$LN23@inflate:

; 669  :                 INITBITS();

  001cd	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  001d4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  001db	33 c9		 xor	 ecx, ecx
  001dd	75 ee		 jne	 SHORT $LN23@inflate

; 670  :                 state->mode = FLAGS;

  001df	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001e2	c7 42 04 35 3f
	00 00		 mov	 DWORD PTR [edx+4], 16181 ; 00003f35H

; 671  :                 break;

  001e9	e9 b4 1d 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */

  001ee	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  001f1	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 674  :             if (state->head != Z_NULL)

  001f8	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  001fb	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  001ff	74 0d		 je	 SHORT $LN340@inflate

; 675  :                 state->head->done = -1;

  00201	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00204	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00207	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN340@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  0020e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00211	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00214	83 e2 01	 and	 edx, 1
  00217	74 20		 je	 SHORT $LN342@inflate
  00219	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  0021c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00221	c1 e0 08	 shl	 eax, 8
  00224	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00227	c1 e9 08	 shr	 ecx, 8
  0022a	03 c1		 add	 eax, ecx
  0022c	33 d2		 xor	 edx, edx
  0022e	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00233	f7 f1		 div	 ecx
  00235	85 d2		 test	 edx, edx
  00237	74 19		 je	 SHORT $LN341@inflate
$LN342@inflate:

; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 681  :                 strm->msg = (char *)"incorrect header check";

  00239	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0023c	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@

; 682  :                 state->mode = BAD;

  00243	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00246	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 683  :                 break;

  0024d	e9 50 1d 00 00	 jmp	 $LN8@inflate
$LN341@inflate:

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  00252	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00255	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00258	83 f9 08	 cmp	 ecx, 8
  0025b	74 19		 je	 SHORT $LN26@inflate

; 686  :                 strm->msg = (char *)"unknown compression method";

  0025d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00260	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@

; 687  :                 state->mode = BAD;

  00267	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0026a	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 688  :                 break;

  00271	e9 2c 1d 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 689  :             }
; 690  :             DROPBITS(4);

  00276	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00279	c1 e9 04	 shr	 ecx, 4
  0027c	89 4d e8	 mov	 DWORD PTR _hold$[ebp], ecx
  0027f	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00282	83 ea 04	 sub	 edx, 4
  00285	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00288	33 c0		 xor	 eax, eax
  0028a	75 ea		 jne	 SHORT $LN26@inflate

; 691  :             len = BITS(4) + 8;

  0028c	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0028f	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00292	83 c1 08	 add	 ecx, 8
  00295	89 4d b8	 mov	 DWORD PTR _len$[ebp], ecx

; 692  :             if (state->wbits == 0)

  00298	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0029b	83 7a 28 00	 cmp	 DWORD PTR [edx+40], 0
  0029f	75 09		 jne	 SHORT $LN344@inflate

; 693  :                 state->wbits = len;

  002a1	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  002a4	8b 4d b8	 mov	 ecx, DWORD PTR _len$[ebp]
  002a7	89 48 28	 mov	 DWORD PTR [eax+40], ecx
$LN344@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  002aa	83 7d b8 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  002ae	77 0b		 ja	 SHORT $LN346@inflate
  002b0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  002b3	8b 45 b8	 mov	 eax, DWORD PTR _len$[ebp]
  002b6	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  002b9	76 19		 jbe	 SHORT $LN345@inflate
$LN346@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  002bb	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  002be	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size@

; 696  :                 state->mode = BAD;

  002c5	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  002c8	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 697  :                 break;

  002cf	e9 ce 1c 00 00	 jmp	 $LN8@inflate
$LN345@inflate:

; 698  :             }
; 699  :             state->dmax = 1U << len;

  002d4	b8 01 00 00 00	 mov	 eax, 1
  002d9	8b 4d b8	 mov	 ecx, DWORD PTR _len$[ebp]
  002dc	d3 e0		 shl	 eax, cl
  002de	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  002e1	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  002e4	6a 00		 push	 0
  002e6	6a 00		 push	 0
  002e8	6a 00		 push	 0
  002ea	e8 00 00 00 00	 call	 _adler32@12
  002ef	89 45 a0	 mov	 DWORD PTR tv195[ebp], eax
  002f2	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  002f5	8b 45 a0	 mov	 eax, DWORD PTR tv195[ebp]
  002f8	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  002fb	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  002fe	8b 55 a0	 mov	 edx, DWORD PTR tv195[ebp]
  00301	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00304	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  00307	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0030c	74 09		 je	 SHORT $LN509@inflate
  0030e	c7 45 9c 3d 3f
	00 00		 mov	 DWORD PTR tv202[ebp], 16189 ; 00003f3dH
  00315	eb 07		 jmp	 SHORT $LN510@inflate
$LN509@inflate:
  00317	c7 45 9c 3f 3f
	00 00		 mov	 DWORD PTR tv202[ebp], 16191 ; 00003f3fH
$LN510@inflate:
  0031e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00321	8b 55 9c	 mov	 edx, DWORD PTR tv202[ebp]
  00324	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN29@inflate:

; 703  :             INITBITS();

  00327	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  0032e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00335	33 c0		 xor	 eax, eax
  00337	75 ee		 jne	 SHORT $LN29@inflate

; 704  :             break;

  00339	e9 64 1c 00 00	 jmp	 $LN8@inflate
$LN33@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  0033e	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00342	73 3d		 jae	 SHORT $LN30@inflate
$LN37@inflate:
  00344	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00348	75 05		 jne	 SHORT $LN348@inflate
  0034a	e9 58 1c 00 00	 jmp	 $inf_leave$566
$LN348@inflate:
  0034f	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00352	83 e9 01	 sub	 ecx, 1
  00355	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00358	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  0035b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0035e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00361	d3 e0		 shl	 eax, cl
  00363	03 45 e8	 add	 eax, DWORD PTR _hold$[ebp]
  00366	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  00369	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  0036c	83 c1 01	 add	 ecx, 1
  0036f	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  00372	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00375	83 c2 08	 add	 edx, 8
  00378	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0037b	33 c0		 xor	 eax, eax
  0037d	75 c5		 jne	 SHORT $LN37@inflate
  0037f	eb bd		 jmp	 SHORT $LN33@inflate
$LN30@inflate:
  00381	33 c9		 xor	 ecx, ecx
  00383	75 b9		 jne	 SHORT $LN33@inflate

; 708  :             state->flags = (int)(hold);

  00385	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00388	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  0038b	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  0038e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00391	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00394	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0039a	83 fa 08	 cmp	 edx, 8
  0039d	74 19		 je	 SHORT $LN349@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";

  0039f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  003a2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@

; 711  :                 state->mode = BAD;

  003a9	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  003ac	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 712  :                 break;

  003b3	e9 ea 1b 00 00	 jmp	 $LN8@inflate
$LN349@inflate:

; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  003b8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  003bb	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  003be	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  003c3	74 19		 je	 SHORT $LN350@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  003c5	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  003c8	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@

; 716  :                 state->mode = BAD;

  003cf	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  003d2	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 717  :                 break;

  003d9	e9 c4 1b 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 718  :             }
; 719  :             if (state->head != Z_NULL)

  003de	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  003e1	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  003e5	74 11		 je	 SHORT $LN351@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  003e7	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  003ea	c1 e9 08	 shr	 ecx, 8
  003ed	83 e1 01	 and	 ecx, 1
  003f0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  003f3	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  003f6	89 08		 mov	 DWORD PTR [eax], ecx
$LN351@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003f8	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  003fb	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  003fe	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  00404	74 48		 je	 SHORT $LN43@inflate
  00406	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00409	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0040c	83 e1 04	 and	 ecx, 4
  0040f	74 3d		 je	 SHORT $LN43@inflate
$LN40@inflate:

; 722  :                 CRC2(state->check, hold);

  00411	ba 01 00 00 00	 mov	 edx, 1
  00416	6b c2 00	 imul	 eax, edx, 0
  00419	8a 4d e8	 mov	 cl, BYTE PTR _hold$[ebp]
  0041c	88 4c 05 ac	 mov	 BYTE PTR _hbuf$[ebp+eax], cl
  00420	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  00423	c1 ea 08	 shr	 edx, 8
  00426	b8 01 00 00 00	 mov	 eax, 1
  0042b	c1 e0 00	 shl	 eax, 0
  0042e	88 54 05 ac	 mov	 BYTE PTR _hbuf$[ebp+eax], dl
  00432	6a 02		 push	 2
  00434	8d 4d ac	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00437	51		 push	 ecx
  00438	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0043b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0043e	50		 push	 eax
  0043f	e8 00 00 00 00	 call	 _crc32@12
  00444	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00447	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0044a	33 d2		 xor	 edx, edx
  0044c	75 c3		 jne	 SHORT $LN40@inflate
$LN43@inflate:

; 723  :             INITBITS();

  0044e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00455	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  0045c	33 c0		 xor	 eax, eax
  0045e	75 ee		 jne	 SHORT $LN43@inflate

; 724  :             state->mode = TIME;

  00460	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00463	c7 41 04 36 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16182 ; 00003f36H
$LN47@inflate:

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  0046a	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  0046e	73 3d		 jae	 SHORT $LN44@inflate
$LN51@inflate:
  00470	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00474	75 05		 jne	 SHORT $LN354@inflate
  00476	e9 2c 1b 00 00	 jmp	 $inf_leave$566
$LN354@inflate:
  0047b	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  0047e	83 ea 01	 sub	 edx, 1
  00481	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00484	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00487	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0048a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0048d	d3 e2		 shl	 edx, cl
  0048f	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  00492	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  00495	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00498	83 c0 01	 add	 eax, 1
  0049b	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  0049e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  004a1	83 c1 08	 add	 ecx, 8
  004a4	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  004a7	33 d2		 xor	 edx, edx
  004a9	75 c5		 jne	 SHORT $LN51@inflate
  004ab	eb bd		 jmp	 SHORT $LN47@inflate
$LN44@inflate:
  004ad	33 c0		 xor	 eax, eax
  004af	75 b9		 jne	 SHORT $LN47@inflate

; 727  :             if (state->head != Z_NULL)

  004b1	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  004b4	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  004b8	74 0f		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  004ba	0f ae e8	 lfence
  004bd	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  004c0	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  004c3	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  004c6	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  004c9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  004cc	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  004cf	25 00 02 00 00	 and	 eax, 512		; 00000200H
  004d4	74 6e		 je	 SHORT $LN57@inflate
  004d6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  004d9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  004dc	83 e2 04	 and	 edx, 4
  004df	74 63		 je	 SHORT $LN57@inflate
$LN54@inflate:

; 730  :                 CRC4(state->check, hold);

  004e1	0f ae e8	 lfence
  004e4	b8 01 00 00 00	 mov	 eax, 1
  004e9	6b c8 00	 imul	 ecx, eax, 0
  004ec	8a 55 e8	 mov	 dl, BYTE PTR _hold$[ebp]
  004ef	88 54 0d ac	 mov	 BYTE PTR _hbuf$[ebp+ecx], dl
  004f3	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  004f6	c1 e8 08	 shr	 eax, 8
  004f9	b9 01 00 00 00	 mov	 ecx, 1
  004fe	c1 e1 00	 shl	 ecx, 0
  00501	88 44 0d ac	 mov	 BYTE PTR _hbuf$[ebp+ecx], al
  00505	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  00508	c1 ea 10	 shr	 edx, 16			; 00000010H
  0050b	b8 01 00 00 00	 mov	 eax, 1
  00510	d1 e0		 shl	 eax, 1
  00512	88 54 05 ac	 mov	 BYTE PTR _hbuf$[ebp+eax], dl
  00516	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00519	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0051c	ba 01 00 00 00	 mov	 edx, 1
  00521	6b c2 03	 imul	 eax, edx, 3
  00524	88 4c 05 ac	 mov	 BYTE PTR _hbuf$[ebp+eax], cl
  00528	6a 04		 push	 4
  0052a	8d 4d ac	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  0052d	51		 push	 ecx
  0052e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00531	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00534	50		 push	 eax
  00535	e8 00 00 00 00	 call	 _crc32@12
  0053a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0053d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00540	33 d2		 xor	 edx, edx
  00542	75 9d		 jne	 SHORT $LN54@inflate
$LN57@inflate:

; 731  :             INITBITS();

  00544	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  0054b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00552	33 c0		 xor	 eax, eax
  00554	75 ee		 jne	 SHORT $LN57@inflate

; 732  :             state->mode = OS;

  00556	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00559	c7 41 04 37 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16183 ; 00003f37H
$LN61@inflate:

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  00560	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00564	73 3d		 jae	 SHORT $LN58@inflate
$LN65@inflate:
  00566	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0056a	75 05		 jne	 SHORT $LN358@inflate
  0056c	e9 36 1a 00 00	 jmp	 $inf_leave$566
$LN358@inflate:
  00571	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00574	83 ea 01	 sub	 edx, 1
  00577	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  0057a	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  0057d	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00580	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00583	d3 e2		 shl	 edx, cl
  00585	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  00588	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  0058b	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  0058e	83 c0 01	 add	 eax, 1
  00591	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00594	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00597	83 c1 08	 add	 ecx, 8
  0059a	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0059d	33 d2		 xor	 edx, edx
  0059f	75 c5		 jne	 SHORT $LN65@inflate
  005a1	eb bd		 jmp	 SHORT $LN61@inflate
$LN58@inflate:
  005a3	33 c0		 xor	 eax, eax
  005a5	75 b9		 jne	 SHORT $LN61@inflate

; 735  :             if (state->head != Z_NULL) {

  005a7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  005aa	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  005ae	74 24		 je	 SHORT $LN359@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  005b0	0f ae e8	 lfence
  005b3	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  005b6	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005bc	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  005bf	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005c2	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 737  :                 state->head->os = (int)(hold >> 8);

  005c5	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  005c8	c1 ea 08	 shr	 edx, 8
  005cb	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  005ce	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  005d1	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN359@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  005d4	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  005d7	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  005da	25 00 02 00 00	 and	 eax, 512		; 00000200H
  005df	74 4b		 je	 SHORT $LN71@inflate
  005e1	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  005e4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  005e7	83 e2 04	 and	 edx, 4
  005ea	74 40		 je	 SHORT $LN71@inflate
$LN68@inflate:

; 740  :                 CRC2(state->check, hold);

  005ec	0f ae e8	 lfence
  005ef	b8 01 00 00 00	 mov	 eax, 1
  005f4	6b c8 00	 imul	 ecx, eax, 0
  005f7	8a 55 e8	 mov	 dl, BYTE PTR _hold$[ebp]
  005fa	88 54 0d ac	 mov	 BYTE PTR _hbuf$[ebp+ecx], dl
  005fe	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  00601	c1 e8 08	 shr	 eax, 8
  00604	b9 01 00 00 00	 mov	 ecx, 1
  00609	c1 e1 00	 shl	 ecx, 0
  0060c	88 44 0d ac	 mov	 BYTE PTR _hbuf$[ebp+ecx], al
  00610	6a 02		 push	 2
  00612	8d 55 ac	 lea	 edx, DWORD PTR _hbuf$[ebp]
  00615	52		 push	 edx
  00616	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00619	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0061c	51		 push	 ecx
  0061d	e8 00 00 00 00	 call	 _crc32@12
  00622	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00625	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  00628	33 c0		 xor	 eax, eax
  0062a	75 c0		 jne	 SHORT $LN68@inflate
$LN71@inflate:

; 741  :             INITBITS();

  0062c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00633	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  0063a	33 c9		 xor	 ecx, ecx
  0063c	75 ee		 jne	 SHORT $LN71@inflate

; 742  :             state->mode = EXLEN;

  0063e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00641	c7 42 04 38 3f
	00 00		 mov	 DWORD PTR [edx+4], 16184 ; 00003f38H
$LN361@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  00648	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0064b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0064e	81 e1 00 04 00
	00		 and	 ecx, 1024		; 00000400H
  00654	0f 84 d5 00 00
	00		 je	 $LN362@inflate
$LN75@inflate:

; 745  :                 NEEDBITS(16);

  0065a	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  0065e	73 3d		 jae	 SHORT $LN72@inflate
$LN79@inflate:
  00660	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00664	75 05		 jne	 SHORT $LN364@inflate
  00666	e9 3c 19 00 00	 jmp	 $inf_leave$566
$LN364@inflate:
  0066b	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  0066e	83 ea 01	 sub	 edx, 1
  00671	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  00674	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00677	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0067a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0067d	d3 e2		 shl	 edx, cl
  0067f	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  00682	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  00685	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00688	83 c0 01	 add	 eax, 1
  0068b	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  0068e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00691	83 c1 08	 add	 ecx, 8
  00694	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00697	33 d2		 xor	 edx, edx
  00699	75 c5		 jne	 SHORT $LN79@inflate
  0069b	eb bd		 jmp	 SHORT $LN75@inflate
$LN72@inflate:
  0069d	33 c0		 xor	 eax, eax
  0069f	75 b9		 jne	 SHORT $LN75@inflate

; 746  :                 state->length = (unsigned)(hold);

  006a1	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  006a4	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  006a7	89 51 44	 mov	 DWORD PTR [ecx+68], edx

; 747  :                 if (state->head != Z_NULL)

  006aa	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  006ad	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  006b1	74 0f		 je	 SHORT $LN365@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  006b3	0f ae e8	 lfence
  006b6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  006b9	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  006bc	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  006bf	89 42 14	 mov	 DWORD PTR [edx+20], eax
$LN365@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  006c2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  006c5	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  006c8	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  006ce	74 4b		 je	 SHORT $LN85@inflate
  006d0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  006d3	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  006d6	83 e1 04	 and	 ecx, 4
  006d9	74 40		 je	 SHORT $LN85@inflate
$LN82@inflate:

; 750  :                     CRC2(state->check, hold);

  006db	0f ae e8	 lfence
  006de	ba 01 00 00 00	 mov	 edx, 1
  006e3	6b c2 00	 imul	 eax, edx, 0
  006e6	8a 4d e8	 mov	 cl, BYTE PTR _hold$[ebp]
  006e9	88 4c 05 ac	 mov	 BYTE PTR _hbuf$[ebp+eax], cl
  006ed	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  006f0	c1 ea 08	 shr	 edx, 8
  006f3	b8 01 00 00 00	 mov	 eax, 1
  006f8	c1 e0 00	 shl	 eax, 0
  006fb	88 54 05 ac	 mov	 BYTE PTR _hbuf$[ebp+eax], dl
  006ff	6a 02		 push	 2
  00701	8d 4d ac	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00704	51		 push	 ecx
  00705	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00708	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0070b	50		 push	 eax
  0070c	e8 00 00 00 00	 call	 _crc32@12
  00711	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00714	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00717	33 d2		 xor	 edx, edx
  00719	75 c0		 jne	 SHORT $LN82@inflate
$LN85@inflate:

; 751  :                 INITBITS();

  0071b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00722	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00729	33 c0		 xor	 eax, eax
  0072b	75 ee		 jne	 SHORT $LN85@inflate

; 752  :             }

  0072d	eb 16		 jmp	 SHORT $LN363@inflate
$LN362@inflate:

; 753  :             else if (state->head != Z_NULL)

  0072f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00732	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00736	74 0d		 je	 SHORT $LN363@inflate

; 754  :                 state->head->extra = Z_NULL;

  00738	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0073b	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0073e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN363@inflate:

; 755  :             state->mode = EXTRA;

  00745	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00748	c7 41 04 39 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16185 ; 00003f39H
$LN368@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  0074f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00752	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00755	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0075a	0f 84 f2 00 00
	00		 je	 $LN369@inflate

; 758  :                 copy = state->length;

  00760	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00763	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00766	89 55 d8	 mov	 DWORD PTR _copy$[ebp], edx

; 759  :                 if (copy > have) copy = have;

  00769	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  0076c	3b 45 f0	 cmp	 eax, DWORD PTR _have$[ebp]
  0076f	76 06		 jbe	 SHORT $LN370@inflate
  00771	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00774	89 4d d8	 mov	 DWORD PTR _copy$[ebp], ecx
$LN370@inflate:

; 760  :                 if (copy) {

  00777	83 7d d8 00	 cmp	 DWORD PTR _copy$[ebp], 0
  0077b	0f 84 c3 00 00
	00		 je	 $LN371@inflate

; 761  :                     if (state->head != Z_NULL &&

  00781	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00784	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  00788	74 66		 je	 SHORT $LN372@inflate
  0078a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0078d	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00790	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00794	74 5a		 je	 SHORT $LN372@inflate

; 762  :                         state->head->extra != Z_NULL) {
; 763  :                         len = state->head->extra_len - state->length;

  00796	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00799	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0079c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0079f	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  007a2	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  007a5	89 55 b8	 mov	 DWORD PTR _len$[ebp], edx

; 764  :                         zmemcpy(state->head->extra + len, next,

  007a8	8b 45 b8	 mov	 eax, DWORD PTR _len$[ebp]
  007ab	03 45 d8	 add	 eax, DWORD PTR _copy$[ebp]
  007ae	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  007b1	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  007b4	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  007b7	76 14		 jbe	 SHORT $LN511@inflate
  007b9	0f ae e8	 lfence
  007bc	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  007bf	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  007c2	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  007c5	2b 55 b8	 sub	 edx, DWORD PTR _len$[ebp]
  007c8	89 55 98	 mov	 DWORD PTR tv400[ebp], edx
  007cb	eb 06		 jmp	 SHORT $LN512@inflate
$LN511@inflate:
  007cd	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  007d0	89 45 98	 mov	 DWORD PTR tv400[ebp], eax
$LN512@inflate:
  007d3	8b 4d 98	 mov	 ecx, DWORD PTR tv400[ebp]
  007d6	51		 push	 ecx
  007d7	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  007da	52		 push	 edx
  007db	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  007de	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  007e1	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  007e4	03 55 b8	 add	 edx, DWORD PTR _len$[ebp]
  007e7	52		 push	 edx
  007e8	e8 00 00 00 00	 call	 _memcpy
  007ed	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN372@inflate:

; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);
; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  007f0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  007f3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  007f6	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  007fc	74 25		 je	 SHORT $LN373@inflate
  007fe	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00801	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00804	83 e0 04	 and	 eax, 4
  00807	74 1a		 je	 SHORT $LN373@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  00809	8b 4d d8	 mov	 ecx, DWORD PTR _copy$[ebp]
  0080c	51		 push	 ecx
  0080d	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00810	52		 push	 edx
  00811	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00814	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00817	51		 push	 ecx
  00818	e8 00 00 00 00	 call	 _crc32@12
  0081d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00820	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$LN373@inflate:

; 770  :                     have -= copy;

  00823	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00826	2b 45 d8	 sub	 eax, DWORD PTR _copy$[ebp]
  00829	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax

; 771  :                     next += copy;

  0082c	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  0082f	03 4d d8	 add	 ecx, DWORD PTR _copy$[ebp]
  00832	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 772  :                     state->length -= copy;

  00835	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00838	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0083b	2b 45 d8	 sub	 eax, DWORD PTR _copy$[ebp]
  0083e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00841	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN371@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  00844	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00847	83 7a 44 00	 cmp	 DWORD PTR [edx+68], 0
  0084b	74 05		 je	 SHORT $LN369@inflate
  0084d	e9 55 17 00 00	 jmp	 $inf_leave$566
$LN369@inflate:

; 775  :             }
; 776  :             state->length = 0;

  00852	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00855	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 777  :             state->mode = NAME;

  0085c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0085f	c7 41 04 3a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16186 ; 00003f3aH
$LN375@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  00866	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00869	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0086c	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00871	0f 84 d1 00 00
	00		 je	 $LN376@inflate

; 780  :                 if (have == 0) goto inf_leave;

  00877	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0087b	75 05		 jne	 SHORT $LN378@inflate
  0087d	e9 25 17 00 00	 jmp	 $inf_leave$566
$LN378@inflate:

; 781  :                 copy = 0;

  00882	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0
$LN88@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  00889	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  0088c	03 4d d8	 add	 ecx, DWORD PTR _copy$[ebp]
  0088f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00892	89 55 b8	 mov	 DWORD PTR _len$[ebp], edx
  00895	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  00898	83 c0 01	 add	 eax, 1
  0089b	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&

  0089e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  008a1	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  008a5	74 41		 je	 SHORT $LN86@inflate
  008a7	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  008aa	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  008ad	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  008b1	74 35		 je	 SHORT $LN86@inflate
  008b3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  008b6	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  008b9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  008bc	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  008bf	3b 4a 20	 cmp	 ecx, DWORD PTR [edx+32]
  008c2	73 24		 jae	 SHORT $LN86@inflate

; 786  :                             state->length < state->head->name_max)
; 787  :                         state->head->name[state->length++] = (Bytef)len;

  008c4	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  008c7	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  008ca	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  008cd	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  008d0	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  008d3	8a 4d b8	 mov	 cl, BYTE PTR _len$[ebp]
  008d6	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  008d9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  008dc	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  008df	83 c0 01	 add	 eax, 1
  008e2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  008e5	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN86@inflate:

; 788  :                 } while (len && copy < have);

  008e8	83 7d b8 00	 cmp	 DWORD PTR _len$[ebp], 0
  008ec	74 08		 je	 SHORT $LN87@inflate
  008ee	8b 55 d8	 mov	 edx, DWORD PTR _copy$[ebp]
  008f1	3b 55 f0	 cmp	 edx, DWORD PTR _have$[ebp]
  008f4	72 93		 jb	 SHORT $LN88@inflate
$LN87@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  008f6	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  008f9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  008fc	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00902	74 25		 je	 SHORT $LN381@inflate
  00904	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00907	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0090a	83 e0 04	 and	 eax, 4
  0090d	74 1a		 je	 SHORT $LN381@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  0090f	8b 4d d8	 mov	 ecx, DWORD PTR _copy$[ebp]
  00912	51		 push	 ecx
  00913	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00916	52		 push	 edx
  00917	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0091a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0091d	51		 push	 ecx
  0091e	e8 00 00 00 00	 call	 _crc32@12
  00923	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00926	89 42 1c	 mov	 DWORD PTR [edx+28], eax
$LN381@inflate:

; 791  :                 have -= copy;

  00929	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  0092c	2b 45 d8	 sub	 eax, DWORD PTR _copy$[ebp]
  0092f	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax

; 792  :                 next += copy;

  00932	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  00935	03 4d d8	 add	 ecx, DWORD PTR _copy$[ebp]
  00938	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx

; 793  :                 if (len) goto inf_leave;

  0093b	83 7d b8 00	 cmp	 DWORD PTR _len$[ebp], 0
  0093f	74 05		 je	 SHORT $LN382@inflate
  00941	e9 61 16 00 00	 jmp	 $inf_leave$566
$LN382@inflate:

; 794  :             }

  00946	eb 16		 jmp	 SHORT $LN377@inflate
$LN376@inflate:

; 795  :             else if (state->head != Z_NULL)

  00948	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0094b	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0094f	74 0d		 je	 SHORT $LN377@inflate

; 796  :                 state->head->name = Z_NULL;

  00951	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00954	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00957	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0
$LN377@inflate:

; 797  :             state->length = 0;

  0095e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00961	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0

; 798  :             state->mode = COMMENT;

  00968	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0096b	c7 40 04 3b 3f
	00 00		 mov	 DWORD PTR [eax+4], 16187 ; 00003f3bH
$LN384@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  00972	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00975	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00978	81 e2 00 10 00
	00		 and	 edx, 4096		; 00001000H
  0097e	0f 84 d0 00 00
	00		 je	 $LN385@inflate

; 801  :                 if (have == 0) goto inf_leave;

  00984	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00988	75 05		 jne	 SHORT $LN387@inflate
  0098a	e9 18 16 00 00	 jmp	 $inf_leave$566
$LN387@inflate:

; 802  :                 copy = 0;

  0098f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0
$LN91@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  00996	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00999	03 45 d8	 add	 eax, DWORD PTR _copy$[ebp]
  0099c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0099f	89 4d b8	 mov	 DWORD PTR _len$[ebp], ecx
  009a2	8b 55 d8	 mov	 edx, DWORD PTR _copy$[ebp]
  009a5	83 c2 01	 add	 edx, 1
  009a8	89 55 d8	 mov	 DWORD PTR _copy$[ebp], edx

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&

  009ab	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  009ae	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  009b2	74 41		 je	 SHORT $LN89@inflate
  009b4	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  009b7	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  009ba	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  009be	74 35		 je	 SHORT $LN89@inflate
  009c0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  009c3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  009c6	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  009c9	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  009cc	3b 41 28	 cmp	 eax, DWORD PTR [ecx+40]
  009cf	73 24		 jae	 SHORT $LN89@inflate

; 807  :                             state->length < state->head->comm_max)
; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  009d1	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  009d4	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  009d7	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  009da	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  009dd	8b 52 24	 mov	 edx, DWORD PTR [edx+36]
  009e0	8a 45 b8	 mov	 al, BYTE PTR _len$[ebp]
  009e3	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  009e6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  009e9	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  009ec	83 c2 01	 add	 edx, 1
  009ef	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  009f2	89 50 44	 mov	 DWORD PTR [eax+68], edx
$LN89@inflate:

; 809  :                 } while (len && copy < have);

  009f5	83 7d b8 00	 cmp	 DWORD PTR _len$[ebp], 0
  009f9	74 08		 je	 SHORT $LN90@inflate
  009fb	8b 4d d8	 mov	 ecx, DWORD PTR _copy$[ebp]
  009fe	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  00a01	72 93		 jb	 SHORT $LN91@inflate
$LN90@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00a03	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00a06	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00a09	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00a0e	74 25		 je	 SHORT $LN390@inflate
  00a10	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a13	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00a16	83 e2 04	 and	 edx, 4
  00a19	74 1a		 je	 SHORT $LN390@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  00a1b	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  00a1e	50		 push	 eax
  00a1f	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  00a22	51		 push	 ecx
  00a23	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00a26	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00a29	50		 push	 eax
  00a2a	e8 00 00 00 00	 call	 _crc32@12
  00a2f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a32	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN390@inflate:

; 812  :                 have -= copy;

  00a35	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00a38	2b 55 d8	 sub	 edx, DWORD PTR _copy$[ebp]
  00a3b	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 813  :                 next += copy;

  00a3e	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00a41	03 45 d8	 add	 eax, DWORD PTR _copy$[ebp]
  00a44	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax

; 814  :                 if (len) goto inf_leave;

  00a47	83 7d b8 00	 cmp	 DWORD PTR _len$[ebp], 0
  00a4b	74 05		 je	 SHORT $LN391@inflate
  00a4d	e9 55 15 00 00	 jmp	 $inf_leave$566
$LN391@inflate:

; 815  :             }

  00a52	eb 16		 jmp	 SHORT $LN386@inflate
$LN385@inflate:

; 816  :             else if (state->head != Z_NULL)

  00a54	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a57	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00a5b	74 0d		 je	 SHORT $LN386@inflate

; 817  :                 state->head->comment = Z_NULL;

  00a5d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00a60	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00a63	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN386@inflate:

; 818  :             state->mode = HCRC;

  00a6a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a6d	c7 41 04 3c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16188 ; 00003f3cH
$LN393@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  00a74	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00a77	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00a7a	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00a7f	0f 84 8e 00 00
	00		 je	 $LN394@inflate
$LN95@inflate:

; 821  :                 NEEDBITS(16);

  00a85	83 7d e4 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00a89	73 3d		 jae	 SHORT $LN92@inflate
$LN99@inflate:
  00a8b	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00a8f	75 05		 jne	 SHORT $LN395@inflate
  00a91	e9 11 15 00 00	 jmp	 $inf_leave$566
$LN395@inflate:
  00a96	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00a99	83 e9 01	 sub	 ecx, 1
  00a9c	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00a9f	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00aa2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00aa5	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00aa8	d3 e0		 shl	 eax, cl
  00aaa	03 45 e8	 add	 eax, DWORD PTR _hold$[ebp]
  00aad	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  00ab0	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  00ab3	83 c1 01	 add	 ecx, 1
  00ab6	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  00ab9	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00abc	83 c2 08	 add	 edx, 8
  00abf	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00ac2	33 c0		 xor	 eax, eax
  00ac4	75 c5		 jne	 SHORT $LN99@inflate
  00ac6	eb bd		 jmp	 SHORT $LN95@inflate
$LN92@inflate:
  00ac8	33 c9		 xor	 ecx, ecx
  00aca	75 b9		 jne	 SHORT $LN95@inflate

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  00acc	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00acf	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00ad2	83 e0 04	 and	 eax, 4
  00ad5	74 2a		 je	 SHORT $LN102@inflate
  00ad7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ada	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00add	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00ae3	39 55 e8	 cmp	 DWORD PTR _hold$[ebp], edx
  00ae6	74 19		 je	 SHORT $LN102@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  00ae8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00aeb	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@

; 824  :                     state->mode = BAD;

  00af2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00af5	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 825  :                     break;

  00afc	e9 a1 14 00 00	 jmp	 $LN8@inflate
$LN102@inflate:

; 826  :                 }
; 827  :                 INITBITS();

  00b01	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00b08	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00b0f	33 d2		 xor	 edx, edx
  00b11	75 ee		 jne	 SHORT $LN102@inflate
$LN394@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  00b13	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00b16	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00b1a	74 22		 je	 SHORT $LN397@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00b1c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b1f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00b22	c1 fa 09	 sar	 edx, 9
  00b25	83 e2 01	 and	 edx, 1
  00b28	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00b2b	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00b2e	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 831  :                 state->head->done = 1;

  00b31	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00b34	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00b37	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN397@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00b3e	6a 00		 push	 0
  00b40	6a 00		 push	 0
  00b42	6a 00		 push	 0
  00b44	e8 00 00 00 00	 call	 _crc32@12
  00b49	89 45 94	 mov	 DWORD PTR tv555[ebp], eax
  00b4c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b4f	8b 55 94	 mov	 edx, DWORD PTR tv555[ebp]
  00b52	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
  00b55	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b58	8b 4d 94	 mov	 ecx, DWORD PTR tv555[ebp]
  00b5b	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 834  :             state->mode = TYPE;

  00b5e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00b61	c7 42 04 3f 3f
	00 00		 mov	 DWORD PTR [edx+4], 16191 ; 00003f3fH

; 835  :             break;

  00b68	e9 35 14 00 00	 jmp	 $LN8@inflate
$LN106@inflate:

; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  00b6d	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00b71	73 3d		 jae	 SHORT $LN103@inflate
$LN110@inflate:
  00b73	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00b77	75 05		 jne	 SHORT $LN399@inflate
  00b79	e9 29 14 00 00	 jmp	 $inf_leave$566
$LN399@inflate:
  00b7e	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  00b81	83 e8 01	 sub	 eax, 1
  00b84	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  00b87	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  00b8a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00b8d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00b90	d3 e2		 shl	 edx, cl
  00b92	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  00b95	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  00b98	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00b9b	83 c0 01	 add	 eax, 1
  00b9e	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  00ba1	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00ba4	83 c1 08	 add	 ecx, 8
  00ba7	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00baa	33 d2		 xor	 edx, edx
  00bac	75 c5		 jne	 SHORT $LN110@inflate
  00bae	eb bd		 jmp	 SHORT $LN106@inflate
$LN103@inflate:
  00bb0	33 c0		 xor	 eax, eax
  00bb2	75 b9		 jne	 SHORT $LN106@inflate

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  00bb4	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00bb7	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00bba	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00bc0	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  00bc3	c1 ea 08	 shr	 edx, 8
  00bc6	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  00bcc	03 ca		 add	 ecx, edx
  00bce	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  00bd1	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00bd6	c1 e0 08	 shl	 eax, 8
  00bd9	03 c8		 add	 ecx, eax
  00bdb	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  00bde	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00be4	c1 e2 18	 shl	 edx, 24			; 00000018H
  00be7	03 ca		 add	 ecx, edx
  00be9	89 4d 90	 mov	 DWORD PTR tv582[ebp], ecx
  00bec	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00bef	8b 4d 90	 mov	 ecx, DWORD PTR tv582[ebp]
  00bf2	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  00bf5	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00bf8	8b 45 90	 mov	 eax, DWORD PTR tv582[ebp]
  00bfb	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN113@inflate:

; 840  :             INITBITS();

  00bfe	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00c05	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00c0c	33 c9		 xor	 ecx, ecx
  00c0e	75 ee		 jne	 SHORT $LN113@inflate

; 841  :             state->mode = DICT;

  00c10	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00c13	c7 42 04 3e 3f
	00 00		 mov	 DWORD PTR [edx+4], 16190 ; 00003f3eH
$LN400@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  00c1a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00c1d	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00c21	75 43		 jne	 SHORT $LN401@inflate
$LN116@inflate:

; 844  :                 RESTORE();

  00c23	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c26	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  00c29	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00c2c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c2f	8b 4d ec	 mov	 ecx, DWORD PTR _left$[ebp]
  00c32	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00c35	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00c38	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00c3b	89 02		 mov	 DWORD PTR [edx], eax
  00c3d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c40	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00c43	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00c46	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00c49	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00c4c	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  00c4f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00c52	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00c55	89 42 40	 mov	 DWORD PTR [edx+64], eax
  00c58	33 c9		 xor	 ecx, ecx
  00c5a	75 c7		 jne	 SHORT $LN116@inflate

; 845  :                 return Z_NEED_DICT;

  00c5c	b8 02 00 00 00	 mov	 eax, 2
  00c61	e9 49 15 00 00	 jmp	 $LN1@inflate
$LN401@inflate:

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00c66	6a 00		 push	 0
  00c68	6a 00		 push	 0
  00c6a	6a 00		 push	 0
  00c6c	e8 00 00 00 00	 call	 _adler32@12
  00c71	89 45 8c	 mov	 DWORD PTR tv596[ebp], eax
  00c74	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00c77	8b 45 8c	 mov	 eax, DWORD PTR tv596[ebp]
  00c7a	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  00c7d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c80	8b 55 8c	 mov	 edx, DWORD PTR tv596[ebp]
  00c83	89 51 30	 mov	 DWORD PTR [ecx+48], edx

; 848  :             state->mode = TYPE;

  00c86	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00c89	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH
$LN402@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00c90	83 7d 0c 05	 cmp	 DWORD PTR _flush$[ebp], 5
  00c94	74 06		 je	 SHORT $LN404@inflate
  00c96	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00c9a	75 05		 jne	 SHORT $LN405@inflate
$LN404@inflate:
  00c9c	e9 06 13 00 00	 jmp	 $inf_leave$566
$LN405@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  00ca1	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ca4	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00ca8	74 2f		 je	 SHORT $LN123@inflate
$LN119@inflate:

; 853  :                 BYTEBITS();

  00caa	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00cad	83 e1 07	 and	 ecx, 7
  00cb0	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  00cb3	d3 ea		 shr	 edx, cl
  00cb5	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  00cb8	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00cbb	83 e0 07	 and	 eax, 7
  00cbe	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00cc1	2b c8		 sub	 ecx, eax
  00cc3	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00cc6	33 d2		 xor	 edx, edx
  00cc8	75 e0		 jne	 SHORT $LN119@inflate

; 854  :                 state->mode = CHECK;

  00cca	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00ccd	c7 40 04 4e 3f
	00 00		 mov	 DWORD PTR [eax+4], 16206 ; 00003f4eH

; 855  :                 break;

  00cd4	e9 c9 12 00 00	 jmp	 $LN8@inflate
$LN123@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  00cd9	83 7d e4 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00cdd	73 3d		 jae	 SHORT $LN120@inflate
$LN127@inflate:
  00cdf	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ce3	75 05		 jne	 SHORT $LN407@inflate
  00ce5	e9 bd 12 00 00	 jmp	 $inf_leave$566
$LN407@inflate:
  00cea	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00ced	83 e9 01	 sub	 ecx, 1
  00cf0	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00cf3	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00cf6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00cf9	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00cfc	d3 e0		 shl	 eax, cl
  00cfe	03 45 e8	 add	 eax, DWORD PTR _hold$[ebp]
  00d01	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  00d04	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  00d07	83 c1 01	 add	 ecx, 1
  00d0a	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  00d0d	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00d10	83 c2 08	 add	 edx, 8
  00d13	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00d16	33 c0		 xor	 eax, eax
  00d18	75 c5		 jne	 SHORT $LN127@inflate
  00d1a	eb bd		 jmp	 SHORT $LN123@inflate
$LN120@inflate:
  00d1c	33 c9		 xor	 ecx, ecx
  00d1e	75 b9		 jne	 SHORT $LN123@inflate

; 858  :             state->last = BITS(1);

  00d20	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  00d23	83 e2 01	 and	 edx, 1
  00d26	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00d29	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN130@inflate:

; 859  :             DROPBITS(1);

  00d2c	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00d2f	d1 e9		 shr	 ecx, 1
  00d31	89 4d e8	 mov	 DWORD PTR _hold$[ebp], ecx
  00d34	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00d37	83 ea 01	 sub	 edx, 1
  00d3a	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00d3d	33 c0		 xor	 eax, eax
  00d3f	75 eb		 jne	 SHORT $LN130@inflate

; 860  :             switch (BITS(2)) {

  00d41	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00d44	83 e1 03	 and	 ecx, 3
  00d47	89 4d 88	 mov	 DWORD PTR tv627[ebp], ecx
  00d4a	83 7d 88 03	 cmp	 DWORD PTR tv627[ebp], 3
  00d4e	77 72		 ja	 SHORT $LN138@inflate
  00d50	8b 55 88	 mov	 edx, DWORD PTR tv627[ebp]
  00d53	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN560@inflate[edx*4]
$LN408@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;

  00d5a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00d5d	c7 40 04 41 3f
	00 00		 mov	 DWORD PTR [eax+4], 16193 ; 00003f41H

; 865  :                 break;

  00d64	eb 5c		 jmp	 SHORT $LN138@inflate
$LN409@inflate:

; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  00d66	0f ae e8	 lfence
  00d69	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00d6c	51		 push	 ecx
  00d6d	e8 00 00 00 00	 call	 _fixedtables
  00d72	83 c4 04	 add	 esp, 4

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */

  00d75	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00d78	c7 42 04 47 3f
	00 00		 mov	 DWORD PTR [edx+4], 16199 ; 00003f47H

; 871  :                 if (flush == Z_TREES) {

  00d7f	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00d83	75 1b		 jne	 SHORT $LN410@inflate
$LN135@inflate:

; 872  :                     DROPBITS(2);

  00d85	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  00d88	c1 e8 02	 shr	 eax, 2
  00d8b	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  00d8e	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d91	83 e9 02	 sub	 ecx, 2
  00d94	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00d97	33 d2		 xor	 edx, edx
  00d99	75 ea		 jne	 SHORT $LN135@inflate

; 873  :                     goto inf_leave;

  00d9b	e9 07 12 00 00	 jmp	 $inf_leave$566
$LN410@inflate:

; 874  :                 }
; 875  :                 break;

  00da0	eb 20		 jmp	 SHORT $LN138@inflate
$LN411@inflate:

; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;

  00da2	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00da5	c7 40 04 44 3f
	00 00		 mov	 DWORD PTR [eax+4], 16196 ; 00003f44H

; 880  :                 break;

  00dac	eb 14		 jmp	 SHORT $LN138@inflate
$LN412@inflate:

; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  00dae	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00db1	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 883  :                 state->mode = BAD;

  00db8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00dbb	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H
$LN138@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  00dc2	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  00dc5	c1 e8 02	 shr	 eax, 2
  00dc8	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  00dcb	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00dce	83 e9 02	 sub	 ecx, 2
  00dd1	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00dd4	33 d2		 xor	 edx, edx
  00dd6	75 ea		 jne	 SHORT $LN138@inflate

; 886  :             break;

  00dd8	e9 c5 11 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  00ddd	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00de0	83 e1 07	 and	 ecx, 7
  00de3	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  00de6	d3 e8		 shr	 eax, cl
  00de8	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  00deb	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00dee	83 e1 07	 and	 ecx, 7
  00df1	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00df4	2b d1		 sub	 edx, ecx
  00df6	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00df9	33 c0		 xor	 eax, eax
  00dfb	75 e0		 jne	 SHORT $LN141@inflate
$LN145@inflate:

; 889  :             NEEDBITS(32);

  00dfd	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00e01	73 3d		 jae	 SHORT $LN142@inflate
$LN149@inflate:
  00e03	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00e07	75 05		 jne	 SHORT $LN414@inflate
  00e09	e9 99 11 00 00	 jmp	 $inf_leave$566
$LN414@inflate:
  00e0e	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00e11	83 e9 01	 sub	 ecx, 1
  00e14	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00e17	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00e1a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00e1d	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00e20	d3 e0		 shl	 eax, cl
  00e22	03 45 e8	 add	 eax, DWORD PTR _hold$[ebp]
  00e25	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  00e28	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  00e2b	83 c1 01	 add	 ecx, 1
  00e2e	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  00e31	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00e34	83 c2 08	 add	 edx, 8
  00e37	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00e3a	33 c0		 xor	 eax, eax
  00e3c	75 c5		 jne	 SHORT $LN149@inflate
  00e3e	eb bd		 jmp	 SHORT $LN145@inflate
$LN142@inflate:
  00e40	33 c9		 xor	 ecx, ecx
  00e42	75 b9		 jne	 SHORT $LN145@inflate

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00e44	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  00e47	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00e4d	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  00e50	c1 e8 10	 shr	 eax, 16			; 00000010H
  00e53	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  00e58	3b d0		 cmp	 edx, eax
  00e5a	74 19		 je	 SHORT $LN415@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  00e5c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00e5f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@

; 892  :                 state->mode = BAD;

  00e66	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00e69	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 893  :                 break;

  00e70	e9 2d 11 00 00	 jmp	 $LN8@inflate
$LN415@inflate:

; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  00e75	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  00e78	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00e7d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00e80	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN152@inflate:

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  00e83	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00e8a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00e91	33 d2		 xor	 edx, edx
  00e93	75 ee		 jne	 SHORT $LN152@inflate

; 899  :             state->mode = COPY_;

  00e95	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00e98	c7 40 04 42 3f
	00 00		 mov	 DWORD PTR [eax+4], 16194 ; 00003f42H

; 900  :             if (flush == Z_TREES) goto inf_leave;

  00e9f	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  00ea3	75 05		 jne	 SHORT $LN417@inflate
  00ea5	e9 fd 10 00 00	 jmp	 $inf_leave$566
$LN417@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  00eaa	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ead	c7 41 04 43 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16195 ; 00003f43H
$LN418@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  00eb4	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00eb7	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00eba	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax

; 905  :             if (copy) {

  00ebd	83 7d d8 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00ec1	74 73		 je	 SHORT $LN419@inflate

; 906  :                 if (copy > have) copy = have;

  00ec3	8b 4d d8	 mov	 ecx, DWORD PTR _copy$[ebp]
  00ec6	3b 4d f0	 cmp	 ecx, DWORD PTR _have$[ebp]
  00ec9	76 06		 jbe	 SHORT $LN420@inflate
  00ecb	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00ece	89 55 d8	 mov	 DWORD PTR _copy$[ebp], edx
$LN420@inflate:

; 907  :                 if (copy > left) copy = left;

  00ed1	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  00ed4	3b 45 ec	 cmp	 eax, DWORD PTR _left$[ebp]
  00ed7	76 06		 jbe	 SHORT $LN421@inflate
  00ed9	8b 4d ec	 mov	 ecx, DWORD PTR _left$[ebp]
  00edc	89 4d d8	 mov	 DWORD PTR _copy$[ebp], ecx
$LN421@inflate:

; 908  :                 if (copy == 0) goto inf_leave;

  00edf	83 7d d8 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00ee3	75 05		 jne	 SHORT $LN422@inflate
  00ee5	e9 bd 10 00 00	 jmp	 $inf_leave$566
$LN422@inflate:

; 909  :                 zmemcpy(put, next, copy);

  00eea	8b 55 d8	 mov	 edx, DWORD PTR _copy$[ebp]
  00eed	52		 push	 edx
  00eee	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00ef1	50		 push	 eax
  00ef2	8b 4d f4	 mov	 ecx, DWORD PTR _put$[ebp]
  00ef5	51		 push	 ecx
  00ef6	e8 00 00 00 00	 call	 _memcpy
  00efb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 910  :                 have -= copy;

  00efe	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  00f01	2b 55 d8	 sub	 edx, DWORD PTR _copy$[ebp]
  00f04	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx

; 911  :                 next += copy;

  00f07	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00f0a	03 45 d8	 add	 eax, DWORD PTR _copy$[ebp]
  00f0d	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax

; 912  :                 left -= copy;

  00f10	8b 4d ec	 mov	 ecx, DWORD PTR _left$[ebp]
  00f13	2b 4d d8	 sub	 ecx, DWORD PTR _copy$[ebp]
  00f16	89 4d ec	 mov	 DWORD PTR _left$[ebp], ecx

; 913  :                 put += copy;

  00f19	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  00f1c	03 55 d8	 add	 edx, DWORD PTR _copy$[ebp]
  00f1f	89 55 f4	 mov	 DWORD PTR _put$[ebp], edx

; 914  :                 state->length -= copy;

  00f22	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00f25	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00f28	2b 4d d8	 sub	 ecx, DWORD PTR _copy$[ebp]
  00f2b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00f2e	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 915  :                 break;

  00f31	e9 6c 10 00 00	 jmp	 $LN8@inflate
$LN419@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;

  00f36	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00f39	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 919  :             break;

  00f40	e9 5d 10 00 00	 jmp	 $LN8@inflate
$LN156@inflate:

; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  00f45	83 7d e4 0e	 cmp	 DWORD PTR _bits$[ebp], 14 ; 0000000eH
  00f49	73 3d		 jae	 SHORT $LN153@inflate
$LN160@inflate:
  00f4b	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f4f	75 05		 jne	 SHORT $LN424@inflate
  00f51	e9 51 10 00 00	 jmp	 $inf_leave$566
$LN424@inflate:
  00f56	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  00f59	83 e9 01	 sub	 ecx, 1
  00f5c	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  00f5f	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00f62	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00f65	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f68	d3 e0		 shl	 eax, cl
  00f6a	03 45 e8	 add	 eax, DWORD PTR _hold$[ebp]
  00f6d	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  00f70	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  00f73	83 c1 01	 add	 ecx, 1
  00f76	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  00f79	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00f7c	83 c2 08	 add	 edx, 8
  00f7f	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00f82	33 c0		 xor	 eax, eax
  00f84	75 c5		 jne	 SHORT $LN160@inflate
  00f86	eb bd		 jmp	 SHORT $LN156@inflate
$LN153@inflate:
  00f88	33 c9		 xor	 ecx, ecx
  00f8a	75 b9		 jne	 SHORT $LN156@inflate

; 922  :             state->nlen = BITS(5) + 257;

  00f8c	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  00f8f	83 e2 1f	 and	 edx, 31			; 0000001fH
  00f92	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  00f98	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00f9b	89 50 64	 mov	 DWORD PTR [eax+100], edx
$LN163@inflate:

; 923  :             DROPBITS(5);

  00f9e	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00fa1	c1 e9 05	 shr	 ecx, 5
  00fa4	89 4d e8	 mov	 DWORD PTR _hold$[ebp], ecx
  00fa7	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  00faa	83 ea 05	 sub	 edx, 5
  00fad	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  00fb0	33 c0		 xor	 eax, eax
  00fb2	75 ea		 jne	 SHORT $LN163@inflate

; 924  :             state->ndist = BITS(5) + 1;

  00fb4	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00fb7	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00fba	83 c1 01	 add	 ecx, 1
  00fbd	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00fc0	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
$LN166@inflate:

; 925  :             DROPBITS(5);

  00fc3	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  00fc6	c1 e8 05	 shr	 eax, 5
  00fc9	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  00fcc	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  00fcf	83 e9 05	 sub	 ecx, 5
  00fd2	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  00fd5	33 d2		 xor	 edx, edx
  00fd7	75 ea		 jne	 SHORT $LN166@inflate

; 926  :             state->ncode = BITS(4) + 4;

  00fd9	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  00fdc	83 e0 0f	 and	 eax, 15			; 0000000fH
  00fdf	83 c0 04	 add	 eax, 4
  00fe2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00fe5	89 41 60	 mov	 DWORD PTR [ecx+96], eax
$LN169@inflate:

; 927  :             DROPBITS(4);

  00fe8	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  00feb	c1 ea 04	 shr	 edx, 4
  00fee	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  00ff1	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  00ff4	83 e8 04	 sub	 eax, 4
  00ff7	89 45 e4	 mov	 DWORD PTR _bits$[ebp], eax
  00ffa	33 c9		 xor	 ecx, ecx
  00ffc	75 ea		 jne	 SHORT $LN169@inflate

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  00ffe	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01001	81 7a 64 1e 01
	00 00		 cmp	 DWORD PTR [edx+100], 286 ; 0000011eH
  01008	77 09		 ja	 SHORT $LN426@inflate
  0100a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0100d	83 78 68 1e	 cmp	 DWORD PTR [eax+104], 30	; 0000001eH
  01011	76 19		 jbe	 SHORT $LN425@inflate
$LN426@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  01013	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01016	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@

; 931  :                 state->mode = BAD;

  0101d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01020	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 932  :                 break;

  01027	e9 76 0f 00 00	 jmp	 $LN8@inflate
$LN425@inflate:

; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  0102c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0102f	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0

; 937  :             state->mode = LENLENS;

  01036	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01039	c7 41 04 45 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16197 ; 00003f45H
$LN170@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  01040	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01043	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01046	8b 4a 6c	 mov	 ecx, DWORD PTR [edx+108]
  01049	3b 48 60	 cmp	 ecx, DWORD PTR [eax+96]
  0104c	0f 83 90 00 00
	00		 jae	 $LN183@inflate
$LN175@inflate:

; 940  :                 NEEDBITS(3);

  01052	83 7d e4 03	 cmp	 DWORD PTR _bits$[ebp], 3
  01056	73 3d		 jae	 SHORT $LN172@inflate
$LN179@inflate:
  01058	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0105c	75 05		 jne	 SHORT $LN428@inflate
  0105e	e9 44 0f 00 00	 jmp	 $inf_leave$566
$LN428@inflate:
  01063	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01066	83 ea 01	 sub	 edx, 1
  01069	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  0106c	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  0106f	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01072	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01075	d3 e2		 shl	 edx, cl
  01077	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  0107a	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  0107d	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  01080	83 c0 01	 add	 eax, 1
  01083	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  01086	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01089	83 c1 08	 add	 ecx, 8
  0108c	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0108f	33 d2		 xor	 edx, edx
  01091	75 c5		 jne	 SHORT $LN179@inflate
  01093	eb bd		 jmp	 SHORT $LN175@inflate
$LN172@inflate:
  01095	33 c0		 xor	 eax, eax
  01097	75 b9		 jne	 SHORT $LN175@inflate

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  01099	0f ae e8	 lfence
  0109c	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0109f	83 e1 07	 and	 ecx, 7
  010a2	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  010a5	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  010a8	0f b7 14 45 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  010b0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  010b3	66 89 4c 50 74	 mov	 WORD PTR [eax+edx*2+116], cx
  010b8	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  010bb	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  010be	83 c2 01	 add	 edx, 1
  010c1	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  010c4	89 50 6c	 mov	 DWORD PTR [eax+108], edx
$LN182@inflate:

; 942  :                 DROPBITS(3);

  010c7	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  010ca	c1 e9 03	 shr	 ecx, 3
  010cd	89 4d e8	 mov	 DWORD PTR _hold$[ebp], ecx
  010d0	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  010d3	83 ea 03	 sub	 edx, 3
  010d6	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  010d9	33 c0		 xor	 eax, eax
  010db	75 ea		 jne	 SHORT $LN182@inflate

; 943  :             }

  010dd	e9 5e ff ff ff	 jmp	 $LN170@inflate
$LN183@inflate:

; 944  :             while (state->have < 19)

  010e2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  010e5	83 79 6c 13	 cmp	 DWORD PTR [ecx+108], 19	; 00000013H
  010e9	73 29		 jae	 SHORT $LN184@inflate

; 945  :                 state->lens[order[state->have++]] = 0;

  010eb	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  010ee	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  010f1	0f b7 0c 45 00
	00 00 00	 movzx	 ecx, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  010f9	33 d2		 xor	 edx, edx
  010fb	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  010fe	66 89 54 48 74	 mov	 WORD PTR [eax+ecx*2+116], dx
  01103	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01106	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  01109	83 c2 01	 add	 edx, 1
  0110c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0110f	89 50 6c	 mov	 DWORD PTR [eax+108], edx
  01112	eb ce		 jmp	 SHORT $LN183@inflate
$LN184@inflate:

; 946  :             state->next = state->codes;

  01114	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01117	81 c1 34 05 00
	00		 add	 ecx, 1332		; 00000534H
  0111d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01120	89 4a 70	 mov	 DWORD PTR [edx+112], ecx

; 947  :             state->lencode = (const code FAR *)(state->next);

  01123	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01126	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01129	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  0112c	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 948  :             state->lenbits = 7;

  0112f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01132	c7 40 58 07 00
	00 00		 mov	 DWORD PTR [eax+88], 7

; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  01139	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0113c	81 c1 f4 02 00
	00		 add	 ecx, 756		; 000002f4H
  01142	51		 push	 ecx
  01143	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01146	83 c2 58	 add	 edx, 88			; 00000058H
  01149	52		 push	 edx
  0114a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0114d	83 c0 70	 add	 eax, 112		; 00000070H
  01150	50		 push	 eax
  01151	6a 13		 push	 19			; 00000013H
  01153	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01156	83 c1 74	 add	 ecx, 116		; 00000074H
  01159	51		 push	 ecx
  0115a	6a 00		 push	 0
  0115c	e8 00 00 00 00	 call	 _inflate_table
  01161	83 c4 18	 add	 esp, 24			; 00000018H
  01164	89 45 b4	 mov	 DWORD PTR _ret$[ebp], eax

; 950  :                                 &(state->lenbits), state->work);
; 951  :             if (ret) {

  01167	83 7d b4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0116b	74 19		 je	 SHORT $LN429@inflate

; 952  :                 strm->msg = (char *)"invalid code lengths set";

  0116d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01170	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@

; 953  :                 state->mode = BAD;

  01177	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0117a	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 954  :                 break;

  01181	e9 1c 0e 00 00	 jmp	 $LN8@inflate
$LN429@inflate:

; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  01186	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01189	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 958  :             state->mode = CODELENS;

  01190	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01193	c7 42 04 46 3f
	00 00		 mov	 DWORD PTR [edx+4], 16198 ; 00003f46H
$LN185@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  0119a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0119d	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  011a0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  011a3	03 4a 68	 add	 ecx, DWORD PTR [edx+104]
  011a6	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  011a9	39 48 6c	 cmp	 DWORD PTR [eax+108], ecx
  011ac	0f 83 27 03 00
	00		 jae	 $LN186@inflate
$LN189@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  011b2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  011b5	ba 01 00 00 00	 mov	 edx, 1
  011ba	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  011bd	d3 e2		 shl	 edx, cl
  011bf	83 ea 01	 sub	 edx, 1
  011c2	23 55 e8	 and	 edx, DWORD PTR _hold$[ebp]
  011c5	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  011c8	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  011cb	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  011ce	89 55 cc	 mov	 DWORD PTR _here$[ebp], edx

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  011d1	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  011d5	3b 45 e4	 cmp	 eax, DWORD PTR _bits$[ebp]
  011d8	77 02		 ja	 SHORT $LN192@inflate
  011da	eb 3d		 jmp	 SHORT $LN188@inflate
$LN192@inflate:

; 964  :                     PULLBYTE();

  011dc	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  011e0	75 05		 jne	 SHORT $LN432@inflate
  011e2	e9 c0 0d 00 00	 jmp	 $inf_leave$566
$LN432@inflate:
  011e7	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  011ea	83 e9 01	 sub	 ecx, 1
  011ed	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  011f0	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  011f3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  011f6	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  011f9	d3 e0		 shl	 eax, cl
  011fb	03 45 e8	 add	 eax, DWORD PTR _hold$[ebp]
  011fe	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  01201	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  01204	83 c1 01	 add	 ecx, 1
  01207	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  0120a	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  0120d	83 c2 08	 add	 edx, 8
  01210	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01213	33 c0		 xor	 eax, eax
  01215	75 c5		 jne	 SHORT $LN192@inflate

; 965  :                 }

  01217	eb 99		 jmp	 SHORT $LN189@inflate
$LN188@inflate:

; 966  :                 if (here.val < 16) {

  01219	0f b7 4d ce	 movzx	 ecx, WORD PTR _here$[ebp+2]
  0121d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  01220	7d 45		 jge	 SHORT $LN433@inflate
  01222	0f ae e8	 lfence
$LN195@inflate:

; 967  :                     DROPBITS(here.bits);

  01225	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01229	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  0122c	d3 ea		 shr	 edx, cl
  0122e	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  01231	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01235	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01238	2b c8		 sub	 ecx, eax
  0123a	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0123d	33 d2		 xor	 edx, edx
  0123f	75 e4		 jne	 SHORT $LN195@inflate

; 968  :                     state->lens[state->have++] = here.val;

  01241	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01244	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  01247	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0124a	66 8b 45 ce	 mov	 ax, WORD PTR _here$[ebp+2]
  0124e	66 89 44 4a 74	 mov	 WORD PTR [edx+ecx*2+116], ax
  01253	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01256	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  01259	83 c2 01	 add	 edx, 1
  0125c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0125f	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 969  :                 }

  01262	e9 6d 02 00 00	 jmp	 $LN434@inflate
$LN433@inflate:

; 970  :                 else {
; 971  :                     if (here.val == 16) {

  01267	0f b7 4d ce	 movzx	 ecx, WORD PTR _here$[ebp+2]
  0126b	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0126e	0f 85 c3 00 00
	00		 jne	 $LN435@inflate
$LN199@inflate:

; 972  :                         NEEDBITS(here.bits + 2);

  01274	0f b6 55 cd	 movzx	 edx, BYTE PTR _here$[ebp+1]
  01278	83 c2 02	 add	 edx, 2
  0127b	39 55 e4	 cmp	 DWORD PTR _bits$[ebp], edx
  0127e	73 3d		 jae	 SHORT $LN196@inflate
$LN203@inflate:
  01280	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01284	75 05		 jne	 SHORT $LN437@inflate
  01286	e9 1c 0d 00 00	 jmp	 $inf_leave$566
$LN437@inflate:
  0128b	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  0128e	83 e8 01	 sub	 eax, 1
  01291	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01294	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  01297	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0129a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0129d	d3 e2		 shl	 edx, cl
  0129f	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  012a2	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  012a5	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  012a8	83 c0 01	 add	 eax, 1
  012ab	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  012ae	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  012b1	83 c1 08	 add	 ecx, 8
  012b4	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  012b7	33 d2		 xor	 edx, edx
  012b9	75 c5		 jne	 SHORT $LN203@inflate
  012bb	eb b7		 jmp	 SHORT $LN199@inflate
$LN196@inflate:
  012bd	33 c0		 xor	 eax, eax
  012bf	75 b3		 jne	 SHORT $LN199@inflate
$LN206@inflate:

; 973  :                         DROPBITS(here.bits);

  012c1	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  012c5	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  012c8	d3 ea		 shr	 edx, cl
  012ca	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  012cd	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  012d1	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  012d4	2b c8		 sub	 ecx, eax
  012d6	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  012d9	33 d2		 xor	 edx, edx
  012db	75 e4		 jne	 SHORT $LN206@inflate

; 974  :                         if (state->have == 0) {

  012dd	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  012e0	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  012e4	75 19		 jne	 SHORT $LN438@inflate

; 975  :                             strm->msg = (char *)"invalid bit length repeat";

  012e6	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  012e9	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@

; 976  :                             state->mode = BAD;

  012f0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  012f3	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 977  :                             break;

  012fa	e9 da 01 00 00	 jmp	 $LN186@inflate
$LN438@inflate:

; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];

  012ff	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01302	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  01305	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01308	0f b7 44 4a 72	 movzx	 eax, WORD PTR [edx+ecx*2+114]
  0130d	89 45 b8	 mov	 DWORD PTR _len$[ebp], eax

; 980  :                         copy = 3 + BITS(2);

  01310	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  01313	83 e1 03	 and	 ecx, 3
  01316	83 c1 03	 add	 ecx, 3
  01319	89 4d d8	 mov	 DWORD PTR _copy$[ebp], ecx
$LN209@inflate:

; 981  :                         DROPBITS(2);

  0131c	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  0131f	c1 ea 02	 shr	 edx, 2
  01322	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  01325	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  01328	83 e8 02	 sub	 eax, 2
  0132b	89 45 e4	 mov	 DWORD PTR _bits$[ebp], eax
  0132e	33 c9		 xor	 ecx, ecx
  01330	75 ea		 jne	 SHORT $LN209@inflate

; 982  :                     }

  01332	e9 36 01 00 00	 jmp	 $LN436@inflate
$LN435@inflate:

; 983  :                     else if (here.val == 17) {

  01337	0f b7 55 ce	 movzx	 edx, WORD PTR _here$[ebp+2]
  0133b	83 fa 11	 cmp	 edx, 17			; 00000011H
  0133e	0f 85 97 00 00
	00		 jne	 $LN227@inflate
$LN213@inflate:

; 984  :                         NEEDBITS(here.bits + 3);

  01344	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01348	83 c0 03	 add	 eax, 3
  0134b	39 45 e4	 cmp	 DWORD PTR _bits$[ebp], eax
  0134e	73 3d		 jae	 SHORT $LN210@inflate
$LN217@inflate:
  01350	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01354	75 05		 jne	 SHORT $LN441@inflate
  01356	e9 4c 0c 00 00	 jmp	 $inf_leave$566
$LN441@inflate:
  0135b	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  0135e	83 e9 01	 sub	 ecx, 1
  01361	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01364	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  01367	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0136a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0136d	d3 e0		 shl	 eax, cl
  0136f	03 45 e8	 add	 eax, DWORD PTR _hold$[ebp]
  01372	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  01375	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  01378	83 c1 01	 add	 ecx, 1
  0137b	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  0137e	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01381	83 c2 08	 add	 edx, 8
  01384	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01387	33 c0		 xor	 eax, eax
  01389	75 c5		 jne	 SHORT $LN217@inflate
  0138b	eb b7		 jmp	 SHORT $LN213@inflate
$LN210@inflate:
  0138d	33 c9		 xor	 ecx, ecx
  0138f	75 b3		 jne	 SHORT $LN213@inflate
$LN220@inflate:

; 985  :                         DROPBITS(here.bits);

  01391	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01395	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  01398	d3 ea		 shr	 edx, cl
  0139a	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  0139d	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  013a1	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  013a4	2b c8		 sub	 ecx, eax
  013a6	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  013a9	33 d2		 xor	 edx, edx
  013ab	75 e4		 jne	 SHORT $LN220@inflate

; 986  :                         len = 0;

  013ad	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 987  :                         copy = 3 + BITS(3);

  013b4	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  013b7	83 e0 07	 and	 eax, 7
  013ba	83 c0 03	 add	 eax, 3
  013bd	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax
$LN223@inflate:

; 988  :                         DROPBITS(3);

  013c0	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  013c3	c1 e9 03	 shr	 ecx, 3
  013c6	89 4d e8	 mov	 DWORD PTR _hold$[ebp], ecx
  013c9	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  013cc	83 ea 03	 sub	 edx, 3
  013cf	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  013d2	33 c0		 xor	 eax, eax
  013d4	75 ea		 jne	 SHORT $LN223@inflate

; 989  :                     }

  013d6	e9 92 00 00 00	 jmp	 $LN436@inflate
$LN227@inflate:

; 990  :                     else {
; 991  :                         NEEDBITS(here.bits + 7);

  013db	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  013df	83 c1 07	 add	 ecx, 7
  013e2	39 4d e4	 cmp	 DWORD PTR _bits$[ebp], ecx
  013e5	73 3d		 jae	 SHORT $LN224@inflate
$LN231@inflate:
  013e7	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  013eb	75 05		 jne	 SHORT $LN442@inflate
  013ed	e9 b5 0b 00 00	 jmp	 $inf_leave$566
$LN442@inflate:
  013f2	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  013f5	83 ea 01	 sub	 edx, 1
  013f8	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  013fb	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  013fe	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01401	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01404	d3 e2		 shl	 edx, cl
  01406	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  01409	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  0140c	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  0140f	83 c0 01	 add	 eax, 1
  01412	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  01415	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01418	83 c1 08	 add	 ecx, 8
  0141b	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0141e	33 d2		 xor	 edx, edx
  01420	75 c5		 jne	 SHORT $LN231@inflate
  01422	eb b7		 jmp	 SHORT $LN227@inflate
$LN224@inflate:
  01424	33 c0		 xor	 eax, eax
  01426	75 b3		 jne	 SHORT $LN227@inflate
$LN234@inflate:

; 992  :                         DROPBITS(here.bits);

  01428	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  0142c	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  0142f	d3 ea		 shr	 edx, cl
  01431	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  01434	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01438	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0143b	2b c8		 sub	 ecx, eax
  0143d	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01440	33 d2		 xor	 edx, edx
  01442	75 e4		 jne	 SHORT $LN234@inflate

; 993  :                         len = 0;

  01444	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 994  :                         copy = 11 + BITS(7);

  0144b	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  0144e	83 e0 7f	 and	 eax, 127		; 0000007fH
  01451	83 c0 0b	 add	 eax, 11			; 0000000bH
  01454	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax
$LN237@inflate:

; 995  :                         DROPBITS(7);

  01457	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0145a	c1 e9 07	 shr	 ecx, 7
  0145d	89 4d e8	 mov	 DWORD PTR _hold$[ebp], ecx
  01460	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01463	83 ea 07	 sub	 edx, 7
  01466	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01469	33 c0		 xor	 eax, eax
  0146b	75 ea		 jne	 SHORT $LN237@inflate
$LN436@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  0146d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01470	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  01473	03 55 d8	 add	 edx, DWORD PTR _copy$[ebp]
  01476	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01479	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0147c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0147f	03 48 68	 add	 ecx, DWORD PTR [eax+104]
  01482	3b d1		 cmp	 edx, ecx
  01484	76 16		 jbe	 SHORT $LN238@inflate

; 998  :                         strm->msg = (char *)"invalid bit length repeat";

  01486	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01489	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@

; 999  :                         state->mode = BAD;

  01490	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01493	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 1000 :                         break;

  0149a	eb 3d		 jmp	 SHORT $LN186@inflate
$LN238@inflate:

; 1001 :                     }
; 1002 :                     while (copy--)

  0149c	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  0149f	89 45 84	 mov	 DWORD PTR tv908[ebp], eax
  014a2	8b 4d d8	 mov	 ecx, DWORD PTR _copy$[ebp]
  014a5	83 e9 01	 sub	 ecx, 1
  014a8	89 4d d8	 mov	 DWORD PTR _copy$[ebp], ecx
  014ab	83 7d 84 00	 cmp	 DWORD PTR tv908[ebp], 0
  014af	74 23		 je	 SHORT $LN434@inflate

; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  014b1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  014b4	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  014b7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  014ba	66 8b 55 b8	 mov	 dx, WORD PTR _len$[ebp]
  014be	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  014c3	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  014c6	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  014c9	83 c1 01	 add	 ecx, 1
  014cc	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  014cf	89 4a 6c	 mov	 DWORD PTR [edx+108], ecx
  014d2	eb c8		 jmp	 SHORT $LN238@inflate
$LN434@inflate:

; 1004 :                 }
; 1005 :             }

  014d4	e9 c1 fc ff ff	 jmp	 $LN185@inflate
$LN186@inflate:

; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  014d9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  014dc	81 78 04 51 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16209 ; 00003f51H
  014e3	75 05		 jne	 SHORT $LN444@inflate
  014e5	e9 b8 0a 00 00	 jmp	 $LN8@inflate
$LN444@inflate:

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  014ea	b9 02 00 00 00	 mov	 ecx, 2
  014ef	c1 e1 08	 shl	 ecx, 8
  014f2	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  014f5	0f b7 44 0a 74	 movzx	 eax, WORD PTR [edx+ecx+116]
  014fa	85 c0		 test	 eax, eax
  014fc	75 19		 jne	 SHORT $LN445@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  014fe	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01501	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@

; 1013 :                 state->mode = BAD;

  01508	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0150b	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 1014 :                 break;

  01512	e9 8b 0a 00 00	 jmp	 $LN8@inflate
$LN445@inflate:

; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  01517	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0151a	05 34 05 00 00	 add	 eax, 1332		; 00000534H
  0151f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01522	89 41 70	 mov	 DWORD PTR [ecx+112], eax

; 1021 :             state->lencode = (const code FAR *)(state->next);

  01525	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01528	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0152b	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  0152e	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 1022 :             state->lenbits = 9;

  01531	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01534	c7 42 58 09 00
	00 00		 mov	 DWORD PTR [edx+88], 9

; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  0153b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0153e	05 f4 02 00 00	 add	 eax, 756		; 000002f4H
  01543	50		 push	 eax
  01544	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01547	83 c1 58	 add	 ecx, 88			; 00000058H
  0154a	51		 push	 ecx
  0154b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0154e	83 c2 70	 add	 edx, 112		; 00000070H
  01551	52		 push	 edx
  01552	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01555	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  01558	51		 push	 ecx
  01559	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0155c	83 c2 74	 add	 edx, 116		; 00000074H
  0155f	52		 push	 edx
  01560	6a 01		 push	 1
  01562	e8 00 00 00 00	 call	 _inflate_table
  01567	83 c4 18	 add	 esp, 24			; 00000018H
  0156a	89 45 b4	 mov	 DWORD PTR _ret$[ebp], eax

; 1024 :                                 &(state->lenbits), state->work);
; 1025 :             if (ret) {

  0156d	83 7d b4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  01571	74 19		 je	 SHORT $LN446@inflate

; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  01573	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01576	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@

; 1027 :                 state->mode = BAD;

  0157d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01580	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 1028 :                 break;

  01587	e9 16 0a 00 00	 jmp	 $LN8@inflate
$LN446@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  0158c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0158f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01592	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  01595	89 4a 54	 mov	 DWORD PTR [edx+84], ecx

; 1031 :             state->distbits = 6;

  01598	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0159b	c7 42 5c 06 00
	00 00		 mov	 DWORD PTR [edx+92], 6

; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  015a2	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  015a5	05 f4 02 00 00	 add	 eax, 756		; 000002f4H
  015aa	50		 push	 eax
  015ab	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  015ae	83 c1 5c	 add	 ecx, 92			; 0000005cH
  015b1	51		 push	 ecx
  015b2	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  015b5	83 c2 70	 add	 edx, 112		; 00000070H
  015b8	52		 push	 edx
  015b9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  015bc	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  015bf	51		 push	 ecx
  015c0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  015c3	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  015c6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  015c9	8d 54 41 74	 lea	 edx, DWORD PTR [ecx+eax*2+116]
  015cd	52		 push	 edx
  015ce	6a 02		 push	 2
  015d0	e8 00 00 00 00	 call	 _inflate_table
  015d5	83 c4 18	 add	 esp, 24			; 00000018H
  015d8	89 45 b4	 mov	 DWORD PTR _ret$[ebp], eax

; 1033 :                             &(state->next), &(state->distbits), state->work);
; 1034 :             if (ret) {

  015db	83 7d b4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  015df	74 19		 je	 SHORT $LN447@inflate

; 1035 :                 strm->msg = (char *)"invalid distances set";

  015e1	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  015e4	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@

; 1036 :                 state->mode = BAD;

  015eb	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  015ee	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 1037 :                 break;

  015f5	e9 a8 09 00 00	 jmp	 $LN8@inflate
$LN447@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;

  015fa	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  015fd	c7 42 04 47 3f
	00 00		 mov	 DWORD PTR [edx+4], 16199 ; 00003f47H

; 1041 :             if (flush == Z_TREES) goto inf_leave;

  01604	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  01608	75 05		 jne	 SHORT $LN449@inflate
  0160a	e9 98 09 00 00	 jmp	 $inf_leave$566
$LN449@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  0160f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01612	c7 40 04 48 3f
	00 00		 mov	 DWORD PTR [eax+4], 16200 ; 00003f48H
$LN450@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  01619	83 7d f0 06	 cmp	 DWORD PTR _have$[ebp], 6
  0161d	0f 82 b0 00 00
	00		 jb	 $LN451@inflate
  01623	81 7d ec 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  0162a	0f 82 a3 00 00
	00		 jb	 $LN451@inflate
  01630	0f ae e8	 lfence
$LN242@inflate:

; 1046 :                 RESTORE();

  01633	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01636	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  01639	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  0163c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0163f	8b 4d ec	 mov	 ecx, DWORD PTR _left$[ebp]
  01642	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01645	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01648	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  0164b	89 02		 mov	 DWORD PTR [edx], eax
  0164d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01650	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01653	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01656	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01659	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0165c	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  0165f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01662	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  01665	89 42 40	 mov	 DWORD PTR [edx+64], eax
  01668	33 c9		 xor	 ecx, ecx
  0166a	75 c7		 jne	 SHORT $LN242@inflate

; 1047 :                 inflate_fast(strm, out);

  0166c	8b 55 dc	 mov	 edx, DWORD PTR _out$[ebp]
  0166f	52		 push	 edx
  01670	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01673	50		 push	 eax
  01674	e8 00 00 00 00	 call	 _inflate_fast
  01679	83 c4 08	 add	 esp, 8
$LN245@inflate:

; 1048 :                 LOAD();

  0167c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0167f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01682	89 55 f4	 mov	 DWORD PTR _put$[ebp], edx
  01685	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01688	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0168b	89 4d ec	 mov	 DWORD PTR _left$[ebp], ecx
  0168e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01691	8b 02		 mov	 eax, DWORD PTR [edx]
  01693	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  01696	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01699	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0169c	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  0169f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  016a2	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  016a5	89 4d e8	 mov	 DWORD PTR _hold$[ebp], ecx
  016a8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  016ab	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  016ae	89 45 e4	 mov	 DWORD PTR _bits$[ebp], eax
  016b1	33 c9		 xor	 ecx, ecx
  016b3	75 c7		 jne	 SHORT $LN245@inflate

; 1049 :                 if (state->mode == TYPE)

  016b5	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  016b8	81 7a 04 3f 3f
	00 00		 cmp	 DWORD PTR [edx+4], 16191 ; 00003f3fH
  016bf	75 0d		 jne	 SHORT $LN452@inflate

; 1050 :                     state->back = -1;

  016c1	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  016c4	c7 80 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+7112], -1
$LN452@inflate:

; 1051 :                 break;

  016ce	e9 cf 08 00 00	 jmp	 $LN8@inflate
$LN451@inflate:

; 1052 :             }
; 1053 :             state->back = 0;

  016d3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  016d6	c7 81 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7112], 0
$LN248@inflate:

; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  016e0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  016e3	b8 01 00 00 00	 mov	 eax, 1
  016e8	8b 4a 58	 mov	 ecx, DWORD PTR [edx+88]
  016eb	d3 e0		 shl	 eax, cl
  016ed	83 e8 01	 sub	 eax, 1
  016f0	23 45 e8	 and	 eax, DWORD PTR _hold$[ebp]
  016f3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  016f6	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  016f9	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  016fc	89 45 cc	 mov	 DWORD PTR _here$[ebp], eax

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  016ff	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01703	3b 4d e4	 cmp	 ecx, DWORD PTR _bits$[ebp]
  01706	77 02		 ja	 SHORT $LN251@inflate
  01708	eb 3d		 jmp	 SHORT $LN247@inflate
$LN251@inflate:

; 1057 :                 PULLBYTE();

  0170a	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  0170e	75 05		 jne	 SHORT $LN454@inflate
  01710	e9 92 08 00 00	 jmp	 $inf_leave$566
$LN454@inflate:
  01715	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01718	83 ea 01	 sub	 edx, 1
  0171b	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  0171e	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  01721	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01724	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01727	d3 e2		 shl	 edx, cl
  01729	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  0172c	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  0172f	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  01732	83 c0 01	 add	 eax, 1
  01735	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  01738	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0173b	83 c1 08	 add	 ecx, 8
  0173e	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01741	33 d2		 xor	 edx, edx
  01743	75 c5		 jne	 SHORT $LN251@inflate

; 1058 :             }

  01745	eb 99		 jmp	 SHORT $LN248@inflate
$LN247@inflate:

; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  01747	0f b6 45 cc	 movzx	 eax, BYTE PTR _here$[ebp]
  0174b	85 c0		 test	 eax, eax
  0174d	0f 84 c8 00 00
	00		 je	 $LN263@inflate
  01753	0f b6 4d cc	 movzx	 ecx, BYTE PTR _here$[ebp]
  01757	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  0175d	0f 85 b8 00 00
	00		 jne	 $LN263@inflate

; 1060 :                 last = here;

  01763	0f ae e8	 lfence
  01766	8b 55 cc	 mov	 edx, DWORD PTR _here$[ebp]
  01769	89 55 c0	 mov	 DWORD PTR _last$[ebp], edx
$LN254@inflate:

; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +

  0176c	0f b7 45 c2	 movzx	 eax, WORD PTR _last$[ebp+2]
  01770	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01774	0f b6 55 c0	 movzx	 edx, BYTE PTR _last$[ebp]
  01778	03 ca		 add	 ecx, edx
  0177a	ba 01 00 00 00	 mov	 edx, 1
  0177f	d3 e2		 shl	 edx, cl
  01781	83 ea 01	 sub	 edx, 1
  01784	23 55 e8	 and	 edx, DWORD PTR _hold$[ebp]
  01787	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0178b	d3 ea		 shr	 edx, cl
  0178d	03 c2		 add	 eax, edx
  0178f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01792	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  01795	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  01798	89 45 cc	 mov	 DWORD PTR _here$[ebp], eax

; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0179b	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0179f	0f b6 55 cd	 movzx	 edx, BYTE PTR _here$[ebp+1]
  017a3	03 ca		 add	 ecx, edx
  017a5	3b 4d e4	 cmp	 ecx, DWORD PTR _bits$[ebp]
  017a8	77 02		 ja	 SHORT $LN257@inflate
  017aa	eb 3d		 jmp	 SHORT $LN260@inflate
$LN257@inflate:

; 1065 :                     PULLBYTE();

  017ac	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  017b0	75 05		 jne	 SHORT $LN457@inflate
  017b2	e9 f0 07 00 00	 jmp	 $inf_leave$566
$LN457@inflate:
  017b7	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  017ba	83 e8 01	 sub	 eax, 1
  017bd	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  017c0	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  017c3	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  017c6	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  017c9	d3 e2		 shl	 edx, cl
  017cb	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  017ce	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  017d1	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  017d4	83 c0 01	 add	 eax, 1
  017d7	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  017da	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  017dd	83 c1 08	 add	 ecx, 8
  017e0	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  017e3	33 d2		 xor	 edx, edx
  017e5	75 c5		 jne	 SHORT $LN257@inflate

; 1066 :                 }

  017e7	eb 83		 jmp	 SHORT $LN254@inflate
$LN260@inflate:

; 1067 :                 DROPBITS(last.bits);

  017e9	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  017ed	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  017f0	d3 e8		 shr	 eax, cl
  017f2	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  017f5	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  017f9	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  017fc	2b d1		 sub	 edx, ecx
  017fe	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01801	33 c0		 xor	 eax, eax
  01803	75 e4		 jne	 SHORT $LN260@inflate

; 1068 :                 state->back += last.bits;

  01805	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01809	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0180c	03 8a c8 1b 00
	00		 add	 ecx, DWORD PTR [edx+7112]
  01812	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01815	89 88 c8 1b 00
	00		 mov	 DWORD PTR [eax+7112], ecx
$LN263@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);

  0181b	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  0181f	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  01822	d3 ea		 shr	 edx, cl
  01824	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  01827	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0182b	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  0182e	2b c8		 sub	 ecx, eax
  01830	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01833	33 d2		 xor	 edx, edx
  01835	75 e4		 jne	 SHORT $LN263@inflate

; 1071 :             state->back += here.bits;

  01837	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  0183b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0183e	03 81 c8 1b 00
	00		 add	 eax, DWORD PTR [ecx+7112]
  01844	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01847	89 82 c8 1b 00
	00		 mov	 DWORD PTR [edx+7112], eax

; 1072 :             state->length = (unsigned)here.val;

  0184d	0f b7 45 ce	 movzx	 eax, WORD PTR _here$[ebp+2]
  01851	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01854	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 1073 :             if ((int)(here.op) == 0) {

  01857	0f b6 55 cc	 movzx	 edx, BYTE PTR _here$[ebp]
  0185b	85 d2		 test	 edx, edx
  0185d	75 0f		 jne	 SHORT $LN458@inflate

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  0185f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01862	c7 40 04 4d 3f
	00 00		 mov	 DWORD PTR [eax+4], 16205 ; 00003f4dH

; 1078 :                 break;

  01869	e9 34 07 00 00	 jmp	 $LN8@inflate
$LN458@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  0186e	0f b6 4d cc	 movzx	 ecx, BYTE PTR _here$[ebp]
  01872	83 e1 20	 and	 ecx, 32			; 00000020H
  01875	74 1c		 je	 SHORT $LN459@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  01877	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0187a	c7 82 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+7112], -1

; 1083 :                 state->mode = TYPE;

  01884	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01887	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 1084 :                 break;

  0188e	e9 0f 07 00 00	 jmp	 $LN8@inflate
$LN459@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  01893	0f b6 4d cc	 movzx	 ecx, BYTE PTR _here$[ebp]
  01897	83 e1 40	 and	 ecx, 64			; 00000040H
  0189a	74 19		 je	 SHORT $LN460@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  0189c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0189f	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 1088 :                 state->mode = BAD;

  018a6	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  018a9	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 1089 :                 break;

  018b0	e9 ed 06 00 00	 jmp	 $LN8@inflate
$LN460@inflate:

; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  018b5	0f b6 4d cc	 movzx	 ecx, BYTE PTR _here$[ebp]
  018b9	83 e1 0f	 and	 ecx, 15			; 0000000fH
  018bc	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  018bf	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 1092 :             state->mode = LENEXT;

  018c2	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  018c5	c7 40 04 49 3f
	00 00		 mov	 DWORD PTR [eax+4], 16201 ; 00003f49H
$LN461@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  018cc	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  018cf	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  018d3	0f 84 a1 00 00
	00		 je	 $LN462@inflate
$LN267@inflate:

; 1095 :                 NEEDBITS(state->extra);

  018d9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  018dc	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  018df	3b 42 4c	 cmp	 eax, DWORD PTR [edx+76]
  018e2	73 3d		 jae	 SHORT $LN264@inflate
$LN271@inflate:
  018e4	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  018e8	75 05		 jne	 SHORT $LN463@inflate
  018ea	e9 b8 06 00 00	 jmp	 $inf_leave$566
$LN463@inflate:
  018ef	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  018f2	83 e9 01	 sub	 ecx, 1
  018f5	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  018f8	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  018fb	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  018fe	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01901	d3 e0		 shl	 eax, cl
  01903	03 45 e8	 add	 eax, DWORD PTR _hold$[ebp]
  01906	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  01909	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  0190c	83 c1 01	 add	 ecx, 1
  0190f	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  01912	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01915	83 c2 08	 add	 edx, 8
  01918	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  0191b	33 c0		 xor	 eax, eax
  0191d	75 c5		 jne	 SHORT $LN271@inflate
  0191f	eb b8		 jmp	 SHORT $LN267@inflate
$LN264@inflate:
  01921	33 c9		 xor	 ecx, ecx
  01923	75 b4		 jne	 SHORT $LN267@inflate

; 1096 :                 state->length += BITS(state->extra);

  01925	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01928	b8 01 00 00 00	 mov	 eax, 1
  0192d	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  01930	d3 e0		 shl	 eax, cl
  01932	83 e8 01	 sub	 eax, 1
  01935	23 45 e8	 and	 eax, DWORD PTR _hold$[ebp]
  01938	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0193b	03 41 44	 add	 eax, DWORD PTR [ecx+68]
  0193e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01941	89 42 44	 mov	 DWORD PTR [edx+68], eax
$LN274@inflate:

; 1097 :                 DROPBITS(state->extra);

  01944	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01947	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  0194a	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0194d	d3 ea		 shr	 edx, cl
  0194f	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  01952	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01955	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01958	2b 48 4c	 sub	 ecx, DWORD PTR [eax+76]
  0195b	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  0195e	33 d2		 xor	 edx, edx
  01960	75 e2		 jne	 SHORT $LN274@inflate

; 1098 :                 state->back += state->extra;

  01962	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01965	8b 88 c8 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7112]
  0196b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0196e	03 4a 4c	 add	 ecx, DWORD PTR [edx+76]
  01971	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01974	89 88 c8 1b 00
	00		 mov	 DWORD PTR [eax+7112], ecx
$LN462@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  0197a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0197d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01980	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  01983	89 81 cc 1b 00
	00		 mov	 DWORD PTR [ecx+7116], eax

; 1102 :             state->mode = DIST;

  01989	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0198c	c7 41 04 4a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16202 ; 00003f4aH
$LN277@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  01993	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01996	b8 01 00 00 00	 mov	 eax, 1
  0199b	8b 4a 5c	 mov	 ecx, DWORD PTR [edx+92]
  0199e	d3 e0		 shl	 eax, cl
  019a0	83 e8 01	 sub	 eax, 1
  019a3	23 45 e8	 and	 eax, DWORD PTR _hold$[ebp]
  019a6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  019a9	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  019ac	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  019af	89 45 cc	 mov	 DWORD PTR _here$[ebp], eax

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  019b2	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  019b6	3b 4d e4	 cmp	 ecx, DWORD PTR _bits$[ebp]
  019b9	77 02		 ja	 SHORT $LN280@inflate
  019bb	eb 3d		 jmp	 SHORT $LN276@inflate
$LN280@inflate:

; 1107 :                 PULLBYTE();

  019bd	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  019c1	75 05		 jne	 SHORT $LN466@inflate
  019c3	e9 df 05 00 00	 jmp	 $inf_leave$566
$LN466@inflate:
  019c8	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  019cb	83 ea 01	 sub	 edx, 1
  019ce	89 55 f0	 mov	 DWORD PTR _have$[ebp], edx
  019d1	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  019d4	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  019d7	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  019da	d3 e2		 shl	 edx, cl
  019dc	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  019df	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  019e2	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  019e5	83 c0 01	 add	 eax, 1
  019e8	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  019eb	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  019ee	83 c1 08	 add	 ecx, 8
  019f1	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  019f4	33 d2		 xor	 edx, edx
  019f6	75 c5		 jne	 SHORT $LN280@inflate

; 1108 :             }

  019f8	eb 99		 jmp	 SHORT $LN277@inflate
$LN276@inflate:

; 1109 :             if ((here.op & 0xf0) == 0) {

  019fa	0f b6 45 cc	 movzx	 eax, BYTE PTR _here$[ebp]
  019fe	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01a03	0f 85 b8 00 00
	00		 jne	 $LN292@inflate

; 1110 :                 last = here;

  01a09	0f ae e8	 lfence
  01a0c	8b 4d cc	 mov	 ecx, DWORD PTR _here$[ebp]
  01a0f	89 4d c0	 mov	 DWORD PTR _last$[ebp], ecx
$LN283@inflate:

; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +

  01a12	0f b7 55 c2	 movzx	 edx, WORD PTR _last$[ebp+2]
  01a16	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01a1a	0f b6 45 c0	 movzx	 eax, BYTE PTR _last$[ebp]
  01a1e	03 c8		 add	 ecx, eax
  01a20	b8 01 00 00 00	 mov	 eax, 1
  01a25	d3 e0		 shl	 eax, cl
  01a27	83 e8 01	 sub	 eax, 1
  01a2a	23 45 e8	 and	 eax, DWORD PTR _hold$[ebp]
  01a2d	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01a31	d3 e8		 shr	 eax, cl
  01a33	03 d0		 add	 edx, eax
  01a35	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01a38	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  01a3b	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  01a3e	89 4d cc	 mov	 DWORD PTR _here$[ebp], ecx

; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01a41	0f b6 55 c1	 movzx	 edx, BYTE PTR _last$[ebp+1]
  01a45	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01a49	03 d0		 add	 edx, eax
  01a4b	3b 55 e4	 cmp	 edx, DWORD PTR _bits$[ebp]
  01a4e	77 02		 ja	 SHORT $LN286@inflate
  01a50	eb 3d		 jmp	 SHORT $LN289@inflate
$LN286@inflate:

; 1115 :                     PULLBYTE();

  01a52	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01a56	75 05		 jne	 SHORT $LN469@inflate
  01a58	e9 4a 05 00 00	 jmp	 $inf_leave$566
$LN469@inflate:
  01a5d	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01a60	83 e9 01	 sub	 ecx, 1
  01a63	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01a66	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  01a69	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01a6c	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01a6f	d3 e0		 shl	 eax, cl
  01a71	03 45 e8	 add	 eax, DWORD PTR _hold$[ebp]
  01a74	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  01a77	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  01a7a	83 c1 01	 add	 ecx, 1
  01a7d	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  01a80	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01a83	83 c2 08	 add	 edx, 8
  01a86	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01a89	33 c0		 xor	 eax, eax
  01a8b	75 c5		 jne	 SHORT $LN286@inflate

; 1116 :                 }

  01a8d	eb 83		 jmp	 SHORT $LN283@inflate
$LN289@inflate:

; 1117 :                 DROPBITS(last.bits);

  01a8f	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01a93	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  01a96	d3 ea		 shr	 edx, cl
  01a98	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  01a9b	0f b6 45 c1	 movzx	 eax, BYTE PTR _last$[ebp+1]
  01a9f	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01aa2	2b c8		 sub	 ecx, eax
  01aa4	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01aa7	33 d2		 xor	 edx, edx
  01aa9	75 e4		 jne	 SHORT $LN289@inflate

; 1118 :                 state->back += last.bits;

  01aab	0f b6 45 c1	 movzx	 eax, BYTE PTR _last$[ebp+1]
  01aaf	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01ab2	03 81 c8 1b 00
	00		 add	 eax, DWORD PTR [ecx+7112]
  01ab8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01abb	89 82 c8 1b 00
	00		 mov	 DWORD PTR [edx+7112], eax
$LN292@inflate:

; 1119 :             }
; 1120 :             DROPBITS(here.bits);

  01ac1	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01ac5	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  01ac8	d3 e8		 shr	 eax, cl
  01aca	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  01acd	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01ad1	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01ad4	2b d1		 sub	 edx, ecx
  01ad6	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01ad9	33 c0		 xor	 eax, eax
  01adb	75 e4		 jne	 SHORT $LN292@inflate

; 1121 :             state->back += here.bits;

  01add	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01ae1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01ae4	03 8a c8 1b 00
	00		 add	 ecx, DWORD PTR [edx+7112]
  01aea	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01aed	89 88 c8 1b 00
	00		 mov	 DWORD PTR [eax+7112], ecx

; 1122 :             if (here.op & 64) {

  01af3	0f b6 4d cc	 movzx	 ecx, BYTE PTR _here$[ebp]
  01af7	83 e1 40	 and	 ecx, 64			; 00000040H
  01afa	74 19		 je	 SHORT $LN470@inflate

; 1123 :                 strm->msg = (char *)"invalid distance code";

  01afc	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01aff	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@

; 1124 :                 state->mode = BAD;

  01b06	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01b09	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 1125 :                 break;

  01b10	e9 8d 04 00 00	 jmp	 $LN8@inflate
$LN470@inflate:

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  01b15	0f b7 4d ce	 movzx	 ecx, WORD PTR _here$[ebp+2]
  01b19	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01b1c	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  01b1f	0f b6 45 cc	 movzx	 eax, BYTE PTR _here$[ebp]
  01b23	83 e0 0f	 and	 eax, 15			; 0000000fH
  01b26	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01b29	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1129 :             state->mode = DISTEXT;

  01b2c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01b2f	c7 42 04 4b 3f
	00 00		 mov	 DWORD PTR [edx+4], 16203 ; 00003f4bH
$LN471@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  01b36	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01b39	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  01b3d	0f 84 a1 00 00
	00		 je	 $LN472@inflate
$LN296@inflate:

; 1132 :                 NEEDBITS(state->extra);

  01b43	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01b46	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01b49	3b 51 4c	 cmp	 edx, DWORD PTR [ecx+76]
  01b4c	73 3d		 jae	 SHORT $LN293@inflate
$LN300@inflate:
  01b4e	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01b52	75 05		 jne	 SHORT $LN473@inflate
  01b54	e9 4e 04 00 00	 jmp	 $inf_leave$566
$LN473@inflate:
  01b59	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  01b5c	83 e8 01	 sub	 eax, 1
  01b5f	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01b62	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  01b65	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  01b68	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01b6b	d3 e2		 shl	 edx, cl
  01b6d	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  01b70	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  01b73	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  01b76	83 c0 01	 add	 eax, 1
  01b79	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  01b7c	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01b7f	83 c1 08	 add	 ecx, 8
  01b82	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01b85	33 d2		 xor	 edx, edx
  01b87	75 c5		 jne	 SHORT $LN300@inflate
  01b89	eb b8		 jmp	 SHORT $LN296@inflate
$LN293@inflate:
  01b8b	33 c0		 xor	 eax, eax
  01b8d	75 b4		 jne	 SHORT $LN296@inflate

; 1133 :                 state->offset += BITS(state->extra);

  01b8f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01b92	ba 01 00 00 00	 mov	 edx, 1
  01b97	8b 49 4c	 mov	 ecx, DWORD PTR [ecx+76]
  01b9a	d3 e2		 shl	 edx, cl
  01b9c	83 ea 01	 sub	 edx, 1
  01b9f	23 55 e8	 and	 edx, DWORD PTR _hold$[ebp]
  01ba2	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01ba5	03 50 48	 add	 edx, DWORD PTR [eax+72]
  01ba8	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01bab	89 51 48	 mov	 DWORD PTR [ecx+72], edx
$LN303@inflate:

; 1134 :                 DROPBITS(state->extra);

  01bae	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01bb1	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  01bb4	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  01bb7	d3 e8		 shr	 eax, cl
  01bb9	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  01bbc	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01bbf	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01bc2	2b 51 4c	 sub	 edx, DWORD PTR [ecx+76]
  01bc5	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01bc8	33 c0		 xor	 eax, eax
  01bca	75 e2		 jne	 SHORT $LN303@inflate

; 1135 :                 state->back += state->extra;

  01bcc	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01bcf	8b 91 c8 1b 00
	00		 mov	 edx, DWORD PTR [ecx+7112]
  01bd5	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01bd8	03 50 4c	 add	 edx, DWORD PTR [eax+76]
  01bdb	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01bde	89 91 c8 1b 00
	00		 mov	 DWORD PTR [ecx+7112], edx
$LN472@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  01be4	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01be7	c7 42 04 4c 3f
	00 00		 mov	 DWORD PTR [edx+4], 16204 ; 00003f4cH
$LN474@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  01bee	83 7d ec 00	 cmp	 DWORD PTR _left$[ebp], 0
  01bf2	75 05		 jne	 SHORT $LN475@inflate
  01bf4	e9 ae 03 00 00	 jmp	 $inf_leave$566
$LN475@inflate:

; 1148 :             copy = out - left;

  01bf9	8b 45 dc	 mov	 eax, DWORD PTR _out$[ebp]
  01bfc	2b 45 ec	 sub	 eax, DWORD PTR _left$[ebp]
  01bff	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax

; 1149 :             if (state->offset > copy) {         /* copy from window */

  01c02	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01c05	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  01c08	3b 55 d8	 cmp	 edx, DWORD PTR _copy$[ebp]
  01c0b	0f 86 98 00 00
	00		 jbe	 $LN476@inflate

; 1150 :                 copy = state->offset - copy;

  01c11	0f ae e8	 lfence
  01c14	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01c17	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  01c1a	2b 4d d8	 sub	 ecx, DWORD PTR _copy$[ebp]
  01c1d	89 4d d8	 mov	 DWORD PTR _copy$[ebp], ecx

; 1151 :                 if (copy > state->whave) {

  01c20	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01c23	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  01c26	3b 42 30	 cmp	 eax, DWORD PTR [edx+48]
  01c29	76 25		 jbe	 SHORT $LN478@inflate

; 1152 :                     if (state->sane) {

  01c2b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01c2e	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  01c35	74 19		 je	 SHORT $LN478@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  01c37	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01c3a	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 1154 :                         state->mode = BAD;

  01c41	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01c44	c7 40 04 51 3f
	00 00		 mov	 DWORD PTR [eax+4], 16209 ; 00003f51H

; 1155 :                         break;

  01c4b	e9 52 03 00 00	 jmp	 $LN8@inflate
$LN478@inflate:

; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  01c50	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01c53	8b 55 d8	 mov	 edx, DWORD PTR _copy$[ebp]
  01c56	3b 51 34	 cmp	 edx, DWORD PTR [ecx+52]
  01c59	76 23		 jbe	 SHORT $LN480@inflate

; 1172 :                     copy -= state->wnext;

  01c5b	0f ae e8	 lfence
  01c5e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01c61	8b 4d d8	 mov	 ecx, DWORD PTR _copy$[ebp]
  01c64	2b 48 34	 sub	 ecx, DWORD PTR [eax+52]
  01c67	89 4d d8	 mov	 DWORD PTR _copy$[ebp], ecx

; 1173 :                     from = state->window + (state->wsize - copy);

  01c6a	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01c6d	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  01c70	2b 45 d8	 sub	 eax, DWORD PTR _copy$[ebp]
  01c73	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01c76	03 41 38	 add	 eax, DWORD PTR [ecx+56]
  01c79	89 45 d4	 mov	 DWORD PTR _from$[ebp], eax

; 1174 :                 }

  01c7c	eb 15		 jmp	 SHORT $LN481@inflate
$LN480@inflate:

; 1175 :                 else
; 1176 :                     from = state->window + (state->wnext - copy);

  01c7e	0f ae e8	 lfence
  01c81	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01c84	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  01c87	2b 45 d8	 sub	 eax, DWORD PTR _copy$[ebp]
  01c8a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01c8d	03 41 38	 add	 eax, DWORD PTR [ecx+56]
  01c90	89 45 d4	 mov	 DWORD PTR _from$[ebp], eax
$LN481@inflate:

; 1177 :                 if (copy > state->length) copy = state->length;

  01c93	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01c96	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  01c99	3b 42 44	 cmp	 eax, DWORD PTR [edx+68]
  01c9c	76 09		 jbe	 SHORT $LN482@inflate
  01c9e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01ca1	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  01ca4	89 55 d8	 mov	 DWORD PTR _copy$[ebp], edx
$LN482@inflate:

; 1178 :             }

  01ca7	eb 18		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1179 :             else {                              /* copy from output */
; 1180 :                 from = put - state->offset;

  01ca9	0f ae e8	 lfence
  01cac	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01caf	8b 4d f4	 mov	 ecx, DWORD PTR _put$[ebp]
  01cb2	2b 48 48	 sub	 ecx, DWORD PTR [eax+72]
  01cb5	89 4d d4	 mov	 DWORD PTR _from$[ebp], ecx

; 1181 :                 copy = state->length;

  01cb8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01cbb	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  01cbe	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax
$LN477@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;

  01cc1	8b 4d d8	 mov	 ecx, DWORD PTR _copy$[ebp]
  01cc4	3b 4d ec	 cmp	 ecx, DWORD PTR _left$[ebp]
  01cc7	76 06		 jbe	 SHORT $LN483@inflate
  01cc9	8b 55 ec	 mov	 edx, DWORD PTR _left$[ebp]
  01ccc	89 55 d8	 mov	 DWORD PTR _copy$[ebp], edx
$LN483@inflate:

; 1184 :             left -= copy;

  01ccf	8b 45 ec	 mov	 eax, DWORD PTR _left$[ebp]
  01cd2	2b 45 d8	 sub	 eax, DWORD PTR _copy$[ebp]
  01cd5	89 45 ec	 mov	 DWORD PTR _left$[ebp], eax

; 1185 :             state->length -= copy;

  01cd8	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01cdb	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  01cde	2b 55 d8	 sub	 edx, DWORD PTR _copy$[ebp]
  01ce1	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01ce4	89 50 44	 mov	 DWORD PTR [eax+68], edx
$LN306@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  01ce7	8b 4d f4	 mov	 ecx, DWORD PTR _put$[ebp]
  01cea	8b 55 d4	 mov	 edx, DWORD PTR _from$[ebp]
  01ced	8a 02		 mov	 al, BYTE PTR [edx]
  01cef	88 01		 mov	 BYTE PTR [ecx], al
  01cf1	8b 4d f4	 mov	 ecx, DWORD PTR _put$[ebp]
  01cf4	83 c1 01	 add	 ecx, 1
  01cf7	89 4d f4	 mov	 DWORD PTR _put$[ebp], ecx
  01cfa	8b 55 d4	 mov	 edx, DWORD PTR _from$[ebp]
  01cfd	83 c2 01	 add	 edx, 1
  01d00	89 55 d4	 mov	 DWORD PTR _from$[ebp], edx

; 1188 :             } while (--copy);

  01d03	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  01d06	83 e8 01	 sub	 eax, 1
  01d09	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax
  01d0c	75 d9		 jne	 SHORT $LN306@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  01d0e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01d11	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  01d15	75 0a		 jne	 SHORT $LN484@inflate
  01d17	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01d1a	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H
$LN484@inflate:

; 1190 :             break;

  01d21	e9 7c 02 00 00	 jmp	 $LN8@inflate
$LN485@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  01d26	83 7d ec 00	 cmp	 DWORD PTR _left$[ebp], 0
  01d2a	75 05		 jne	 SHORT $LN486@inflate
  01d2c	e9 76 02 00 00	 jmp	 $inf_leave$566
$LN486@inflate:

; 1193 :             *put++ = (unsigned char)(state->length);

  01d31	8b 45 f4	 mov	 eax, DWORD PTR _put$[ebp]
  01d34	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01d37	8a 51 44	 mov	 dl, BYTE PTR [ecx+68]
  01d3a	88 10		 mov	 BYTE PTR [eax], dl
  01d3c	8b 45 f4	 mov	 eax, DWORD PTR _put$[ebp]
  01d3f	83 c0 01	 add	 eax, 1
  01d42	89 45 f4	 mov	 DWORD PTR _put$[ebp], eax

; 1194 :             left--;

  01d45	8b 4d ec	 mov	 ecx, DWORD PTR _left$[ebp]
  01d48	83 e9 01	 sub	 ecx, 1
  01d4b	89 4d ec	 mov	 DWORD PTR _left$[ebp], ecx

; 1195 :             state->mode = LEN;

  01d4e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01d51	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H

; 1196 :             break;

  01d58	e9 45 02 00 00	 jmp	 $LN8@inflate
$LN487@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  01d5d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01d60	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  01d64	0f 84 6e 01 00
	00		 je	 $LN488@inflate
$LN310@inflate:

; 1199 :                 NEEDBITS(32);

  01d6a	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  01d6e	73 3d		 jae	 SHORT $LN307@inflate
$LN314@inflate:
  01d70	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01d74	75 05		 jne	 SHORT $LN489@inflate
  01d76	e9 2c 02 00 00	 jmp	 $inf_leave$566
$LN489@inflate:
  01d7b	8b 4d f0	 mov	 ecx, DWORD PTR _have$[ebp]
  01d7e	83 e9 01	 sub	 ecx, 1
  01d81	89 4d f0	 mov	 DWORD PTR _have$[ebp], ecx
  01d84	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  01d87	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01d8a	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01d8d	d3 e0		 shl	 eax, cl
  01d8f	03 45 e8	 add	 eax, DWORD PTR _hold$[ebp]
  01d92	89 45 e8	 mov	 DWORD PTR _hold$[ebp], eax
  01d95	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  01d98	83 c1 01	 add	 ecx, 1
  01d9b	89 4d f8	 mov	 DWORD PTR _next$[ebp], ecx
  01d9e	8b 55 e4	 mov	 edx, DWORD PTR _bits$[ebp]
  01da1	83 c2 08	 add	 edx, 8
  01da4	89 55 e4	 mov	 DWORD PTR _bits$[ebp], edx
  01da7	33 c0		 xor	 eax, eax
  01da9	75 c5		 jne	 SHORT $LN314@inflate
  01dab	eb bd		 jmp	 SHORT $LN310@inflate
$LN307@inflate:
  01dad	33 c9		 xor	 ecx, ecx
  01daf	75 b9		 jne	 SHORT $LN310@inflate

; 1200 :                 out -= left;

  01db1	8b 55 dc	 mov	 edx, DWORD PTR _out$[ebp]
  01db4	2b 55 ec	 sub	 edx, DWORD PTR _left$[ebp]
  01db7	89 55 dc	 mov	 DWORD PTR _out$[ebp], edx

; 1201 :                 strm->total_out += out;

  01dba	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01dbd	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  01dc0	03 4d dc	 add	 ecx, DWORD PTR _out$[ebp]
  01dc3	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01dc6	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 1202 :                 state->total += out;

  01dc9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01dcc	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  01dcf	03 4d dc	 add	 ecx, DWORD PTR _out$[ebp]
  01dd2	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01dd5	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 1203 :                 if ((state->wrap & 4) && out)

  01dd8	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01ddb	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  01dde	83 e1 04	 and	 ecx, 4
  01de1	74 5d		 je	 SHORT $LN490@inflate
  01de3	83 7d dc 00	 cmp	 DWORD PTR _out$[ebp], 0
  01de7	74 57		 je	 SHORT $LN490@inflate

; 1204 :                     strm->adler = state->check =

  01de9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01dec	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  01df0	74 1f		 je	 SHORT $LN513@inflate
  01df2	0f ae e8	 lfence
  01df5	8b 45 dc	 mov	 eax, DWORD PTR _out$[ebp]
  01df8	50		 push	 eax
  01df9	8b 4d f4	 mov	 ecx, DWORD PTR _put$[ebp]
  01dfc	2b 4d dc	 sub	 ecx, DWORD PTR _out$[ebp]
  01dff	51		 push	 ecx
  01e00	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01e03	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  01e06	50		 push	 eax
  01e07	e8 00 00 00 00	 call	 _crc32@12
  01e0c	89 45 80	 mov	 DWORD PTR tv1302[ebp], eax
  01e0f	eb 1d		 jmp	 SHORT $LN514@inflate
$LN513@inflate:
  01e11	0f ae e8	 lfence
  01e14	8b 4d dc	 mov	 ecx, DWORD PTR _out$[ebp]
  01e17	51		 push	 ecx
  01e18	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  01e1b	2b 55 dc	 sub	 edx, DWORD PTR _out$[ebp]
  01e1e	52		 push	 edx
  01e1f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01e22	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  01e25	51		 push	 ecx
  01e26	e8 00 00 00 00	 call	 _adler32@12
  01e2b	89 45 80	 mov	 DWORD PTR tv1302[ebp], eax
$LN514@inflate:
  01e2e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01e31	8b 45 80	 mov	 eax, DWORD PTR tv1302[ebp]
  01e34	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  01e37	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01e3a	8b 55 80	 mov	 edx, DWORD PTR tv1302[ebp]
  01e3d	89 51 30	 mov	 DWORD PTR [ecx+48], edx
$LN490@inflate:

; 1205 :                         UPDATE(state->check, put - out, out);
; 1206 :                 out = left;

  01e40	8b 45 ec	 mov	 eax, DWORD PTR _left$[ebp]
  01e43	89 45 dc	 mov	 DWORD PTR _out$[ebp], eax

; 1207 :                 if ((state->wrap & 4) && (

  01e46	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01e49	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01e4c	83 e2 04	 and	 edx, 4
  01e4f	74 75		 je	 SHORT $LN317@inflate
  01e51	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01e54	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  01e58	74 0b		 je	 SHORT $LN515@inflate
  01e5a	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  01e5d	89 8d 7c ff ff
	ff		 mov	 DWORD PTR tv1319[ebp], ecx
  01e63	eb 3a		 jmp	 SHORT $LN516@inflate
$LN515@inflate:
  01e65	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  01e68	c1 ea 18	 shr	 edx, 24			; 00000018H
  01e6b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01e71	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  01e74	c1 e8 08	 shr	 eax, 8
  01e77	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01e7c	03 d0		 add	 edx, eax
  01e7e	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  01e81	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  01e87	c1 e1 08	 shl	 ecx, 8
  01e8a	03 d1		 add	 edx, ecx
  01e8c	8b 45 e8	 mov	 eax, DWORD PTR _hold$[ebp]
  01e8f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01e94	c1 e0 18	 shl	 eax, 24			; 00000018H
  01e97	03 d0		 add	 edx, eax
  01e99	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv1319[ebp], edx
$LN516@inflate:
  01e9f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01ea2	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv1319[ebp]
  01ea8	3b 51 1c	 cmp	 edx, DWORD PTR [ecx+28]
  01eab	74 19		 je	 SHORT $LN317@inflate

; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {
; 1212 :                     strm->msg = (char *)"incorrect data check";

  01ead	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01eb0	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@

; 1213 :                     state->mode = BAD;

  01eb7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01eba	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 1214 :                     break;

  01ec1	e9 dc 00 00 00	 jmp	 $LN8@inflate
$LN317@inflate:

; 1215 :                 }
; 1216 :                 INITBITS();

  01ec6	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  01ecd	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  01ed4	33 d2		 xor	 edx, edx
  01ed6	75 ee		 jne	 SHORT $LN317@inflate
$LN488@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  01ed8	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01edb	c7 40 04 4f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16207 ; 00003f4fH
$LN492@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  01ee2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01ee5	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  01ee9	0f 84 83 00 00
	00		 je	 $LN493@inflate
  01eef	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01ef2	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  01ef6	74 7a		 je	 SHORT $LN493@inflate
$LN321@inflate:

; 1223 :                 NEEDBITS(32);

  01ef8	83 7d e4 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  01efc	73 3d		 jae	 SHORT $LN318@inflate
$LN325@inflate:
  01efe	83 7d f0 00	 cmp	 DWORD PTR _have$[ebp], 0
  01f02	75 05		 jne	 SHORT $LN494@inflate
  01f04	e9 9e 00 00 00	 jmp	 $inf_leave$566
$LN494@inflate:
  01f09	8b 45 f0	 mov	 eax, DWORD PTR _have$[ebp]
  01f0c	83 e8 01	 sub	 eax, 1
  01f0f	89 45 f0	 mov	 DWORD PTR _have$[ebp], eax
  01f12	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  01f15	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  01f18	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01f1b	d3 e2		 shl	 edx, cl
  01f1d	03 55 e8	 add	 edx, DWORD PTR _hold$[ebp]
  01f20	89 55 e8	 mov	 DWORD PTR _hold$[ebp], edx
  01f23	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  01f26	83 c0 01	 add	 eax, 1
  01f29	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
  01f2c	8b 4d e4	 mov	 ecx, DWORD PTR _bits$[ebp]
  01f2f	83 c1 08	 add	 ecx, 8
  01f32	89 4d e4	 mov	 DWORD PTR _bits$[ebp], ecx
  01f35	33 d2		 xor	 edx, edx
  01f37	75 c5		 jne	 SHORT $LN325@inflate
  01f39	eb bd		 jmp	 SHORT $LN321@inflate
$LN318@inflate:
  01f3b	33 c0		 xor	 eax, eax
  01f3d	75 b9		 jne	 SHORT $LN321@inflate

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  01f3f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01f42	8b 55 e8	 mov	 edx, DWORD PTR _hold$[ebp]
  01f45	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  01f48	74 16		 je	 SHORT $LN328@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  01f4a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01f4d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@

; 1226 :                     state->mode = BAD;

  01f54	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01f57	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 1227 :                     break;

  01f5e	eb 42		 jmp	 SHORT $LN8@inflate
$LN328@inflate:

; 1228 :                 }
; 1229 :                 INITBITS();

  01f60	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  01f67	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  01f6e	33 d2		 xor	 edx, edx
  01f70	75 ee		 jne	 SHORT $LN328@inflate
$LN493@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  01f72	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01f75	c7 40 04 50 3f
	00 00		 mov	 DWORD PTR [eax+4], 16208 ; 00003f50H
$LN496@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  01f7c	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 1236 :             goto inf_leave;

  01f83	eb 22		 jmp	 SHORT $inf_leave$566
$LN497@inflate:

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  01f85	c7 45 b4 fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH

; 1239 :             goto inf_leave;

  01f8c	eb 19		 jmp	 SHORT $inf_leave$566
$LN498@inflate:

; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;

  01f8e	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01f93	e9 17 02 00 00	 jmp	 $LN1@inflate
$LN499@inflate:

; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;

  01f98	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  01f9d	e9 0d 02 00 00	 jmp	 $LN1@inflate
$LN8@inflate:

; 1245 :         }

  01fa2	e9 1e e1 ff ff	 jmp	 $LN7@inflate
$inf_leave$566:

; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  01fa7	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01faa	8b 55 f4	 mov	 edx, DWORD PTR _put$[ebp]
  01fad	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  01fb0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01fb3	8b 4d ec	 mov	 ecx, DWORD PTR _left$[ebp]
  01fb6	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01fb9	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01fbc	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  01fbf	89 02		 mov	 DWORD PTR [edx], eax
  01fc1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01fc4	8b 55 f0	 mov	 edx, DWORD PTR _have$[ebp]
  01fc7	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01fca	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01fcd	8b 4d e8	 mov	 ecx, DWORD PTR _hold$[ebp]
  01fd0	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  01fd3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01fd6	8b 45 e4	 mov	 eax, DWORD PTR _bits$[ebp]
  01fd9	89 42 40	 mov	 DWORD PTR [edx+64], eax
  01fdc	33 c9		 xor	 ecx, ecx
  01fde	75 c7		 jne	 SHORT $inf_leave$566

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  01fe0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01fe3	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  01fe7	75 29		 jne	 SHORT $LN501@inflate
  01fe9	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01fec	8b 4d dc	 mov	 ecx, DWORD PTR _out$[ebp]
  01fef	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  01ff2	74 53		 je	 SHORT $LN500@inflate
  01ff4	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01ff7	81 7a 04 51 3f
	00 00		 cmp	 DWORD PTR [edx+4], 16209 ; 00003f51H
  01ffe	7d 47		 jge	 SHORT $LN500@inflate
  02000	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  02003	81 78 04 4e 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16206 ; 00003f4eH
  0200a	7c 06		 jl	 SHORT $LN501@inflate
  0200c	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  02010	74 35		 je	 SHORT $LN500@inflate
$LN501@inflate:

; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  02012	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  02015	8b 55 dc	 mov	 edx, DWORD PTR _out$[ebp]
  02018	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  0201b	52		 push	 edx
  0201c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0201f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  02022	51		 push	 ecx
  02023	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  02026	52		 push	 edx
  02027	e8 00 00 00 00	 call	 _updatewindow
  0202c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0202f	85 c0		 test	 eax, eax
  02031	74 14		 je	 SHORT $LN500@inflate

; 1258 :             state->mode = MEM;

  02033	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  02036	c7 40 04 52 3f
	00 00		 mov	 DWORD PTR [eax+4], 16210 ; 00003f52H

; 1259 :             return Z_MEM_ERROR;

  0203d	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  02042	e9 68 01 00 00	 jmp	 $LN1@inflate
$LN500@inflate:

; 1260 :         }
; 1261 :     in -= strm->avail_in;

  02047	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0204a	8b 55 e0	 mov	 edx, DWORD PTR _in$[ebp]
  0204d	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  02050	89 55 e0	 mov	 DWORD PTR _in$[ebp], edx

; 1262 :     out -= strm->avail_out;

  02053	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  02056	8b 4d dc	 mov	 ecx, DWORD PTR _out$[ebp]
  02059	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  0205c	89 4d dc	 mov	 DWORD PTR _out$[ebp], ecx

; 1263 :     strm->total_in += in;

  0205f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  02062	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  02065	03 45 e0	 add	 eax, DWORD PTR _in$[ebp]
  02068	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0206b	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1264 :     strm->total_out += out;

  0206e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  02071	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  02074	03 45 dc	 add	 eax, DWORD PTR _out$[ebp]
  02077	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0207a	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1265 :     state->total += out;

  0207d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  02080	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  02083	03 45 dc	 add	 eax, DWORD PTR _out$[ebp]
  02086	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  02089	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 1266 :     if ((state->wrap & 4) && out)

  0208c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0208f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  02092	83 e0 04	 and	 eax, 4
  02095	74 69		 je	 SHORT $LN504@inflate
  02097	83 7d dc 00	 cmp	 DWORD PTR _out$[ebp], 0
  0209b	74 63		 je	 SHORT $LN504@inflate

; 1267 :         strm->adler = state->check =

  0209d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  020a0	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  020a4	74 22		 je	 SHORT $LN517@inflate
  020a6	8b 55 dc	 mov	 edx, DWORD PTR _out$[ebp]
  020a9	52		 push	 edx
  020aa	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  020ad	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  020b0	2b 4d dc	 sub	 ecx, DWORD PTR _out$[ebp]
  020b3	51		 push	 ecx
  020b4	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  020b7	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  020ba	50		 push	 eax
  020bb	e8 00 00 00 00	 call	 _crc32@12
  020c0	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv1408[ebp], eax
  020c6	eb 20		 jmp	 SHORT $LN518@inflate
$LN517@inflate:
  020c8	8b 4d dc	 mov	 ecx, DWORD PTR _out$[ebp]
  020cb	51		 push	 ecx
  020cc	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  020cf	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  020d2	2b 45 dc	 sub	 eax, DWORD PTR _out$[ebp]
  020d5	50		 push	 eax
  020d6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  020d9	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  020dc	52		 push	 edx
  020dd	e8 00 00 00 00	 call	 _adler32@12
  020e2	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv1408[ebp], eax
$LN518@inflate:
  020e8	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  020eb	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv1408[ebp]
  020f1	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  020f4	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  020f7	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv1408[ebp]
  020fd	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN504@inflate:

; 1268 :             UPDATE(state->check, strm->next_out - out, out);
; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  02100	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  02103	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  02107	74 0c		 je	 SHORT $LN519@inflate
  02109	c7 85 74 ff ff
	ff 40 00 00 00	 mov	 DWORD PTR tv1413[ebp], 64 ; 00000040H
  02113	eb 0a		 jmp	 SHORT $LN520@inflate
$LN519@inflate:
  02115	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1413[ebp], 0
$LN520@inflate:
  0211f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  02122	81 7a 04 3f 3f
	00 00		 cmp	 DWORD PTR [edx+4], 16191 ; 00003f3fH
  02129	75 0c		 jne	 SHORT $LN521@inflate
  0212b	c7 85 70 ff ff
	ff 80 00 00 00	 mov	 DWORD PTR tv1417[ebp], 128 ; 00000080H
  02135	eb 0a		 jmp	 SHORT $LN522@inflate
$LN521@inflate:
  02137	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1417[ebp], 0
$LN522@inflate:
  02141	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  02144	81 78 04 47 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16199 ; 00003f47H
  0214b	74 18		 je	 SHORT $LN523@inflate
  0214d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  02150	81 79 04 42 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16194 ; 00003f42H
  02157	74 0c		 je	 SHORT $LN523@inflate
  02159	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv1423[ebp], 0
  02163	eb 0a		 jmp	 SHORT $LN524@inflate
$LN523@inflate:
  02165	c7 85 6c ff ff
	ff 00 01 00 00	 mov	 DWORD PTR tv1423[ebp], 256 ; 00000100H
$LN524@inflate:
  0216f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  02172	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  02175	03 85 74 ff ff
	ff		 add	 eax, DWORD PTR tv1413[ebp]
  0217b	03 85 70 ff ff
	ff		 add	 eax, DWORD PTR tv1417[ebp]
  02181	03 85 6c ff ff
	ff		 add	 eax, DWORD PTR tv1423[ebp]
  02187	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0218a	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0218d	83 7d e0 00	 cmp	 DWORD PTR _in$[ebp], 0
  02191	75 06		 jne	 SHORT $LN507@inflate
  02193	83 7d dc 00	 cmp	 DWORD PTR _out$[ebp], 0
  02197	74 06		 je	 SHORT $LN506@inflate
$LN507@inflate:
  02199	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  0219d	75 0d		 jne	 SHORT $LN505@inflate
$LN506@inflate:
  0219f	83 7d b4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  021a3	75 07		 jne	 SHORT $LN505@inflate

; 1273 :         ret = Z_BUF_ERROR;

  021a5	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
$LN505@inflate:

; 1274 :     return ret;

  021ac	8b 45 b4	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@inflate:

; 1275 : }

  021af	52		 push	 edx
  021b0	8b cd		 mov	 ecx, ebp
  021b2	50		 push	 eax
  021b3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN565@inflate
  021b9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  021be	58		 pop	 eax
  021bf	5a		 pop	 edx
  021c0	5f		 pop	 edi
  021c1	81 c4 94 00 00
	00		 add	 esp, 148		; 00000094H
  021c7	3b ec		 cmp	 ebp, esp
  021c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  021ce	8b e5		 mov	 esp, ebp
  021d0	5d		 pop	 ebp
  021d1	c2 08 00	 ret	 8
$LN565@inflate:
  021d4	03 00 00 00	 DD	 3
  021d8	00 00 00 00	 DD	 $LN564@inflate
$LN564@inflate:
  021dc	cc ff ff ff	 DD	 -52			; ffffffccH
  021e0	04 00 00 00	 DD	 4
  021e4	00 00 00 00	 DD	 $LN561@inflate
  021e8	c0 ff ff ff	 DD	 -64			; ffffffc0H
  021ec	04 00 00 00	 DD	 4
  021f0	00 00 00 00	 DD	 $LN562@inflate
  021f4	ac ff ff ff	 DD	 -84			; ffffffacH
  021f8	04 00 00 00	 DD	 4
  021fc	00 00 00 00	 DD	 $LN563@inflate
$LN563@inflate:
  02200	68		 DB	 104			; 00000068H
  02201	62		 DB	 98			; 00000062H
  02202	75		 DB	 117			; 00000075H
  02203	66		 DB	 102			; 00000066H
  02204	00		 DB	 0
$LN562@inflate:
  02205	6c		 DB	 108			; 0000006cH
  02206	61		 DB	 97			; 00000061H
  02207	73		 DB	 115			; 00000073H
  02208	74		 DB	 116			; 00000074H
  02209	00		 DB	 0
$LN561@inflate:
  0220a	68		 DB	 104			; 00000068H
  0220b	65		 DB	 101			; 00000065H
  0220c	72		 DB	 114			; 00000072H
  0220d	65		 DB	 101			; 00000065H
  0220e	00		 DB	 0
  0220f	90		 npad	 1
$LN559@inflate:
  02210	00 00 00 00	 DD	 $LN335@inflate
  02214	00 00 00 00	 DD	 $LN33@inflate
  02218	00 00 00 00	 DD	 $LN47@inflate
  0221c	00 00 00 00	 DD	 $LN61@inflate
  02220	00 00 00 00	 DD	 $LN361@inflate
  02224	00 00 00 00	 DD	 $LN368@inflate
  02228	00 00 00 00	 DD	 $LN375@inflate
  0222c	00 00 00 00	 DD	 $LN384@inflate
  02230	00 00 00 00	 DD	 $LN393@inflate
  02234	00 00 00 00	 DD	 $LN106@inflate
  02238	00 00 00 00	 DD	 $LN400@inflate
  0223c	00 00 00 00	 DD	 $LN402@inflate
  02240	00 00 00 00	 DD	 $LN405@inflate
  02244	00 00 00 00	 DD	 $LN141@inflate
  02248	00 00 00 00	 DD	 $LN417@inflate
  0224c	00 00 00 00	 DD	 $LN418@inflate
  02250	00 00 00 00	 DD	 $LN156@inflate
  02254	00 00 00 00	 DD	 $LN170@inflate
  02258	00 00 00 00	 DD	 $LN185@inflate
  0225c	00 00 00 00	 DD	 $LN449@inflate
  02260	00 00 00 00	 DD	 $LN450@inflate
  02264	00 00 00 00	 DD	 $LN461@inflate
  02268	00 00 00 00	 DD	 $LN277@inflate
  0226c	00 00 00 00	 DD	 $LN471@inflate
  02270	00 00 00 00	 DD	 $LN474@inflate
  02274	00 00 00 00	 DD	 $LN485@inflate
  02278	00 00 00 00	 DD	 $LN487@inflate
  0227c	00 00 00 00	 DD	 $LN492@inflate
  02280	00 00 00 00	 DD	 $LN496@inflate
  02284	00 00 00 00	 DD	 $LN497@inflate
  02288	00 00 00 00	 DD	 $LN498@inflate
$LN560@inflate:
  0228c	00 00 00 00	 DD	 $LN408@inflate
  02290	00 00 00 00	 DD	 $LN409@inflate
  02294	00 00 00 00	 DD	 $LN411@inflate
  02298	00 00 00 00	 DD	 $LN412@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00011	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00016	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _inflateStateCheck
  0001f	83 c4 04	 add	 esp, 4
  00022	85 c0		 test	 eax, eax
  00024	74 07		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00026	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002b	eb 62		 jmp	 SHORT $LN1@inflateEnd
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00030	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00033	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00036	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00039	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0003d	74 22		 je	 SHORT $LN3@inflateEnd
  0003f	8b f4		 mov	 esi, esp
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00044	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00047	52		 push	 edx
  00048	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0004b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0004e	51		 push	 ecx
  0004f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00052	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00055	ff d0		 call	 eax
  00057	83 c4 08	 add	 esp, 8
  0005a	3b f4		 cmp	 esi, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00061	8b f4		 mov	 esi, esp
  00063	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00066	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00069	52		 push	 edx
  0006a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0006d	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00070	51		 push	 ecx
  00071	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00074	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00077	ff d0		 call	 eax
  00079	83 c4 08	 add	 esp, 8
  0007c	3b f4		 cmp	 esi, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1286 :     strm->state = Z_NULL;

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00086	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  0008d	33 c0		 xor	 eax, eax
$LN1@inflateEnd:

; 1289 : }

  0008f	5e		 pop	 esi
  00090	83 c4 04	 add	 esp, 4
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateStateCheck PROC					; COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00015	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00019	74 12		 je	 SHORT $LN3@inflateSta
  0001b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0001e	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00022	74 09		 je	 SHORT $LN3@inflateSta
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00027	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0002b	75 07		 jne	 SHORT $LN2@inflateSta
$LN3@inflateSta:

; 111  :         return 1;

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	eb 3a		 jmp	 SHORT $LN1@inflateSta
$LN2@inflateSta:

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00034	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00037	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0003a	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  0003d	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  00041	74 22		 je	 SHORT $LN5@inflateSta
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00046	8b 11		 mov	 edx, DWORD PTR [ecx]
  00048	3b 55 08	 cmp	 edx, DWORD PTR _strm$[ebp]
  0004b	75 18		 jne	 SHORT $LN5@inflateSta
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00050	81 78 04 34 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16180 ; 00003f34H
  00057	7c 0c		 jl	 SHORT $LN5@inflateSta
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0005c	81 79 04 53 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16211 ; 00003f53H
  00063	7e 07		 jle	 SHORT $LN4@inflateSta
$LN5@inflateSta:

; 115  :         return 1;

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	eb 02		 jmp	 SHORT $LN1@inflateSta
$LN4@inflateSta:

; 116  :     return 0;

  0006c	33 c0		 xor	 eax, eax
$LN1@inflateSta:

; 117  : }

  0006e	83 c4 04	 add	 esp, 4
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
_inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
tv87 = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _inflateStateCheck
  00027	83 c4 04	 add	 esp, 4
  0002a	85 c0		 test	 eax, eax
  0002c	74 0a		 je	 SHORT $LN2@inflateRes
  0002e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00033	e9 d1 00 00 00	 jmp	 $LN1@inflateRes
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0003e	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00044	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0004e	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00055	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00058	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 127  :     strm->msg = Z_NULL;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00062	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0006c	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00070	74 0f		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00072	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00075	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00078	83 e0 01	 and	 eax, 1
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0007e	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;

  00081	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00084	c7 42 04 34 3f
	00 00		 mov	 DWORD PTR [edx+4], 16180 ; 00003f34H

; 131  :     state->last = 0;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0008e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 132  :     state->havedict = 0;

  00095	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00098	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 133  :     state->dmax = 32768U;

  0009f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000a2	c7 42 18 00 80
	00 00		 mov	 DWORD PTR [edx+24], 32768 ; 00008000H

; 134  :     state->head = Z_NULL;

  000a9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000ac	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 135  :     state->hold = 0;

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000b6	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 136  :     state->bits = 0;

  000bd	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000c0	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 137  :     state->lencode = state->distcode = state->next = state->codes;

  000c7	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000ca	05 34 05 00 00	 add	 eax, 1332		; 00000534H
  000cf	89 45 f8	 mov	 DWORD PTR tv87[ebp], eax
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000d5	8b 55 f8	 mov	 edx, DWORD PTR tv87[ebp]
  000d8	89 51 70	 mov	 DWORD PTR [ecx+112], edx
  000db	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000de	8b 4d f8	 mov	 ecx, DWORD PTR tv87[ebp]
  000e1	89 48 54	 mov	 DWORD PTR [eax+84], ecx
  000e4	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000e7	8b 45 f8	 mov	 eax, DWORD PTR tv87[ebp]
  000ea	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 138  :     state->sane = 1;

  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000f0	c7 81 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7108], 1

; 139  :     state->back = -1;

  000fa	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000fd	c7 82 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+7112], -1

; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  00107	33 c0		 xor	 eax, eax
$LN1@inflateRes:

; 142  : }

  00109	83 c4 08	 add	 esp, 8
  0010c	3b ec		 cmp	 ebp, esp
  0010e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_state$ = -8						; size = 4
_wrap$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _inflateStateCheck
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	74 0a		 je	 SHORT $LN2@inflateRes
  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00034	e9 af 00 00 00	 jmp	 $LN1@inflateRes
$LN2@inflateRes:

; 166  :     state = (struct inflate_state FAR *)strm->state;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0003f	89 55 f8	 mov	 DWORD PTR _state$[ebp], edx

; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00042	83 7d 0c 00	 cmp	 DWORD PTR _windowBits$[ebp], 0
  00046	7d 11		 jge	 SHORT $LN3@inflateRes

; 170  :         wrap = 0;

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _wrap$[ebp], 0

; 171  :         windowBits = -windowBits;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _windowBits$[ebp]
  00052	f7 d8		 neg	 eax
  00054	89 45 0c	 mov	 DWORD PTR _windowBits$[ebp], eax

; 172  :     }

  00057	eb 1b		 jmp	 SHORT $LN4@inflateRes
$LN3@inflateRes:

; 173  :     else {
; 174  :         wrap = (windowBits >> 4) + 5;

  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  0005c	c1 f9 04	 sar	 ecx, 4
  0005f	83 c1 05	 add	 ecx, 5
  00062	89 4d fc	 mov	 DWORD PTR _wrap$[ebp], ecx

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  00065	83 7d 0c 30	 cmp	 DWORD PTR _windowBits$[ebp], 48 ; 00000030H
  00069	7d 09		 jge	 SHORT $LN4@inflateRes

; 177  :             windowBits &= 15;

  0006b	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  0006e	83 e2 0f	 and	 edx, 15			; 0000000fH
  00071	89 55 0c	 mov	 DWORD PTR _windowBits$[ebp], edx
$LN4@inflateRes:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00074	83 7d 0c 00	 cmp	 DWORD PTR _windowBits$[ebp], 0
  00078	74 13		 je	 SHORT $LN6@inflateRes
  0007a	83 7d 0c 08	 cmp	 DWORD PTR _windowBits$[ebp], 8
  0007e	7c 06		 jl	 SHORT $LN7@inflateRes
  00080	83 7d 0c 0f	 cmp	 DWORD PTR _windowBits$[ebp], 15 ; 0000000fH
  00084	7e 07		 jle	 SHORT $LN6@inflateRes
$LN7@inflateRes:

; 183  :         return Z_STREAM_ERROR;

  00086	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0008b	eb 5b		 jmp	 SHORT $LN1@inflateRes
$LN6@inflateRes:

; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00090	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00094	74 37		 je	 SHORT $LN8@inflateRes
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00099	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0009c	3b 55 0c	 cmp	 edx, DWORD PTR _windowBits$[ebp]
  0009f	74 2c		 je	 SHORT $LN8@inflateRes

; 185  :         ZFREE(strm, state->window);

  000a1	8b f4		 mov	 esi, esp
  000a3	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000a6	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000a9	51		 push	 ecx
  000aa	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000ad	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000b0	50		 push	 eax
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b4	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000b7	ff d2		 call	 edx
  000b9	83 c4 08	 add	 esp, 8
  000bc	3b f4		 cmp	 esi, esp
  000be	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 186  :         state->window = Z_NULL;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000c6	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN8@inflateRes:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;

  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000d0	8b 55 fc	 mov	 edx, DWORD PTR _wrap$[ebp]
  000d3	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 191  :     state->wbits = (unsigned)windowBits;

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000dc	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 192  :     return inflateReset(strm);

  000df	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000e2	52		 push	 edx
  000e3	e8 00 00 00 00	 call	 _inflateReset@4
$LN1@inflateRes:

; 193  : }

  000e8	5e		 pop	 esi
  000e9	83 c4 08	 add	 esp, 8
  000ec	3b ec		 cmp	 ebp, esp
  000ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  0000d	8b 45 10	 mov	 eax, DWORD PTR _stream_size$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _version$[ebp]
  00014	51		 push	 ecx
  00015	6a 0f		 push	 15			; 0000000fH
  00017	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 _inflateInit2_@16

; 245  : }

  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	5d		 pop	 ebp
  00028	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00015	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _inflateStateCheck
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	74 07		 je	 SHORT $LN2@inflatePri
  00025	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002a	eb 7d		 jmp	 SHORT $LN1@inflatePri
$LN2@inflatePri:

; 255  :     state = (struct inflate_state FAR *)strm->state;

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00032	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 256  :     if (bits < 0) {

  00035	83 7d 0c 00	 cmp	 DWORD PTR _bits$[ebp], 0
  00039	7d 18		 jge	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003e	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 258  :         state->bits = 0;

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00048	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 259  :         return Z_OK;

  0004f	33 c0		 xor	 eax, eax
  00051	eb 56		 jmp	 SHORT $LN1@inflatePri
$LN3@inflatePri:

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00053	83 7d 0c 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00057	7f 0e		 jg	 SHORT $LN5@inflatePri
  00059	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005c	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0005f	03 45 0c	 add	 eax, DWORD PTR _bits$[ebp]
  00062	83 f8 20	 cmp	 eax, 32			; 00000020H
  00065	76 07		 jbe	 SHORT $LN4@inflatePri
$LN5@inflatePri:
  00067	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0006c	eb 3b		 jmp	 SHORT $LN1@inflatePri
$LN4@inflatePri:

; 262  :     value &= (1L << bits) - 1;

  0006e	ba 01 00 00 00	 mov	 edx, 1
  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  00076	d3 e2		 shl	 edx, cl
  00078	83 ea 01	 sub	 edx, 1
  0007b	23 55 10	 and	 edx, DWORD PTR _value$[ebp]
  0007e	89 55 10	 mov	 DWORD PTR _value$[ebp], edx

; 263  :     state->hold += (unsigned)value << state->bits;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00084	8b 55 10	 mov	 edx, DWORD PTR _value$[ebp]
  00087	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0008a	d3 e2		 shl	 edx, cl
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0008f	03 50 3c	 add	 edx, DWORD PTR [eax+60]
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00095	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 264  :     state->bits += (uInt)bits;

  00098	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0009b	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0009e	03 45 0c	 add	 eax, DWORD PTR _bits$[ebp]
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000a4	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 265  :     return Z_OK;

  000a7	33 c0		 xor	 eax, eax
$LN1@inflatePri:

; 266  : }

  000a9	83 c4 04	 add	 esp, 4
  000ac	3b ec		 cmp	 ebp, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00010	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0001a	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 317  :     state->distcode = distfix;

  00021	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00024	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 318  :     state->distbits = 5;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002e	c7 40 5c 05 00
	00 00		 mov	 DWORD PTR [eax+92], 5

; 319  : }

  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
_dist$ = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_end$ = 12						; size = 4
_copy$ = 16						; size = 4
_updatewindow PROC					; COMDAT

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00022	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00025	89 4d fc	 mov	 DWORD PTR _state$[ebp], ecx

; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  00028	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0002b	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0002f	75 44		 jne	 SHORT $LN2@updatewind

; 408  :         state->window = (unsigned char FAR *)

  00031	8b f4		 mov	 esi, esp
  00033	6a 01		 push	 1
  00035	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00038	ba 01 00 00 00	 mov	 edx, 1
  0003d	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00040	d3 e2		 shl	 edx, cl
  00042	52		 push	 edx
  00043	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00046	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00049	51		 push	 ecx
  0004a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0004d	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00050	ff d0		 call	 eax
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0005f	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  00062	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00065	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  00069	75 0a		 jne	 SHORT $LN2@updatewind
  0006b	b8 01 00 00 00	 mov	 eax, 1
  00070	e9 3b 01 00 00	 jmp	 $LN1@updatewind
$LN2@updatewind:

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  00075	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00078	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0007c	75 27		 jne	 SHORT $LN4@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00081	ba 01 00 00 00	 mov	 edx, 1
  00086	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00089	d3 e2		 shl	 edx, cl
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0008e	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 417  :         state->wnext = 0;

  00091	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00094	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 418  :         state->whave = 0;

  0009b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0009e	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0
$LN4@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  000a5	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000a8	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  000ab	3b 48 2c	 cmp	 ecx, DWORD PTR [eax+44]
  000ae	72 3b		 jb	 SHORT $LN5@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  000b0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000b3	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000b6	50		 push	 eax
  000b7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000ba	8b 55 0c	 mov	 edx, DWORD PTR _end$[ebp]
  000bd	2b 51 2c	 sub	 edx, DWORD PTR [ecx+44]
  000c0	52		 push	 edx
  000c1	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000c4	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 _memcpy
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 424  :         state->wnext = 0;

  000d0	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000d3	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0

; 425  :         state->whave = state->wsize;

  000da	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000dd	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000e0	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000e3	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 426  :     }

  000e6	e9 c3 00 00 00	 jmp	 $LN6@updatewind
$LN5@updatewind:

; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  000eb	0f ae e8	 lfence
  000ee	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000f1	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000f4	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  000f7	2b 51 34	 sub	 edx, DWORD PTR [ecx+52]
  000fa	89 55 f8	 mov	 DWORD PTR _dist$[ebp], edx

; 429  :         if (dist > copy) dist = copy;

  000fd	8b 45 f8	 mov	 eax, DWORD PTR _dist$[ebp]
  00100	3b 45 10	 cmp	 eax, DWORD PTR _copy$[ebp]
  00103	76 06		 jbe	 SHORT $LN7@updatewind
  00105	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  00108	89 4d f8	 mov	 DWORD PTR _dist$[ebp], ecx
$LN7@updatewind:

; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  0010b	8b 55 f8	 mov	 edx, DWORD PTR _dist$[ebp]
  0010e	52		 push	 edx
  0010f	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
  00112	2b 45 10	 sub	 eax, DWORD PTR _copy$[ebp]
  00115	50		 push	 eax
  00116	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00119	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0011c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0011f	03 50 34	 add	 edx, DWORD PTR [eax+52]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 _memcpy
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  :         copy -= dist;

  0012b	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  0012e	2b 4d f8	 sub	 ecx, DWORD PTR _dist$[ebp]
  00131	89 4d 10	 mov	 DWORD PTR _copy$[ebp], ecx

; 432  :         if (copy) {

  00134	74 34		 je	 SHORT $LN8@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  00136	0f ae e8	 lfence
  00139	8b 55 10	 mov	 edx, DWORD PTR _copy$[ebp]
  0013c	52		 push	 edx
  0013d	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
  00140	2b 45 10	 sub	 eax, DWORD PTR _copy$[ebp]
  00143	50		 push	 eax
  00144	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00147	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0014a	52		 push	 edx
  0014b	e8 00 00 00 00	 call	 _memcpy
  00150	83 c4 0c	 add	 esp, 12			; 0000000cH

; 434  :             state->wnext = copy;

  00153	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00156	8b 4d 10	 mov	 ecx, DWORD PTR _copy$[ebp]
  00159	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 435  :             state->whave = state->wsize;

  0015c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0015f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00162	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00165	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 436  :         }

  00168	eb 44		 jmp	 SHORT $LN6@updatewind
$LN8@updatewind:

; 437  :         else {
; 438  :             state->wnext += dist;

  0016a	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0016d	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00170	03 45 f8	 add	 eax, DWORD PTR _dist$[ebp]
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00176	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  00179	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0017c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0017f	8b 4a 34	 mov	 ecx, DWORD PTR [edx+52]
  00182	3b 48 2c	 cmp	 ecx, DWORD PTR [eax+44]
  00185	75 0a		 jne	 SHORT $LN10@updatewind
  00187	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0018a	c7 42 34 00 00
	00 00		 mov	 DWORD PTR [edx+52], 0
$LN10@updatewind:

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  00191	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00194	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00197	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  0019a	3b 51 2c	 cmp	 edx, DWORD PTR [ecx+44]
  0019d	73 0f		 jae	 SHORT $LN6@updatewind
  0019f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  001a2	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  001a5	03 4d f8	 add	 ecx, DWORD PTR _dist$[ebp]
  001a8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001ab	89 4a 30	 mov	 DWORD PTR [edx+48], ecx
$LN6@updatewind:

; 441  :         }
; 442  :     }
; 443  :     return 0;

  001ae	33 c0		 xor	 eax, eax
$LN1@updatewind:

; 444  : }

  001b0	5e		 pop	 esi
  001b1	83 c4 08	 add	 esp, 8
  001b4	3b ec		 cmp	 ebp, esp
  001b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001bb	8b e5		 mov	 esp, ebp
  001bd	5d		 pop	 ebp
  001be	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00015	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _inflateStateCheck
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	74 07		 je	 SHORT $LN2@inflateGet
  00025	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002a	eb 77		 jmp	 SHORT $LN1@inflateGet
$LN2@inflateGet:

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00032	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  00035	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00038	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  0003c	74 52		 je	 SHORT $LN3@inflateGet
  0003e	83 7d 0c 00	 cmp	 DWORD PTR _dictionary$[ebp], 0
  00042	74 4c		 je	 SHORT $LN3@inflateGet

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00047	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0004a	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0004d	2b 42 34	 sub	 eax, DWORD PTR [edx+52]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00054	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00057	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0005a	03 50 34	 add	 edx, DWORD PTR [eax+52]
  0005d	52		 push	 edx
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 _memcpy
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1305 :                 state->whave - state->wnext);
; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,

  0006a	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0006d	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00070	50		 push	 eax
  00071	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00074	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00077	52		 push	 edx
  00078	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  0007e	03 48 30	 add	 ecx, DWORD PTR [eax+48]
  00081	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00084	2b 4a 34	 sub	 ecx, DWORD PTR [edx+52]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _memcpy
  0008d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@inflateGet:

; 1307 :                 state->window, state->wnext);
; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  00090	83 7d 10 00	 cmp	 DWORD PTR _dictLength$[ebp], 0
  00094	74 0b		 je	 SHORT $LN4@inflateGet

; 1310 :         *dictLength = state->whave;

  00096	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0009c	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0009f	89 10		 mov	 DWORD PTR [eax], edx
$LN4@inflateGet:

; 1311 :     return Z_OK;

  000a1	33 c0		 xor	 eax, eax
$LN1@inflateGet:

; 1312 : }

  000a3	83 c4 04	 add	 esp, 4
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_ret$ = -12						; size = 4
_dictid$ = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1318 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00025	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _inflateStateCheck
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	74 0a		 je	 SHORT $LN2@inflateSet
  00035	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003a	e9 a2 00 00 00	 jmp	 $LN1@inflateSet
$LN2@inflateSet:

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00042	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00045	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  00048	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0004b	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0004f	74 13		 je	 SHORT $LN3@inflateSet
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00054	81 79 04 3e 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16190 ; 00003f3eH
  0005b	74 07		 je	 SHORT $LN3@inflateSet

; 1327 :         return Z_STREAM_ERROR;

  0005d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00062	eb 7d		 jmp	 SHORT $LN1@inflateSet
$LN3@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  00064	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00067	81 7a 04 3e 3f
	00 00		 cmp	 DWORD PTR [edx+4], 16190 ; 00003f3eH
  0006e	75 34		 jne	 SHORT $LN4@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);

  00070	6a 00		 push	 0
  00072	6a 00		 push	 0
  00074	6a 00		 push	 0
  00076	e8 00 00 00 00	 call	 _adler32@12
  0007b	89 45 f8	 mov	 DWORD PTR _dictid$[ebp], eax

; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  0007e	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  00081	50		 push	 eax
  00082	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  00085	51		 push	 ecx
  00086	8b 55 f8	 mov	 edx, DWORD PTR _dictid$[ebp]
  00089	52		 push	 edx
  0008a	e8 00 00 00 00	 call	 _adler32@12
  0008f	89 45 f8	 mov	 DWORD PTR _dictid$[ebp], eax

; 1333 :         if (dictid != state->check)

  00092	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00095	8b 4d f8	 mov	 ecx, DWORD PTR _dictid$[ebp]
  00098	3b 48 1c	 cmp	 ecx, DWORD PTR [eax+28]
  0009b	74 07		 je	 SHORT $LN4@inflateSet

; 1334 :             return Z_DATA_ERROR;

  0009d	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000a2	eb 3d		 jmp	 SHORT $LN1@inflateSet
$LN4@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  000a4	8b 55 10	 mov	 edx, DWORD PTR _dictLength$[ebp]
  000a7	52		 push	 edx
  000a8	8b 45 0c	 mov	 eax, DWORD PTR _dictionary$[ebp]
  000ab	03 45 10	 add	 eax, DWORD PTR _dictLength$[ebp]
  000ae	50		 push	 eax
  000af	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 _updatewindow
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bb	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax

; 1340 :     if (ret) {

  000be	83 7d f4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000c2	74 11		 je	 SHORT $LN6@inflateSet

; 1341 :         state->mode = MEM;

  000c4	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000c7	c7 42 04 52 3f
	00 00		 mov	 DWORD PTR [edx+4], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  000ce	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000d3	eb 0c		 jmp	 SHORT $LN1@inflateSet
$LN6@inflateSet:

; 1343 :     }
; 1344 :     state->havedict = 1;

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000d8	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  000df	33 c0		 xor	 eax, eax
$LN1@inflateSet:

; 1347 : }

  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e4	3b ec		 cmp	 ebp, esp
  000e6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00015	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _inflateStateCheck
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	74 07		 je	 SHORT $LN2@inflateGet
  00025	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002a	eb 30		 jmp	 SHORT $LN1@inflateGet
$LN2@inflateGet:

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00032	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00038	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0003b	83 e1 02	 and	 ecx, 2
  0003e	75 07		 jne	 SHORT $LN3@inflateGet
  00040	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00045	eb 15		 jmp	 SHORT $LN1@inflateGet
$LN3@inflateGet:

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  0004d	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 1362 :     head->done = 0;

  00050	8b 4d 0c	 mov	 ecx, DWORD PTR _head$[ebp]
  00053	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 1363 :     return Z_OK;

  0005a	33 c0		 xor	 eax, eax
$LN1@inflateGet:

; 1364 : }

  0005c	83 c4 04	 add	 esp, 4
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
tv70 = -12						; size = 4
_next$ = -8						; size = 4
_got$ = -4						; size = 4
_have$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_syncsearch PROC					; COMDAT

; 1381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00025	8b 45 08	 mov	 eax, DWORD PTR _have$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d fc	 mov	 DWORD PTR _got$[ebp], ecx

; 1386 :     next = 0;

  0002d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
$LN2@syncsearch:

; 1387 :     while (next < len && got < 4) {

  00034	8b 55 f8	 mov	 edx, DWORD PTR _next$[ebp]
  00037	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  0003a	73 61		 jae	 SHORT $LN3@syncsearch
  0003c	83 7d fc 04	 cmp	 DWORD PTR _got$[ebp], 4
  00040	73 5b		 jae	 SHORT $LN3@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00042	83 7d fc 02	 cmp	 DWORD PTR _got$[ebp], 2
  00046	73 09		 jae	 SHORT $LN9@syncsearch
  00048	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
  0004f	eb 07		 jmp	 SHORT $LN10@syncsearch
$LN9@syncsearch:
  00051	c7 45 f4 ff 00
	00 00		 mov	 DWORD PTR tv70[ebp], 255 ; 000000ffH
$LN10@syncsearch:
  00058	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0005b	03 45 f8	 add	 eax, DWORD PTR _next$[ebp]
  0005e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00061	3b 4d f4	 cmp	 ecx, DWORD PTR tv70[ebp]
  00064	75 0b		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00066	8b 55 fc	 mov	 edx, DWORD PTR _got$[ebp]
  00069	83 c2 01	 add	 edx, 1
  0006c	89 55 fc	 mov	 DWORD PTR _got$[ebp], edx
  0006f	eb 21		 jmp	 SHORT $LN5@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])

  00071	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00074	03 45 f8	 add	 eax, DWORD PTR _next$[ebp]
  00077	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0007a	85 c9		 test	 ecx, ecx
  0007c	74 09		 je	 SHORT $LN6@syncsearch

; 1391 :             got = 0;

  0007e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _got$[ebp], 0
  00085	eb 0b		 jmp	 SHORT $LN5@syncsearch
$LN6@syncsearch:

; 1392 :         else
; 1393 :             got = 4 - got;

  00087	ba 04 00 00 00	 mov	 edx, 4
  0008c	2b 55 fc	 sub	 edx, DWORD PTR _got$[ebp]
  0008f	89 55 fc	 mov	 DWORD PTR _got$[ebp], edx
$LN5@syncsearch:

; 1394 :         next++;

  00092	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]
  00095	83 c0 01	 add	 eax, 1
  00098	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax

; 1395 :     }

  0009b	eb 97		 jmp	 SHORT $LN2@syncsearch
$LN3@syncsearch:

; 1396 :     *have = got;

  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _have$[ebp]
  000a0	8b 55 fc	 mov	 edx, DWORD PTR _got$[ebp]
  000a3	89 11		 mov	 DWORD PTR [ecx], edx

; 1397 :     return next;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _next$[ebp]

; 1398 : }

  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	3b ec		 cmp	 ebp, esp
  000ad	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_state$ = -28						; size = 4
_buf$ = -20						; size = 4
_out$ = -12						; size = 4
_in$ = -8						; size = 4
_len$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _inflateStateCheck
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	74 0a		 je	 SHORT $LN4@inflateSyn
  0003a	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003f	e9 67 01 00 00	 jmp	 $LN1@inflateSyn
$LN4@inflateSyn:

; 1410 :     state = (struct inflate_state FAR *)strm->state;

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00047	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0004a	89 55 e4	 mov	 DWORD PTR _state$[ebp], edx

; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0004d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00050	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00054	75 13		 jne	 SHORT $LN5@inflateSyn
  00056	8b 4d e4	 mov	 ecx, DWORD PTR _state$[ebp]
  00059	83 79 40 08	 cmp	 DWORD PTR [ecx+64], 8
  0005d	73 0a		 jae	 SHORT $LN5@inflateSyn
  0005f	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00064	e9 42 01 00 00	 jmp	 $LN1@inflateSyn
$LN5@inflateSyn:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00069	8b 55 e4	 mov	 edx, DWORD PTR _state$[ebp]
  0006c	81 7a 04 53 3f
	00 00		 cmp	 DWORD PTR [edx+4], 16211 ; 00003f53H
  00073	0f 84 9f 00 00
	00		 je	 $LN6@inflateSyn

; 1415 :         state->mode = SYNC;

  00079	8b 45 e4	 mov	 eax, DWORD PTR _state$[ebp]
  0007c	c7 40 04 53 3f
	00 00		 mov	 DWORD PTR [eax+4], 16211 ; 00003f53H

; 1416 :         state->hold <<= state->bits & 7;

  00083	8b 4d e4	 mov	 ecx, DWORD PTR _state$[ebp]
  00086	8b 49 40	 mov	 ecx, DWORD PTR [ecx+64]
  00089	83 e1 07	 and	 ecx, 7
  0008c	8b 55 e4	 mov	 edx, DWORD PTR _state$[ebp]
  0008f	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00092	d3 e0		 shl	 eax, cl
  00094	8b 4d e4	 mov	 ecx, DWORD PTR _state$[ebp]
  00097	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 1417 :         state->bits -= state->bits & 7;

  0009a	8b 55 e4	 mov	 edx, DWORD PTR _state$[ebp]
  0009d	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000a0	83 e0 07	 and	 eax, 7
  000a3	8b 4d e4	 mov	 ecx, DWORD PTR _state$[ebp]
  000a6	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  000a9	2b d0		 sub	 edx, eax
  000ab	8b 45 e4	 mov	 eax, DWORD PTR _state$[ebp]
  000ae	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 1418 :         len = 0;

  000b1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN2@inflateSyn:

; 1419 :         while (state->bits >= 8) {

  000b8	8b 4d e4	 mov	 ecx, DWORD PTR _state$[ebp]
  000bb	83 79 40 08	 cmp	 DWORD PTR [ecx+64], 8
  000bf	72 36		 jb	 SHORT $LN3@inflateSyn

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  000c1	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  000c4	8b 45 e4	 mov	 eax, DWORD PTR _state$[ebp]
  000c7	8a 48 3c	 mov	 cl, BYTE PTR [eax+60]
  000ca	88 4c 15 ec	 mov	 BYTE PTR _buf$[ebp+edx], cl
  000ce	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  000d1	83 c2 01	 add	 edx, 1
  000d4	89 55 fc	 mov	 DWORD PTR _len$[ebp], edx

; 1421 :             state->hold >>= 8;

  000d7	8b 45 e4	 mov	 eax, DWORD PTR _state$[ebp]
  000da	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000dd	c1 e9 08	 shr	 ecx, 8
  000e0	8b 55 e4	 mov	 edx, DWORD PTR _state$[ebp]
  000e3	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 1422 :             state->bits -= 8;

  000e6	8b 45 e4	 mov	 eax, DWORD PTR _state$[ebp]
  000e9	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000ec	83 e9 08	 sub	 ecx, 8
  000ef	8b 55 e4	 mov	 edx, DWORD PTR _state$[ebp]
  000f2	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 1423 :         }

  000f5	eb c1		 jmp	 SHORT $LN2@inflateSyn
$LN3@inflateSyn:

; 1424 :         state->have = 0;

  000f7	8b 45 e4	 mov	 eax, DWORD PTR _state$[ebp]
  000fa	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0

; 1425 :         syncsearch(&(state->have), buf, len);

  00101	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00104	51		 push	 ecx
  00105	8d 55 ec	 lea	 edx, DWORD PTR _buf$[ebp]
  00108	52		 push	 edx
  00109	8b 45 e4	 mov	 eax, DWORD PTR _state$[ebp]
  0010c	83 c0 6c	 add	 eax, 108		; 0000006cH
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 _syncsearch
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@inflateSyn:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  00118	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0011b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0011e	52		 push	 edx
  0011f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00122	8b 08		 mov	 ecx, DWORD PTR [eax]
  00124	51		 push	 ecx
  00125	8b 55 e4	 mov	 edx, DWORD PTR _state$[ebp]
  00128	83 c2 6c	 add	 edx, 108		; 0000006cH
  0012b	52		 push	 edx
  0012c	e8 00 00 00 00	 call	 _syncsearch
  00131	83 c4 0c	 add	 esp, 12			; 0000000cH
  00134	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax

; 1430 :     strm->avail_in -= len;

  00137	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0013a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013d	2b 4d fc	 sub	 ecx, DWORD PTR _len$[ebp]
  00140	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00143	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1431 :     strm->next_in += len;

  00146	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00149	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014b	03 4d fc	 add	 ecx, DWORD PTR _len$[ebp]
  0014e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00151	89 0a		 mov	 DWORD PTR [edx], ecx

; 1432 :     strm->total_in += len;

  00153	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00156	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00159	03 4d fc	 add	 ecx, DWORD PTR _len$[ebp]
  0015c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0015f	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  00162	8b 45 e4	 mov	 eax, DWORD PTR _state$[ebp]
  00165	83 78 6c 04	 cmp	 DWORD PTR [eax+108], 4
  00169	74 07		 je	 SHORT $LN7@inflateSyn
  0016b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00170	eb 39		 jmp	 SHORT $LN1@inflateSyn
$LN7@inflateSyn:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  00172	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00175	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00178	89 55 f8	 mov	 DWORD PTR _in$[ebp], edx
  0017b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0017e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00181	89 4d f4	 mov	 DWORD PTR _out$[ebp], ecx

; 1437 :     inflateReset(strm);

  00184	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00187	52		 push	 edx
  00188	e8 00 00 00 00	 call	 _inflateReset@4

; 1438 :     strm->total_in = in;  strm->total_out = out;

  0018d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00190	8b 4d f8	 mov	 ecx, DWORD PTR _in$[ebp]
  00193	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00196	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00199	8b 45 f4	 mov	 eax, DWORD PTR _out$[ebp]
  0019c	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1439 :     state->mode = TYPE;

  0019f	8b 4d e4	 mov	 ecx, DWORD PTR _state$[ebp]
  001a2	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 1440 :     return Z_OK;

  001a9	33 c0		 xor	 eax, eax
$LN1@inflateSyn:

; 1441 : }

  001ab	52		 push	 edx
  001ac	8b cd		 mov	 ecx, ebp
  001ae	50		 push	 eax
  001af	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@inflateSyn
  001b5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001ba	58		 pop	 eax
  001bb	5a		 pop	 edx
  001bc	83 c4 1c	 add	 esp, 28			; 0000001cH
  001bf	3b ec		 cmp	 ebp, esp
  001c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c2 04 00	 ret	 4
$LN12@inflateSyn:
  001cc	01 00 00 00	 DD	 1
  001d0	00 00 00 00	 DD	 $LN11@inflateSyn
$LN11@inflateSyn:
  001d4	ec ff ff ff	 DD	 -20			; ffffffecH
  001d8	04 00 00 00	 DD	 4
  001dc	00 00 00 00	 DD	 $LN10@inflateSyn
$LN10@inflateSyn:
  001e0	62		 DB	 98			; 00000062H
  001e1	75		 DB	 117			; 00000075H
  001e2	66		 DB	 102			; 00000066H
  001e3	00		 DB	 0
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
tv72 = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _inflateStateCheck
  00027	83 c4 04	 add	 esp, 4
  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN2@inflateSyn
  0002e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00033	eb 31		 jmp	 SHORT $LN1@inflateSyn
$LN2@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00038	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0003b	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1458 :     return state->mode == STORED && state->bits == 0;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00041	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00048	75 12		 jne	 SHORT $LN4@inflateSyn
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0004d	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  00051	75 09		 jne	 SHORT $LN4@inflateSyn
  00053	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  0005a	eb 07		 jmp	 SHORT $LN5@inflateSyn
$LN4@inflateSyn:
  0005c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN5@inflateSyn:
  00063	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
$LN1@inflateSyn:

; 1459 : }

  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_wsize$ = -16						; size = 4
_window$ = -12						; size = 4
_copy$ = -8						; size = 4
_state$ = -4						; size = 4
_dest$ = 8						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1464 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00022	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _inflateStateCheck
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	75 06		 jne	 SHORT $LN3@inflateCop
  00032	83 7d 08 00	 cmp	 DWORD PTR _dest$[ebp], 0
  00036	75 0a		 jne	 SHORT $LN2@inflateCop
$LN3@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  00038	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003d	e9 a8 01 00 00	 jmp	 $LN1@inflateCop
$LN2@inflateCop:

; 1473 :     state = (struct inflate_state FAR *)source->state;

  00042	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  00045	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00048	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)

  0004b	8b f4		 mov	 esi, esp
  0004d	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00052	6a 01		 push	 1
  00054	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00057	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0005a	51		 push	 ecx
  0005b	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  0005e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00061	ff d0		 call	 eax
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	3b f4		 cmp	 esi, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	89 45 f8	 mov	 DWORD PTR _copy$[ebp], eax

; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00070	83 7d f8 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00074	75 0a		 jne	 SHORT $LN4@inflateCop
  00076	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007b	e9 6a 01 00 00	 jmp	 $LN1@inflateCop
$LN4@inflateCop:

; 1479 :     window = Z_NULL;

  00080	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _window$[ebp], 0

; 1480 :     if (state->window != Z_NULL) {

  00087	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0008a	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  0008e	74 5d		 je	 SHORT $LN5@inflateCop

; 1481 :         window = (unsigned char FAR *)

  00090	8b f4		 mov	 esi, esp
  00092	6a 01		 push	 1
  00094	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00097	b8 01 00 00 00	 mov	 eax, 1
  0009c	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  0009f	d3 e0		 shl	 eax, cl
  000a1	50		 push	 eax
  000a2	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  000a5	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000a8	52		 push	 edx
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  000ac	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000af	ff d1		 call	 ecx
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	3b f4		 cmp	 esi, esp
  000b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bb	89 45 f4	 mov	 DWORD PTR _window$[ebp], eax

; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1483 :         if (window == Z_NULL) {

  000be	83 7d f4 00	 cmp	 DWORD PTR _window$[ebp], 0
  000c2	75 29		 jne	 SHORT $LN5@inflateCop

; 1484 :             ZFREE(source, copy);

  000c4	8b f4		 mov	 esi, esp
  000c6	8b 55 f8	 mov	 edx, DWORD PTR _copy$[ebp]
  000c9	52		 push	 edx
  000ca	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  000cd	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000d0	51		 push	 ecx
  000d1	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  000d4	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000d7	ff d0		 call	 eax
  000d9	83 c4 08	 add	 esp, 8
  000dc	3b f4		 cmp	 esi, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1485 :             return Z_MEM_ERROR;

  000e3	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000e8	e9 fd 00 00 00	 jmp	 $LN1@inflateCop
$LN5@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000ed	6a 38		 push	 56			; 00000038H
  000ef	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  000f2	51		 push	 ecx
  000f3	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  000f6	52		 push	 edx
  000f7	e8 00 00 00 00	 call	 _memcpy
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000ff	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00104	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00107	50		 push	 eax
  00108	8b 4d f8	 mov	 ecx, DWORD PTR _copy$[ebp]
  0010b	51		 push	 ecx
  0010c	e8 00 00 00 00	 call	 _memcpy
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1492 :     copy->strm = dest;

  00114	8b 55 f8	 mov	 edx, DWORD PTR _copy$[ebp]
  00117	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0011a	89 02		 mov	 DWORD PTR [edx], eax

; 1493 :     if (state->lencode >= state->codes &&

  0011c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0011f	81 c1 34 05 00
	00		 add	 ecx, 1332		; 00000534H
  00125	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00128	39 4a 50	 cmp	 DWORD PTR [edx+80], ecx
  0012b	72 58		 jb	 SHORT $LN7@inflateCop
  0012d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00130	05 c0 1b 00 00	 add	 eax, 7104		; 00001bc0H
  00135	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00138	39 41 50	 cmp	 DWORD PTR [ecx+80], eax
  0013b	77 48		 ja	 SHORT $LN7@inflateCop

; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  0013d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00140	81 c2 34 05 00
	00		 add	 edx, 1332		; 00000534H
  00146	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00149	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0014c	2b ca		 sub	 ecx, edx
  0014e	c1 f9 02	 sar	 ecx, 2
  00151	8b 55 f8	 mov	 edx, DWORD PTR _copy$[ebp]
  00154	8d 84 8a 34 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1332]
  0015b	8b 4d f8	 mov	 ecx, DWORD PTR _copy$[ebp]
  0015e	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00161	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00164	81 c2 34 05 00
	00		 add	 edx, 1332		; 00000534H
  0016a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0016d	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00170	2b ca		 sub	 ecx, edx
  00172	c1 f9 02	 sar	 ecx, 2
  00175	8b 55 f8	 mov	 edx, DWORD PTR _copy$[ebp]
  00178	8d 84 8a 34 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1332]
  0017f	8b 4d f8	 mov	 ecx, DWORD PTR _copy$[ebp]
  00182	89 41 54	 mov	 DWORD PTR [ecx+84], eax
$LN7@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  00185	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00188	81 c2 34 05 00
	00		 add	 edx, 1332		; 00000534H
  0018e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00191	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00194	2b ca		 sub	 ecx, edx
  00196	c1 f9 02	 sar	 ecx, 2
  00199	8b 55 f8	 mov	 edx, DWORD PTR _copy$[ebp]
  0019c	8d 84 8a 34 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1332]
  001a3	8b 4d f8	 mov	 ecx, DWORD PTR _copy$[ebp]
  001a6	89 41 70	 mov	 DWORD PTR [ecx+112], eax

; 1499 :     if (window != Z_NULL) {

  001a9	83 7d f4 00	 cmp	 DWORD PTR _window$[ebp], 0
  001ad	74 27		 je	 SHORT $LN8@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  001af	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001b2	b8 01 00 00 00	 mov	 eax, 1
  001b7	8b 4a 28	 mov	 ecx, DWORD PTR [edx+40]
  001ba	d3 e0		 shl	 eax, cl
  001bc	89 45 f0	 mov	 DWORD PTR _wsize$[ebp], eax

; 1501 :         zmemcpy(window, state->window, wsize);

  001bf	8b 4d f0	 mov	 ecx, DWORD PTR _wsize$[ebp]
  001c2	51		 push	 ecx
  001c3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001c6	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  001c9	50		 push	 eax
  001ca	8b 4d f4	 mov	 ecx, DWORD PTR _window$[ebp]
  001cd	51		 push	 ecx
  001ce	e8 00 00 00 00	 call	 _memcpy
  001d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  001d6	8b 55 f8	 mov	 edx, DWORD PTR _copy$[ebp]
  001d9	8b 45 f4	 mov	 eax, DWORD PTR _window$[ebp]
  001dc	89 42 38	 mov	 DWORD PTR [edx+56], eax

; 1504 :     dest->state = (struct internal_state FAR *)copy;

  001df	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  001e2	8b 55 f8	 mov	 edx, DWORD PTR _copy$[ebp]
  001e5	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 1505 :     return Z_OK;

  001e8	33 c0		 xor	 eax, eax
$LN1@inflateCop:

; 1506 : }

  001ea	5e		 pop	 esi
  001eb	83 c4 10	 add	 esp, 16			; 00000010H
  001ee	3b ec		 cmp	 ebp, esp
  001f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f5	8b e5		 mov	 esp, ebp
  001f7	5d		 pop	 ebp
  001f8	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00015	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _inflateStateCheck
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	74 07		 je	 SHORT $LN2@inflateUnd
  00025	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002a	eb 1b		 jmp	 SHORT $LN1@inflateUnd
$LN2@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00032	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00038	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1522 :     return Z_DATA_ERROR;

  00042	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
$LN1@inflateUnd:

; 1523 : #endif
; 1524 : }

  00047	83 c4 04	 add	 esp, 4
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateValidate@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate@8 PROC					; COMDAT

; 1529 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00015	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _inflateStateCheck
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	74 07		 je	 SHORT $LN2@inflateVal
  00025	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002a	eb 31		 jmp	 SHORT $LN1@inflateVal
$LN2@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;

  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00032	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1534 :     if (check)

  00035	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  00039	74 11		 je	 SHORT $LN3@inflateVal

; 1535 :         state->wrap |= 4;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0003e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00041	83 c9 04	 or	 ecx, 4
  00044	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00047	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0004a	eb 0f		 jmp	 SHORT $LN4@inflateVal
$LN3@inflateVal:

; 1536 :     else
; 1537 :         state->wrap &= ~4;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0004f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00052	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00055	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00058	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
$LN4@inflateVal:

; 1538 :     return Z_OK;

  0005b	33 c0		 xor	 eax, eax
$LN1@inflateVal:

; 1539 : }

  0005d	83 c4 04	 add	 esp, 4
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
_inflateValidate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv79 = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00025	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _inflateStateCheck
  0002e	83 c4 04	 add	 esp, 4
  00031	85 c0		 test	 eax, eax
  00033	74 07		 je	 SHORT $LN2@inflateMar

; 1547 :         return -(1L << 16);

  00035	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H
  0003a	eb 5c		 jmp	 SHORT $LN1@inflateMar
$LN2@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00042	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00045	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00048	81 78 04 43 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16195 ; 00003f43H
  0004f	75 0b		 jne	 SHORT $LN6@inflateMar
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00054	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00057	89 55 f8	 mov	 DWORD PTR tv79[ebp], edx
  0005a	eb 2d		 jmp	 SHORT $LN7@inflateMar
$LN6@inflateMar:
  0005c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0005f	81 78 04 4c 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16204 ; 00003f4cH
  00066	75 14		 jne	 SHORT $LN4@inflateMar
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0006b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0006e	8b 81 cc 1b 00
	00		 mov	 eax, DWORD PTR [ecx+7116]
  00074	2b 42 44	 sub	 eax, DWORD PTR [edx+68]
  00077	89 45 f4	 mov	 DWORD PTR tv78[ebp], eax
  0007a	eb 07		 jmp	 SHORT $LN5@inflateMar
$LN4@inflateMar:
  0007c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN5@inflateMar:
  00083	8b 4d f4	 mov	 ecx, DWORD PTR tv78[ebp]
  00086	89 4d f8	 mov	 DWORD PTR tv79[ebp], ecx
$LN7@inflateMar:
  00089	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0008c	8b 82 c8 1b 00
	00		 mov	 eax, DWORD PTR [edx+7112]
  00092	c1 e0 10	 shl	 eax, 16			; 00000010H
  00095	03 45 f8	 add	 eax, DWORD PTR tv79[ebp]
$LN1@inflateMar:

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inflate.c
;	COMDAT _inflateCodesUsed@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateCodesUsed@4 PROC				; COMDAT

; 1556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00015	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _inflateStateCheck
  0001e	83 c4 04	 add	 esp, 4
  00021	85 c0		 test	 eax, eax
  00023	74 05		 je	 SHORT $LN2@inflateCod
  00025	83 c8 ff	 or	 eax, -1
  00028	eb 1e		 jmp	 SHORT $LN1@inflateCod
$LN2@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00030	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1560 :     return (unsigned long)(state->next - state->codes);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00036	05 34 05 00 00	 add	 eax, 1332		; 00000534H
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003e	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00041	2b d0		 sub	 edx, eax
  00043	c1 fa 02	 sar	 edx, 2
  00046	8b c2		 mov	 eax, edx
$LN1@inflateCod:

; 1561 : }

  00048	83 c4 04	 add	 esp, 4
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
_inflateCodesUsed@4 ENDP
_TEXT	ENDS
END
