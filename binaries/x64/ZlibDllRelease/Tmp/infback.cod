; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type@		; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@	; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ DB 'invalid distanc'
	DB	'e too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code@ DB 'invalid distance code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ DB 'invalid literal/le'
	DB	'ngth code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set@ DB 'invalid distances set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ DB 'invalid literal/le'
	DB	'ngths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ DB 'invalid c'
	DB	'ode -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ DB 'invalid bit length r'
	DB	'epeat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@ DB 'invalid code lengths '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ DB 'too many len'
	DB	'gth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ DB 'invalid stored bl'
	DB	'ock lengths', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type@ DB 'invalid block type', 00H ; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__55962C33_inffixed@h DB 01H
__B796723E_infback@c DB 01H
PUBLIC	inflateBackEnd
PUBLIC	inflateBack
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN6
	DD	imagerel $LN6+128
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN386
	DD	imagerel $LN386+7652
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fixedtables DD imagerel fixedtables
	DD	imagerel fixedtables+104
	DD	imagerel $unwind$fixedtables
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN11
	DD	imagerel $LN11+407
	DD	imagerel $unwind$inflateBackInit_
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 022c01H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fixedtables DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 033301H
	DD	022011cH
	DD	07015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
inflateBack$rtcName$0 DB 06eH
	DB	065H
	DB	078H
	DB	074H
	DB	00H
	ORG $+3
inflateBack$rtcName$1 DB 068H
	DB	065H
	DB	072H
	DB	065H
	DB	00H
	ORG $+3
inflateBack$rtcName$2 DB 06cH
	DB	061H
	DB	073H
	DB	074H
	DB	00H
	ORG $+3
inflateBack$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:inflateBack$rtcVarDesc
	ORG $+8
inflateBack$rtcVarDesc DD 0a4H
	DD	04H
	DQ	FLAT:inflateBack$rtcName$2
	DD	084H
	DD	04H
	DQ	FLAT:inflateBack$rtcName$1
	DD	048H
	DD	08H
	DQ	FLAT:inflateBack$rtcName$0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 021e01H
	DD	07006320aH
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
state$ = 32
tv156 = 40
strm$ = 64
windowBits$ = 72
window$ = 80
version$ = 88
stream_size$ = 96
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 0c 00 00 00	 mov	 ecx, 12
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00033	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00038	48 83 7c 24 58
	00		 cmp	 QWORD PTR version$[rsp], 0
  0003e	74 31		 je	 SHORT $LN3@inflateBac
  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	48 6b c0 00	 imul	 rax, rax, 0
  00049	48 8b 4c 24 58	 mov	 rcx, QWORD PTR version$[rsp]
  0004e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00052	b9 01 00 00 00	 mov	 ecx, 1
  00057	48 6b c9 00	 imul	 rcx, rcx, 0
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411@
  00062	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00066	3b c1		 cmp	 eax, ecx
  00068	75 07		 jne	 SHORT $LN3@inflateBac
  0006a	83 7c 24 60 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0006f	74 0a		 je	 SHORT $LN2@inflateBac
$LN3@inflateBac:

; 38   :         stream_size != (int)(sizeof(z_stream)))
; 39   :         return Z_VERSION_ERROR;

  00071	b8 fa ff ff ff	 mov	 eax, -6
  00076	e9 16 01 00 00	 jmp	 $LN1@inflateBac
$LN2@inflateBac:

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  0007b	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00081	74 16		 je	 SHORT $LN5@inflateBac
  00083	48 83 7c 24 50
	00		 cmp	 QWORD PTR window$[rsp], 0
  00089	74 0e		 je	 SHORT $LN5@inflateBac
  0008b	83 7c 24 48 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  00090	7c 07		 jl	 SHORT $LN5@inflateBac
  00092	83 7c 24 48 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  00097	7e 0a		 jle	 SHORT $LN4@inflateBac
$LN5@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  00099	b8 fe ff ff ff	 mov	 eax, -2
  0009e	e9 ee 00 00 00	 jmp	 $LN1@inflateBac
$LN4@inflateBac:

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a8	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 44   :     if (strm->zalloc == (alloc_func)0) {

  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000b5	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000ba	75 1d		 jne	 SHORT $LN6@inflateBac

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcalloc
  000c8	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 49   :         strm->opaque = (voidpf)0;

  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d1	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN6@inflateBac:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000de	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000e3	75 10		 jne	 SHORT $LN7@inflateBac

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  000e5	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree
  000f1	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN7@inflateBac:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,

  000f5	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  000fb	ba 01 00 00 00	 mov	 edx, 1
  00100	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00105	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00109	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0010e	ff 50 30	 call	 QWORD PTR [rax+48]
  00111	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 59   :                                                sizeof(struct inflate_state));
; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  00116	48 83 7c 24 20
	00		 cmp	 QWORD PTR state$[rsp], 0
  0011c	75 07		 jne	 SHORT $LN8@inflateBac
  0011e	b8 fc ff ff ff	 mov	 eax, -4
  00123	eb 6c		 jmp	 SHORT $LN1@inflateBac
$LN8@inflateBac:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  00125	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0012a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0012f	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 63   :     state->dmax = 32768U;

  00133	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00138	c7 40 1c 00 80
	00 00		 mov	 DWORD PTR [rax+28], 32768 ; 00008000H

; 64   :     state->wbits = (uInt)windowBits;

  0013f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00144	8b 4c 24 48	 mov	 ecx, DWORD PTR windowBits$[rsp]
  00148	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 65   :     state->wsize = 1U << windowBits;

  0014b	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  0014f	b9 01 00 00 00	 mov	 ecx, 1
  00154	89 4c 24 28	 mov	 DWORD PTR tv156[rsp], ecx
  00158	0f b6 c8	 movzx	 ecx, al
  0015b	8b 44 24 28	 mov	 eax, DWORD PTR tv156[rsp]
  0015f	d3 e0		 shl	 eax, cl
  00161	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00166	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 66   :     state->window = window;

  00169	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0016e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  00173	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 67   :     state->wnext = 0;

  00177	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0017c	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0

; 68   :     state->whave = 0;

  00183	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00188	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 69   :     return Z_OK;

  0018f	33 c0		 xor	 eax, eax
$LN1@inflateBac:

; 70   : }

  00191	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00195	5f		 pop	 rdi
  00196	c3		 ret	 0
inflateBackInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 48
fixedtables PROC					; COMDAT

; 84   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9
  00036	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 120  :     state->lenbits = 9;

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0003f	c7 40 70 09 00
	00 00		 mov	 DWORD PTR [rax+112], 9

; 121  :     state->distcode = distfix;

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00052	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 122  :     state->distbits = 5;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0005b	c7 40 74 05 00
	00 00		 mov	 DWORD PTR [rax+116], 5

; 123  : }

  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT inflateBack
_TEXT	SEGMENT
state$ = 48
next$ = 72
put$ = 88
have$ = 96
left$ = 100
hold$ = 104
bits$ = 108
copy$ = 112
from$ = 120
here$ = 132
last$ = 164
len$ = 180
ret$ = 184
tv75 = 188
tv79 = 192
tv141 = 196
tv319 = 200
tv1220 = 208
tv475 = 212
tv508 = 216
tv530 = 224
tv1397 = 232
tv598 = 236
tv1478 = 240
tv1494 = 244
tv727 = 248
tv1560 = 252
tv807 = 256
strm$ = 288
in$ = 296
in_desc$ = 304
out$ = 312
out_desc$ = 320
inflateBack PROC					; COMDAT

; 256  : {

$LN386:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR [rsp+288]
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0003a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0003f	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR strm$[rsp], 0
  00048	74 0f		 je	 SHORT $LN254@inflateBac
  0004a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00052	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00057	75 0a		 jne	 SHORT $LN253@inflateBac
$LN254@inflateBac:

; 274  :         return Z_STREAM_ERROR;

  00059	b8 fe ff ff ff	 mov	 eax, -2
  0005e	e9 15 1d 00 00	 jmp	 $LN1@inflateBac
$LN253@inflateBac:

; 275  :     state = (struct inflate_state FAR *)strm->state;

  00063	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0006b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006f	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00074	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0007c	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 279  :     state->mode = TYPE;

  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00089	c7 40 08 3f 3f
	00 00		 mov	 DWORD PTR [rax+8], 16191 ; 00003f3fH

; 280  :     state->last = 0;

  00090	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00095	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 281  :     state->whave = 0;

  0009c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000a1	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 282  :     next = strm->next_in;

  000a8	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000b0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b3	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  000b8	48 83 7c 24 48
	00		 cmp	 QWORD PTR next$[rsp], 0
  000be	74 14		 je	 SHORT $LN343@inflateBac
  000c0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000c8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000cb	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv75[rsp], eax
  000d2	eb 0b		 jmp	 SHORT $LN344@inflateBac
$LN343@inflateBac:
  000d4	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv75[rsp], 0
$LN344@inflateBac:
  000df	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv75[rsp]
  000e6	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax

; 284  :     hold = 0;

  000ea	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0

; 285  :     bits = 0;

  000f2	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0

; 286  :     put = state->window;

  000fa	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000ff	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00103	48 89 44 24 58	 mov	 QWORD PTR put$[rsp], rax

; 287  :     left = state->wsize;

  00108	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0010d	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00110	89 44 24 64	 mov	 DWORD PTR left$[rsp], eax
$LN2@inflateBac:

; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  00114	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00119	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0011c	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv79[rsp], eax
  00123	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv79[rsp]
  0012a	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  0012f	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv79[rsp], eax
  00136	83 bc 24 c0 00
	00 00 12	 cmp	 DWORD PTR tv79[rsp], 18
  0013e	0f 87 fc 1b 00
	00		 ja	 $LN341@inflateBac
  00144	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR tv79[rsp]
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00153	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN385@inflateBac[rcx+rax*4]
  0015a	48 03 c1	 add	 rax, rcx
  0015d	ff e0		 jmp	 rax
$LN255@inflateBac:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  0015f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00164	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  00168	74 3e		 je	 SHORT $LN256@inflateBac
$LN9@inflateBac:

; 295  :                 BYTEBITS();

  0016a	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  0016e	83 e0 07	 and	 eax, 7
  00171	0f b6 c8	 movzx	 ecx, al
  00174	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00178	d3 e8		 shr	 eax, cl
  0017a	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0017e	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00182	83 e0 07	 and	 eax, 7
  00185	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00189	2b c8		 sub	 ecx, eax
  0018b	8b c1		 mov	 eax, ecx
  0018d	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00191	33 c0		 xor	 eax, eax
  00193	85 c0		 test	 eax, eax
  00195	75 d3		 jne	 SHORT $LN9@inflateBac

; 296  :                 state->mode = DONE;

  00197	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0019c	c7 40 08 50 3f
	00 00		 mov	 DWORD PTR [rax+8], 16208 ; 00003f50H

; 297  :                 break;

  001a3	e9 a5 1b 00 00	 jmp	 $LN5@inflateBac
$LN256@inflateBac:
$LN12@inflateBac:
$LN13@inflateBac:

; 298  :             }
; 299  :             NEEDBITS(3);

  001a8	83 7c 24 6c 03	 cmp	 DWORD PTR bits$[rsp], 3
  001ad	0f 83 90 00 00
	00		 jae	 $LN14@inflateBac
$LN17@inflateBac:
$LN20@inflateBac:
  001b3	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  001b8	75 38		 jne	 SHORT $LN257@inflateBac
  001ba	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  001bf	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  001c7	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  001ce	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  001d2	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  001d7	75 19		 jne	 SHORT $LN258@inflateBac
  001d9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  001e2	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  001ed	e9 60 1b 00 00	 jmp	 $inf_leave$387
$LN258@inflateBac:
$LN257@inflateBac:
  001f2	33 c0		 xor	 eax, eax
  001f4	85 c0		 test	 eax, eax
  001f6	75 bb		 jne	 SHORT $LN20@inflateBac
  001f8	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  001fc	ff c8		 dec	 eax
  001fe	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00202	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00207	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0020a	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  0020e	d3 e0		 shl	 eax, cl
  00210	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  00214	03 c8		 add	 ecx, eax
  00216	8b c1		 mov	 eax, ecx
  00218	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0021c	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00221	48 ff c0	 inc	 rax
  00224	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  00229	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  0022d	83 c0 08	 add	 eax, 8
  00230	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00234	33 c0		 xor	 eax, eax
  00236	85 c0		 test	 eax, eax
  00238	0f 85 75 ff ff
	ff		 jne	 $LN17@inflateBac
  0023e	e9 65 ff ff ff	 jmp	 $LN13@inflateBac
$LN14@inflateBac:
  00243	33 c0		 xor	 eax, eax
  00245	85 c0		 test	 eax, eax
  00247	0f 85 5b ff ff
	ff		 jne	 $LN12@inflateBac

; 300  :             state->last = BITS(1);

  0024d	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00251	83 e0 01	 and	 eax, 1
  00254	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00259	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
$LN23@inflateBac:

; 301  :             DROPBITS(1);

  0025c	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00260	d1 e8		 shr	 eax, 1
  00262	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00266	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  0026a	ff c8		 dec	 eax
  0026c	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00270	33 c0		 xor	 eax, eax
  00272	85 c0		 test	 eax, eax
  00274	75 e6		 jne	 SHORT $LN23@inflateBac

; 302  :             switch (BITS(2)) {

  00276	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  0027a	83 e0 03	 and	 eax, 3
  0027d	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv141[rsp], eax
  00284	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR tv141[rsp], 0
  0028c	74 20		 je	 SHORT $LN259@inflateBac
  0028e	83 bc 24 c4 00
	00 00 01	 cmp	 DWORD PTR tv141[rsp], 1
  00296	74 24		 je	 SHORT $LN260@inflateBac
  00298	83 bc 24 c4 00
	00 00 02	 cmp	 DWORD PTR tv141[rsp], 2
  002a0	74 35		 je	 SHORT $LN261@inflateBac
  002a2	83 bc 24 c4 00
	00 00 03	 cmp	 DWORD PTR tv141[rsp], 3
  002aa	74 39		 je	 SHORT $LN262@inflateBac
  002ac	eb 56		 jmp	 SHORT $LN24@inflateBac
$LN259@inflateBac:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  002ae	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  002b3	c7 40 08 41 3f
	00 00		 mov	 DWORD PTR [rax+8], 16193 ; 00003f41H

; 307  :                 break;

  002ba	eb 48		 jmp	 SHORT $LN24@inflateBac
$LN260@inflateBac:

; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  002bc	0f ae e8	 lfence
  002bf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  002c4	e8 00 00 00 00	 call	 fixedtables

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */

  002c9	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  002ce	c7 40 08 48 3f
	00 00		 mov	 DWORD PTR [rax+8], 16200 ; 00003f48H

; 313  :                 break;

  002d5	eb 2d		 jmp	 SHORT $LN24@inflateBac
$LN261@inflateBac:

; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;

  002d7	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  002dc	c7 40 08 44 3f
	00 00		 mov	 DWORD PTR [rax+8], 16196 ; 00003f44H

; 318  :                 break;

  002e3	eb 1f		 jmp	 SHORT $LN24@inflateBac
$LN262@inflateBac:

; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  002e5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  002ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@
  002f4	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 321  :                 state->mode = BAD;

  002f8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  002fd	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H
$LN24@inflateBac:
$LN28@inflateBac:

; 322  :             }
; 323  :             DROPBITS(2);

  00304	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00308	c1 e8 02	 shr	 eax, 2
  0030b	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0030f	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00313	83 e8 02	 sub	 eax, 2
  00316	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  0031a	33 c0		 xor	 eax, eax
  0031c	85 c0		 test	 eax, eax
  0031e	75 e4		 jne	 SHORT $LN28@inflateBac

; 324  :             break;

  00320	e9 28 1a 00 00	 jmp	 $LN5@inflateBac
$LN263@inflateBac:
$LN31@inflateBac:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  00325	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00329	83 e0 07	 and	 eax, 7
  0032c	0f b6 c8	 movzx	 ecx, al
  0032f	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00333	d3 e8		 shr	 eax, cl
  00335	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00339	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  0033d	83 e0 07	 and	 eax, 7
  00340	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00344	2b c8		 sub	 ecx, eax
  00346	8b c1		 mov	 eax, ecx
  00348	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  0034c	33 c0		 xor	 eax, eax
  0034e	85 c0		 test	 eax, eax
  00350	75 d3		 jne	 SHORT $LN31@inflateBac
$LN34@inflateBac:
$LN35@inflateBac:

; 329  :             NEEDBITS(32);

  00352	83 7c 24 6c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  00357	0f 83 90 00 00
	00		 jae	 $LN36@inflateBac
$LN39@inflateBac:
$LN42@inflateBac:
  0035d	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00362	75 38		 jne	 SHORT $LN264@inflateBac
  00364	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  00369	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00371	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  00378	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  0037c	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00381	75 19		 jne	 SHORT $LN265@inflateBac
  00383	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0038c	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  00397	e9 b6 19 00 00	 jmp	 $inf_leave$387
$LN265@inflateBac:
$LN264@inflateBac:
  0039c	33 c0		 xor	 eax, eax
  0039e	85 c0		 test	 eax, eax
  003a0	75 bb		 jne	 SHORT $LN42@inflateBac
  003a2	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  003a6	ff c8		 dec	 eax
  003a8	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  003ac	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  003b1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003b4	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  003b8	d3 e0		 shl	 eax, cl
  003ba	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  003be	03 c8		 add	 ecx, eax
  003c0	8b c1		 mov	 eax, ecx
  003c2	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  003c6	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  003cb	48 ff c0	 inc	 rax
  003ce	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  003d3	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  003d7	83 c0 08	 add	 eax, 8
  003da	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  003de	33 c0		 xor	 eax, eax
  003e0	85 c0		 test	 eax, eax
  003e2	0f 85 75 ff ff
	ff		 jne	 $LN39@inflateBac
  003e8	e9 65 ff ff ff	 jmp	 $LN35@inflateBac
$LN36@inflateBac:
  003ed	33 c0		 xor	 eax, eax
  003ef	85 c0		 test	 eax, eax
  003f1	0f 85 5b ff ff
	ff		 jne	 $LN34@inflateBac

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  003f7	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  003fb	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00400	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  00404	c1 e9 10	 shr	 ecx, 16
  00407	81 f1 ff ff 00
	00		 xor	 ecx, 65535		; 0000ffffH
  0040d	3b c1		 cmp	 eax, ecx
  0040f	74 24		 je	 SHORT $LN266@inflateBac

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  00411	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00419	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  00420	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 332  :                 state->mode = BAD;

  00424	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00429	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 333  :                 break;

  00430	e9 18 19 00 00	 jmp	 $LN5@inflateBac
$LN266@inflateBac:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;

  00435	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00439	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0043e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00443	89 41 50	 mov	 DWORD PTR [rcx+80], eax
$LN45@inflateBac:

; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  00446	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  0044e	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00456	33 c0		 xor	 eax, eax
  00458	85 c0		 test	 eax, eax
  0045a	75 ea		 jne	 SHORT $LN45@inflateBac
$LN46@inflateBac:

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  0045c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00461	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  00465	0f 84 4f 01 00
	00		 je	 $LN47@inflateBac

; 342  :                 copy = state->length;

  0046b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00470	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  00473	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax
$LN50@inflateBac:

; 343  :                 PULL();

  00477	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  0047c	75 38		 jne	 SHORT $LN267@inflateBac
  0047e	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  00483	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0048b	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  00492	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00496	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  0049b	75 19		 jne	 SHORT $LN268@inflateBac
  0049d	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  004a6	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  004b1	e9 9c 18 00 00	 jmp	 $inf_leave$387
$LN268@inflateBac:
$LN267@inflateBac:
  004b6	33 c0		 xor	 eax, eax
  004b8	85 c0		 test	 eax, eax
  004ba	75 bb		 jne	 SHORT $LN50@inflateBac
$LN53@inflateBac:

; 344  :                 ROOM();

  004bc	83 7c 24 64 00	 cmp	 DWORD PTR left$[rsp], 0
  004c1	75 53		 jne	 SHORT $LN269@inflateBac
  004c3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  004c8	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  004cc	48 89 44 24 58	 mov	 QWORD PTR put$[rsp], rax
  004d1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  004d6	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  004d9	89 44 24 64	 mov	 DWORD PTR left$[rsp], eax
  004dd	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  004e2	8b 4c 24 64	 mov	 ecx, DWORD PTR left$[rsp]
  004e6	89 48 38	 mov	 DWORD PTR [rax+56], ecx
  004e9	44 8b 44 24 64	 mov	 r8d, DWORD PTR left$[rsp]
  004ee	48 8b 54 24 58	 mov	 rdx, QWORD PTR put$[rsp]
  004f3	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  004fb	ff 94 24 38 01
	00 00		 call	 QWORD PTR out$[rsp]
  00502	85 c0		 test	 eax, eax
  00504	74 10		 je	 SHORT $LN270@inflateBac
  00506	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  00511	e9 3c 18 00 00	 jmp	 $inf_leave$387
$LN270@inflateBac:
$LN269@inflateBac:
  00516	33 c0		 xor	 eax, eax
  00518	85 c0		 test	 eax, eax
  0051a	75 a0		 jne	 SHORT $LN53@inflateBac

; 345  :                 if (copy > have) copy = have;

  0051c	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  00520	39 44 24 70	 cmp	 DWORD PTR copy$[rsp], eax
  00524	76 08		 jbe	 SHORT $LN271@inflateBac
  00526	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  0052a	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax
$LN271@inflateBac:

; 346  :                 if (copy > left) copy = left;

  0052e	8b 44 24 64	 mov	 eax, DWORD PTR left$[rsp]
  00532	39 44 24 70	 cmp	 DWORD PTR copy$[rsp], eax
  00536	76 08		 jbe	 SHORT $LN272@inflateBac
  00538	8b 44 24 64	 mov	 eax, DWORD PTR left$[rsp]
  0053c	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax
$LN272@inflateBac:

; 347  :                 zmemcpy(put, next, copy);

  00540	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  00544	44 8b c0	 mov	 r8d, eax
  00547	48 8b 54 24 48	 mov	 rdx, QWORD PTR next$[rsp]
  0054c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR put$[rsp]
  00551	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 348  :                 have -= copy;

  00557	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  0055b	8b 4c 24 60	 mov	 ecx, DWORD PTR have$[rsp]
  0055f	2b c8		 sub	 ecx, eax
  00561	8b c1		 mov	 eax, ecx
  00563	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax

; 349  :                 next += copy;

  00567	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  0056b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR next$[rsp]
  00570	48 03 c8	 add	 rcx, rax
  00573	48 8b c1	 mov	 rax, rcx
  00576	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax

; 350  :                 left -= copy;

  0057b	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  0057f	8b 4c 24 64	 mov	 ecx, DWORD PTR left$[rsp]
  00583	2b c8		 sub	 ecx, eax
  00585	8b c1		 mov	 eax, ecx
  00587	89 44 24 64	 mov	 DWORD PTR left$[rsp], eax

; 351  :                 put += copy;

  0058b	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  0058f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR put$[rsp]
  00594	48 03 c8	 add	 rcx, rax
  00597	48 8b c1	 mov	 rax, rcx
  0059a	48 89 44 24 58	 mov	 QWORD PTR put$[rsp], rax

; 352  :                 state->length -= copy;

  0059f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  005a4	8b 4c 24 70	 mov	 ecx, DWORD PTR copy$[rsp]
  005a8	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  005ab	2b c1		 sub	 eax, ecx
  005ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  005b2	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 353  :             }

  005b5	e9 a2 fe ff ff	 jmp	 $LN46@inflateBac
$LN47@inflateBac:

; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  005ba	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  005bf	c7 40 08 3f 3f
	00 00		 mov	 DWORD PTR [rax+8], 16191 ; 00003f3fH

; 356  :             break;

  005c6	e9 82 17 00 00	 jmp	 $LN5@inflateBac
$LN273@inflateBac:
$LN56@inflateBac:
$LN57@inflateBac:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  005cb	83 7c 24 6c 0e	 cmp	 DWORD PTR bits$[rsp], 14
  005d0	0f 83 90 00 00
	00		 jae	 $LN58@inflateBac
$LN61@inflateBac:
$LN64@inflateBac:
  005d6	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  005db	75 38		 jne	 SHORT $LN274@inflateBac
  005dd	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  005e2	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  005ea	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  005f1	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  005f5	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  005fa	75 19		 jne	 SHORT $LN275@inflateBac
  005fc	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00605	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  00610	e9 3d 17 00 00	 jmp	 $inf_leave$387
$LN275@inflateBac:
$LN274@inflateBac:
  00615	33 c0		 xor	 eax, eax
  00617	85 c0		 test	 eax, eax
  00619	75 bb		 jne	 SHORT $LN64@inflateBac
  0061b	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  0061f	ff c8		 dec	 eax
  00621	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00625	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  0062a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0062d	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00631	d3 e0		 shl	 eax, cl
  00633	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  00637	03 c8		 add	 ecx, eax
  00639	8b c1		 mov	 eax, ecx
  0063b	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0063f	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00644	48 ff c0	 inc	 rax
  00647	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  0064c	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00650	83 c0 08	 add	 eax, 8
  00653	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00657	33 c0		 xor	 eax, eax
  00659	85 c0		 test	 eax, eax
  0065b	0f 85 75 ff ff
	ff		 jne	 $LN61@inflateBac
  00661	e9 65 ff ff ff	 jmp	 $LN57@inflateBac
$LN58@inflateBac:
  00666	33 c0		 xor	 eax, eax
  00668	85 c0		 test	 eax, eax
  0066a	0f 85 5b ff ff
	ff		 jne	 $LN56@inflateBac

; 361  :             state->nlen = BITS(5) + 257;

  00670	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00674	83 e0 1f	 and	 eax, 31
  00677	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0067c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00681	89 41 7c	 mov	 DWORD PTR [rcx+124], eax
$LN67@inflateBac:

; 362  :             DROPBITS(5);

  00684	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00688	c1 e8 05	 shr	 eax, 5
  0068b	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0068f	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00693	83 e8 05	 sub	 eax, 5
  00696	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  0069a	33 c0		 xor	 eax, eax
  0069c	85 c0		 test	 eax, eax
  0069e	75 e4		 jne	 SHORT $LN67@inflateBac

; 363  :             state->ndist = BITS(5) + 1;

  006a0	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  006a4	83 e0 1f	 and	 eax, 31
  006a7	ff c0		 inc	 eax
  006a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  006ae	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax
$LN70@inflateBac:

; 364  :             DROPBITS(5);

  006b4	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  006b8	c1 e8 05	 shr	 eax, 5
  006bb	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  006bf	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  006c3	83 e8 05	 sub	 eax, 5
  006c6	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  006ca	33 c0		 xor	 eax, eax
  006cc	85 c0		 test	 eax, eax
  006ce	75 e4		 jne	 SHORT $LN70@inflateBac

; 365  :             state->ncode = BITS(4) + 4;

  006d0	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  006d4	83 e0 0f	 and	 eax, 15
  006d7	83 c0 04	 add	 eax, 4
  006da	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  006df	89 41 78	 mov	 DWORD PTR [rcx+120], eax
$LN73@inflateBac:

; 366  :             DROPBITS(4);

  006e2	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  006e6	c1 e8 04	 shr	 eax, 4
  006e9	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  006ed	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  006f1	83 e8 04	 sub	 eax, 4
  006f4	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  006f8	33 c0		 xor	 eax, eax
  006fa	85 c0		 test	 eax, eax
  006fc	75 e4		 jne	 SHORT $LN73@inflateBac

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  006fe	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00703	81 78 7c 1e 01
	00 00		 cmp	 DWORD PTR [rax+124], 286 ; 0000011eH
  0070a	77 0e		 ja	 SHORT $LN277@inflateBac
  0070c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00711	83 b8 80 00 00
	00 1e		 cmp	 DWORD PTR [rax+128], 30
  00718	76 24		 jbe	 SHORT $LN276@inflateBac
$LN277@inflateBac:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  0071a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00722	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00729	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 370  :                 state->mode = BAD;

  0072d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00732	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 371  :                 break;

  00739	e9 0f 16 00 00	 jmp	 $LN5@inflateBac
$LN276@inflateBac:

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  0073e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00743	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0
$LN74@inflateBac:

; 378  :             while (state->have < state->ncode) {

  0074d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00752	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00757	8b 49 78	 mov	 ecx, DWORD PTR [rcx+120]
  0075a	39 88 84 00 00
	00		 cmp	 DWORD PTR [rax+132], ecx
  00760	0f 83 0b 01 00
	00		 jae	 $LN75@inflateBac
$LN78@inflateBac:
$LN79@inflateBac:

; 379  :                 NEEDBITS(3);

  00766	83 7c 24 6c 03	 cmp	 DWORD PTR bits$[rsp], 3
  0076b	0f 83 90 00 00
	00		 jae	 $LN80@inflateBac
$LN83@inflateBac:
$LN86@inflateBac:
  00771	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00776	75 38		 jne	 SHORT $LN278@inflateBac
  00778	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  0077d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00785	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  0078c	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00790	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00795	75 19		 jne	 SHORT $LN279@inflateBac
  00797	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  007a0	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  007ab	e9 a2 15 00 00	 jmp	 $inf_leave$387
$LN279@inflateBac:
$LN278@inflateBac:
  007b0	33 c0		 xor	 eax, eax
  007b2	85 c0		 test	 eax, eax
  007b4	75 bb		 jne	 SHORT $LN86@inflateBac
  007b6	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  007ba	ff c8		 dec	 eax
  007bc	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  007c0	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  007c5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007c8	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  007cc	d3 e0		 shl	 eax, cl
  007ce	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  007d2	03 c8		 add	 ecx, eax
  007d4	8b c1		 mov	 eax, ecx
  007d6	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  007da	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  007df	48 ff c0	 inc	 rax
  007e2	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  007e7	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  007eb	83 c0 08	 add	 eax, 8
  007ee	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  007f2	33 c0		 xor	 eax, eax
  007f4	85 c0		 test	 eax, eax
  007f6	0f 85 75 ff ff
	ff		 jne	 $LN83@inflateBac
  007fc	e9 65 ff ff ff	 jmp	 $LN79@inflateBac
$LN80@inflateBac:
  00801	33 c0		 xor	 eax, eax
  00803	85 c0		 test	 eax, eax
  00805	0f 85 5b ff ff
	ff		 jne	 $LN78@inflateBac

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  0080b	0f ae e8	 lfence
  0080e	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00812	83 e0 07	 and	 eax, 7
  00815	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0081a	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00820	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?order@?1??inflateBack@@9@9
  00827	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  0082b	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  00830	66 89 84 4a 90
	00 00 00	 mov	 WORD PTR [rdx+rcx*2+144], ax
  00838	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0083d	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00843	ff c0		 inc	 eax
  00845	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0084a	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax
$LN89@inflateBac:

; 381  :                 DROPBITS(3);

  00850	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00854	c1 e8 03	 shr	 eax, 3
  00857	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0085b	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  0085f	83 e8 03	 sub	 eax, 3
  00862	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00866	33 c0		 xor	 eax, eax
  00868	85 c0		 test	 eax, eax
  0086a	75 e4		 jne	 SHORT $LN89@inflateBac

; 382  :             }

  0086c	e9 dc fe ff ff	 jmp	 $LN74@inflateBac
$LN75@inflateBac:
$LN90@inflateBac:

; 383  :             while (state->have < 19)

  00871	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00876	83 b8 84 00 00
	00 13		 cmp	 DWORD PTR [rax+132], 19
  0087d	73 3f		 jae	 SHORT $LN91@inflateBac

; 384  :                 state->lens[order[state->have++]] = 0;

  0087f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00884	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0088a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?order@?1??inflateBack@@9@9
  00891	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00895	33 c9		 xor	 ecx, ecx
  00897	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  0089c	66 89 8c 42 90
	00 00 00	 mov	 WORD PTR [rdx+rax*2+144], cx
  008a4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  008a9	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  008af	ff c0		 inc	 eax
  008b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  008b6	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax
  008bc	eb b3		 jmp	 SHORT $LN90@inflateBac
$LN91@inflateBac:

; 385  :             state->next = state->codes;

  008be	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  008c3	48 05 50 05 00
	00		 add	 rax, 1360		; 00000550H
  008c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  008ce	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 386  :             state->lencode = (code const FAR *)(state->next);

  008d5	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  008da	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  008df	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  008e6	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 387  :             state->lenbits = 7;

  008ea	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  008ef	c7 40 70 07 00
	00 00		 mov	 DWORD PTR [rax+112], 7

; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  008f6	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  008fb	48 05 10 03 00
	00		 add	 rax, 784		; 00000310H
  00901	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00906	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0090a	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  0090f	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  00916	4c 8b 44 24 30	 mov	 r8, QWORD PTR state$[rsp]
  0091b	49 81 c0 90 00
	00 00		 add	 r8, 144			; 00000090H
  00922	4c 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv319[rsp], r8
  0092a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0092f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00934	4c 8b ca	 mov	 r9, rdx
  00937	41 b8 13 00 00
	00		 mov	 r8d, 19
  0093d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv319[rsp]
  00945	48 8b d0	 mov	 rdx, rax
  00948	33 c9		 xor	 ecx, ecx
  0094a	e8 00 00 00 00	 call	 inflate_table
  0094f	89 84 24 b8 00
	00 00		 mov	 DWORD PTR ret$[rsp], eax

; 389  :                                 &(state->lenbits), state->work);
; 390  :             if (ret) {

  00956	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR ret$[rsp], 0
  0095e	74 24		 je	 SHORT $LN280@inflateBac

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  00960	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00968	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  0096f	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 392  :                 state->mode = BAD;

  00973	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00978	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 393  :                 break;

  0097f	e9 c9 13 00 00	 jmp	 $LN5@inflateBac
$LN280@inflateBac:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;

  00984	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00989	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0
$LN92@inflateBac:

; 399  :             while (state->have < state->nlen + state->ndist) {

  00993	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00998	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  0099b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  009a0	03 81 80 00 00
	00		 add	 eax, DWORD PTR [rcx+128]
  009a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  009ab	39 81 84 00 00
	00		 cmp	 DWORD PTR [rcx+132], eax
  009b1	0f 83 b2 05 00
	00		 jae	 $LN93@inflateBac
$LN94@inflateBac:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  009b7	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  009bc	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  009bf	b9 01 00 00 00	 mov	 ecx, 1
  009c4	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv1220[rsp], ecx
  009cb	0f b6 c8	 movzx	 ecx, al
  009ce	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv1220[rsp]
  009d5	d3 e0		 shl	 eax, cl
  009d7	ff c8		 dec	 eax
  009d9	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  009dd	23 c8		 and	 ecx, eax
  009df	8b c1		 mov	 eax, ecx
  009e1	8b c0		 mov	 eax, eax
  009e3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  009e8	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  009ec	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  009ef	89 84 24 84 00
	00 00		 mov	 DWORD PTR here$[rsp], eax

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  009f6	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  009fe	3b 44 24 6c	 cmp	 eax, DWORD PTR bits$[rsp]
  00a02	77 05		 ja	 SHORT $LN281@inflateBac
  00a04	e9 90 00 00 00	 jmp	 $LN95@inflateBac
$LN281@inflateBac:
$LN99@inflateBac:
$LN102@inflateBac:

; 403  :                     PULLBYTE();

  00a09	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00a0e	75 38		 jne	 SHORT $LN282@inflateBac
  00a10	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  00a15	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00a1d	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  00a24	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00a28	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00a2d	75 19		 jne	 SHORT $LN283@inflateBac
  00a2f	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00a38	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  00a43	e9 0a 13 00 00	 jmp	 $inf_leave$387
$LN283@inflateBac:
$LN282@inflateBac:
  00a48	33 c0		 xor	 eax, eax
  00a4a	85 c0		 test	 eax, eax
  00a4c	75 bb		 jne	 SHORT $LN102@inflateBac
  00a4e	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  00a52	ff c8		 dec	 eax
  00a54	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00a58	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00a5d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a60	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00a64	d3 e0		 shl	 eax, cl
  00a66	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  00a6a	03 c8		 add	 ecx, eax
  00a6c	8b c1		 mov	 eax, ecx
  00a6e	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00a72	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00a77	48 ff c0	 inc	 rax
  00a7a	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  00a7f	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00a83	83 c0 08	 add	 eax, 8
  00a86	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00a8a	33 c0		 xor	 eax, eax
  00a8c	85 c0		 test	 eax, eax
  00a8e	0f 85 75 ff ff
	ff		 jne	 $LN99@inflateBac

; 404  :                 }

  00a94	e9 1e ff ff ff	 jmp	 $LN94@inflateBac
$LN95@inflateBac:

; 405  :                 if (here.val < 16) {

  00a99	0f b7 84 24 86
	00 00 00	 movzx	 eax, WORD PTR here$[rsp+2]
  00aa1	83 f8 10	 cmp	 eax, 16
  00aa4	7d 6f		 jge	 SHORT $LN284@inflateBac
  00aa6	0f ae e8	 lfence
$LN105@inflateBac:

; 406  :                     DROPBITS(here.bits);

  00aa9	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00ab1	0f b6 c8	 movzx	 ecx, al
  00ab4	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00ab8	d3 e8		 shr	 eax, cl
  00aba	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00abe	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00ac6	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00aca	2b c8		 sub	 ecx, eax
  00acc	8b c1		 mov	 eax, ecx
  00ace	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00ad2	33 c0		 xor	 eax, eax
  00ad4	85 c0		 test	 eax, eax
  00ad6	75 d1		 jne	 SHORT $LN105@inflateBac

; 407  :                     state->lens[state->have++] = here.val;

  00ad8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00add	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00ae3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00ae8	0f b7 94 24 86
	00 00 00	 movzx	 edx, WORD PTR here$[rsp+2]
  00af0	66 89 94 41 90
	00 00 00	 mov	 WORD PTR [rcx+rax*2+144], dx
  00af8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00afd	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00b03	ff c0		 inc	 eax
  00b05	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00b0a	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 408  :                 }

  00b10	e9 4f 04 00 00	 jmp	 $LN285@inflateBac
$LN284@inflateBac:

; 409  :                 else {
; 410  :                     if (here.val == 16) {

  00b15	0f b7 84 24 86
	00 00 00	 movzx	 eax, WORD PTR here$[rsp+2]
  00b1d	83 f8 10	 cmp	 eax, 16
  00b20	0f 85 62 01 00
	00		 jne	 $LN286@inflateBac
$LN108@inflateBac:
$LN109@inflateBac:

; 411  :                         NEEDBITS(here.bits + 2);

  00b26	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00b2e	83 c0 02	 add	 eax, 2
  00b31	39 44 24 6c	 cmp	 DWORD PTR bits$[rsp], eax
  00b35	0f 83 90 00 00
	00		 jae	 $LN110@inflateBac
$LN113@inflateBac:
$LN116@inflateBac:
  00b3b	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00b40	75 38		 jne	 SHORT $LN288@inflateBac
  00b42	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  00b47	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00b4f	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  00b56	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00b5a	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00b5f	75 19		 jne	 SHORT $LN289@inflateBac
  00b61	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00b6a	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  00b75	e9 d8 11 00 00	 jmp	 $inf_leave$387
$LN289@inflateBac:
$LN288@inflateBac:
  00b7a	33 c0		 xor	 eax, eax
  00b7c	85 c0		 test	 eax, eax
  00b7e	75 bb		 jne	 SHORT $LN116@inflateBac
  00b80	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  00b84	ff c8		 dec	 eax
  00b86	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00b8a	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00b8f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b92	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00b96	d3 e0		 shl	 eax, cl
  00b98	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  00b9c	03 c8		 add	 ecx, eax
  00b9e	8b c1		 mov	 eax, ecx
  00ba0	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00ba4	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00ba9	48 ff c0	 inc	 rax
  00bac	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  00bb1	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00bb5	83 c0 08	 add	 eax, 8
  00bb8	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00bbc	33 c0		 xor	 eax, eax
  00bbe	85 c0		 test	 eax, eax
  00bc0	0f 85 75 ff ff
	ff		 jne	 $LN113@inflateBac
  00bc6	e9 5b ff ff ff	 jmp	 $LN109@inflateBac
$LN110@inflateBac:
  00bcb	33 c0		 xor	 eax, eax
  00bcd	85 c0		 test	 eax, eax
  00bcf	0f 85 51 ff ff
	ff		 jne	 $LN108@inflateBac
$LN119@inflateBac:

; 412  :                         DROPBITS(here.bits);

  00bd5	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00bdd	0f b6 c8	 movzx	 ecx, al
  00be0	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00be4	d3 e8		 shr	 eax, cl
  00be6	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00bea	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00bf2	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00bf6	2b c8		 sub	 ecx, eax
  00bf8	8b c1		 mov	 eax, ecx
  00bfa	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00bfe	33 c0		 xor	 eax, eax
  00c00	85 c0		 test	 eax, eax
  00c02	75 d1		 jne	 SHORT $LN119@inflateBac

; 413  :                         if (state->have == 0) {

  00c04	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00c09	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00c10	75 24		 jne	 SHORT $LN290@inflateBac

; 414  :                             strm->msg = (char *)"invalid bit length repeat";

  00c12	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00c1a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00c21	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 415  :                             state->mode = BAD;

  00c25	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00c2a	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 416  :                             break;

  00c31	e9 33 03 00 00	 jmp	 $LN93@inflateBac
$LN290@inflateBac:

; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);

  00c36	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00c3b	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00c41	ff c8		 dec	 eax
  00c43	8b c0		 mov	 eax, eax
  00c45	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00c4a	0f b7 84 41 90
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+144]
  00c52	89 84 24 b4 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 419  :                         copy = 3 + BITS(2);

  00c59	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00c5d	83 e0 03	 and	 eax, 3
  00c60	83 c0 03	 add	 eax, 3
  00c63	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax
$LN122@inflateBac:

; 420  :                         DROPBITS(2);

  00c67	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00c6b	c1 e8 02	 shr	 eax, 2
  00c6e	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00c72	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00c76	83 e8 02	 sub	 eax, 2
  00c79	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00c7d	33 c0		 xor	 eax, eax
  00c7f	85 c0		 test	 eax, eax
  00c81	75 e4		 jne	 SHORT $LN122@inflateBac

; 421  :                     }

  00c83	e9 3c 02 00 00	 jmp	 $LN287@inflateBac
$LN286@inflateBac:

; 422  :                     else if (here.val == 17) {

  00c88	0f b7 84 24 86
	00 00 00	 movzx	 eax, WORD PTR here$[rsp+2]
  00c90	83 f8 11	 cmp	 eax, 17
  00c93	0f 85 18 01 00
	00		 jne	 $LN291@inflateBac
$LN125@inflateBac:
$LN126@inflateBac:

; 423  :                         NEEDBITS(here.bits + 3);

  00c99	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00ca1	83 c0 03	 add	 eax, 3
  00ca4	39 44 24 6c	 cmp	 DWORD PTR bits$[rsp], eax
  00ca8	0f 83 90 00 00
	00		 jae	 $LN127@inflateBac
$LN130@inflateBac:
$LN133@inflateBac:
  00cae	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00cb3	75 38		 jne	 SHORT $LN293@inflateBac
  00cb5	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  00cba	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00cc2	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  00cc9	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00ccd	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00cd2	75 19		 jne	 SHORT $LN294@inflateBac
  00cd4	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00cdd	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  00ce8	e9 65 10 00 00	 jmp	 $inf_leave$387
$LN294@inflateBac:
$LN293@inflateBac:
  00ced	33 c0		 xor	 eax, eax
  00cef	85 c0		 test	 eax, eax
  00cf1	75 bb		 jne	 SHORT $LN133@inflateBac
  00cf3	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  00cf7	ff c8		 dec	 eax
  00cf9	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00cfd	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00d02	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00d05	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00d09	d3 e0		 shl	 eax, cl
  00d0b	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  00d0f	03 c8		 add	 ecx, eax
  00d11	8b c1		 mov	 eax, ecx
  00d13	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00d17	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00d1c	48 ff c0	 inc	 rax
  00d1f	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  00d24	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00d28	83 c0 08	 add	 eax, 8
  00d2b	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00d2f	33 c0		 xor	 eax, eax
  00d31	85 c0		 test	 eax, eax
  00d33	0f 85 75 ff ff
	ff		 jne	 $LN130@inflateBac
  00d39	e9 5b ff ff ff	 jmp	 $LN126@inflateBac
$LN127@inflateBac:
  00d3e	33 c0		 xor	 eax, eax
  00d40	85 c0		 test	 eax, eax
  00d42	0f 85 51 ff ff
	ff		 jne	 $LN125@inflateBac
$LN136@inflateBac:

; 424  :                         DROPBITS(here.bits);

  00d48	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00d50	0f b6 c8	 movzx	 ecx, al
  00d53	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00d57	d3 e8		 shr	 eax, cl
  00d59	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00d5d	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00d65	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00d69	2b c8		 sub	 ecx, eax
  00d6b	8b c1		 mov	 eax, ecx
  00d6d	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00d71	33 c0		 xor	 eax, eax
  00d73	85 c0		 test	 eax, eax
  00d75	75 d1		 jne	 SHORT $LN136@inflateBac

; 425  :                         len = 0;

  00d77	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR len$[rsp], 0

; 426  :                         copy = 3 + BITS(3);

  00d82	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00d86	83 e0 07	 and	 eax, 7
  00d89	83 c0 03	 add	 eax, 3
  00d8c	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax
$LN139@inflateBac:

; 427  :                         DROPBITS(3);

  00d90	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00d94	c1 e8 03	 shr	 eax, 3
  00d97	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00d9b	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00d9f	83 e8 03	 sub	 eax, 3
  00da2	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00da6	33 c0		 xor	 eax, eax
  00da8	85 c0		 test	 eax, eax
  00daa	75 e4		 jne	 SHORT $LN139@inflateBac

; 428  :                     }

  00dac	e9 13 01 00 00	 jmp	 $LN292@inflateBac
$LN291@inflateBac:
$LN142@inflateBac:
$LN143@inflateBac:

; 429  :                     else {
; 430  :                         NEEDBITS(here.bits + 7);

  00db1	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00db9	83 c0 07	 add	 eax, 7
  00dbc	39 44 24 6c	 cmp	 DWORD PTR bits$[rsp], eax
  00dc0	0f 83 90 00 00
	00		 jae	 $LN144@inflateBac
$LN147@inflateBac:
$LN150@inflateBac:
  00dc6	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00dcb	75 38		 jne	 SHORT $LN295@inflateBac
  00dcd	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  00dd2	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00dda	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  00de1	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00de5	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  00dea	75 19		 jne	 SHORT $LN296@inflateBac
  00dec	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00df5	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  00e00	e9 4d 0f 00 00	 jmp	 $inf_leave$387
$LN296@inflateBac:
$LN295@inflateBac:
  00e05	33 c0		 xor	 eax, eax
  00e07	85 c0		 test	 eax, eax
  00e09	75 bb		 jne	 SHORT $LN150@inflateBac
  00e0b	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  00e0f	ff c8		 dec	 eax
  00e11	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  00e15	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00e1a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e1d	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00e21	d3 e0		 shl	 eax, cl
  00e23	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  00e27	03 c8		 add	 ecx, eax
  00e29	8b c1		 mov	 eax, ecx
  00e2b	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00e2f	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  00e34	48 ff c0	 inc	 rax
  00e37	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  00e3c	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00e40	83 c0 08	 add	 eax, 8
  00e43	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00e47	33 c0		 xor	 eax, eax
  00e49	85 c0		 test	 eax, eax
  00e4b	0f 85 75 ff ff
	ff		 jne	 $LN147@inflateBac
  00e51	e9 5b ff ff ff	 jmp	 $LN143@inflateBac
$LN144@inflateBac:
  00e56	33 c0		 xor	 eax, eax
  00e58	85 c0		 test	 eax, eax
  00e5a	0f 85 51 ff ff
	ff		 jne	 $LN142@inflateBac
$LN153@inflateBac:

; 431  :                         DROPBITS(here.bits);

  00e60	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00e68	0f b6 c8	 movzx	 ecx, al
  00e6b	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00e6f	d3 e8		 shr	 eax, cl
  00e71	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00e75	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  00e7d	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  00e81	2b c8		 sub	 ecx, eax
  00e83	8b c1		 mov	 eax, ecx
  00e85	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00e89	33 c0		 xor	 eax, eax
  00e8b	85 c0		 test	 eax, eax
  00e8d	75 d1		 jne	 SHORT $LN153@inflateBac

; 432  :                         len = 0;

  00e8f	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR len$[rsp], 0

; 433  :                         copy = 11 + BITS(7);

  00e9a	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00e9e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00ea1	83 c0 0b	 add	 eax, 11
  00ea4	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax
$LN156@inflateBac:

; 434  :                         DROPBITS(7);

  00ea8	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  00eac	c1 e8 07	 shr	 eax, 7
  00eaf	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  00eb3	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  00eb7	83 e8 07	 sub	 eax, 7
  00eba	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  00ebe	33 c0		 xor	 eax, eax
  00ec0	85 c0		 test	 eax, eax
  00ec2	75 e4		 jne	 SHORT $LN156@inflateBac
$LN292@inflateBac:
$LN287@inflateBac:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  00ec4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00ec9	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00ecf	03 44 24 70	 add	 eax, DWORD PTR copy$[rsp]
  00ed3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00ed8	8b 49 7c	 mov	 ecx, DWORD PTR [rcx+124]
  00edb	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  00ee0	03 8a 80 00 00
	00		 add	 ecx, DWORD PTR [rdx+128]
  00ee6	3b c1		 cmp	 eax, ecx
  00ee8	76 21		 jbe	 SHORT $LN297@inflateBac

; 437  :                         strm->msg = (char *)"invalid bit length repeat";

  00eea	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00ef2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00ef9	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 438  :                         state->mode = BAD;

  00efd	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00f02	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 439  :                         break;

  00f09	eb 5e		 jmp	 SHORT $LN93@inflateBac
$LN297@inflateBac:
$LN157@inflateBac:

; 440  :                     }
; 441  :                     while (copy--)

  00f0b	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  00f0f	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv475[rsp], eax
  00f16	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  00f1a	ff c8		 dec	 eax
  00f1c	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax
  00f20	83 bc 24 d4 00
	00 00 00	 cmp	 DWORD PTR tv475[rsp], 0
  00f28	74 3a		 je	 SHORT $LN158@inflateBac

; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00f2a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00f2f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00f35	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00f3a	0f b7 94 24 b4
	00 00 00	 movzx	 edx, WORD PTR len$[rsp]
  00f42	66 89 94 41 90
	00 00 00	 mov	 WORD PTR [rcx+rax*2+144], dx
  00f4a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00f4f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00f55	ff c0		 inc	 eax
  00f57	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00f5c	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax
  00f62	eb a7		 jmp	 SHORT $LN157@inflateBac
$LN158@inflateBac:
$LN285@inflateBac:

; 443  :                 }
; 444  :             }

  00f64	e9 2a fa ff ff	 jmp	 $LN92@inflateBac
$LN93@inflateBac:

; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  00f69	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00f6e	81 78 08 51 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16209 ; 00003f51H
  00f75	75 05		 jne	 SHORT $LN298@inflateBac
  00f77	e9 d1 0d 00 00	 jmp	 $LN5@inflateBac
$LN298@inflateBac:

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  00f7c	b8 02 00 00 00	 mov	 eax, 2
  00f81	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  00f88	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00f8d	0f b7 84 01 90
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax+144]
  00f95	85 c0		 test	 eax, eax
  00f97	75 24		 jne	 SHORT $LN299@inflateBac

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00f99	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00fa1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00fa8	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 452  :                 state->mode = BAD;

  00fac	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00fb1	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 453  :                 break;

  00fb8	e9 90 0d 00 00	 jmp	 $LN5@inflateBac
$LN299@inflateBac:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  00fbd	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00fc2	48 05 50 05 00
	00		 add	 rax, 1360		; 00000550H
  00fc8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00fcd	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 460  :             state->lencode = (code const FAR *)(state->next);

  00fd4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00fd9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00fde	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00fe5	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 461  :             state->lenbits = 9;

  00fe9	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00fee	c7 40 70 09 00
	00 00		 mov	 DWORD PTR [rax+112], 9

; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00ff5	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00ffa	48 05 10 03 00
	00		 add	 rax, 784		; 00000310H
  01000	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01005	48 83 c1 70	 add	 rcx, 112		; 00000070H
  01009	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  0100e	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  01015	4c 8b 44 24 30	 mov	 r8, QWORD PTR state$[rsp]
  0101a	49 81 c0 90 00
	00 00		 add	 r8, 144			; 00000090H
  01021	4c 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv508[rsp], r8
  01029	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0102e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01033	4c 8b ca	 mov	 r9, rdx
  01036	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0103b	44 8b 40 7c	 mov	 r8d, DWORD PTR [rax+124]
  0103f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv508[rsp]
  01047	48 8b d0	 mov	 rdx, rax
  0104a	b9 01 00 00 00	 mov	 ecx, 1
  0104f	e8 00 00 00 00	 call	 inflate_table
  01054	89 84 24 b8 00
	00 00		 mov	 DWORD PTR ret$[rsp], eax

; 463  :                                 &(state->lenbits), state->work);
; 464  :             if (ret) {

  0105b	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR ret$[rsp], 0
  01063	74 24		 je	 SHORT $LN300@inflateBac

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  01065	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0106d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  01074	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 466  :                 state->mode = BAD;

  01078	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0107d	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 467  :                 break;

  01084	e9 c4 0c 00 00	 jmp	 $LN5@inflateBac
$LN300@inflateBac:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);

  01089	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0108e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01093	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  0109a	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 470  :             state->distbits = 6;

  0109e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  010a3	c7 40 74 06 00
	00 00		 mov	 DWORD PTR [rax+116], 6

; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  010aa	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  010af	48 05 10 03 00
	00		 add	 rax, 784		; 00000310H
  010b5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  010ba	48 83 c1 74	 add	 rcx, 116		; 00000074H
  010be	48 8b 54 24 30	 mov	 rdx, QWORD PTR state$[rsp]
  010c3	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  010ca	4c 8b 44 24 30	 mov	 r8, QWORD PTR state$[rsp]
  010cf	45 8b 40 7c	 mov	 r8d, DWORD PTR [r8+124]
  010d3	4c 8b 4c 24 30	 mov	 r9, QWORD PTR state$[rsp]
  010d8	4f 8d 84 41 90
	00 00 00	 lea	 r8, QWORD PTR [r9+r8*2+144]
  010e0	4c 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv530[rsp], r8
  010e8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  010ed	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  010f2	4c 8b ca	 mov	 r9, rdx
  010f5	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  010fa	44 8b 80 80 00
	00 00		 mov	 r8d, DWORD PTR [rax+128]
  01101	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv530[rsp]
  01109	48 8b d0	 mov	 rdx, rax
  0110c	b9 02 00 00 00	 mov	 ecx, 2
  01111	e8 00 00 00 00	 call	 inflate_table
  01116	89 84 24 b8 00
	00 00		 mov	 DWORD PTR ret$[rsp], eax

; 472  :                             &(state->next), &(state->distbits), state->work);
; 473  :             if (ret) {

  0111d	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR ret$[rsp], 0
  01125	74 24		 je	 SHORT $LN301@inflateBac

; 474  :                 strm->msg = (char *)"invalid distances set";

  01127	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0112f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  01136	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 475  :                 state->mode = BAD;

  0113a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0113f	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 476  :                 break;

  01146	e9 02 0c 00 00	 jmp	 $LN5@inflateBac
$LN301@inflateBac:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  0114b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01150	c7 40 08 48 3f
	00 00		 mov	 DWORD PTR [rax+8], 16200 ; 00003f48H
$LN302@inflateBac:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  01157	83 7c 24 60 06	 cmp	 DWORD PTR have$[rsp], 6
  0115c	0f 82 0d 01 00
	00		 jb	 $LN303@inflateBac
  01162	81 7c 24 64 02
	01 00 00	 cmp	 DWORD PTR left$[rsp], 258 ; 00000102H
  0116a	0f 82 ff 00 00
	00		 jb	 $LN303@inflateBac
  01170	0f ae e8	 lfence
$LN161@inflateBac:

; 484  :                 RESTORE();

  01173	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0117b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR put$[rsp]
  01180	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  01184	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0118c	8b 4c 24 64	 mov	 ecx, DWORD PTR left$[rsp]
  01190	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  01193	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0119b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR next$[rsp]
  011a0	48 89 08	 mov	 QWORD PTR [rax], rcx
  011a3	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  011ab	8b 4c 24 60	 mov	 ecx, DWORD PTR have$[rsp]
  011af	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  011b2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  011b7	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  011bb	89 48 48	 mov	 DWORD PTR [rax+72], ecx
  011be	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  011c3	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  011c7	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
  011ca	33 c0		 xor	 eax, eax
  011cc	85 c0		 test	 eax, eax
  011ce	75 a3		 jne	 SHORT $LN161@inflateBac

; 485  :                 if (state->whave < state->wsize)

  011d0	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  011d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  011da	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  011dd	39 48 38	 cmp	 DWORD PTR [rax+56], ecx
  011e0	73 16		 jae	 SHORT $LN304@inflateBac

; 486  :                     state->whave = state->wsize - left;

  011e2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  011e7	8b 4c 24 64	 mov	 ecx, DWORD PTR left$[rsp]
  011eb	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  011ee	2b c1		 sub	 eax, ecx
  011f0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  011f5	89 41 38	 mov	 DWORD PTR [rcx+56], eax
$LN304@inflateBac:

; 487  :                 inflate_fast(strm, state->wsize);

  011f8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  011fd	8b 50 34	 mov	 edx, DWORD PTR [rax+52]
  01200	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01208	e8 00 00 00 00	 call	 inflate_fast
$LN164@inflateBac:

; 488  :                 LOAD();

  0120d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01215	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01219	48 89 44 24 58	 mov	 QWORD PTR put$[rsp], rax
  0121e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01226	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01229	89 44 24 64	 mov	 DWORD PTR left$[rsp], eax
  0122d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01235	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01238	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  0123d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01245	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01248	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  0124c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01251	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01254	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  01258	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0125d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01260	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  01264	33 c0		 xor	 eax, eax
  01266	85 c0		 test	 eax, eax
  01268	75 a3		 jne	 SHORT $LN164@inflateBac

; 489  :                 break;

  0126a	e9 de 0a 00 00	 jmp	 $LN5@inflateBac
$LN303@inflateBac:
$LN165@inflateBac:

; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  0126f	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01274	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01277	b9 01 00 00 00	 mov	 ecx, 1
  0127c	89 8c 24 e8 00
	00 00		 mov	 DWORD PTR tv1397[rsp], ecx
  01283	0f b6 c8	 movzx	 ecx, al
  01286	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv1397[rsp]
  0128d	d3 e0		 shl	 eax, cl
  0128f	ff c8		 dec	 eax
  01291	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  01295	23 c8		 and	 ecx, eax
  01297	8b c1		 mov	 eax, ecx
  01299	8b c0		 mov	 eax, eax
  0129b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  012a0	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  012a4	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  012a7	89 84 24 84 00
	00 00		 mov	 DWORD PTR here$[rsp], eax

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  012ae	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  012b6	3b 44 24 6c	 cmp	 eax, DWORD PTR bits$[rsp]
  012ba	77 05		 ja	 SHORT $LN305@inflateBac
  012bc	e9 90 00 00 00	 jmp	 $LN166@inflateBac
$LN305@inflateBac:
$LN170@inflateBac:
$LN173@inflateBac:

; 496  :                 PULLBYTE();

  012c1	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  012c6	75 38		 jne	 SHORT $LN306@inflateBac
  012c8	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  012cd	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  012d5	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  012dc	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  012e0	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  012e5	75 19		 jne	 SHORT $LN307@inflateBac
  012e7	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  012f0	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  012fb	e9 52 0a 00 00	 jmp	 $inf_leave$387
$LN307@inflateBac:
$LN306@inflateBac:
  01300	33 c0		 xor	 eax, eax
  01302	85 c0		 test	 eax, eax
  01304	75 bb		 jne	 SHORT $LN173@inflateBac
  01306	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  0130a	ff c8		 dec	 eax
  0130c	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  01310	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  01315	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01318	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  0131c	d3 e0		 shl	 eax, cl
  0131e	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  01322	03 c8		 add	 ecx, eax
  01324	8b c1		 mov	 eax, ecx
  01326	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0132a	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  0132f	48 ff c0	 inc	 rax
  01332	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  01337	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  0133b	83 c0 08	 add	 eax, 8
  0133e	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  01342	33 c0		 xor	 eax, eax
  01344	85 c0		 test	 eax, eax
  01346	0f 85 75 ff ff
	ff		 jne	 $LN170@inflateBac

; 497  :             }

  0134c	e9 1e ff ff ff	 jmp	 $LN165@inflateBac
$LN166@inflateBac:

; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  01351	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp]
  01359	85 c0		 test	 eax, eax
  0135b	0f 84 60 01 00
	00		 je	 $LN308@inflateBac
  01361	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp]
  01369	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0136e	85 c0		 test	 eax, eax
  01370	0f 85 4b 01 00
	00		 jne	 $LN308@inflateBac

; 499  :                 last = here;

  01376	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR here$[rsp]
  0137d	89 84 24 a4 00
	00 00		 mov	 DWORD PTR last$[rsp], eax
$LN174@inflateBac:

; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +

  01384	0f b7 84 24 a6
	00 00 00	 movzx	 eax, WORD PTR last$[rsp+2]
  0138c	0f b6 8c 24 a5
	00 00 00	 movzx	 ecx, BYTE PTR last$[rsp+1]
  01394	0f b6 94 24 a4
	00 00 00	 movzx	 edx, BYTE PTR last$[rsp]
  0139c	03 ca		 add	 ecx, edx
  0139e	ba 01 00 00 00	 mov	 edx, 1
  013a3	d3 e2		 shl	 edx, cl
  013a5	8b ca		 mov	 ecx, edx
  013a7	ff c9		 dec	 ecx
  013a9	8b 54 24 68	 mov	 edx, DWORD PTR hold$[rsp]
  013ad	23 d1		 and	 edx, ecx
  013af	8b ca		 mov	 ecx, edx
  013b1	89 8c 24 ec 00
	00 00		 mov	 DWORD PTR tv598[rsp], ecx
  013b8	0f b6 94 24 a5
	00 00 00	 movzx	 edx, BYTE PTR last$[rsp+1]
  013c0	0f b6 ca	 movzx	 ecx, dl
  013c3	8b 94 24 ec 00
	00 00		 mov	 edx, DWORD PTR tv598[rsp]
  013ca	d3 ea		 shr	 edx, cl
  013cc	8b ca		 mov	 ecx, edx
  013ce	03 c1		 add	 eax, ecx
  013d0	8b c0		 mov	 eax, eax
  013d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  013d7	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  013db	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  013de	89 84 24 84 00
	00 00		 mov	 DWORD PTR here$[rsp], eax

; 502  :                             (BITS(last.bits + last.op) >> last.bits)];
; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  013e5	0f b6 84 24 a5
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  013ed	0f b6 8c 24 85
	00 00 00	 movzx	 ecx, BYTE PTR here$[rsp+1]
  013f5	03 c1		 add	 eax, ecx
  013f7	3b 44 24 6c	 cmp	 eax, DWORD PTR bits$[rsp]
  013fb	77 05		 ja	 SHORT $LN309@inflateBac
  013fd	e9 90 00 00 00	 jmp	 $LN175@inflateBac
$LN309@inflateBac:
$LN179@inflateBac:
$LN182@inflateBac:

; 504  :                     PULLBYTE();

  01402	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  01407	75 38		 jne	 SHORT $LN310@inflateBac
  01409	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  0140e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01416	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  0141d	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  01421	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  01426	75 19		 jne	 SHORT $LN311@inflateBac
  01428	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  01431	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  0143c	e9 11 09 00 00	 jmp	 $inf_leave$387
$LN311@inflateBac:
$LN310@inflateBac:
  01441	33 c0		 xor	 eax, eax
  01443	85 c0		 test	 eax, eax
  01445	75 bb		 jne	 SHORT $LN182@inflateBac
  01447	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  0144b	ff c8		 dec	 eax
  0144d	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  01451	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  01456	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01459	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  0145d	d3 e0		 shl	 eax, cl
  0145f	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  01463	03 c8		 add	 ecx, eax
  01465	8b c1		 mov	 eax, ecx
  01467	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0146b	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  01470	48 ff c0	 inc	 rax
  01473	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  01478	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  0147c	83 c0 08	 add	 eax, 8
  0147f	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  01483	33 c0		 xor	 eax, eax
  01485	85 c0		 test	 eax, eax
  01487	0f 85 75 ff ff
	ff		 jne	 $LN179@inflateBac

; 505  :                 }

  0148d	e9 f2 fe ff ff	 jmp	 $LN174@inflateBac
$LN175@inflateBac:
$LN185@inflateBac:

; 506  :                 DROPBITS(last.bits);

  01492	0f b6 84 24 a5
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  0149a	0f b6 c8	 movzx	 ecx, al
  0149d	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  014a1	d3 e8		 shr	 eax, cl
  014a3	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  014a7	0f b6 84 24 a5
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  014af	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  014b3	2b c8		 sub	 ecx, eax
  014b5	8b c1		 mov	 eax, ecx
  014b7	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  014bb	33 c0		 xor	 eax, eax
  014bd	85 c0		 test	 eax, eax
  014bf	75 d1		 jne	 SHORT $LN185@inflateBac
$LN308@inflateBac:
$LN188@inflateBac:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  014c1	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  014c9	0f b6 c8	 movzx	 ecx, al
  014cc	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  014d0	d3 e8		 shr	 eax, cl
  014d2	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  014d6	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  014de	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  014e2	2b c8		 sub	 ecx, eax
  014e4	8b c1		 mov	 eax, ecx
  014e6	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  014ea	33 c0		 xor	 eax, eax
  014ec	85 c0		 test	 eax, eax
  014ee	75 d1		 jne	 SHORT $LN188@inflateBac

; 509  :             state->length = (unsigned)here.val;

  014f0	0f b7 84 24 86
	00 00 00	 movzx	 eax, WORD PTR here$[rsp+2]
  014f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  014fd	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  01500	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp]
  01508	85 c0		 test	 eax, eax
  0150a	0f 85 98 00 00
	00		 jne	 $LN312@inflateBac
$LN191@inflateBac:

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  01510	83 7c 24 64 00	 cmp	 DWORD PTR left$[rsp], 0
  01515	75 53		 jne	 SHORT $LN313@inflateBac
  01517	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0151c	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  01520	48 89 44 24 58	 mov	 QWORD PTR put$[rsp], rax
  01525	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0152a	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0152d	89 44 24 64	 mov	 DWORD PTR left$[rsp], eax
  01531	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01536	8b 4c 24 64	 mov	 ecx, DWORD PTR left$[rsp]
  0153a	89 48 38	 mov	 DWORD PTR [rax+56], ecx
  0153d	44 8b 44 24 64	 mov	 r8d, DWORD PTR left$[rsp]
  01542	48 8b 54 24 58	 mov	 rdx, QWORD PTR put$[rsp]
  01547	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  0154f	ff 94 24 38 01
	00 00		 call	 QWORD PTR out$[rsp]
  01556	85 c0		 test	 eax, eax
  01558	74 10		 je	 SHORT $LN314@inflateBac
  0155a	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  01565	e9 e8 07 00 00	 jmp	 $inf_leave$387
$LN314@inflateBac:
$LN313@inflateBac:
  0156a	33 c0		 xor	 eax, eax
  0156c	85 c0		 test	 eax, eax
  0156e	75 a0		 jne	 SHORT $LN191@inflateBac

; 517  :                 *put++ = (unsigned char)(state->length);

  01570	48 8b 44 24 58	 mov	 rax, QWORD PTR put$[rsp]
  01575	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0157a	0f b6 49 50	 movzx	 ecx, BYTE PTR [rcx+80]
  0157e	88 08		 mov	 BYTE PTR [rax], cl
  01580	48 8b 44 24 58	 mov	 rax, QWORD PTR put$[rsp]
  01585	48 ff c0	 inc	 rax
  01588	48 89 44 24 58	 mov	 QWORD PTR put$[rsp], rax

; 518  :                 left--;

  0158d	8b 44 24 64	 mov	 eax, DWORD PTR left$[rsp]
  01591	ff c8		 dec	 eax
  01593	89 44 24 64	 mov	 DWORD PTR left$[rsp], eax

; 519  :                 state->mode = LEN;

  01597	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0159c	c7 40 08 48 3f
	00 00		 mov	 DWORD PTR [rax+8], 16200 ; 00003f48H

; 520  :                 break;

  015a3	e9 a5 07 00 00	 jmp	 $LN5@inflateBac
$LN312@inflateBac:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  015a8	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp]
  015b0	83 e0 20	 and	 eax, 32			; 00000020H
  015b3	85 c0		 test	 eax, eax
  015b5	74 11		 je	 SHORT $LN315@inflateBac

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;

  015b7	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  015bc	c7 40 08 3f 3f
	00 00		 mov	 DWORD PTR [rax+8], 16191 ; 00003f3fH

; 527  :                 break;

  015c3	e9 85 07 00 00	 jmp	 $LN5@inflateBac
$LN315@inflateBac:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  015c8	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp]
  015d0	83 e0 40	 and	 eax, 64			; 00000040H
  015d3	85 c0		 test	 eax, eax
  015d5	74 24		 je	 SHORT $LN316@inflateBac

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  015d7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  015df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  015e6	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 533  :                 state->mode = BAD;

  015ea	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  015ef	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 534  :                 break;

  015f6	e9 52 07 00 00	 jmp	 $LN5@inflateBac
$LN316@inflateBac:

; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  015fb	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp]
  01603	83 e0 0f	 and	 eax, 15
  01606	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0160b	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 539  :             if (state->extra != 0) {

  0160e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01613	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  01617	0f 84 18 01 00
	00		 je	 $LN317@inflateBac
$LN194@inflateBac:
$LN195@inflateBac:

; 540  :                 NEEDBITS(state->extra);

  0161d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01622	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  01625	39 44 24 6c	 cmp	 DWORD PTR bits$[rsp], eax
  01629	0f 83 90 00 00
	00		 jae	 $LN196@inflateBac
$LN199@inflateBac:
$LN202@inflateBac:
  0162f	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  01634	75 38		 jne	 SHORT $LN318@inflateBac
  01636	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  0163b	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01643	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  0164a	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  0164e	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  01653	75 19		 jne	 SHORT $LN319@inflateBac
  01655	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0165e	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  01669	e9 e4 06 00 00	 jmp	 $inf_leave$387
$LN319@inflateBac:
$LN318@inflateBac:
  0166e	33 c0		 xor	 eax, eax
  01670	85 c0		 test	 eax, eax
  01672	75 bb		 jne	 SHORT $LN202@inflateBac
  01674	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  01678	ff c8		 dec	 eax
  0167a	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  0167e	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  01683	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01686	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  0168a	d3 e0		 shl	 eax, cl
  0168c	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  01690	03 c8		 add	 ecx, eax
  01692	8b c1		 mov	 eax, ecx
  01694	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  01698	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  0169d	48 ff c0	 inc	 rax
  016a0	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  016a5	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  016a9	83 c0 08	 add	 eax, 8
  016ac	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  016b0	33 c0		 xor	 eax, eax
  016b2	85 c0		 test	 eax, eax
  016b4	0f 85 75 ff ff
	ff		 jne	 $LN199@inflateBac
  016ba	e9 5e ff ff ff	 jmp	 $LN195@inflateBac
$LN196@inflateBac:
  016bf	33 c0		 xor	 eax, eax
  016c1	85 c0		 test	 eax, eax
  016c3	0f 85 54 ff ff
	ff		 jne	 $LN194@inflateBac

; 541  :                 state->length += BITS(state->extra);

  016c9	0f ae e8	 lfence
  016cc	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  016d1	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  016d4	b9 01 00 00 00	 mov	 ecx, 1
  016d9	89 8c 24 f0 00
	00 00		 mov	 DWORD PTR tv1478[rsp], ecx
  016e0	0f b6 c8	 movzx	 ecx, al
  016e3	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv1478[rsp]
  016ea	d3 e0		 shl	 eax, cl
  016ec	ff c8		 dec	 eax
  016ee	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  016f2	23 c8		 and	 ecx, eax
  016f4	8b c1		 mov	 eax, ecx
  016f6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  016fb	03 41 50	 add	 eax, DWORD PTR [rcx+80]
  016fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01703	89 41 50	 mov	 DWORD PTR [rcx+80], eax
$LN205@inflateBac:

; 542  :                 DROPBITS(state->extra);

  01706	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0170b	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0170e	0f b6 c8	 movzx	 ecx, al
  01711	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  01715	d3 e8		 shr	 eax, cl
  01717	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0171b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01720	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  01723	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  01727	2b c8		 sub	 ecx, eax
  01729	8b c1		 mov	 eax, ecx
  0172b	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  0172f	33 c0		 xor	 eax, eax
  01731	85 c0		 test	 eax, eax
  01733	75 d1		 jne	 SHORT $LN205@inflateBac
$LN317@inflateBac:
$LN206@inflateBac:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  01735	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0173a	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0173d	b9 01 00 00 00	 mov	 ecx, 1
  01742	89 8c 24 f4 00
	00 00		 mov	 DWORD PTR tv1494[rsp], ecx
  01749	0f b6 c8	 movzx	 ecx, al
  0174c	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv1494[rsp]
  01753	d3 e0		 shl	 eax, cl
  01755	ff c8		 dec	 eax
  01757	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  0175b	23 c8		 and	 ecx, eax
  0175d	8b c1		 mov	 eax, ecx
  0175f	8b c0		 mov	 eax, eax
  01761	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01766	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0176a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0176d	89 84 24 84 00
	00 00		 mov	 DWORD PTR here$[rsp], eax

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  01774	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  0177c	3b 44 24 6c	 cmp	 eax, DWORD PTR bits$[rsp]
  01780	77 05		 ja	 SHORT $LN320@inflateBac
  01782	e9 90 00 00 00	 jmp	 $LN207@inflateBac
$LN320@inflateBac:
$LN211@inflateBac:
$LN214@inflateBac:

; 550  :                 PULLBYTE();

  01787	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  0178c	75 38		 jne	 SHORT $LN321@inflateBac
  0178e	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  01793	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0179b	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  017a2	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  017a6	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  017ab	75 19		 jne	 SHORT $LN322@inflateBac
  017ad	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  017b6	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  017c1	e9 8c 05 00 00	 jmp	 $inf_leave$387
$LN322@inflateBac:
$LN321@inflateBac:
  017c6	33 c0		 xor	 eax, eax
  017c8	85 c0		 test	 eax, eax
  017ca	75 bb		 jne	 SHORT $LN214@inflateBac
  017cc	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  017d0	ff c8		 dec	 eax
  017d2	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  017d6	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  017db	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  017de	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  017e2	d3 e0		 shl	 eax, cl
  017e4	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  017e8	03 c8		 add	 ecx, eax
  017ea	8b c1		 mov	 eax, ecx
  017ec	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  017f0	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  017f5	48 ff c0	 inc	 rax
  017f8	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  017fd	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  01801	83 c0 08	 add	 eax, 8
  01804	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  01808	33 c0		 xor	 eax, eax
  0180a	85 c0		 test	 eax, eax
  0180c	0f 85 75 ff ff
	ff		 jne	 $LN211@inflateBac

; 551  :             }

  01812	e9 1e ff ff ff	 jmp	 $LN206@inflateBac
$LN207@inflateBac:

; 552  :             if ((here.op & 0xf0) == 0) {

  01817	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp]
  0181f	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01824	85 c0		 test	 eax, eax
  01826	0f 85 4b 01 00
	00		 jne	 $LN323@inflateBac

; 553  :                 last = here;

  0182c	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR here$[rsp]
  01833	89 84 24 a4 00
	00 00		 mov	 DWORD PTR last$[rsp], eax
$LN215@inflateBac:

; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +

  0183a	0f b7 84 24 a6
	00 00 00	 movzx	 eax, WORD PTR last$[rsp+2]
  01842	0f b6 8c 24 a5
	00 00 00	 movzx	 ecx, BYTE PTR last$[rsp+1]
  0184a	0f b6 94 24 a4
	00 00 00	 movzx	 edx, BYTE PTR last$[rsp]
  01852	03 ca		 add	 ecx, edx
  01854	ba 01 00 00 00	 mov	 edx, 1
  01859	d3 e2		 shl	 edx, cl
  0185b	8b ca		 mov	 ecx, edx
  0185d	ff c9		 dec	 ecx
  0185f	8b 54 24 68	 mov	 edx, DWORD PTR hold$[rsp]
  01863	23 d1		 and	 edx, ecx
  01865	8b ca		 mov	 ecx, edx
  01867	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR tv727[rsp], ecx
  0186e	0f b6 94 24 a5
	00 00 00	 movzx	 edx, BYTE PTR last$[rsp+1]
  01876	0f b6 ca	 movzx	 ecx, dl
  01879	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR tv727[rsp]
  01880	d3 ea		 shr	 edx, cl
  01882	8b ca		 mov	 ecx, edx
  01884	03 c1		 add	 eax, ecx
  01886	8b c0		 mov	 eax, eax
  01888	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0188d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01891	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  01894	89 84 24 84 00
	00 00		 mov	 DWORD PTR here$[rsp], eax

; 556  :                             (BITS(last.bits + last.op) >> last.bits)];
; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0189b	0f b6 84 24 a5
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  018a3	0f b6 8c 24 85
	00 00 00	 movzx	 ecx, BYTE PTR here$[rsp+1]
  018ab	03 c1		 add	 eax, ecx
  018ad	3b 44 24 6c	 cmp	 eax, DWORD PTR bits$[rsp]
  018b1	77 05		 ja	 SHORT $LN324@inflateBac
  018b3	e9 90 00 00 00	 jmp	 $LN216@inflateBac
$LN324@inflateBac:
$LN220@inflateBac:
$LN223@inflateBac:

; 558  :                     PULLBYTE();

  018b8	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  018bd	75 38		 jne	 SHORT $LN325@inflateBac
  018bf	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  018c4	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  018cc	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  018d3	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  018d7	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  018dc	75 19		 jne	 SHORT $LN326@inflateBac
  018de	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  018e7	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  018f2	e9 5b 04 00 00	 jmp	 $inf_leave$387
$LN326@inflateBac:
$LN325@inflateBac:
  018f7	33 c0		 xor	 eax, eax
  018f9	85 c0		 test	 eax, eax
  018fb	75 bb		 jne	 SHORT $LN223@inflateBac
  018fd	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  01901	ff c8		 dec	 eax
  01903	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  01907	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  0190c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0190f	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  01913	d3 e0		 shl	 eax, cl
  01915	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  01919	03 c8		 add	 ecx, eax
  0191b	8b c1		 mov	 eax, ecx
  0191d	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  01921	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  01926	48 ff c0	 inc	 rax
  01929	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  0192e	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  01932	83 c0 08	 add	 eax, 8
  01935	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  01939	33 c0		 xor	 eax, eax
  0193b	85 c0		 test	 eax, eax
  0193d	0f 85 75 ff ff
	ff		 jne	 $LN220@inflateBac

; 559  :                 }

  01943	e9 f2 fe ff ff	 jmp	 $LN215@inflateBac
$LN216@inflateBac:
$LN226@inflateBac:

; 560  :                 DROPBITS(last.bits);

  01948	0f b6 84 24 a5
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  01950	0f b6 c8	 movzx	 ecx, al
  01953	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  01957	d3 e8		 shr	 eax, cl
  01959	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0195d	0f b6 84 24 a5
	00 00 00	 movzx	 eax, BYTE PTR last$[rsp+1]
  01965	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  01969	2b c8		 sub	 ecx, eax
  0196b	8b c1		 mov	 eax, ecx
  0196d	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  01971	33 c0		 xor	 eax, eax
  01973	85 c0		 test	 eax, eax
  01975	75 d1		 jne	 SHORT $LN226@inflateBac
$LN323@inflateBac:
$LN229@inflateBac:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  01977	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  0197f	0f b6 c8	 movzx	 ecx, al
  01982	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  01986	d3 e8		 shr	 eax, cl
  01988	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  0198c	0f b6 84 24 85
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp+1]
  01994	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  01998	2b c8		 sub	 ecx, eax
  0199a	8b c1		 mov	 eax, ecx
  0199c	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  019a0	33 c0		 xor	 eax, eax
  019a2	85 c0		 test	 eax, eax
  019a4	75 d1		 jne	 SHORT $LN229@inflateBac

; 563  :             if (here.op & 64) {

  019a6	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp]
  019ae	83 e0 40	 and	 eax, 64			; 00000040H
  019b1	85 c0		 test	 eax, eax
  019b3	74 24		 je	 SHORT $LN327@inflateBac

; 564  :                 strm->msg = (char *)"invalid distance code";

  019b5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  019bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  019c4	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 565  :                 state->mode = BAD;

  019c8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  019cd	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 566  :                 break;

  019d4	e9 74 03 00 00	 jmp	 $LN5@inflateBac
$LN327@inflateBac:

; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  019d9	0f b7 84 24 86
	00 00 00	 movzx	 eax, WORD PTR here$[rsp+2]
  019e1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  019e6	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  019e9	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR here$[rsp]
  019f1	83 e0 0f	 and	 eax, 15
  019f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  019f9	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 572  :             if (state->extra != 0) {

  019fc	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01a01	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  01a05	0f 84 15 01 00
	00		 je	 $LN328@inflateBac
$LN232@inflateBac:
$LN233@inflateBac:

; 573  :                 NEEDBITS(state->extra);

  01a0b	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01a10	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  01a13	39 44 24 6c	 cmp	 DWORD PTR bits$[rsp], eax
  01a17	0f 83 90 00 00
	00		 jae	 $LN234@inflateBac
$LN237@inflateBac:
$LN240@inflateBac:
  01a1d	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  01a22	75 38		 jne	 SHORT $LN329@inflateBac
  01a24	48 8d 54 24 48	 lea	 rdx, QWORD PTR next$[rsp]
  01a29	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01a31	ff 94 24 28 01
	00 00		 call	 QWORD PTR in$[rsp]
  01a38	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  01a3c	83 7c 24 60 00	 cmp	 DWORD PTR have$[rsp], 0
  01a41	75 19		 jne	 SHORT $LN330@inflateBac
  01a43	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  01a4c	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  01a57	e9 f6 02 00 00	 jmp	 $inf_leave$387
$LN330@inflateBac:
$LN329@inflateBac:
  01a5c	33 c0		 xor	 eax, eax
  01a5e	85 c0		 test	 eax, eax
  01a60	75 bb		 jne	 SHORT $LN240@inflateBac
  01a62	8b 44 24 60	 mov	 eax, DWORD PTR have$[rsp]
  01a66	ff c8		 dec	 eax
  01a68	89 44 24 60	 mov	 DWORD PTR have$[rsp], eax
  01a6c	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  01a71	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01a74	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  01a78	d3 e0		 shl	 eax, cl
  01a7a	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  01a7e	03 c8		 add	 ecx, eax
  01a80	8b c1		 mov	 eax, ecx
  01a82	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  01a86	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  01a8b	48 ff c0	 inc	 rax
  01a8e	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax
  01a93	8b 44 24 6c	 mov	 eax, DWORD PTR bits$[rsp]
  01a97	83 c0 08	 add	 eax, 8
  01a9a	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  01a9e	33 c0		 xor	 eax, eax
  01aa0	85 c0		 test	 eax, eax
  01aa2	0f 85 75 ff ff
	ff		 jne	 $LN237@inflateBac
  01aa8	e9 5e ff ff ff	 jmp	 $LN233@inflateBac
$LN234@inflateBac:
  01aad	33 c0		 xor	 eax, eax
  01aaf	85 c0		 test	 eax, eax
  01ab1	0f 85 54 ff ff
	ff		 jne	 $LN232@inflateBac

; 574  :                 state->offset += BITS(state->extra);

  01ab7	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01abc	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  01abf	b9 01 00 00 00	 mov	 ecx, 1
  01ac4	89 8c 24 fc 00
	00 00		 mov	 DWORD PTR tv1560[rsp], ecx
  01acb	0f b6 c8	 movzx	 ecx, al
  01ace	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR tv1560[rsp]
  01ad5	d3 e0		 shl	 eax, cl
  01ad7	ff c8		 dec	 eax
  01ad9	8b 4c 24 68	 mov	 ecx, DWORD PTR hold$[rsp]
  01add	23 c8		 and	 ecx, eax
  01adf	8b c1		 mov	 eax, ecx
  01ae1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01ae6	03 41 54	 add	 eax, DWORD PTR [rcx+84]
  01ae9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01aee	89 41 54	 mov	 DWORD PTR [rcx+84], eax
$LN243@inflateBac:

; 575  :                 DROPBITS(state->extra);

  01af1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01af6	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  01af9	0f b6 c8	 movzx	 ecx, al
  01afc	8b 44 24 68	 mov	 eax, DWORD PTR hold$[rsp]
  01b00	d3 e8		 shr	 eax, cl
  01b02	89 44 24 68	 mov	 DWORD PTR hold$[rsp], eax
  01b06	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01b0b	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  01b0e	8b 4c 24 6c	 mov	 ecx, DWORD PTR bits$[rsp]
  01b12	2b c8		 sub	 ecx, eax
  01b14	8b c1		 mov	 eax, ecx
  01b16	89 44 24 6c	 mov	 DWORD PTR bits$[rsp], eax
  01b1a	33 c0		 xor	 eax, eax
  01b1c	85 c0		 test	 eax, eax
  01b1e	75 d1		 jne	 SHORT $LN243@inflateBac
$LN328@inflateBac:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?

  01b20	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01b25	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01b2a	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  01b2d	39 48 38	 cmp	 DWORD PTR [rax+56], ecx
  01b30	73 0d		 jae	 SHORT $LN345@inflateBac
  01b32	8b 44 24 64	 mov	 eax, DWORD PTR left$[rsp]
  01b36	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv807[rsp], eax
  01b3d	eb 0b		 jmp	 SHORT $LN346@inflateBac
$LN345@inflateBac:
  01b3f	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv807[rsp], 0
$LN346@inflateBac:
  01b4a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01b4f	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv807[rsp]
  01b56	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  01b59	2b c1		 sub	 eax, ecx
  01b5b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01b60	39 41 54	 cmp	 DWORD PTR [rcx+84], eax
  01b63	76 24		 jbe	 SHORT $LN331@inflateBac

; 578  :                                                 left : 0)) {
; 579  :                 strm->msg = (char *)"invalid distance too far back";

  01b65	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01b6d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
  01b74	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 580  :                 state->mode = BAD;

  01b78	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01b7d	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 581  :                 break;

  01b84	e9 c4 01 00 00	 jmp	 $LN5@inflateBac
$LN331@inflateBac:
$LN246@inflateBac:
$LN249@inflateBac:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  01b89	83 7c 24 64 00	 cmp	 DWORD PTR left$[rsp], 0
  01b8e	75 53		 jne	 SHORT $LN332@inflateBac
  01b90	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01b95	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  01b99	48 89 44 24 58	 mov	 QWORD PTR put$[rsp], rax
  01b9e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01ba3	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  01ba6	89 44 24 64	 mov	 DWORD PTR left$[rsp], eax
  01baa	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01baf	8b 4c 24 64	 mov	 ecx, DWORD PTR left$[rsp]
  01bb3	89 48 38	 mov	 DWORD PTR [rax+56], ecx
  01bb6	44 8b 44 24 64	 mov	 r8d, DWORD PTR left$[rsp]
  01bbb	48 8b 54 24 58	 mov	 rdx, QWORD PTR put$[rsp]
  01bc0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  01bc8	ff 94 24 38 01
	00 00		 call	 QWORD PTR out$[rsp]
  01bcf	85 c0		 test	 eax, eax
  01bd1	74 10		 je	 SHORT $LN333@inflateBac
  01bd3	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
  01bde	e9 6f 01 00 00	 jmp	 $inf_leave$387
$LN333@inflateBac:
$LN332@inflateBac:
  01be3	33 c0		 xor	 eax, eax
  01be5	85 c0		 test	 eax, eax
  01be7	75 a0		 jne	 SHORT $LN249@inflateBac

; 588  :                 copy = state->wsize - state->offset;

  01be9	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01bee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01bf3	8b 49 54	 mov	 ecx, DWORD PTR [rcx+84]
  01bf6	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  01bf9	2b c1		 sub	 eax, ecx
  01bfb	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax

; 589  :                 if (copy < left) {

  01bff	8b 44 24 64	 mov	 eax, DWORD PTR left$[rsp]
  01c03	39 44 24 70	 cmp	 DWORD PTR copy$[rsp], eax
  01c07	73 26		 jae	 SHORT $LN334@inflateBac

; 590  :                     from = put + copy;

  01c09	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  01c0d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR put$[rsp]
  01c12	48 03 c8	 add	 rcx, rax
  01c15	48 8b c1	 mov	 rax, rcx
  01c18	48 89 44 24 78	 mov	 QWORD PTR from$[rsp], rax

; 591  :                     copy = left - copy;

  01c1d	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  01c21	8b 4c 24 64	 mov	 ecx, DWORD PTR left$[rsp]
  01c25	2b c8		 sub	 ecx, eax
  01c27	8b c1		 mov	 eax, ecx
  01c29	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax

; 592  :                 }

  01c2d	eb 23		 jmp	 SHORT $LN335@inflateBac
$LN334@inflateBac:

; 593  :                 else {
; 594  :                     from = put - state->offset;

  01c2f	0f ae e8	 lfence
  01c32	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01c37	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  01c3a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR put$[rsp]
  01c3f	48 2b c8	 sub	 rcx, rax
  01c42	48 8b c1	 mov	 rax, rcx
  01c45	48 89 44 24 78	 mov	 QWORD PTR from$[rsp], rax

; 595  :                     copy = left;

  01c4a	8b 44 24 64	 mov	 eax, DWORD PTR left$[rsp]
  01c4e	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax
$LN335@inflateBac:

; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  01c52	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01c57	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  01c5a	39 44 24 70	 cmp	 DWORD PTR copy$[rsp], eax
  01c5e	76 0c		 jbe	 SHORT $LN336@inflateBac
  01c60	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01c65	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  01c68	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax
$LN336@inflateBac:

; 598  :                 state->length -= copy;

  01c6c	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01c71	8b 4c 24 70	 mov	 ecx, DWORD PTR copy$[rsp]
  01c75	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  01c78	2b c1		 sub	 eax, ecx
  01c7a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  01c7f	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 599  :                 left -= copy;

  01c82	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  01c86	8b 4c 24 64	 mov	 ecx, DWORD PTR left$[rsp]
  01c8a	2b c8		 sub	 ecx, eax
  01c8c	8b c1		 mov	 eax, ecx
  01c8e	89 44 24 64	 mov	 DWORD PTR left$[rsp], eax
$LN252@inflateBac:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  01c92	48 8b 44 24 58	 mov	 rax, QWORD PTR put$[rsp]
  01c97	48 8b 4c 24 78	 mov	 rcx, QWORD PTR from$[rsp]
  01c9c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01c9f	88 08		 mov	 BYTE PTR [rax], cl
  01ca1	48 8b 44 24 58	 mov	 rax, QWORD PTR put$[rsp]
  01ca6	48 ff c0	 inc	 rax
  01ca9	48 89 44 24 58	 mov	 QWORD PTR put$[rsp], rax
  01cae	48 8b 44 24 78	 mov	 rax, QWORD PTR from$[rsp]
  01cb3	48 ff c0	 inc	 rax
  01cb6	48 89 44 24 78	 mov	 QWORD PTR from$[rsp], rax

; 602  :                 } while (--copy);

  01cbb	8b 44 24 70	 mov	 eax, DWORD PTR copy$[rsp]
  01cbf	ff c8		 dec	 eax
  01cc1	89 44 24 70	 mov	 DWORD PTR copy$[rsp], eax
  01cc5	83 7c 24 70 00	 cmp	 DWORD PTR copy$[rsp], 0
  01cca	75 c6		 jne	 SHORT $LN252@inflateBac

; 603  :             } while (state->length != 0);

  01ccc	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01cd1	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  01cd5	0f 85 ae fe ff
	ff		 jne	 $LN246@inflateBac

; 604  :             break;

  01cdb	eb 70		 jmp	 SHORT $LN5@inflateBac
$LN337@inflateBac:

; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;

  01cdd	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ret$[rsp], 1

; 609  :             if (left < state->wsize) {

  01ce8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01ced	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  01cf0	39 44 24 64	 cmp	 DWORD PTR left$[rsp], eax
  01cf4	73 3b		 jae	 SHORT $LN338@inflateBac

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  01cf6	0f ae e8	 lfence
  01cf9	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01cfe	8b 4c 24 64	 mov	 ecx, DWORD PTR left$[rsp]
  01d02	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  01d05	2b c1		 sub	 eax, ecx
  01d07	44 8b c0	 mov	 r8d, eax
  01d0a	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  01d0f	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  01d13	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  01d1b	ff 94 24 38 01
	00 00		 call	 QWORD PTR out$[rsp]
  01d22	85 c0		 test	 eax, eax
  01d24	74 0b		 je	 SHORT $LN339@inflateBac

; 611  :                     ret = Z_BUF_ERROR;

  01d26	c7 84 24 b8 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -5
$LN339@inflateBac:
$LN338@inflateBac:

; 612  :             }
; 613  :             goto inf_leave;

  01d31	eb 1f		 jmp	 SHORT $inf_leave$387
$LN340@inflateBac:

; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  01d33	c7 84 24 b8 00
	00 00 fd ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -3

; 617  :             goto inf_leave;

  01d3e	eb 12		 jmp	 SHORT $inf_leave$387
$LN341@inflateBac:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  01d40	c7 84 24 b8 00
	00 00 fe ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -2

; 621  :             goto inf_leave;

  01d4b	eb 05		 jmp	 SHORT $inf_leave$387
$LN5@inflateBac:

; 622  :         }

  01d4d	e9 c2 e3 ff ff	 jmp	 $LN2@inflateBac
$inf_leave$387:

; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  01d52	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01d5a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR next$[rsp]
  01d5f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 627  :     strm->avail_in = have;

  01d62	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01d6a	8b 4c 24 60	 mov	 ecx, DWORD PTR have$[rsp]
  01d6e	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 628  :     return ret;

  01d71	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR ret$[rsp]
$LN1@inflateBac:

; 629  : }

  01d78	48 8b f8	 mov	 rdi, rax
  01d7b	48 8b cc	 mov	 rcx, rsp
  01d7e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:inflateBack$rtcFrameData
  01d85	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  01d8a	48 8b c7	 mov	 rax, rdi
  01d8d	48 81 c4 10 01
	00 00		 add	 rsp, 272		; 00000110H
  01d94	5f		 pop	 rdi
  01d95	c3		 ret	 0
  01d96	66 90		 npad	 2
$LN385@inflateBac:
  01d98	00 00 00 00	 DD	 $LN255@inflateBac
  01d9c	00 00 00 00	 DD	 $LN341@inflateBac
  01da0	00 00 00 00	 DD	 $LN263@inflateBac
  01da4	00 00 00 00	 DD	 $LN341@inflateBac
  01da8	00 00 00 00	 DD	 $LN341@inflateBac
  01dac	00 00 00 00	 DD	 $LN273@inflateBac
  01db0	00 00 00 00	 DD	 $LN341@inflateBac
  01db4	00 00 00 00	 DD	 $LN341@inflateBac
  01db8	00 00 00 00	 DD	 $LN341@inflateBac
  01dbc	00 00 00 00	 DD	 $LN302@inflateBac
  01dc0	00 00 00 00	 DD	 $LN341@inflateBac
  01dc4	00 00 00 00	 DD	 $LN341@inflateBac
  01dc8	00 00 00 00	 DD	 $LN341@inflateBac
  01dcc	00 00 00 00	 DD	 $LN341@inflateBac
  01dd0	00 00 00 00	 DD	 $LN341@inflateBac
  01dd4	00 00 00 00	 DD	 $LN341@inflateBac
  01dd8	00 00 00 00	 DD	 $LN341@inflateBac
  01ddc	00 00 00 00	 DD	 $LN337@inflateBac
  01de0	00 00 00 00	 DD	 $LN340@inflateBac
inflateBack ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 633  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  0002a	48 83 7c 24 30
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00030	74 18		 je	 SHORT $LN3@inflateBac
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00037	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0003c	74 0c		 je	 SHORT $LN3@inflateBac
  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00043	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00048	75 07		 jne	 SHORT $LN2@inflateBac
$LN3@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  0004a	b8 fe ff ff ff	 mov	 eax, -2
  0004f	eb 29		 jmp	 SHORT $LN1@inflateBac
$LN2@inflateBac:

; 636  :     ZFREE(strm, strm->state);

  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00056	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  0005a	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  0005f	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00068	ff 50 38	 call	 QWORD PTR [rax+56]

; 637  :     strm->state = Z_NULL;

  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00070	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  00078	33 c0		 xor	 eax, eax
$LN1@inflateBac:

; 640  : }

  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
END
