; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	longest_match:PROC
EXTRN	__imp_memset:PROC
EXTRN	match_init:PROC
EXTRN	__imp_memcpy:PROC
?my_version@?1??deflateInit2_@@9@9 DB '1.2.11', 00H	; `deflateInit2_'::`2'::my_version
	ORG $+9
configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DQ	FLAT:deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DQ	FLAT:deflate_slow
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__E6E9AA63_deflate@c DB 01H
PUBLIC	deflateCopy
PUBLIC	deflateBound
PUBLIC	deflateTune
PUBLIC	deflateParams
PUBLIC	deflatePrime
PUBLIC	deflatePending
PUBLIC	deflateSetHeader
PUBLIC	deflateReset
PUBLIC	deflateResetKeep
PUBLIC	deflateGetDictionary
PUBLIC	deflateSetDictionary
PUBLIC	deflateInit2_
PUBLIC	deflateInit_
PUBLIC	deflateEnd
PUBLIC	deflate
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_huff DD imagerel deflate_huff
	DD	imagerel deflate_huff+924
	DD	imagerel $unwind$deflate_huff
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_rle DD imagerel deflate_rle
	DD	imagerel deflate_rle+2210
	DD	imagerel $unwind$deflate_rle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_slow DD imagerel deflate_slow
	DD	imagerel deflate_slow+3383
	DD	imagerel $unwind$deflate_slow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_fast DD imagerel deflate_fast
	DD	imagerel deflate_fast+2693
	DD	imagerel $unwind$deflate_fast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_stored DD imagerel deflate_stored
	DD	imagerel deflate_stored+2784
	DD	imagerel $unwind$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_window DD imagerel fill_window
	DD	imagerel fill_window+1234
	DD	imagerel $unwind$fill_window
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lm_init DD imagerel lm_init
	DD	imagerel lm_init+405
	DD	imagerel $unwind$lm_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_buf DD imagerel read_buf
	DD	imagerel read_buf+288
	DD	imagerel $unwind$read_buf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateCopy DD imagerel $LN11
	DD	imagerel $LN11+800
	DD	imagerel $unwind$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$flush_pending DD imagerel flush_pending
	DD	imagerel flush_pending+290
	DD	imagerel $unwind$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$putShortMSB DD imagerel putShortMSB
	DD	imagerel putShortMSB+144
	DD	imagerel $unwind$putShortMSB
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateBound DD imagerel $LN27
	DD	imagerel $LN27+546
	DD	imagerel $unwind$deflateBound
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateTune DD imagerel $LN5
	DD	imagerel $LN5+159
	DD	imagerel $unwind$deflateTune
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateParams DD imagerel $LN17
	DD	imagerel $LN17+607
	DD	imagerel $unwind$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflatePrime DD imagerel $LN10
	DD	imagerel $LN10+330
	DD	imagerel $unwind$deflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflatePending DD imagerel $LN7
	DD	imagerel $LN7+138
	DD	imagerel $unwind$deflatePending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetHeader DD imagerel $LN6
	DD	imagerel $LN6+109
	DD	imagerel $unwind$deflateSetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateReset DD imagerel $LN5
	DD	imagerel $LN5+87
	DD	imagerel $unwind$deflateReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateResetKeep DD imagerel $LN13
	DD	imagerel $LN13+345
	DD	imagerel $unwind$deflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateGetDictionary DD imagerel $LN8
	DD	imagerel $LN8+252
	DD	imagerel $unwind$deflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetDictionary DD imagerel $LN17
	DD	imagerel $LN17+912
	DD	imagerel $unwind$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateStateCheck DD imagerel deflateStateCheck
	DD	imagerel deflateStateCheck+227
	DD	imagerel $unwind$deflateStateCheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit2_ DD imagerel $LN22
	DD	imagerel $LN22+1205
	DD	imagerel $unwind$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$slide_hash DD imagerel slide_hash
	DD	imagerel slide_hash+308
	DD	imagerel $unwind$slide_hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit_ DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$deflateInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateEnd DD imagerel $LN11
	DD	imagerel $LN11+340
	DD	imagerel $unwind$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate DD imagerel $LN143
	DD	imagerel $LN143+5447
	DD	imagerel $unwind$deflate
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate DD 032801H
	DD	0180111H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateEnd DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit_ DD 022c01H
	DD	070147218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slide_hash DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit2_ DD 022c01H
	DD	070149218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateStateCheck DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetDictionary DD 022801H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateGetDictionary DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateResetKeep DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateReset DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetHeader DD 022301H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflatePending DD 022801H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflatePrime DD 022701H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateParams DD 022701H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateTune DD 022c01H
	DD	070145218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateBound DD 022201H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$putShortMSB DD 022201H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$flush_pending DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateCopy DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_buf DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lm_init DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_window DD 021e01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_stored DD 022501H
	DD	0700ad20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_fast DD 032801H
	DD	0120111H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_slow DD 032801H
	DD	0120111H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_rle DD 022501H
	DD	0700ad20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_huff DD 022201H
	DD	0700a920eH
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate
_TEXT	SEGMENT
old_flush$ = 32
s$ = 40
header$1 = 48
level_flags$2 = 52
beg$3 = 56
left$4 = 60
copy$5 = 64
beg$6 = 68
val$7 = 72
beg$8 = 76
val$9 = 80
bstate$10 = 84
tv131 = 88
tv135 = 92
tv282 = 96
tv281 = 100
tv308 = 104
tv312 = 108
tv317 = 112
tv322 = 116
tv327 = 120
tv396 = 124
tv395 = 128
tv481 = 136
tv521 = 144
tv757 = 152
tv756 = 156
tv755 = 160
tv934 = 168
tv913 = 176
strm$ = 208
flush$ = 216
deflate	PROC						; COMDAT

; 766  : {

$LN143:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+208]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 767  :     int old_flush; /* value of flush param for previous deflate call */
; 768  :     deflate_state *s;
; 769  : 
; 770  :     if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {

  00034	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0003c	e8 00 00 00 00	 call	 deflateStateCheck
  00041	85 c0		 test	 eax, eax
  00043	75 14		 jne	 SHORT $LN29@deflate
  00045	83 bc 24 d8 00
	00 00 05	 cmp	 DWORD PTR flush$[rsp], 5
  0004d	7f 0a		 jg	 SHORT $LN29@deflate
  0004f	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  00057	7d 0a		 jge	 SHORT $LN28@deflate
$LN29@deflate:

; 771  :         return Z_STREAM_ERROR;

  00059	b8 fe ff ff ff	 mov	 eax, -2
  0005e	e9 db 14 00 00	 jmp	 $LN1@deflate
$LN28@deflate:

; 772  :     }
; 773  :     s = strm->state;

  00063	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0006b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006f	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 774  : 
; 775  :     if (strm->next_out == Z_NULL ||
; 776  :         (strm->avail_in != 0 && strm->next_in == Z_NULL) ||

  00074	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0007c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00081	74 34		 je	 SHORT $LN31@deflate
  00083	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0008b	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0008f	74 0e		 je	 SHORT $LN32@deflate
  00091	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00099	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0009d	74 18		 je	 SHORT $LN31@deflate
$LN32@deflate:
  0009f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000a4	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  000ab	75 34		 jne	 SHORT $LN30@deflate
  000ad	83 bc 24 d8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  000b5	74 2a		 je	 SHORT $LN30@deflate
$LN31@deflate:

; 777  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {
; 778  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  000b7	b8 08 00 00 00	 mov	 eax, 8
  000bc	48 6b c0 04	 imul	 rax, rax, 4
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z_errmsg
  000c7	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  000cf	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000d3	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax
  000d7	b8 fe ff ff ff	 mov	 eax, -2
  000dc	e9 5d 14 00 00	 jmp	 $LN1@deflate
$LN30@deflate:

; 779  :     }
; 780  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  000e1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000e9	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000ed	75 2a		 jne	 SHORT $LN33@deflate
  000ef	b8 08 00 00 00	 mov	 eax, 8
  000f4	48 6b c0 07	 imul	 rax, rax, 7
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z_errmsg
  000ff	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00107	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0010b	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax
  0010f	b8 fb ff ff ff	 mov	 eax, -5
  00114	e9 25 14 00 00	 jmp	 $LN1@deflate
$LN33@deflate:

; 781  : 
; 782  :     old_flush = s->last_flush;

  00119	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0011e	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  00121	89 44 24 20	 mov	 DWORD PTR old_flush$[rsp], eax

; 783  :     s->last_flush = flush;

  00125	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0012a	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR flush$[rsp]
  00131	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 784  : 
; 785  :     /* Flush as much pending output as possible */
; 786  :     if (s->pending != 0) {

  00134	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00139	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0013d	74 33		 je	 SHORT $LN34@deflate

; 787  :         flush_pending(strm);

  0013f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00147	e8 00 00 00 00	 call	 flush_pending

; 788  :         if (strm->avail_out == 0) {

  0014c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00154	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00158	75 13		 jne	 SHORT $LN36@deflate

; 789  :             /* Since avail_out is 0, deflate will be called again with
; 790  :              * more output space, but possibly with both pending and
; 791  :              * avail_in equal to zero. There won't be anything to do,
; 792  :              * but this is not an error situation so make sure we
; 793  :              * return OK instead of BUF_ERROR at next call of deflate:
; 794  :              */
; 795  :             s->last_flush = -1;

  0015a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0015f	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 796  :             return Z_OK;

  00166	33 c0		 xor	 eax, eax
  00168	e9 d1 13 00 00	 jmp	 $LN1@deflate
$LN36@deflate:

; 797  :         }

  0016d	e9 96 00 00 00	 jmp	 $LN35@deflate
$LN34@deflate:

; 798  : 
; 799  :     /* Make sure there is something to do and avoid duplicate consecutive
; 800  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 801  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 802  :      */
; 803  :     } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&

  00172	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0017a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0017e	0f 85 84 00 00
	00		 jne	 $LN37@deflate
  00184	83 bc 24 d8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  0018c	7e 0a		 jle	 SHORT $LN98@deflate
  0018e	c7 44 24 58 09
	00 00 00	 mov	 DWORD PTR tv131[rsp], 9
  00196	eb 08		 jmp	 SHORT $LN99@deflate
$LN98@deflate:
  00198	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN99@deflate:
  001a0	83 7c 24 20 04	 cmp	 DWORD PTR old_flush$[rsp], 4
  001a5	7e 0a		 jle	 SHORT $LN100@deflate
  001a7	c7 44 24 5c 09
	00 00 00	 mov	 DWORD PTR tv135[rsp], 9
  001af	eb 08		 jmp	 SHORT $LN101@deflate
$LN100@deflate:
  001b1	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN101@deflate:
  001b9	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR flush$[rsp]
  001c0	d1 e0		 shl	 eax, 1
  001c2	2b 44 24 58	 sub	 eax, DWORD PTR tv131[rsp]
  001c6	8b 4c 24 20	 mov	 ecx, DWORD PTR old_flush$[rsp]
  001ca	d1 e1		 shl	 ecx, 1
  001cc	2b 4c 24 5c	 sub	 ecx, DWORD PTR tv135[rsp]
  001d0	3b c1		 cmp	 eax, ecx
  001d2	7f 34		 jg	 SHORT $LN37@deflate
  001d4	83 bc 24 d8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  001dc	74 2a		 je	 SHORT $LN37@deflate

; 804  :                flush != Z_FINISH) {
; 805  :         ERR_RETURN(strm, Z_BUF_ERROR);

  001de	b8 08 00 00 00	 mov	 eax, 8
  001e3	48 6b c0 07	 imul	 rax, rax, 7
  001e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z_errmsg
  001ee	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  001f6	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  001fa	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax
  001fe	b8 fb ff ff ff	 mov	 eax, -5
  00203	e9 36 13 00 00	 jmp	 $LN1@deflate
$LN37@deflate:
$LN35@deflate:

; 806  :     }
; 807  : 
; 808  :     /* User must not provide more input after the first FINISH: */
; 809  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  00208	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0020d	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  00214	75 38		 jne	 SHORT $LN38@deflate
  00216	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0021e	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00222	74 2a		 je	 SHORT $LN38@deflate

; 810  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00224	b8 08 00 00 00	 mov	 eax, 8
  00229	48 6b c0 07	 imul	 rax, rax, 7
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z_errmsg
  00234	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  0023c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00240	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax
  00244	b8 fb ff ff ff	 mov	 eax, -5
  00249	e9 f0 12 00 00	 jmp	 $LN1@deflate
$LN38@deflate:

; 811  :     }
; 812  : 
; 813  :     /* Write the header */
; 814  :     if (s->status == INIT_STATE) {

  0024e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00253	83 78 08 2a	 cmp	 DWORD PTR [rax+8], 42	; 0000002aH
  00257	0f 85 66 01 00
	00		 jne	 $LN39@deflate

; 815  :         /* zlib header */
; 816  :         uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  0025d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00262	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00265	83 e8 08	 sub	 eax, 8
  00268	c1 e0 04	 shl	 eax, 4
  0026b	83 c0 08	 add	 eax, 8
  0026e	c1 e0 08	 shl	 eax, 8
  00271	89 44 24 30	 mov	 DWORD PTR header$1[rsp], eax

; 817  :         uInt level_flags;
; 818  : 
; 819  :         if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  00275	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0027a	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  00281	7d 0e		 jge	 SHORT $LN42@deflate
  00283	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00288	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  0028f	7d 0a		 jge	 SHORT $LN40@deflate
$LN42@deflate:

; 820  :             level_flags = 0;

  00291	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR level_flags$2[rsp], 0
  00299	eb 38		 jmp	 SHORT $LN41@deflate
$LN40@deflate:

; 821  :         else if (s->level < 6)

  0029b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  002a0	83 b8 ac 00 00
	00 06		 cmp	 DWORD PTR [rax+172], 6
  002a7	7d 0a		 jge	 SHORT $LN43@deflate

; 822  :             level_flags = 1;

  002a9	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR level_flags$2[rsp], 1
  002b1	eb 20		 jmp	 SHORT $LN44@deflate
$LN43@deflate:

; 823  :         else if (s->level == 6)

  002b3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  002b8	83 b8 ac 00 00
	00 06		 cmp	 DWORD PTR [rax+172], 6
  002bf	75 0a		 jne	 SHORT $LN45@deflate

; 824  :             level_flags = 2;

  002c1	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR level_flags$2[rsp], 2
  002c9	eb 08		 jmp	 SHORT $LN46@deflate
$LN45@deflate:

; 825  :         else
; 826  :             level_flags = 3;

  002cb	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR level_flags$2[rsp], 3
$LN46@deflate:
$LN44@deflate:
$LN41@deflate:

; 827  :         header |= (level_flags << 6);

  002d3	8b 44 24 34	 mov	 eax, DWORD PTR level_flags$2[rsp]
  002d7	c1 e0 06	 shl	 eax, 6
  002da	8b 4c 24 30	 mov	 ecx, DWORD PTR header$1[rsp]
  002de	0b c8		 or	 ecx, eax
  002e0	8b c1		 mov	 eax, ecx
  002e2	89 44 24 30	 mov	 DWORD PTR header$1[rsp], eax

; 828  :         if (s->strstart != 0) header |= PRESET_DICT;

  002e6	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  002eb	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  002f2	74 0b		 je	 SHORT $LN47@deflate
  002f4	8b 44 24 30	 mov	 eax, DWORD PTR header$1[rsp]
  002f8	83 c8 20	 or	 eax, 32			; 00000020H
  002fb	89 44 24 30	 mov	 DWORD PTR header$1[rsp], eax
$LN47@deflate:

; 829  :         header += 31 - (header % 31);

  002ff	33 d2		 xor	 edx, edx
  00301	8b 44 24 30	 mov	 eax, DWORD PTR header$1[rsp]
  00305	b9 1f 00 00 00	 mov	 ecx, 31
  0030a	f7 f1		 div	 ecx
  0030c	8b c2		 mov	 eax, edx
  0030e	b9 1f 00 00 00	 mov	 ecx, 31
  00313	2b c8		 sub	 ecx, eax
  00315	8b c1		 mov	 eax, ecx
  00317	8b 4c 24 30	 mov	 ecx, DWORD PTR header$1[rsp]
  0031b	03 c8		 add	 ecx, eax
  0031d	8b c1		 mov	 eax, ecx
  0031f	89 44 24 30	 mov	 DWORD PTR header$1[rsp], eax

; 830  : 
; 831  :         putShortMSB(s, header);

  00323	8b 54 24 30	 mov	 edx, DWORD PTR header$1[rsp]
  00327	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0032c	e8 00 00 00 00	 call	 putShortMSB

; 832  : 
; 833  :         /* Save the adler32 of the preset dictionary: */
; 834  :         if (s->strstart != 0) {

  00331	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00336	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  0033d	74 36		 je	 SHORT $LN48@deflate

; 835  :             putShortMSB(s, (uInt)(strm->adler >> 16));

  0033f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00347	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0034a	c1 e8 10	 shr	 eax, 16
  0034d	8b d0		 mov	 edx, eax
  0034f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00354	e8 00 00 00 00	 call	 putShortMSB

; 836  :             putShortMSB(s, (uInt)(strm->adler & 0xffff));

  00359	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00361	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00364	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00369	8b d0		 mov	 edx, eax
  0036b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00370	e8 00 00 00 00	 call	 putShortMSB
$LN48@deflate:

; 837  :         }
; 838  :         strm->adler = adler32(0L, Z_NULL, 0);

  00375	45 33 c0	 xor	 r8d, r8d
  00378	33 d2		 xor	 edx, edx
  0037a	33 c9		 xor	 ecx, ecx
  0037c	e8 00 00 00 00	 call	 adler32
  00381	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00389	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 839  :         s->status = BUSY_STATE;

  0038c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00391	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H

; 840  : 
; 841  :         /* Compression must start with an empty pending buffer */
; 842  :         flush_pending(strm);

  00398	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  003a0	e8 00 00 00 00	 call	 flush_pending

; 843  :         if (s->pending != 0) {

  003a5	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003aa	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  003ae	74 13		 je	 SHORT $LN49@deflate

; 844  :             s->last_flush = -1;

  003b0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003b5	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 845  :             return Z_OK;

  003bc	33 c0		 xor	 eax, eax
  003be	e9 7b 11 00 00	 jmp	 $LN1@deflate
$LN49@deflate:
$LN39@deflate:

; 846  :         }
; 847  :     }
; 848  : #ifdef GZIP
; 849  :     if (s->status == GZIP_STATE) {

  003c3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003c8	83 78 08 39	 cmp	 DWORD PTR [rax+8], 57	; 00000039H
  003cc	0f 85 93 05 00
	00		 jne	 $LN50@deflate

; 850  :         /* gzip header */
; 851  :         strm->adler = crc32(0L, Z_NULL, 0);

  003d2	45 33 c0	 xor	 r8d, r8d
  003d5	33 d2		 xor	 edx, edx
  003d7	33 c9		 xor	 ecx, ecx
  003d9	e8 00 00 00 00	 call	 crc32
  003de	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  003e6	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 852  :         put_byte(s, 31);

  003e9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003ee	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  003f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  003f6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  003fa	c6 04 01 1f	 mov	 BYTE PTR [rcx+rax], 31
  003fe	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00403	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00406	ff c0		 inc	 eax
  00408	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0040d	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 853  :         put_byte(s, 139);

  00410	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00415	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00418	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0041d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00421	c6 04 01 8b	 mov	 BYTE PTR [rcx+rax], 139	; 0000008bH
  00425	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0042a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0042d	ff c0		 inc	 eax
  0042f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00434	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 854  :         put_byte(s, 8);

  00437	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0043c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0043f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00444	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00448	c6 04 01 08	 mov	 BYTE PTR [rcx+rax], 8
  0044c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00451	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00454	ff c0		 inc	 eax
  00456	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0045b	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 855  :         if (s->gzhead == Z_NULL) {

  0045e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00463	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00468	0f 85 9f 01 00
	00		 jne	 $LN51@deflate

; 856  :             put_byte(s, 0);

  0046e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00473	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00476	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0047b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0047f	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  00483	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00488	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0048b	ff c0		 inc	 eax
  0048d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00492	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 857  :             put_byte(s, 0);

  00495	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0049a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0049d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  004a2	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  004a6	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  004aa	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  004af	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  004b2	ff c0		 inc	 eax
  004b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  004b9	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 858  :             put_byte(s, 0);

  004bc	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  004c1	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  004c4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  004c9	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  004cd	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  004d1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  004d6	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  004d9	ff c0		 inc	 eax
  004db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  004e0	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 859  :             put_byte(s, 0);

  004e3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  004e8	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  004eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  004f0	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  004f4	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  004f8	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  004fd	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00500	ff c0		 inc	 eax
  00502	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00507	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 860  :             put_byte(s, 0);

  0050a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0050f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00512	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00517	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0051b	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  0051f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00524	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00527	ff c0		 inc	 eax
  00529	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0052e	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 861  :             put_byte(s, s->level == 9 ? 2 :

  00531	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00536	83 b8 ac 00 00
	00 09		 cmp	 DWORD PTR [rax+172], 9
  0053d	75 0a		 jne	 SHORT $LN104@deflate
  0053f	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR tv282[rsp], 2
  00547	eb 36		 jmp	 SHORT $LN105@deflate
$LN104@deflate:
  00549	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0054e	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  00555	7d 18		 jge	 SHORT $LN102@deflate
  00557	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0055c	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  00563	7c 0a		 jl	 SHORT $LN102@deflate
  00565	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv281[rsp], 0
  0056d	eb 08		 jmp	 SHORT $LN103@deflate
$LN102@deflate:
  0056f	c7 44 24 64 04
	00 00 00	 mov	 DWORD PTR tv281[rsp], 4
$LN103@deflate:
  00577	8b 44 24 64	 mov	 eax, DWORD PTR tv281[rsp]
  0057b	89 44 24 60	 mov	 DWORD PTR tv282[rsp], eax
$LN105@deflate:
  0057f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00584	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00587	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0058c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00590	0f b6 54 24 60	 movzx	 edx, BYTE PTR tv282[rsp]
  00595	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00598	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0059d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  005a0	ff c0		 inc	 eax
  005a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  005a7	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 862  :                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 863  :                       4 : 0));
; 864  :             put_byte(s, OS_CODE);

  005aa	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  005af	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  005b2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  005b7	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  005bb	c6 04 01 0a	 mov	 BYTE PTR [rcx+rax], 10
  005bf	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  005c4	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  005c7	ff c0		 inc	 eax
  005c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  005ce	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 865  :             s->status = BUSY_STATE;

  005d1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  005d6	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H

; 866  : 
; 867  :             /* Compression must start with an empty pending buffer */
; 868  :             flush_pending(strm);

  005dd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  005e5	e8 00 00 00 00	 call	 flush_pending

; 869  :             if (s->pending != 0) {

  005ea	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  005ef	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  005f3	74 13		 je	 SHORT $LN53@deflate

; 870  :                 s->last_flush = -1;

  005f5	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  005fa	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 871  :                 return Z_OK;

  00601	33 c0		 xor	 eax, eax
  00603	e9 36 0f 00 00	 jmp	 $LN1@deflate
$LN53@deflate:

; 872  :             }
; 873  :         }

  00608	e9 58 03 00 00	 jmp	 $LN52@deflate
$LN51@deflate:

; 874  :         else {
; 875  :             put_byte(s, (s->gzhead->text ? 1 : 0) +

  0060d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00612	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00616	83 38 00	 cmp	 DWORD PTR [rax], 0
  00619	74 0a		 je	 SHORT $LN106@deflate
  0061b	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv308[rsp], 1
  00623	eb 08		 jmp	 SHORT $LN107@deflate
$LN106@deflate:
  00625	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv308[rsp], 0
$LN107@deflate:
  0062d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00632	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00636	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0063a	74 0a		 je	 SHORT $LN108@deflate
  0063c	c7 44 24 6c 02
	00 00 00	 mov	 DWORD PTR tv312[rsp], 2
  00644	eb 08		 jmp	 SHORT $LN109@deflate
$LN108@deflate:
  00646	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv312[rsp], 0
$LN109@deflate:
  0064e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00653	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00657	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0065c	75 0a		 jne	 SHORT $LN110@deflate
  0065e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv317[rsp], 0
  00666	eb 08		 jmp	 SHORT $LN111@deflate
$LN110@deflate:
  00668	c7 44 24 70 04
	00 00 00	 mov	 DWORD PTR tv317[rsp], 4
$LN111@deflate:
  00670	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00675	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00679	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0067e	75 0a		 jne	 SHORT $LN112@deflate
  00680	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv322[rsp], 0
  00688	eb 08		 jmp	 SHORT $LN113@deflate
$LN112@deflate:
  0068a	c7 44 24 74 08
	00 00 00	 mov	 DWORD PTR tv322[rsp], 8
$LN113@deflate:
  00692	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00697	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0069b	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  006a0	75 0a		 jne	 SHORT $LN114@deflate
  006a2	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv327[rsp], 0
  006aa	eb 08		 jmp	 SHORT $LN115@deflate
$LN114@deflate:
  006ac	c7 44 24 78 10
	00 00 00	 mov	 DWORD PTR tv327[rsp], 16
$LN115@deflate:
  006b4	8b 44 24 6c	 mov	 eax, DWORD PTR tv312[rsp]
  006b8	8b 4c 24 68	 mov	 ecx, DWORD PTR tv308[rsp]
  006bc	03 c8		 add	 ecx, eax
  006be	8b c1		 mov	 eax, ecx
  006c0	03 44 24 70	 add	 eax, DWORD PTR tv317[rsp]
  006c4	03 44 24 74	 add	 eax, DWORD PTR tv322[rsp]
  006c8	03 44 24 78	 add	 eax, DWORD PTR tv327[rsp]
  006cc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  006d1	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  006d4	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  006d9	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  006dd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006e0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  006e5	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  006e8	ff c0		 inc	 eax
  006ea	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  006ef	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 876  :                      (s->gzhead->hcrc ? 2 : 0) +
; 877  :                      (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 878  :                      (s->gzhead->name == Z_NULL ? 0 : 8) +
; 879  :                      (s->gzhead->comment == Z_NULL ? 0 : 16)
; 880  :                      );
; 881  :             put_byte(s, (Byte)(s->gzhead->time & 0xff));

  006f2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  006f7	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  006fb	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  006fe	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00703	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00708	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0070b	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00710	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00714	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00717	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0071c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0071f	ff c0		 inc	 eax
  00721	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00726	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 882  :             put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  00729	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0072e	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00732	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00735	c1 e8 08	 shr	 eax, 8
  00738	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0073d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00742	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00745	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  0074a	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0074e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00751	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00756	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00759	ff c0		 inc	 eax
  0075b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00760	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 883  :             put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  00763	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00768	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0076c	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0076f	c1 e8 10	 shr	 eax, 16
  00772	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00777	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0077c	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0077f	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00784	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00788	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0078b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00790	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00793	ff c0		 inc	 eax
  00795	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0079a	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 884  :             put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  0079d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  007a2	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  007a6	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  007a9	c1 e8 18	 shr	 eax, 24
  007ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  007b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  007b6	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  007b9	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  007be	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  007c2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007c5	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  007ca	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  007cd	ff c0		 inc	 eax
  007cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  007d4	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 885  :             put_byte(s, s->level == 9 ? 2 :

  007d7	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  007dc	83 b8 ac 00 00
	00 09		 cmp	 DWORD PTR [rax+172], 9
  007e3	75 0a		 jne	 SHORT $LN118@deflate
  007e5	c7 44 24 7c 02
	00 00 00	 mov	 DWORD PTR tv396[rsp], 2
  007ed	eb 3f		 jmp	 SHORT $LN119@deflate
$LN118@deflate:
  007ef	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  007f4	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  007fb	7d 1b		 jge	 SHORT $LN116@deflate
  007fd	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00802	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  00809	7c 0d		 jl	 SHORT $LN116@deflate
  0080b	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv395[rsp], 0
  00816	eb 0b		 jmp	 SHORT $LN117@deflate
$LN116@deflate:
  00818	c7 84 24 80 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv395[rsp], 4
$LN117@deflate:
  00823	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv395[rsp]
  0082a	89 44 24 7c	 mov	 DWORD PTR tv396[rsp], eax
$LN119@deflate:
  0082e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00833	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00836	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0083b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0083f	0f b6 54 24 7c	 movzx	 edx, BYTE PTR tv396[rsp]
  00844	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00847	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0084c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0084f	ff c0		 inc	 eax
  00851	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00856	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 886  :                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 887  :                       4 : 0));
; 888  :             put_byte(s, s->gzhead->os & 0xff);

  00859	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0085e	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00862	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00865	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0086a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0086f	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00872	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00877	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0087b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0087e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00883	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00886	ff c0		 inc	 eax
  00888	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0088d	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 889  :             if (s->gzhead->extra != Z_NULL) {

  00890	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00895	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00899	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0089e	74 71		 je	 SHORT $LN54@deflate

; 890  :                 put_byte(s, s->gzhead->extra_len & 0xff);

  008a0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  008a5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  008a9	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  008ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  008b6	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  008b9	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  008be	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  008c2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008c5	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  008ca	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  008cd	ff c0		 inc	 eax
  008cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  008d4	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 891  :                 put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  008d7	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  008dc	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  008e0	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  008e3	c1 e8 08	 shr	 eax, 8
  008e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  008eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  008f0	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  008f3	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  008f8	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  008fc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008ff	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00904	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00907	ff c0		 inc	 eax
  00909	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0090e	89 41 28	 mov	 DWORD PTR [rcx+40], eax
$LN54@deflate:

; 892  :             }
; 893  :             if (s->gzhead->hcrc)

  00911	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00916	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0091a	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0091e	74 2d		 je	 SHORT $LN55@deflate

; 894  :                 strm->adler = crc32(strm->adler, s->pending_buf,

  00920	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00925	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  00929	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0092e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00932	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0093a	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  0093d	e8 00 00 00 00	 call	 crc32
  00942	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0094a	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN55@deflate:

; 895  :                                     s->pending);
; 896  :             s->gzindex = 0;

  0094d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00952	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 897  :             s->status = EXTRA_STATE;

  00959	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0095e	c7 40 08 45 00
	00 00		 mov	 DWORD PTR [rax+8], 69	; 00000045H
$LN52@deflate:
$LN50@deflate:

; 898  :         }
; 899  :     }
; 900  :     if (s->status == EXTRA_STATE) {

  00965	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0096a	83 78 08 45	 cmp	 DWORD PTR [rax+8], 69	; 00000045H
  0096e	0f 85 67 02 00
	00		 jne	 $LN56@deflate

; 901  :         if (s->gzhead->extra != Z_NULL) {

  00974	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00979	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0097d	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00982	0f 84 47 02 00
	00		 je	 $LN57@deflate

; 902  :             ulg beg = s->pending;   /* start of bytes to update crc */

  00988	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0098d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00990	89 44 24 38	 mov	 DWORD PTR beg$3[rsp], eax

; 903  :             uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;

  00994	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00999	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0099d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  009a0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  009a5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  009aa	2b 41 38	 sub	 eax, DWORD PTR [rcx+56]
  009ad	89 44 24 3c	 mov	 DWORD PTR left$4[rsp], eax
$LN2@deflate:

; 904  :             while (s->pending + left > s->pending_buf_size) {

  009b1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  009b6	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  009b9	03 44 24 3c	 add	 eax, DWORD PTR left$4[rsp]
  009bd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  009c2	3b 41 18	 cmp	 eax, DWORD PTR [rcx+24]
  009c5	0f 86 33 01 00
	00		 jbe	 $LN3@deflate

; 905  :                 uInt copy = s->pending_buf_size - s->pending;

  009cb	0f ae e8	 lfence
  009ce	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  009d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  009d8	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  009db	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  009de	2b c1		 sub	 eax, ecx
  009e0	89 44 24 40	 mov	 DWORD PTR copy$5[rsp], eax

; 906  :                 zmemcpy(s->pending_buf + s->pending,

  009e4	8b 44 24 40	 mov	 eax, DWORD PTR copy$5[rsp]
  009e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  009ed	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  009f1	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  009f6	8b 52 38	 mov	 edx, DWORD PTR [rdx+56]
  009f9	48 03 51 10	 add	 rdx, QWORD PTR [rcx+16]
  009fd	48 8b ca	 mov	 rcx, rdx
  00a00	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00a05	8b 52 28	 mov	 edx, DWORD PTR [rdx+40]
  00a08	4c 8b 44 24 28	 mov	 r8, QWORD PTR s$[rsp]
  00a0d	49 03 50 10	 add	 rdx, QWORD PTR [r8+16]
  00a11	48 89 94 24 88
	00 00 00	 mov	 QWORD PTR tv481[rsp], rdx
  00a19	44 8b c0	 mov	 r8d, eax
  00a1c	48 8b d1	 mov	 rdx, rcx
  00a1f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv481[rsp]
  00a27	48 8b c8	 mov	 rcx, rax
  00a2a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 907  :                         s->gzhead->extra + s->gzindex, copy);
; 908  :                 s->pending = s->pending_buf_size;

  00a30	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00a35	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00a3a	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00a3d	89 48 28	 mov	 DWORD PTR [rax+40], ecx
$LN6@deflate:

; 909  :                 HCRC_UPDATE(beg);

  00a40	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00a45	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00a49	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00a4d	74 4d		 je	 SHORT $LN58@deflate
  00a4f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00a54	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$3[rsp]
  00a58	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00a5b	76 3f		 jbe	 SHORT $LN58@deflate
  00a5d	0f ae e8	 lfence
  00a60	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00a65	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$3[rsp]
  00a69	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00a6c	2b c1		 sub	 eax, ecx
  00a6e	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$3[rsp]
  00a72	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00a77	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00a7b	44 8b c0	 mov	 r8d, eax
  00a7e	48 8b d1	 mov	 rdx, rcx
  00a81	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00a89	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00a8c	e8 00 00 00 00	 call	 crc32
  00a91	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00a99	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN58@deflate:
  00a9c	33 c0		 xor	 eax, eax
  00a9e	85 c0		 test	 eax, eax
  00aa0	75 9e		 jne	 SHORT $LN6@deflate

; 910  :                 s->gzindex += copy;

  00aa2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00aa7	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00aaa	03 44 24 40	 add	 eax, DWORD PTR copy$5[rsp]
  00aae	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00ab3	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 911  :                 flush_pending(strm);

  00ab6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00abe	e8 00 00 00 00	 call	 flush_pending

; 912  :                 if (s->pending != 0) {

  00ac3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00ac8	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00acc	74 13		 je	 SHORT $LN59@deflate

; 913  :                     s->last_flush = -1;

  00ace	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00ad3	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 914  :                     return Z_OK;

  00ada	33 c0		 xor	 eax, eax
  00adc	e9 5d 0a 00 00	 jmp	 $LN1@deflate
$LN59@deflate:

; 915  :                 }
; 916  :                 beg = 0;

  00ae1	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR beg$3[rsp], 0

; 917  :                 left -= copy;

  00ae9	8b 44 24 40	 mov	 eax, DWORD PTR copy$5[rsp]
  00aed	8b 4c 24 3c	 mov	 ecx, DWORD PTR left$4[rsp]
  00af1	2b c8		 sub	 ecx, eax
  00af3	8b c1		 mov	 eax, ecx
  00af5	89 44 24 3c	 mov	 DWORD PTR left$4[rsp], eax

; 918  :             }

  00af9	e9 b3 fe ff ff	 jmp	 $LN2@deflate
$LN3@deflate:

; 919  :             zmemcpy(s->pending_buf + s->pending,

  00afe	0f ae e8	 lfence
  00b01	8b 44 24 3c	 mov	 eax, DWORD PTR left$4[rsp]
  00b05	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00b0a	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00b0e	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00b13	8b 52 38	 mov	 edx, DWORD PTR [rdx+56]
  00b16	48 03 51 10	 add	 rdx, QWORD PTR [rcx+16]
  00b1a	48 8b ca	 mov	 rcx, rdx
  00b1d	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00b22	8b 52 28	 mov	 edx, DWORD PTR [rdx+40]
  00b25	4c 8b 44 24 28	 mov	 r8, QWORD PTR s$[rsp]
  00b2a	49 03 50 10	 add	 rdx, QWORD PTR [r8+16]
  00b2e	48 89 94 24 90
	00 00 00	 mov	 QWORD PTR tv521[rsp], rdx
  00b36	44 8b c0	 mov	 r8d, eax
  00b39	48 8b d1	 mov	 rdx, rcx
  00b3c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv521[rsp]
  00b44	48 8b c8	 mov	 rcx, rax
  00b47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 920  :                     s->gzhead->extra + s->gzindex, left);
; 921  :             s->pending += left;

  00b4d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00b52	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b55	03 44 24 3c	 add	 eax, DWORD PTR left$4[rsp]
  00b59	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00b5e	89 41 28	 mov	 DWORD PTR [rcx+40], eax
$LN9@deflate:

; 922  :             HCRC_UPDATE(beg);

  00b61	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00b66	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00b6a	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00b6e	74 4d		 je	 SHORT $LN60@deflate
  00b70	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00b75	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$3[rsp]
  00b79	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00b7c	76 3f		 jbe	 SHORT $LN60@deflate
  00b7e	0f ae e8	 lfence
  00b81	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00b86	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$3[rsp]
  00b8a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b8d	2b c1		 sub	 eax, ecx
  00b8f	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$3[rsp]
  00b93	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00b98	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00b9c	44 8b c0	 mov	 r8d, eax
  00b9f	48 8b d1	 mov	 rdx, rcx
  00ba2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00baa	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00bad	e8 00 00 00 00	 call	 crc32
  00bb2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00bba	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN60@deflate:
  00bbd	33 c0		 xor	 eax, eax
  00bbf	85 c0		 test	 eax, eax
  00bc1	75 9e		 jne	 SHORT $LN9@deflate

; 923  :             s->gzindex = 0;

  00bc3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00bc8	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0
$LN57@deflate:

; 924  :         }
; 925  :         s->status = NAME_STATE;

  00bcf	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00bd4	c7 40 08 49 00
	00 00		 mov	 DWORD PTR [rax+8], 73	; 00000049H
$LN56@deflate:

; 926  :     }
; 927  :     if (s->status == NAME_STATE) {

  00bdb	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00be0	83 78 08 49	 cmp	 DWORD PTR [rax+8], 73	; 00000049H
  00be4	0f 85 aa 01 00
	00		 jne	 $LN61@deflate

; 928  :         if (s->gzhead->name != Z_NULL) {

  00bea	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00bef	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00bf3	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00bf8	0f 84 8a 01 00
	00		 je	 $LN62@deflate

; 929  :             ulg beg = s->pending;   /* start of bytes to update crc */

  00bfe	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00c03	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00c06	89 44 24 44	 mov	 DWORD PTR beg$6[rsp], eax
$LN12@deflate:

; 930  :             int val;
; 931  :             do {
; 932  :                 if (s->pending == s->pending_buf_size) {

  00c0a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00c0f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00c14	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00c17	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00c1a	0f 85 95 00 00
	00		 jne	 $LN63@deflate
$LN15@deflate:

; 933  :                     HCRC_UPDATE(beg);

  00c20	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00c25	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00c29	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00c2d	74 4d		 je	 SHORT $LN64@deflate
  00c2f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00c34	8b 4c 24 44	 mov	 ecx, DWORD PTR beg$6[rsp]
  00c38	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00c3b	76 3f		 jbe	 SHORT $LN64@deflate
  00c3d	0f ae e8	 lfence
  00c40	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00c45	8b 4c 24 44	 mov	 ecx, DWORD PTR beg$6[rsp]
  00c49	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00c4c	2b c1		 sub	 eax, ecx
  00c4e	8b 4c 24 44	 mov	 ecx, DWORD PTR beg$6[rsp]
  00c52	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00c57	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00c5b	44 8b c0	 mov	 r8d, eax
  00c5e	48 8b d1	 mov	 rdx, rcx
  00c61	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00c69	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00c6c	e8 00 00 00 00	 call	 crc32
  00c71	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00c79	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN64@deflate:
  00c7c	33 c0		 xor	 eax, eax
  00c7e	85 c0		 test	 eax, eax
  00c80	75 9e		 jne	 SHORT $LN15@deflate

; 934  :                     flush_pending(strm);

  00c82	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00c8a	e8 00 00 00 00	 call	 flush_pending

; 935  :                     if (s->pending != 0) {

  00c8f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00c94	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00c98	74 13		 je	 SHORT $LN65@deflate

; 936  :                         s->last_flush = -1;

  00c9a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00c9f	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 937  :                         return Z_OK;

  00ca6	33 c0		 xor	 eax, eax
  00ca8	e9 91 08 00 00	 jmp	 $LN1@deflate
$LN65@deflate:

; 938  :                     }
; 939  :                     beg = 0;

  00cad	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR beg$6[rsp], 0
$LN63@deflate:

; 940  :                 }
; 941  :                 val = s->gzhead->name[s->gzindex++];

  00cb5	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00cba	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00cbe	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00cc3	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  00cc6	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00cca	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00cce	89 44 24 48	 mov	 DWORD PTR val$7[rsp], eax
  00cd2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00cd7	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00cda	ff c0		 inc	 eax
  00cdc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00ce1	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 942  :                 put_byte(s, val);

  00ce4	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00ce9	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00cec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00cf1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00cf5	0f b6 54 24 48	 movzx	 edx, BYTE PTR val$7[rsp]
  00cfa	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00cfd	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00d02	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00d05	ff c0		 inc	 eax
  00d07	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00d0c	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 943  :             } while (val != 0);

  00d0f	83 7c 24 48 00	 cmp	 DWORD PTR val$7[rsp], 0
  00d14	0f 85 f0 fe ff
	ff		 jne	 $LN12@deflate
$LN18@deflate:

; 944  :             HCRC_UPDATE(beg);

  00d1a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00d1f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00d23	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00d27	74 4d		 je	 SHORT $LN66@deflate
  00d29	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00d2e	8b 4c 24 44	 mov	 ecx, DWORD PTR beg$6[rsp]
  00d32	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00d35	76 3f		 jbe	 SHORT $LN66@deflate
  00d37	0f ae e8	 lfence
  00d3a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00d3f	8b 4c 24 44	 mov	 ecx, DWORD PTR beg$6[rsp]
  00d43	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00d46	2b c1		 sub	 eax, ecx
  00d48	8b 4c 24 44	 mov	 ecx, DWORD PTR beg$6[rsp]
  00d4c	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00d51	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00d55	44 8b c0	 mov	 r8d, eax
  00d58	48 8b d1	 mov	 rdx, rcx
  00d5b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00d63	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00d66	e8 00 00 00 00	 call	 crc32
  00d6b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00d73	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN66@deflate:
  00d76	33 c0		 xor	 eax, eax
  00d78	85 c0		 test	 eax, eax
  00d7a	75 9e		 jne	 SHORT $LN18@deflate

; 945  :             s->gzindex = 0;

  00d7c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00d81	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0
$LN62@deflate:

; 946  :         }
; 947  :         s->status = COMMENT_STATE;

  00d88	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00d8d	c7 40 08 5b 00
	00 00		 mov	 DWORD PTR [rax+8], 91	; 0000005bH
$LN61@deflate:

; 948  :     }
; 949  :     if (s->status == COMMENT_STATE) {

  00d94	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00d99	83 78 08 5b	 cmp	 DWORD PTR [rax+8], 91	; 0000005bH
  00d9d	0f 85 9e 01 00
	00		 jne	 $LN67@deflate

; 950  :         if (s->gzhead->comment != Z_NULL) {

  00da3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00da8	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00dac	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00db1	0f 84 7e 01 00
	00		 je	 $LN68@deflate

; 951  :             ulg beg = s->pending;   /* start of bytes to update crc */

  00db7	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00dbc	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00dbf	89 44 24 4c	 mov	 DWORD PTR beg$8[rsp], eax
$LN21@deflate:

; 952  :             int val;
; 953  :             do {
; 954  :                 if (s->pending == s->pending_buf_size) {

  00dc3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00dc8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00dcd	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00dd0	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00dd3	0f 85 95 00 00
	00		 jne	 $LN69@deflate
$LN24@deflate:

; 955  :                     HCRC_UPDATE(beg);

  00dd9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00dde	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00de2	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00de6	74 4d		 je	 SHORT $LN70@deflate
  00de8	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00ded	8b 4c 24 4c	 mov	 ecx, DWORD PTR beg$8[rsp]
  00df1	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00df4	76 3f		 jbe	 SHORT $LN70@deflate
  00df6	0f ae e8	 lfence
  00df9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00dfe	8b 4c 24 4c	 mov	 ecx, DWORD PTR beg$8[rsp]
  00e02	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00e05	2b c1		 sub	 eax, ecx
  00e07	8b 4c 24 4c	 mov	 ecx, DWORD PTR beg$8[rsp]
  00e0b	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00e10	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00e14	44 8b c0	 mov	 r8d, eax
  00e17	48 8b d1	 mov	 rdx, rcx
  00e1a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00e22	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00e25	e8 00 00 00 00	 call	 crc32
  00e2a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00e32	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN70@deflate:
  00e35	33 c0		 xor	 eax, eax
  00e37	85 c0		 test	 eax, eax
  00e39	75 9e		 jne	 SHORT $LN24@deflate

; 956  :                     flush_pending(strm);

  00e3b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00e43	e8 00 00 00 00	 call	 flush_pending

; 957  :                     if (s->pending != 0) {

  00e48	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00e4d	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00e51	74 13		 je	 SHORT $LN71@deflate

; 958  :                         s->last_flush = -1;

  00e53	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00e58	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 959  :                         return Z_OK;

  00e5f	33 c0		 xor	 eax, eax
  00e61	e9 d8 06 00 00	 jmp	 $LN1@deflate
$LN71@deflate:

; 960  :                     }
; 961  :                     beg = 0;

  00e66	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR beg$8[rsp], 0
$LN69@deflate:

; 962  :                 }
; 963  :                 val = s->gzhead->comment[s->gzindex++];

  00e6e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00e73	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00e77	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00e7c	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  00e7f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00e83	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00e87	89 44 24 50	 mov	 DWORD PTR val$9[rsp], eax
  00e8b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00e90	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00e93	ff c0		 inc	 eax
  00e95	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00e9a	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 964  :                 put_byte(s, val);

  00e9d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00ea2	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00ea5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00eaa	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00eae	0f b6 54 24 50	 movzx	 edx, BYTE PTR val$9[rsp]
  00eb3	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00eb6	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00ebb	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00ebe	ff c0		 inc	 eax
  00ec0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00ec5	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 965  :             } while (val != 0);

  00ec8	83 7c 24 50 00	 cmp	 DWORD PTR val$9[rsp], 0
  00ecd	0f 85 f0 fe ff
	ff		 jne	 $LN21@deflate
$LN27@deflate:

; 966  :             HCRC_UPDATE(beg);

  00ed3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00ed8	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00edc	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00ee0	74 4d		 je	 SHORT $LN72@deflate
  00ee2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00ee7	8b 4c 24 4c	 mov	 ecx, DWORD PTR beg$8[rsp]
  00eeb	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00eee	76 3f		 jbe	 SHORT $LN72@deflate
  00ef0	0f ae e8	 lfence
  00ef3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00ef8	8b 4c 24 4c	 mov	 ecx, DWORD PTR beg$8[rsp]
  00efc	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00eff	2b c1		 sub	 eax, ecx
  00f01	8b 4c 24 4c	 mov	 ecx, DWORD PTR beg$8[rsp]
  00f05	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00f0a	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00f0e	44 8b c0	 mov	 r8d, eax
  00f11	48 8b d1	 mov	 rdx, rcx
  00f14	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00f1c	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00f1f	e8 00 00 00 00	 call	 crc32
  00f24	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00f2c	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN72@deflate:
  00f2f	33 c0		 xor	 eax, eax
  00f31	85 c0		 test	 eax, eax
  00f33	75 9e		 jne	 SHORT $LN27@deflate
$LN68@deflate:

; 967  :         }
; 968  :         s->status = HCRC_STATE;

  00f35	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00f3a	c7 40 08 67 00
	00 00		 mov	 DWORD PTR [rax+8], 103	; 00000067H
$LN67@deflate:

; 969  :     }
; 970  :     if (s->status == HCRC_STATE) {

  00f41	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00f46	83 78 08 67	 cmp	 DWORD PTR [rax+8], 103	; 00000067H
  00f4a	0f 85 10 01 00
	00		 jne	 $LN73@deflate

; 971  :         if (s->gzhead->hcrc) {

  00f50	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00f55	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00f59	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00f5d	0f 84 c6 00 00
	00		 je	 $LN74@deflate

; 972  :             if (s->pending + 2 > s->pending_buf_size) {

  00f63	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00f68	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00f6b	83 c0 02	 add	 eax, 2
  00f6e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00f73	3b 41 18	 cmp	 eax, DWORD PTR [rcx+24]
  00f76	76 2b		 jbe	 SHORT $LN75@deflate

; 973  :                 flush_pending(strm);

  00f78	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00f80	e8 00 00 00 00	 call	 flush_pending

; 974  :                 if (s->pending != 0) {

  00f85	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00f8a	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00f8e	74 13		 je	 SHORT $LN76@deflate

; 975  :                     s->last_flush = -1;

  00f90	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00f95	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 976  :                     return Z_OK;

  00f9c	33 c0		 xor	 eax, eax
  00f9e	e9 9b 05 00 00	 jmp	 $LN1@deflate
$LN76@deflate:
$LN75@deflate:

; 977  :                 }
; 978  :             }
; 979  :             put_byte(s, (Byte)(strm->adler & 0xff));

  00fa3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00fab	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00fae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00fb3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00fb8	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00fbb	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00fc0	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00fc4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00fc7	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00fcc	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00fcf	ff c0		 inc	 eax
  00fd1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00fd6	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 980  :             put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  00fd9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00fe1	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00fe4	c1 e8 08	 shr	 eax, 8
  00fe7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00fec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00ff1	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00ff4	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00ff9	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00ffd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01000	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01005	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  01008	ff c0		 inc	 eax
  0100a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0100f	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 981  :             strm->adler = crc32(0L, Z_NULL, 0);

  01012	45 33 c0	 xor	 r8d, r8d
  01015	33 d2		 xor	 edx, edx
  01017	33 c9		 xor	 ecx, ecx
  01019	e8 00 00 00 00	 call	 crc32
  0101e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01026	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN74@deflate:

; 982  :         }
; 983  :         s->status = BUSY_STATE;

  01029	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0102e	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H

; 984  : 
; 985  :         /* Compression must start with an empty pending buffer */
; 986  :         flush_pending(strm);

  01035	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0103d	e8 00 00 00 00	 call	 flush_pending

; 987  :         if (s->pending != 0) {

  01042	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01047	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0104b	74 13		 je	 SHORT $LN77@deflate

; 988  :             s->last_flush = -1;

  0104d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01052	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 989  :             return Z_OK;

  01059	33 c0		 xor	 eax, eax
  0105b	e9 de 04 00 00	 jmp	 $LN1@deflate
$LN77@deflate:
$LN73@deflate:

; 990  :         }
; 991  :     }
; 992  : #endif
; 993  : 
; 994  :     /* Start a new block or continue the current one.
; 995  :      */
; 996  :     if (strm->avail_in != 0 || s->lookahead != 0 ||

  01060	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01068	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0106c	75 2e		 jne	 SHORT $LN79@deflate
  0106e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01073	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  0107a	75 20		 jne	 SHORT $LN79@deflate
  0107c	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  01084	0f 84 31 02 00
	00		 je	 $LN78@deflate
  0108a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0108f	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  01096	0f 84 1f 02 00
	00		 je	 $LN78@deflate
$LN79@deflate:

; 997  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
; 998  :         block_state bstate;
; 999  : 
; 1000 :         bstate = s->level == 0 ? deflate_stored(s, flush) :

  0109c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  010a1	83 b8 ac 00 00
	00 00		 cmp	 DWORD PTR [rax+172], 0
  010a8	75 1d		 jne	 SHORT $LN124@deflate
  010aa	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  010b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  010b6	e8 00 00 00 00	 call	 deflate_stored
  010bb	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv757[rsp], eax
  010c2	e9 ab 00 00 00	 jmp	 $LN125@deflate
$LN124@deflate:
  010c7	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  010cc	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  010d3	75 1a		 jne	 SHORT $LN122@deflate
  010d5	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  010dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  010e1	e8 00 00 00 00	 call	 deflate_huff
  010e6	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv756[rsp], eax
  010ed	eb 75		 jmp	 SHORT $LN123@deflate
$LN122@deflate:
  010ef	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  010f4	83 b8 b0 00 00
	00 03		 cmp	 DWORD PTR [rax+176], 3
  010fb	75 1a		 jne	 SHORT $LN120@deflate
  010fd	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  01104	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01109	e8 00 00 00 00	 call	 deflate_rle
  0110e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv755[rsp], eax
  01115	eb 3f		 jmp	 SHORT $LN121@deflate
$LN120@deflate:
  01117	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0111c	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  01123	48 6b c0 10	 imul	 rax, rax, 16
  01127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  0112e	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR tv934[rsp], rcx
  01136	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  0113d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01142	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR tv934[rsp]
  0114a	41 ff 54 00 08	 call	 QWORD PTR [r8+rax+8]
  0114f	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv755[rsp], eax
$LN121@deflate:
  01156	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv755[rsp]
  0115d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv756[rsp], eax
$LN123@deflate:
  01164	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv756[rsp]
  0116b	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv757[rsp], eax
$LN125@deflate:
  01172	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv757[rsp]
  01179	89 44 24 54	 mov	 DWORD PTR bstate$10[rsp], eax

; 1001 :                  s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
; 1002 :                  s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 1003 :                  (*(configuration_table[s->level].func))(s, flush);
; 1004 : 
; 1005 :         if (bstate == finish_started || bstate == finish_done) {

  0117d	83 7c 24 54 02	 cmp	 DWORD PTR bstate$10[rsp], 2
  01182	74 07		 je	 SHORT $LN81@deflate
  01184	83 7c 24 54 03	 cmp	 DWORD PTR bstate$10[rsp], 3
  01189	75 0c		 jne	 SHORT $LN80@deflate
$LN81@deflate:

; 1006 :             s->status = FINISH_STATE;

  0118b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01190	c7 40 08 9a 02
	00 00		 mov	 DWORD PTR [rax+8], 666	; 0000029aH
$LN80@deflate:

; 1007 :         }
; 1008 :         if (bstate == need_more || bstate == finish_started) {

  01197	83 7c 24 54 00	 cmp	 DWORD PTR bstate$10[rsp], 0
  0119c	74 07		 je	 SHORT $LN83@deflate
  0119e	83 7c 24 54 02	 cmp	 DWORD PTR bstate$10[rsp], 2
  011a3	75 21		 jne	 SHORT $LN82@deflate
$LN83@deflate:

; 1009 :             if (strm->avail_out == 0) {

  011a5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  011ad	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  011b1	75 0c		 jne	 SHORT $LN84@deflate

; 1010 :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */

  011b3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  011b8	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN84@deflate:

; 1011 :             }
; 1012 :             return Z_OK;

  011bf	33 c0		 xor	 eax, eax
  011c1	e9 78 03 00 00	 jmp	 $LN1@deflate
$LN82@deflate:

; 1013 :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 1014 :              * of deflate should use the same flush parameter to make sure
; 1015 :              * that the flush is complete. So we don't have to output an
; 1016 :              * empty block here, this will be done at next call. This also
; 1017 :              * ensures that for a very small output buffer, we emit at most
; 1018 :              * one empty block.
; 1019 :              */
; 1020 :         }
; 1021 :         if (bstate == block_done) {

  011c6	83 7c 24 54 01	 cmp	 DWORD PTR bstate$10[rsp], 1
  011cb	0f 85 ea 00 00
	00		 jne	 $LN85@deflate

; 1022 :             if (flush == Z_PARTIAL_FLUSH) {

  011d1	83 bc 24 d8 00
	00 00 01	 cmp	 DWORD PTR flush$[rsp], 1
  011d9	75 0f		 jne	 SHORT $LN86@deflate

; 1023 :                 _tr_align(s);

  011db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  011e0	e8 00 00 00 00	 call	 _tr_align
  011e5	e9 a3 00 00 00	 jmp	 $LN87@deflate
$LN86@deflate:

; 1024 :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  011ea	83 bc 24 d8 00
	00 00 05	 cmp	 DWORD PTR flush$[rsp], 5
  011f2	0f 84 95 00 00
	00		 je	 $LN88@deflate

; 1025 :                 _tr_stored_block(s, (char*)0, 0L, 0);

  011f8	45 33 c9	 xor	 r9d, r9d
  011fb	45 33 c0	 xor	 r8d, r8d
  011fe	33 d2		 xor	 edx, edx
  01200	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01205	e8 00 00 00 00	 call	 _tr_stored_block

; 1026 :                 /* For a full flush, this empty block will be recognized
; 1027 :                  * as a special marker by inflate_sync().
; 1028 :                  */
; 1029 :                 if (flush == Z_FULL_FLUSH) {

  0120a	83 bc 24 d8 00
	00 00 03	 cmp	 DWORD PTR flush$[rsp], 3
  01212	75 79		 jne	 SHORT $LN89@deflate

; 1030 :                     CLEAR_HASH(s);             /* forget history */

  01214	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01219	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0121c	ff c8		 dec	 eax
  0121e	8b c0		 mov	 eax, eax
  01220	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01225	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01229	33 d2		 xor	 edx, edx
  0122b	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  0122f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01234	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  01237	ff c8		 dec	 eax
  01239	8b c0		 mov	 eax, eax
  0123b	48 d1 e0	 shl	 rax, 1
  0123e	4c 8b c0	 mov	 r8, rax
  01241	33 d2		 xor	 edx, edx
  01243	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01248	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  0124c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memset

; 1031 :                     if (s->lookahead == 0) {

  01252	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01257	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  0125e	75 2d		 jne	 SHORT $LN90@deflate

; 1032 :                         s->strstart = 0;

  01260	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01265	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 1033 :                         s->block_start = 0L;

  0126f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01274	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0

; 1034 :                         s->insert = 0;

  0127e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01283	c7 80 0c 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5900], 0
$LN90@deflate:
$LN89@deflate:
$LN88@deflate:
$LN87@deflate:

; 1035 :                     }
; 1036 :                 }
; 1037 :             }
; 1038 :             flush_pending(strm);

  0128d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01295	e8 00 00 00 00	 call	 flush_pending

; 1039 :             if (strm->avail_out == 0) {

  0129a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  012a2	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  012a6	75 13		 jne	 SHORT $LN91@deflate

; 1040 :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */

  012a8	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  012ad	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 1041 :               return Z_OK;

  012b4	33 c0		 xor	 eax, eax
  012b6	e9 83 02 00 00	 jmp	 $LN1@deflate
$LN91@deflate:
$LN85@deflate:
$LN78@deflate:

; 1042 :             }
; 1043 :         }
; 1044 :     }
; 1045 : 
; 1046 :     if (flush != Z_FINISH) return Z_OK;

  012bb	83 bc 24 d8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  012c3	74 07		 je	 SHORT $LN92@deflate
  012c5	33 c0		 xor	 eax, eax
  012c7	e9 72 02 00 00	 jmp	 $LN1@deflate
$LN92@deflate:

; 1047 :     if (s->wrap <= 0) return Z_STREAM_END;

  012cc	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  012d1	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  012d5	7f 0a		 jg	 SHORT $LN93@deflate
  012d7	b8 01 00 00 00	 mov	 eax, 1
  012dc	e9 5d 02 00 00	 jmp	 $LN1@deflate
$LN93@deflate:

; 1048 : 
; 1049 :     /* Write the trailer */
; 1050 : #ifdef GZIP
; 1051 :     if (s->wrap == 2) {

  012e1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  012e6	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  012ea	0f 85 c4 01 00
	00		 jne	 $LN94@deflate

; 1052 :         put_byte(s, (Byte)(strm->adler & 0xff));

  012f0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  012f8	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  012fb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01300	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01305	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  01308	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  0130d	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  01311	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01314	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01319	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0131c	ff c0		 inc	 eax
  0131e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01323	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1053 :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  01326	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0132e	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01331	c1 e8 08	 shr	 eax, 8
  01334	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01339	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0133e	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  01341	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  01346	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0134a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0134d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01352	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  01355	ff c0		 inc	 eax
  01357	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0135c	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1054 :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  0135f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01367	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0136a	c1 e8 10	 shr	 eax, 16
  0136d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01372	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01377	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0137a	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  0137f	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  01383	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01386	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0138b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0138e	ff c0		 inc	 eax
  01390	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01395	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1055 :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  01398	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  013a0	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  013a3	c1 e8 18	 shr	 eax, 24
  013a6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  013ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  013b0	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  013b3	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  013b8	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  013bc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  013bf	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  013c4	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  013c7	ff c0		 inc	 eax
  013c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  013ce	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1056 :         put_byte(s, (Byte)(strm->total_in & 0xff));

  013d1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  013d9	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  013dc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  013e1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  013e6	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  013e9	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  013ee	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  013f2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  013f5	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  013fa	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  013fd	ff c0		 inc	 eax
  013ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01404	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1057 :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  01407	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0140f	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  01412	c1 e8 08	 shr	 eax, 8
  01415	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0141a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0141f	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  01422	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  01427	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0142b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0142e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01433	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  01436	ff c0		 inc	 eax
  01438	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0143d	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1058 :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  01440	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01448	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0144b	c1 e8 10	 shr	 eax, 16
  0144e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01453	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01458	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0145b	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  01460	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  01464	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01467	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0146c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0146f	ff c0		 inc	 eax
  01471	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01476	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1059 :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  01479	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01481	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  01484	c1 e8 18	 shr	 eax, 24
  01487	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0148c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01491	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  01494	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  01499	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0149d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  014a0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  014a5	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  014a8	ff c0		 inc	 eax
  014aa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  014af	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 1060 :     }

  014b2	eb 36		 jmp	 SHORT $LN95@deflate
$LN94@deflate:

; 1061 :     else
; 1062 : #endif
; 1063 :     {
; 1064 :         putShortMSB(s, (uInt)(strm->adler >> 16));

  014b4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  014bc	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  014bf	c1 e8 10	 shr	 eax, 16
  014c2	8b d0		 mov	 edx, eax
  014c4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  014c9	e8 00 00 00 00	 call	 putShortMSB

; 1065 :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  014ce	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  014d6	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  014d9	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  014de	8b d0		 mov	 edx, eax
  014e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  014e5	e8 00 00 00 00	 call	 putShortMSB
$LN95@deflate:

; 1066 :     }
; 1067 :     flush_pending(strm);

  014ea	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  014f2	e8 00 00 00 00	 call	 flush_pending

; 1068 :     /* If avail_out is zero, the application will call deflate again
; 1069 :      * to flush the rest.
; 1070 :      */
; 1071 :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  014f7	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  014fc	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  01500	7e 12		 jle	 SHORT $LN96@deflate
  01502	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01507	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0150a	f7 d8		 neg	 eax
  0150c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  01511	89 41 2c	 mov	 DWORD PTR [rcx+44], eax
$LN96@deflate:

; 1072 :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  01514	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  01519	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0151d	74 0d		 je	 SHORT $LN126@deflate
  0151f	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv913[rsp], 0
  0152a	eb 0b		 jmp	 SHORT $LN127@deflate
$LN126@deflate:
  0152c	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv913[rsp], 1
$LN127@deflate:
  01537	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv913[rsp]
$LN1@deflate:

; 1073 : }

  0153e	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  01545	5f		 pop	 rdi
  01546	c3		 ret	 0
deflate	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateEnd
_TEXT	SEGMENT
status$ = 32
tv144 = 36
strm$ = 64
deflateEnd PROC						; COMDAT

; 1078 : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1079 :     int status;
; 1080 : 
; 1081 :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0002f	e8 00 00 00 00	 call	 deflateStateCheck
  00034	85 c0		 test	 eax, eax
  00036	74 0a		 je	 SHORT $LN2@deflateEnd
  00038	b8 fe ff ff ff	 mov	 eax, -2
  0003d	e9 0c 01 00 00	 jmp	 $LN1@deflateEnd
$LN2@deflateEnd:

; 1082 : 
; 1083 :     status = strm->state->status;

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00047	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004e	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 1084 : 
; 1085 :     /* Deallocate in reverse order of allocations: */
; 1086 :     TRY_FREE(strm, strm->state->pending_buf);

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00057	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005b	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00060	74 1e		 je	 SHORT $LN3@deflateEnd
  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00067	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006b	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00074	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007d	ff 50 38	 call	 QWORD PTR [rax+56]
$LN3@deflateEnd:

; 1087 :     TRY_FREE(strm, strm->state->head);

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00085	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00089	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0008e	74 1e		 je	 SHORT $LN4@deflateEnd
  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00095	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00099	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a2	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000a6	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ab	ff 50 38	 call	 QWORD PTR [rax+56]
$LN4@deflateEnd:

; 1088 :     TRY_FREE(strm, strm->state->prev);

  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000b3	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000b7	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000bc	74 1e		 je	 SHORT $LN5@deflateEnd
  000be	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c3	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000c7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d0	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000d4	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d9	ff 50 38	 call	 QWORD PTR [rax+56]
$LN5@deflateEnd:

; 1089 :     TRY_FREE(strm, strm->state->window);

  000dc	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000e1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000e5	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000ea	74 1e		 je	 SHORT $LN6@deflateEnd
  000ec	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000f1	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000f5	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  000f9	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000fe	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00102	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00107	ff 50 38	 call	 QWORD PTR [rax+56]
$LN6@deflateEnd:

; 1090 : 
; 1091 :     ZFREE(strm, strm->state);

  0010a	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0010f	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00118	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0011c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00121	ff 50 38	 call	 QWORD PTR [rax+56]

; 1092 :     strm->state = Z_NULL;

  00124	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00129	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 1093 : 
; 1094 :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  00131	83 7c 24 20 71	 cmp	 DWORD PTR status$[rsp], 113 ; 00000071H
  00136	75 0a		 jne	 SHORT $LN8@deflateEnd
  00138	c7 44 24 24 fd
	ff ff ff	 mov	 DWORD PTR tv144[rsp], -3
  00140	eb 08		 jmp	 SHORT $LN9@deflateEnd
$LN8@deflateEnd:
  00142	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
$LN9@deflateEnd:
  0014a	8b 44 24 24	 mov	 eax, DWORD PTR tv144[rsp]
$LN1@deflateEnd:

; 1095 : }

  0014e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00152	5f		 pop	 rdi
  00153	c3		 ret	 0
deflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateInit_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
version$ = 96
stream_size$ = 104
deflateInit_ PROC					; COMDAT

; 233  : {

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 10 00 00 00	 mov	 ecx, 16
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00033	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 234  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,

  00038	8b 44 24 68	 mov	 eax, DWORD PTR stream_size$[rsp]
  0003c	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00040	48 8b 44 24 60	 mov	 rax, QWORD PTR version$[rsp]
  00045	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0004a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00052	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  0005a	41 b9 0f 00 00
	00		 mov	 r9d, 15
  00060	41 b8 08 00 00
	00		 mov	 r8d, 8
  00066	8b 54 24 58	 mov	 edx, DWORD PTR level$[rsp]
  0006a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0006f	e8 00 00 00 00	 call	 deflateInit2_

; 235  :                          Z_DEFAULT_STRATEGY, version, stream_size);
; 236  :     /* To do: ignore strm->next_in if we use it as window */
; 237  : }

  00074	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
deflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT slide_hash
_TEXT	SEGMENT
n$ = 32
m$ = 36
p$ = 40
wsize$ = 48
tv74 = 52
tv86 = 56
s$ = 80
slide_hash PROC						; COMDAT

; 203  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 204  :     unsigned n, m;
; 205  :     Posf *p;
; 206  :     uInt wsize = s->w_size;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0002f	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00032	89 44 24 30	 mov	 DWORD PTR wsize$[rsp], eax

; 207  : 
; 208  :     n = s->hash_size;

  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0003b	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0003e	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 209  :     p = &s->head[n];

  00042	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0004b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0004f	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00053	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
$LN4@slide_hash:

; 210  :     do {
; 211  :         m = *--p;

  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0005d	48 83 e8 02	 sub	 rax, 2
  00061	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0006b	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0006e	89 44 24 24	 mov	 DWORD PTR m$[rsp], eax

; 212  :         *p = (Pos)(m >= wsize ? m - wsize : NIL);

  00072	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00076	39 44 24 24	 cmp	 DWORD PTR m$[rsp], eax
  0007a	72 12		 jb	 SHORT $LN9@slide_hash
  0007c	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00080	8b 4c 24 24	 mov	 ecx, DWORD PTR m$[rsp]
  00084	2b c8		 sub	 ecx, eax
  00086	8b c1		 mov	 eax, ecx
  00088	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
  0008c	eb 08		 jmp	 SHORT $LN10@slide_hash
$LN9@slide_hash:
  0008e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN10@slide_hash:
  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0009b	0f b7 4c 24 34	 movzx	 ecx, WORD PTR tv74[rsp]
  000a0	66 89 08	 mov	 WORD PTR [rax], cx

; 213  :     } while (--n);

  000a3	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000a7	ff c8		 dec	 eax
  000a9	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
  000ad	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  000b2	75 a4		 jne	 SHORT $LN4@slide_hash

; 214  :     n = wsize;

  000b4	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  000b8	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 215  : #ifndef FASTEST
; 216  :     p = &s->prev[n];

  000bc	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000c5	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000c9	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  000cd	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
$LN7@slide_hash:

; 217  :     do {
; 218  :         m = *--p;

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  000d7	48 83 e8 02	 sub	 rax, 2
  000db	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
  000e0	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  000e5	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000e8	89 44 24 24	 mov	 DWORD PTR m$[rsp], eax

; 219  :         *p = (Pos)(m >= wsize ? m - wsize : NIL);

  000ec	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  000f0	39 44 24 24	 cmp	 DWORD PTR m$[rsp], eax
  000f4	72 12		 jb	 SHORT $LN11@slide_hash
  000f6	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  000fa	8b 4c 24 24	 mov	 ecx, DWORD PTR m$[rsp]
  000fe	2b c8		 sub	 ecx, eax
  00100	8b c1		 mov	 eax, ecx
  00102	89 44 24 38	 mov	 DWORD PTR tv86[rsp], eax
  00106	eb 08		 jmp	 SHORT $LN12@slide_hash
$LN11@slide_hash:
  00108	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN12@slide_hash:
  00110	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00115	0f b7 4c 24 38	 movzx	 ecx, WORD PTR tv86[rsp]
  0011a	66 89 08	 mov	 WORD PTR [rax], cx

; 220  :         /* If n is not on any hash chain, prev[n] is garbage but
; 221  :          * its value will never be used.
; 222  :          */
; 223  :     } while (--n);

  0011d	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00121	ff c8		 dec	 eax
  00123	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
  00127	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  0012c	75 a4		 jne	 SHORT $LN7@slide_hash

; 224  : #endif
; 225  : }

  0012e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00132	5f		 pop	 rdi
  00133	c3		 ret	 0
slide_hash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateInit2_
_TEXT	SEGMENT
s$ = 32
wrap$ = 40
overlay$ = 48
tv290 = 56
tv300 = 60
tv326 = 64
strm$ = 96
level$ = 104
method$ = 112
windowBits$ = 120
memLevel$ = 128
strategy$ = 136
version$ = 144
stream_size$ = 152
deflateInit2_ PROC					; COMDAT

; 250  : {

$LN22:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 14 00 00 00	 mov	 ecx, 20
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00033	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 251  :     deflate_state *s;
; 252  :     int wrap = 1;

  00038	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 1

; 253  :     static const char my_version[] = ZLIB_VERSION;
; 254  : 
; 255  :     ushf *overlay;
; 256  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 257  :      * output size for (length,distance) codes is <= 24 bits.
; 258  :      */
; 259  : 
; 260  :     if (version == Z_NULL || version[0] != my_version[0] ||

  00040	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR version$[rsp], 0
  00049	74 3b		 je	 SHORT $LN3@deflateIni
  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	48 6b c0 00	 imul	 rax, rax, 0
  00054	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR version$[rsp]
  0005c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00060	b9 01 00 00 00	 mov	 ecx, 1
  00065	48 6b c9 00	 imul	 rcx, rcx, 0
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?my_version@?1??deflateInit2_@@9@9
  00070	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00074	3b c1		 cmp	 eax, ecx
  00076	75 0e		 jne	 SHORT $LN3@deflateIni
  00078	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR stream_size$[rsp]
  00080	48 83 f8 58	 cmp	 rax, 88			; 00000058H
  00084	74 0a		 je	 SHORT $LN2@deflateIni
$LN3@deflateIni:

; 261  :         stream_size != sizeof(z_stream)) {
; 262  :         return Z_VERSION_ERROR;

  00086	b8 fa ff ff ff	 mov	 eax, -6
  0008b	e9 1f 04 00 00	 jmp	 $LN1@deflateIni
$LN2@deflateIni:

; 263  :     }
; 264  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00090	48 83 7c 24 60
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00096	75 0a		 jne	 SHORT $LN4@deflateIni
  00098	b8 fe ff ff ff	 mov	 eax, -2
  0009d	e9 0d 04 00 00	 jmp	 $LN1@deflateIni
$LN4@deflateIni:

; 265  : 
; 266  :     strm->msg = Z_NULL;

  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  000a7	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 267  :     if (strm->zalloc == (alloc_func)0) {

  000af	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  000b4	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000b9	75 1d		 jne	 SHORT $LN5@deflateIni

; 268  : #ifdef Z_SOLO
; 269  :         return Z_STREAM_ERROR;
; 270  : #else
; 271  :         strm->zalloc = zcalloc;

  000bb	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcalloc
  000c7	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 272  :         strm->opaque = (voidpf)0;

  000cb	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  000d0	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN5@deflateIni:

; 273  : #endif
; 274  :     }
; 275  :     if (strm->zfree == (free_func)0)

  000d8	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  000dd	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000e2	75 10		 jne	 SHORT $LN6@deflateIni

; 276  : #ifdef Z_SOLO
; 277  :         return Z_STREAM_ERROR;
; 278  : #else
; 279  :         strm->zfree = zcfree;

  000e4	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree
  000f0	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN6@deflateIni:

; 280  : #endif
; 281  : 
; 282  : #ifdef FASTEST
; 283  :     if (level != 0) level = 1;
; 284  : #else
; 285  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  000f4	83 7c 24 68 ff	 cmp	 DWORD PTR level$[rsp], -1
  000f9	75 08		 jne	 SHORT $LN7@deflateIni
  000fb	c7 44 24 68 06
	00 00 00	 mov	 DWORD PTR level$[rsp], 6
$LN7@deflateIni:

; 286  : #endif
; 287  : 
; 288  :     if (windowBits < 0) { /* suppress zlib wrapper */

  00103	83 7c 24 78 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  00108	7d 14		 jge	 SHORT $LN8@deflateIni

; 289  :         wrap = 0;

  0010a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 0

; 290  :         windowBits = -windowBits;

  00112	8b 44 24 78	 mov	 eax, DWORD PTR windowBits$[rsp]
  00116	f7 d8		 neg	 eax
  00118	89 44 24 78	 mov	 DWORD PTR windowBits$[rsp], eax

; 291  :     }

  0011c	eb 1a		 jmp	 SHORT $LN9@deflateIni
$LN8@deflateIni:

; 292  : #ifdef GZIP
; 293  :     else if (windowBits > 15) {

  0011e	83 7c 24 78 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  00123	7e 13		 jle	 SHORT $LN10@deflateIni

; 294  :         wrap = 2;       /* write gzip wrapper instead */

  00125	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 2

; 295  :         windowBits -= 16;

  0012d	8b 44 24 78	 mov	 eax, DWORD PTR windowBits$[rsp]
  00131	83 e8 10	 sub	 eax, 16
  00134	89 44 24 78	 mov	 DWORD PTR windowBits$[rsp], eax
$LN10@deflateIni:
$LN9@deflateIni:

; 296  :     }
; 297  : #endif
; 298  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 299  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 300  :         strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {

  00138	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR memLevel$[rsp], 1
  00140	7c 4f		 jl	 SHORT $LN12@deflateIni
  00142	83 bc 24 80 00
	00 00 09	 cmp	 DWORD PTR memLevel$[rsp], 9
  0014a	7f 45		 jg	 SHORT $LN12@deflateIni
  0014c	83 7c 24 70 08	 cmp	 DWORD PTR method$[rsp], 8
  00151	75 3e		 jne	 SHORT $LN12@deflateIni
  00153	83 7c 24 78 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  00158	7c 37		 jl	 SHORT $LN12@deflateIni
  0015a	83 7c 24 78 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  0015f	7f 30		 jg	 SHORT $LN12@deflateIni
  00161	83 7c 24 68 00	 cmp	 DWORD PTR level$[rsp], 0
  00166	7c 29		 jl	 SHORT $LN12@deflateIni
  00168	83 7c 24 68 09	 cmp	 DWORD PTR level$[rsp], 9
  0016d	7f 22		 jg	 SHORT $LN12@deflateIni
  0016f	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR strategy$[rsp], 0
  00177	7c 18		 jl	 SHORT $LN12@deflateIni
  00179	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR strategy$[rsp], 4
  00181	7f 0e		 jg	 SHORT $LN12@deflateIni
  00183	83 7c 24 78 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  00188	75 11		 jne	 SHORT $LN11@deflateIni
  0018a	83 7c 24 28 01	 cmp	 DWORD PTR wrap$[rsp], 1
  0018f	74 0a		 je	 SHORT $LN11@deflateIni
$LN12@deflateIni:

; 301  :         return Z_STREAM_ERROR;

  00191	b8 fe ff ff ff	 mov	 eax, -2
  00196	e9 14 03 00 00	 jmp	 $LN1@deflateIni
$LN11@deflateIni:

; 302  :     }
; 303  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */

  0019b	83 7c 24 78 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  001a0	75 08		 jne	 SHORT $LN13@deflateIni
  001a2	c7 44 24 78 09
	00 00 00	 mov	 DWORD PTR windowBits$[rsp], 9
$LN13@deflateIni:

; 304  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  001aa	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  001b0	ba 01 00 00 00	 mov	 edx, 1
  001b5	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  001ba	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  001be	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  001c3	ff 50 30	 call	 QWORD PTR [rax+48]
  001c6	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 305  :     if (s == Z_NULL) return Z_MEM_ERROR;

  001cb	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  001d1	75 0a		 jne	 SHORT $LN14@deflateIni
  001d3	b8 fc ff ff ff	 mov	 eax, -4
  001d8	e9 d2 02 00 00	 jmp	 $LN1@deflateIni
$LN14@deflateIni:

; 306  :     strm->state = (struct internal_state FAR *)s;

  001dd	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  001e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001e7	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 307  :     s->strm = strm;

  001eb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strm$[rsp]
  001f5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 308  :     s->status = INIT_STATE;     /* to pass state test in deflateReset() */

  001f8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001fd	c7 40 08 2a 00
	00 00		 mov	 DWORD PTR [rax+8], 42	; 0000002aH

; 309  : 
; 310  :     s->wrap = wrap;

  00204	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00209	8b 4c 24 28	 mov	 ecx, DWORD PTR wrap$[rsp]
  0020d	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 311  :     s->gzhead = Z_NULL;

  00210	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00215	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 312  :     s->w_bits = (uInt)windowBits;

  0021d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00222	8b 4c 24 78	 mov	 ecx, DWORD PTR windowBits$[rsp]
  00226	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 313  :     s->w_size = 1 << s->w_bits;

  00229	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0022e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00231	b9 01 00 00 00	 mov	 ecx, 1
  00236	89 4c 24 38	 mov	 DWORD PTR tv290[rsp], ecx
  0023a	0f b6 c8	 movzx	 ecx, al
  0023d	8b 44 24 38	 mov	 eax, DWORD PTR tv290[rsp]
  00241	d3 e0		 shl	 eax, cl
  00243	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00248	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 314  :     s->w_mask = s->w_size - 1;

  0024b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00250	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00253	ff c8		 dec	 eax
  00255	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0025a	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 315  : 
; 316  :     s->hash_bits = (uInt)memLevel + 7;

  0025d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR memLevel$[rsp]
  00264	83 c0 07	 add	 eax, 7
  00267	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0026c	89 41 78	 mov	 DWORD PTR [rcx+120], eax

; 317  :     s->hash_size = 1 << s->hash_bits;

  0026f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00274	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00277	b9 01 00 00 00	 mov	 ecx, 1
  0027c	89 4c 24 3c	 mov	 DWORD PTR tv300[rsp], ecx
  00280	0f b6 c8	 movzx	 ecx, al
  00283	8b 44 24 3c	 mov	 eax, DWORD PTR tv300[rsp]
  00287	d3 e0		 shl	 eax, cl
  00289	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0028e	89 41 74	 mov	 DWORD PTR [rcx+116], eax

; 318  :     s->hash_mask = s->hash_size - 1;

  00291	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00296	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00299	ff c8		 dec	 eax
  0029b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002a0	89 41 7c	 mov	 DWORD PTR [rcx+124], eax

; 319  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

  002a3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002a8	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  002ab	83 c0 02	 add	 eax, 2
  002ae	33 d2		 xor	 edx, edx
  002b0	b9 03 00 00 00	 mov	 ecx, 3
  002b5	f7 f1		 div	 ecx
  002b7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002bc	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 320  : 
; 321  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  002c2	41 b8 02 00 00
	00		 mov	 r8d, 2
  002c8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002cd	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  002d0	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  002d5	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  002d9	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  002de	ff 50 30	 call	 QWORD PTR [rax+48]
  002e1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002e6	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 322  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  002ea	41 b8 02 00 00
	00		 mov	 r8d, 2
  002f0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002f5	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  002f8	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  002fd	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00301	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00306	ff 50 30	 call	 QWORD PTR [rax+48]
  00309	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0030e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 323  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  00312	41 b8 02 00 00
	00		 mov	 r8d, 2
  00318	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0031d	8b 50 74	 mov	 edx, DWORD PTR [rax+116]
  00320	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00325	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00329	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  0032e	ff 50 30	 call	 QWORD PTR [rax+48]
  00331	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00336	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 324  : 
; 325  :     s->high_water = 0;      /* nothing written to s->window yet */

  0033a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0033f	c7 80 18 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5912], 0

; 326  : 
; 327  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  00349	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR memLevel$[rsp]
  00350	83 c0 06	 add	 eax, 6
  00353	b9 01 00 00 00	 mov	 ecx, 1
  00358	89 4c 24 40	 mov	 DWORD PTR tv326[rsp], ecx
  0035c	0f b6 c8	 movzx	 ecx, al
  0035f	8b 44 24 40	 mov	 eax, DWORD PTR tv326[rsp]
  00363	d3 e0		 shl	 eax, cl
  00365	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0036a	89 81 f0 16 00
	00		 mov	 DWORD PTR [rcx+5872], eax

; 328  : 
; 329  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  00370	41 b8 04 00 00
	00		 mov	 r8d, 4
  00376	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0037b	8b 90 f0 16 00
	00		 mov	 edx, DWORD PTR [rax+5872]
  00381	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00386	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0038a	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  0038f	ff 50 30	 call	 QWORD PTR [rax+48]
  00392	48 89 44 24 30	 mov	 QWORD PTR overlay$[rsp], rax

; 330  :     s->pending_buf = (uchf *) overlay;

  00397	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0039c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR overlay$[rsp]
  003a1	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 331  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  003a5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003aa	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  003b0	48 c1 e0 02	 shl	 rax, 2
  003b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  003b9	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 332  : 
; 333  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||

  003bc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003c1	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  003c6	74 24		 je	 SHORT $LN16@deflateIni
  003c8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003cd	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  003d2	74 18		 je	 SHORT $LN16@deflateIni
  003d4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003d9	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  003de	74 0c		 je	 SHORT $LN16@deflateIni
  003e0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003e5	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  003ea	75 3d		 jne	 SHORT $LN15@deflateIni
$LN16@deflateIni:

; 334  :         s->pending_buf == Z_NULL) {
; 335  :         s->status = FINISH_STATE;

  003ec	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003f1	c7 40 08 9a 02
	00 00		 mov	 DWORD PTR [rax+8], 666	; 0000029aH

; 336  :         strm->msg = ERR_MSG(Z_MEM_ERROR);

  003f8	b8 08 00 00 00	 mov	 eax, 8
  003fd	48 6b c0 06	 imul	 rax, rax, 6
  00401	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z_errmsg
  00408	48 8b 54 24 60	 mov	 rdx, QWORD PTR strm$[rsp]
  0040d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00411	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 337  :         deflateEnd (strm);

  00415	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strm$[rsp]
  0041a	e8 00 00 00 00	 call	 deflateEnd

; 338  :         return Z_MEM_ERROR;

  0041f	b8 fc ff ff ff	 mov	 eax, -4
  00424	e9 86 00 00 00	 jmp	 $LN1@deflateIni
$LN15@deflateIni:

; 339  :     }
; 340  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  00429	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0042e	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00434	33 d2		 xor	 edx, edx
  00436	b9 02 00 00 00	 mov	 ecx, 2
  0043b	48 f7 f1	 div	 rcx
  0043e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR overlay$[rsp]
  00443	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00447	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0044c	48 89 81 f8 16
	00 00		 mov	 QWORD PTR [rcx+5880], rax

; 341  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  00453	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00458	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  0045e	48 6b c0 03	 imul	 rax, rax, 3
  00462	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00467	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0046b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00470	48 89 81 e8 16
	00 00		 mov	 QWORD PTR [rcx+5864], rax

; 342  : 
; 343  :     s->level = level;

  00477	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0047c	8b 4c 24 68	 mov	 ecx, DWORD PTR level$[rsp]
  00480	89 88 ac 00 00
	00		 mov	 DWORD PTR [rax+172], ecx

; 344  :     s->strategy = strategy;

  00486	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0048b	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR strategy$[rsp]
  00492	89 88 b0 00 00
	00		 mov	 DWORD PTR [rax+176], ecx

; 345  :     s->method = (Byte)method;

  00498	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0049d	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR method$[rsp]
  004a2	88 48 3c	 mov	 BYTE PTR [rax+60], cl

; 346  : 
; 347  :     return deflateReset(strm);

  004a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strm$[rsp]
  004aa	e8 00 00 00 00	 call	 deflateReset
$LN1@deflateIni:

; 348  : }

  004af	48 83 c4 50	 add	 rsp, 80			; 00000050H
  004b3	5f		 pop	 rdi
  004b4	c3		 ret	 0
deflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateStateCheck
_TEXT	SEGMENT
s$ = 32
strm$ = 64
deflateStateCheck PROC					; COMDAT

; 355  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 356  :     deflate_state *s;
; 357  :     if (strm == Z_NULL ||
; 358  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00030	74 18		 je	 SHORT $LN3@deflateSta
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00037	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0003c	74 0c		 je	 SHORT $LN3@deflateSta
  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00043	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00048	75 0a		 jne	 SHORT $LN2@deflateSta
$LN3@deflateSta:

; 359  :         return 1;

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	e9 89 00 00 00	 jmp	 $LN1@deflateSta
$LN2@deflateSta:

; 360  :     s = strm->state;

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00059	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005d	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 361  :     if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&

  00062	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00068	74 6a		 je	 SHORT $LN5@deflateSta
  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0006f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00074	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00077	75 5b		 jne	 SHORT $LN5@deflateSta
  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0007e	83 78 08 2a	 cmp	 DWORD PTR [rax+8], 42	; 0000002aH
  00082	74 57		 je	 SHORT $LN4@deflateSta
  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00089	83 78 08 39	 cmp	 DWORD PTR [rax+8], 57	; 00000039H
  0008d	74 4c		 je	 SHORT $LN4@deflateSta
  0008f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00094	83 78 08 45	 cmp	 DWORD PTR [rax+8], 69	; 00000045H
  00098	74 41		 je	 SHORT $LN4@deflateSta
  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0009f	83 78 08 49	 cmp	 DWORD PTR [rax+8], 73	; 00000049H
  000a3	74 36		 je	 SHORT $LN4@deflateSta
  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000aa	83 78 08 5b	 cmp	 DWORD PTR [rax+8], 91	; 0000005bH
  000ae	74 2b		 je	 SHORT $LN4@deflateSta
  000b0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000b5	83 78 08 67	 cmp	 DWORD PTR [rax+8], 103	; 00000067H
  000b9	74 20		 je	 SHORT $LN4@deflateSta
  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000c0	83 78 08 71	 cmp	 DWORD PTR [rax+8], 113	; 00000071H
  000c4	74 15		 je	 SHORT $LN4@deflateSta
  000c6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000cb	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  000d2	74 07		 je	 SHORT $LN4@deflateSta
$LN5@deflateSta:

; 362  : #ifdef GZIP
; 363  :                                            s->status != GZIP_STATE &&
; 364  : #endif
; 365  :                                            s->status != EXTRA_STATE &&
; 366  :                                            s->status != NAME_STATE &&
; 367  :                                            s->status != COMMENT_STATE &&
; 368  :                                            s->status != HCRC_STATE &&
; 369  :                                            s->status != BUSY_STATE &&
; 370  :                                            s->status != FINISH_STATE))
; 371  :         return 1;

  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	eb 02		 jmp	 SHORT $LN1@deflateSta
$LN4@deflateSta:

; 372  :     return 0;

  000db	33 c0		 xor	 eax, eax
$LN1@deflateSta:

; 373  : }

  000dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e1	5f		 pop	 rdi
  000e2	c3		 ret	 0
deflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateSetDictionary
_TEXT	SEGMENT
s$ = 32
str$ = 40
n$ = 44
wrap$ = 48
avail$ = 52
next$ = 56
tv263 = 64
strm$ = 96
dictionary$ = 104
dictLength$ = 112
deflateSetDictionary PROC				; COMDAT

; 380  : {

$LN17:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 14 00 00 00	 mov	 ecx, 20
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 381  :     deflate_state *s;
; 382  :     uInt str, n;
; 383  :     int wrap;
; 384  :     unsigned avail;
; 385  :     z_const unsigned char *next;
; 386  : 
; 387  :     if (deflateStateCheck(strm) || dictionary == Z_NULL)

  00034	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strm$[rsp]
  00039	e8 00 00 00 00	 call	 deflateStateCheck
  0003e	85 c0		 test	 eax, eax
  00040	75 08		 jne	 SHORT $LN8@deflateSet
  00042	48 83 7c 24 68
	00		 cmp	 QWORD PTR dictionary$[rsp], 0
  00048	75 0a		 jne	 SHORT $LN7@deflateSet
$LN8@deflateSet:

; 388  :         return Z_STREAM_ERROR;

  0004a	b8 fe ff ff ff	 mov	 eax, -2
  0004f	e9 36 03 00 00	 jmp	 $LN1@deflateSet
$LN7@deflateSet:

; 389  :     s = strm->state;

  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00059	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005d	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 390  :     wrap = s->wrap;

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00067	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0006a	89 44 24 30	 mov	 DWORD PTR wrap$[rsp], eax

; 391  :     if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)

  0006e	83 7c 24 30 02	 cmp	 DWORD PTR wrap$[rsp], 2
  00073	74 20		 je	 SHORT $LN10@deflateSet
  00075	83 7c 24 30 01	 cmp	 DWORD PTR wrap$[rsp], 1
  0007a	75 0b		 jne	 SHORT $LN11@deflateSet
  0007c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00081	83 78 08 2a	 cmp	 DWORD PTR [rax+8], 42	; 0000002aH
  00085	75 0e		 jne	 SHORT $LN10@deflateSet
$LN11@deflateSet:
  00087	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0008c	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00093	74 0a		 je	 SHORT $LN9@deflateSet
$LN10@deflateSet:

; 392  :         return Z_STREAM_ERROR;

  00095	b8 fe ff ff ff	 mov	 eax, -2
  0009a	e9 eb 02 00 00	 jmp	 $LN1@deflateSet
$LN9@deflateSet:

; 393  : 
; 394  :     /* when using zlib wrappers, compute Adler-32 for provided dictionary */
; 395  :     if (wrap == 1)

  0009f	83 7c 24 30 01	 cmp	 DWORD PTR wrap$[rsp], 1
  000a4	75 1f		 jne	 SHORT $LN12@deflateSet

; 396  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  000a6	44 8b 44 24 70	 mov	 r8d, DWORD PTR dictLength$[rsp]
  000ab	48 8b 54 24 68	 mov	 rdx, QWORD PTR dictionary$[rsp]
  000b0	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  000b5	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000b8	e8 00 00 00 00	 call	 adler32
  000bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strm$[rsp]
  000c2	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN12@deflateSet:

; 397  :     s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */

  000c5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ca	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [rax+44], 0

; 398  : 
; 399  :     /* if dictionary would fill window, just replace the history */
; 400  :     if (dictLength >= s->w_size) {

  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000d6	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000d9	39 44 24 70	 cmp	 DWORD PTR dictLength$[rsp], eax
  000dd	0f 82 a0 00 00
	00		 jb	 $LN13@deflateSet

; 401  :         if (wrap == 0) {            /* already empty otherwise */

  000e3	83 7c 24 30 00	 cmp	 DWORD PTR wrap$[rsp], 0
  000e8	75 6b		 jne	 SHORT $LN14@deflateSet

; 402  :             CLEAR_HASH(s);

  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ef	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  000f2	ff c8		 dec	 eax
  000f4	8b c0		 mov	 eax, eax
  000f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000fb	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000ff	33 d2		 xor	 edx, edx
  00101	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  00105	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0010a	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0010d	ff c8		 dec	 eax
  0010f	8b c0		 mov	 eax, eax
  00111	48 d1 e0	 shl	 rax, 1
  00114	4c 8b c0	 mov	 r8, rax
  00117	33 d2		 xor	 edx, edx
  00119	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0011e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memset

; 403  :             s->strstart = 0;

  00128	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0012d	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 404  :             s->block_start = 0L;

  00137	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0013c	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0

; 405  :             s->insert = 0;

  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0014b	c7 80 0c 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5900], 0
$LN14@deflateSet:

; 406  :         }
; 407  :         dictionary += dictLength - s->w_size;  /* use the tail */

  00155	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0015a	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0015d	8b 4c 24 70	 mov	 ecx, DWORD PTR dictLength$[rsp]
  00161	2b c8		 sub	 ecx, eax
  00163	8b c1		 mov	 eax, ecx
  00165	8b c0		 mov	 eax, eax
  00167	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dictionary$[rsp]
  0016c	48 03 c8	 add	 rcx, rax
  0016f	48 8b c1	 mov	 rax, rcx
  00172	48 89 44 24 68	 mov	 QWORD PTR dictionary$[rsp], rax

; 408  :         dictLength = s->w_size;

  00177	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0017c	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0017f	89 44 24 70	 mov	 DWORD PTR dictLength$[rsp], eax
$LN13@deflateSet:

; 409  :     }
; 410  : 
; 411  :     /* insert dictionary into window and hash */
; 412  :     avail = strm->avail_in;

  00183	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00188	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0018b	89 44 24 34	 mov	 DWORD PTR avail$[rsp], eax

; 413  :     next = strm->next_in;

  0018f	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00194	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00197	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 414  :     strm->avail_in = dictLength;

  0019c	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  001a1	8b 4c 24 70	 mov	 ecx, DWORD PTR dictLength$[rsp]
  001a5	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 415  :     strm->next_in = (z_const Bytef *)dictionary;

  001a8	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  001ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dictionary$[rsp]
  001b2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 416  :     fill_window(s);

  001b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001ba	e8 00 00 00 00	 call	 fill_window
$LN2@deflateSet:

; 417  :     while (s->lookahead >= MIN_MATCH) {

  001bf	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001c4	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  001cb	0f 82 09 01 00
	00		 jb	 $LN3@deflateSet

; 418  :         str = s->strstart;

  001d1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001d6	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  001dc	89 44 24 28	 mov	 DWORD PTR str$[rsp], eax

; 419  :         n = s->lookahead - (MIN_MATCH-1);

  001e0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001e5	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  001eb	83 e8 02	 sub	 eax, 2
  001ee	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax
$LN6@deflateSet:

; 420  :         do {
; 421  :             UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  001f2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001f7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00202	48 89 4c 24 40	 mov	 QWORD PTR tv263[rsp], rcx
  00207	0f b6 c8	 movzx	 ecx, al
  0020a	48 8b 44 24 40	 mov	 rax, QWORD PTR tv263[rsp]
  0020f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00212	d3 e0		 shl	 eax, cl
  00214	8b 4c 24 28	 mov	 ecx, DWORD PTR str$[rsp]
  00218	83 c1 02	 add	 ecx, 2
  0021b	8b c9		 mov	 ecx, ecx
  0021d	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00222	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00226	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0022a	33 c1		 xor	 eax, ecx
  0022c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00231	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  00234	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00239	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 422  : #ifndef FASTEST
; 423  :             s->prev[str & s->w_mask] = s->head[s->ins_h];

  0023c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00241	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00244	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00249	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0024d	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00252	8b 52 4c	 mov	 edx, DWORD PTR [rdx+76]
  00255	44 8b 44 24 28	 mov	 r8d, DWORD PTR str$[rsp]
  0025a	44 23 c2	 and	 r8d, edx
  0025d	41 8b d0	 mov	 edx, r8d
  00260	8b d2		 mov	 edx, edx
  00262	4c 8b 44 24 20	 mov	 r8, QWORD PTR s$[rsp]
  00267	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  0026b	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0026f	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax

; 424  : #endif
; 425  :             s->head[s->ins_h] = (Pos)str;

  00274	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00279	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0027c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00281	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00285	0f b7 54 24 28	 movzx	 edx, WORD PTR str$[rsp]
  0028a	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 426  :             str++;

  0028e	8b 44 24 28	 mov	 eax, DWORD PTR str$[rsp]
  00292	ff c0		 inc	 eax
  00294	89 44 24 28	 mov	 DWORD PTR str$[rsp], eax

; 427  :         } while (--n);

  00298	8b 44 24 2c	 mov	 eax, DWORD PTR n$[rsp]
  0029c	ff c8		 dec	 eax
  0029e	89 44 24 2c	 mov	 DWORD PTR n$[rsp], eax
  002a2	83 7c 24 2c 00	 cmp	 DWORD PTR n$[rsp], 0
  002a7	0f 85 45 ff ff
	ff		 jne	 $LN6@deflateSet

; 428  :         s->strstart = str;

  002ad	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002b2	8b 4c 24 28	 mov	 ecx, DWORD PTR str$[rsp]
  002b6	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 429  :         s->lookahead = MIN_MATCH-1;

  002bc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002c1	c7 80 9c 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+156], 2

; 430  :         fill_window(s);

  002cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002d0	e8 00 00 00 00	 call	 fill_window

; 431  :     }

  002d5	e9 e5 fe ff ff	 jmp	 $LN2@deflateSet
$LN3@deflateSet:

; 432  :     s->strstart += s->lookahead;

  002da	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002df	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  002e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002ea	03 81 9c 00 00
	00		 add	 eax, DWORD PTR [rcx+156]
  002f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002f5	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 433  :     s->block_start = (long)s->strstart;

  002fb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00300	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00305	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0030b	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 434  :     s->insert = s->lookahead;

  00311	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00316	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0031b	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  00321	89 88 0c 17 00
	00		 mov	 DWORD PTR [rax+5900], ecx

; 435  :     s->lookahead = 0;

  00327	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0032c	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 436  :     s->match_length = s->prev_length = MIN_MATCH-1;

  00336	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0033b	c7 80 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+160], 2
  00345	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0034a	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 437  :     s->match_available = 0;

  00354	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00359	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 438  :     strm->next_in = next;

  00363	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00368	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  0036d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 439  :     strm->avail_in = avail;

  00370	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00375	8b 4c 24 34	 mov	 ecx, DWORD PTR avail$[rsp]
  00379	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 440  :     s->wrap = wrap;

  0037c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00381	8b 4c 24 30	 mov	 ecx, DWORD PTR wrap$[rsp]
  00385	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 441  :     return Z_OK;

  00388	33 c0		 xor	 eax, eax
$LN1@deflateSet:

; 442  : }

  0038a	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0038e	5f		 pop	 rdi
  0038f	c3		 ret	 0
deflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateGetDictionary
_TEXT	SEGMENT
s$ = 32
len$ = 40
strm$ = 64
dictionary$ = 72
dictLength$ = 80
deflateGetDictionary PROC				; COMDAT

; 449  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 450  :     deflate_state *s;
; 451  :     uInt len;
; 452  : 
; 453  :     if (deflateStateCheck(strm))

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00039	e8 00 00 00 00	 call	 deflateStateCheck
  0003e	85 c0		 test	 eax, eax
  00040	74 0a		 je	 SHORT $LN2@deflateGet

; 454  :         return Z_STREAM_ERROR;

  00042	b8 fe ff ff ff	 mov	 eax, -2
  00047	e9 aa 00 00 00	 jmp	 $LN1@deflateGet
$LN2@deflateGet:

; 455  :     s = strm->state;

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00051	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00055	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 456  :     len = s->strstart + s->lookahead;

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0005f	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00065	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0006a	03 81 9c 00 00
	00		 add	 eax, DWORD PTR [rcx+156]
  00070	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 457  :     if (len > s->w_size)

  00074	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00079	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0007c	39 44 24 28	 cmp	 DWORD PTR len$[rsp], eax
  00080	76 0c		 jbe	 SHORT $LN3@deflateGet

; 458  :         len = s->w_size;

  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00087	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0008a	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax
$LN3@deflateGet:

; 459  :     if (dictionary != Z_NULL && len)

  0008e	48 83 7c 24 48
	00		 cmp	 QWORD PTR dictionary$[rsp], 0
  00094	74 4b		 je	 SHORT $LN4@deflateGet
  00096	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  0009b	74 44		 je	 SHORT $LN4@deflateGet

; 460  :         zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);

  0009d	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000a6	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  000ac	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  000b1	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  000b5	48 03 d1	 add	 rdx, rcx
  000b8	48 8b ca	 mov	 rcx, rdx
  000bb	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  000c0	8b 92 9c 00 00
	00		 mov	 edx, DWORD PTR [rdx+156]
  000c6	48 03 ca	 add	 rcx, rdx
  000c9	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  000cd	48 2b ca	 sub	 rcx, rdx
  000d0	44 8b c0	 mov	 r8d, eax
  000d3	48 8b d1	 mov	 rdx, rcx
  000d6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dictionary$[rsp]
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy
$LN4@deflateGet:

; 461  :     if (dictLength != Z_NULL)

  000e1	48 83 7c 24 50
	00		 cmp	 QWORD PTR dictLength$[rsp], 0
  000e7	74 0b		 je	 SHORT $LN5@deflateGet

; 462  :         *dictLength = len;

  000e9	48 8b 44 24 50	 mov	 rax, QWORD PTR dictLength$[rsp]
  000ee	8b 4c 24 28	 mov	 ecx, DWORD PTR len$[rsp]
  000f2	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@deflateGet:

; 463  :     return Z_OK;

  000f4	33 c0		 xor	 eax, eax
$LN1@deflateGet:

; 464  : }

  000f6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fa	5f		 pop	 rdi
  000fb	c3		 ret	 0
deflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateResetKeep
_TEXT	SEGMENT
s$ = 32
tv86 = 40
tv85 = 44
tv130 = 48
strm$ = 80
deflateResetKeep PROC					; COMDAT

; 469  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 470  :     deflate_state *s;
; 471  : 
; 472  :     if (deflateStateCheck(strm)) {

  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0002f	e8 00 00 00 00	 call	 deflateStateCheck
  00034	85 c0		 test	 eax, eax
  00036	74 0a		 je	 SHORT $LN2@deflateRes

; 473  :         return Z_STREAM_ERROR;

  00038	b8 fe ff ff ff	 mov	 eax, -2
  0003d	e9 11 01 00 00	 jmp	 $LN1@deflateRes
$LN2@deflateRes:

; 474  :     }
; 475  : 
; 476  :     strm->total_in = strm->total_out = 0;

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00047	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00053	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 477  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */

  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0005f	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 478  :     strm->data_type = Z_UNKNOWN;

  00067	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0006c	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 479  : 
; 480  :     s = (deflate_state *)strm->state;

  00073	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00078	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007c	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 481  :     s->pending = 0;

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00086	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 482  :     s->pending_out = s->pending_buf;

  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00092	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00097	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0009b	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 483  : 
; 484  :     if (s->wrap < 0) {

  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000a4	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000a8	7d 12		 jge	 SHORT $LN3@deflateRes

; 485  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000af	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000b2	f7 d8		 neg	 eax
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000b9	89 41 2c	 mov	 DWORD PTR [rcx+44], eax
$LN3@deflateRes:

; 486  :     }
; 487  :     s->status =

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000c1	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  000c5	75 0a		 jne	 SHORT $LN7@deflateRes
  000c7	c7 44 24 28 39
	00 00 00	 mov	 DWORD PTR tv86[rsp], 57	; 00000039H
  000cf	eb 25		 jmp	 SHORT $LN8@deflateRes
$LN7@deflateRes:
  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000d6	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000da	74 0a		 je	 SHORT $LN5@deflateRes
  000dc	c7 44 24 2c 2a
	00 00 00	 mov	 DWORD PTR tv85[rsp], 42	; 0000002aH
  000e4	eb 08		 jmp	 SHORT $LN6@deflateRes
$LN5@deflateRes:
  000e6	c7 44 24 2c 71
	00 00 00	 mov	 DWORD PTR tv85[rsp], 113 ; 00000071H
$LN6@deflateRes:
  000ee	8b 44 24 2c	 mov	 eax, DWORD PTR tv85[rsp]
  000f2	89 44 24 28	 mov	 DWORD PTR tv86[rsp], eax
$LN8@deflateRes:
  000f6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000fb	8b 4c 24 28	 mov	 ecx, DWORD PTR tv86[rsp]
  000ff	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 488  : #ifdef GZIP
; 489  :         s->wrap == 2 ? GZIP_STATE :
; 490  : #endif
; 491  :         s->wrap ? INIT_STATE : BUSY_STATE;
; 492  :     strm->adler =

  00102	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00107	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  0010b	75 12		 jne	 SHORT $LN9@deflateRes
  0010d	45 33 c0	 xor	 r8d, r8d
  00110	33 d2		 xor	 edx, edx
  00112	33 c9		 xor	 ecx, ecx
  00114	e8 00 00 00 00	 call	 crc32
  00119	89 44 24 30	 mov	 DWORD PTR tv130[rsp], eax
  0011d	eb 10		 jmp	 SHORT $LN10@deflateRes
$LN9@deflateRes:
  0011f	45 33 c0	 xor	 r8d, r8d
  00122	33 d2		 xor	 edx, edx
  00124	33 c9		 xor	 ecx, ecx
  00126	e8 00 00 00 00	 call	 adler32
  0012b	89 44 24 30	 mov	 DWORD PTR tv130[rsp], eax
$LN10@deflateRes:
  0012f	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00134	8b 4c 24 30	 mov	 ecx, DWORD PTR tv130[rsp]
  00138	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 493  : #ifdef GZIP
; 494  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 495  : #endif
; 496  :         adler32(0L, Z_NULL, 0);
; 497  :     s->last_flush = Z_NO_FLUSH;

  0013b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00140	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 498  : 
; 499  :     _tr_init(s);

  00147	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0014c	e8 00 00 00 00	 call	 _tr_init

; 500  : 
; 501  :     return Z_OK;

  00151	33 c0		 xor	 eax, eax
$LN1@deflateRes:

; 502  : }

  00153	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00157	5f		 pop	 rdi
  00158	c3		 ret	 0
deflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateReset
_TEXT	SEGMENT
ret$ = 32
strm$ = 64
deflateReset PROC					; COMDAT

; 507  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 508  :     int ret;
; 509  : 
; 510  :     ret = deflateResetKeep(strm);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0002f	e8 00 00 00 00	 call	 deflateResetKeep
  00034	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 511  :     if (ret == Z_OK)

  00038	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  0003d	75 0e		 jne	 SHORT $LN2@deflateRes

; 512  :         lm_init(strm->state);

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00048	e8 00 00 00 00	 call	 lm_init
$LN2@deflateRes:

; 513  :     return ret;

  0004d	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]

; 514  : }

  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
deflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateSetHeader
_TEXT	SEGMENT
strm$ = 48
head$ = 56
deflateSetHeader PROC					; COMDAT

; 520  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 521  :     if (deflateStateCheck(strm) || strm->state->wrap != 2)

  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strm$[rsp]
  00034	e8 00 00 00 00	 call	 deflateStateCheck
  00039	85 c0		 test	 eax, eax
  0003b	75 0f		 jne	 SHORT $LN3@deflateSet
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00042	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00046	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  0004a	74 07		 je	 SHORT $LN2@deflateSet
$LN3@deflateSet:

; 522  :         return Z_STREAM_ERROR;

  0004c	b8 fe ff ff ff	 mov	 eax, -2
  00051	eb 14		 jmp	 SHORT $LN1@deflateSet
$LN2@deflateSet:

; 523  :     strm->state->gzhead = head;

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00058	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR head$[rsp]
  00061	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 524  :     return Z_OK;

  00065	33 c0		 xor	 eax, eax
$LN1@deflateSet:

; 525  : }

  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
deflateSetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflatePending
_TEXT	SEGMENT
strm$ = 48
pending$ = 56
bits$ = 64
deflatePending PROC					; COMDAT

; 532  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 08 00 00 00	 mov	 ecx, 8
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 533  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strm$[rsp]
  00039	e8 00 00 00 00	 call	 deflateStateCheck
  0003e	85 c0		 test	 eax, eax
  00040	74 07		 je	 SHORT $LN2@deflatePen
  00042	b8 fe ff ff ff	 mov	 eax, -2
  00047	eb 3b		 jmp	 SHORT $LN1@deflatePen
$LN2@deflatePen:

; 534  :     if (pending != Z_NULL)

  00049	48 83 7c 24 38
	00		 cmp	 QWORD PTR pending$[rsp], 0
  0004f	74 13		 je	 SHORT $LN3@deflatePen

; 535  :         *pending = strm->state->pending;

  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00056	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pending$[rsp]
  0005f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00062	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@deflatePen:

; 536  :     if (bits != Z_NULL)

  00064	48 83 7c 24 40
	00		 cmp	 QWORD PTR bits$[rsp], 0
  0006a	74 16		 je	 SHORT $LN4@deflatePen

; 537  :         *bits = strm->state->bi_valid;

  0006c	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00071	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bits$[rsp]
  0007a	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00080	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@deflatePen:

; 538  :     return Z_OK;

  00082	33 c0		 xor	 eax, eax
$LN1@deflatePen:

; 539  : }

  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
deflatePending ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflatePrime
_TEXT	SEGMENT
s$ = 32
put$ = 40
tv148 = 44
strm$ = 64
bits$ = 72
value$ = 80
deflatePrime PROC					; COMDAT

; 546  : {

$LN10:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 547  :     deflate_state *s;
; 548  :     int put;
; 549  : 
; 550  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00038	e8 00 00 00 00	 call	 deflateStateCheck
  0003d	85 c0		 test	 eax, eax
  0003f	74 0a		 je	 SHORT $LN5@deflatePri
  00041	b8 fe ff ff ff	 mov	 eax, -2
  00046	e9 f9 00 00 00	 jmp	 $LN1@deflatePri
$LN5@deflatePri:

; 551  :     s = strm->state;

  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00050	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00054	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 552  :     if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0005e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00062	48 83 c0 02	 add	 rax, 2
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0006b	48 39 81 f8 16
	00 00		 cmp	 QWORD PTR [rcx+5880], rax
  00072	73 0a		 jae	 SHORT $LN6@deflatePri

; 553  :         return Z_BUF_ERROR;

  00074	b8 fb ff ff ff	 mov	 eax, -5
  00079	e9 c6 00 00 00	 jmp	 $LN1@deflatePri
$LN6@deflatePri:
$LN4@deflatePri:

; 554  :     do {
; 555  :         put = Buf_size - s->bi_valid;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00083	b9 10 00 00 00	 mov	 ecx, 16
  00088	2b 88 14 17 00
	00		 sub	 ecx, DWORD PTR [rax+5908]
  0008e	8b c1		 mov	 eax, ecx
  00090	89 44 24 28	 mov	 DWORD PTR put$[rsp], eax

; 556  :         if (put > bits)

  00094	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00098	39 44 24 28	 cmp	 DWORD PTR put$[rsp], eax
  0009c	7e 08		 jle	 SHORT $LN7@deflatePri

; 557  :             put = bits;

  0009e	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  000a2	89 44 24 28	 mov	 DWORD PTR put$[rsp], eax
$LN7@deflatePri:

; 558  :         s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);

  000a6	8b 44 24 28	 mov	 eax, DWORD PTR put$[rsp]
  000aa	b9 01 00 00 00	 mov	 ecx, 1
  000af	89 4c 24 2c	 mov	 DWORD PTR tv148[rsp], ecx
  000b3	0f b6 c8	 movzx	 ecx, al
  000b6	8b 44 24 2c	 mov	 eax, DWORD PTR tv148[rsp]
  000ba	d3 e0		 shl	 eax, cl
  000bc	ff c8		 dec	 eax
  000be	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000c2	23 c8		 and	 ecx, eax
  000c4	8b c1		 mov	 eax, ecx
  000c6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000cb	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  000d1	d3 e0		 shl	 eax, cl
  000d3	0f b7 c0	 movzx	 eax, ax
  000d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000db	0f b7 89 10 17
	00 00		 movzx	 ecx, WORD PTR [rcx+5904]
  000e2	0b c8		 or	 ecx, eax
  000e4	8b c1		 mov	 eax, ecx
  000e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000eb	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax

; 559  :         s->bi_valid += put;

  000f2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000f7	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  000fd	03 44 24 28	 add	 eax, DWORD PTR put$[rsp]
  00101	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00106	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax

; 560  :         _tr_flush_bits(s);

  0010c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00111	e8 00 00 00 00	 call	 _tr_flush_bits

; 561  :         value >>= put;

  00116	8b 44 24 28	 mov	 eax, DWORD PTR put$[rsp]
  0011a	0f b6 c8	 movzx	 ecx, al
  0011d	8b 44 24 50	 mov	 eax, DWORD PTR value$[rsp]
  00121	d3 f8		 sar	 eax, cl
  00123	89 44 24 50	 mov	 DWORD PTR value$[rsp], eax

; 562  :         bits -= put;

  00127	8b 44 24 28	 mov	 eax, DWORD PTR put$[rsp]
  0012b	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  0012f	2b c8		 sub	 ecx, eax
  00131	8b c1		 mov	 eax, ecx
  00133	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax

; 563  :     } while (bits);

  00137	83 7c 24 48 00	 cmp	 DWORD PTR bits$[rsp], 0
  0013c	0f 85 3c ff ff
	ff		 jne	 $LN4@deflatePri

; 564  :     return Z_OK;

  00142	33 c0		 xor	 eax, eax
$LN1@deflatePri:

; 565  : }

  00144	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00148	5f		 pop	 rdi
  00149	c3		 ret	 0
deflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateParams
_TEXT	SEGMENT
s$ = 32
func$ = 40
err$1 = 48
strm$ = 80
level$ = 88
strategy$ = 96
deflateParams PROC					; COMDAT

; 572  : {

$LN17:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 10 00 00 00	 mov	 ecx, 16
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 573  :     deflate_state *s;
; 574  :     compress_func func;
; 575  : 
; 576  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00038	e8 00 00 00 00	 call	 deflateStateCheck
  0003d	85 c0		 test	 eax, eax
  0003f	74 0a		 je	 SHORT $LN2@deflatePar
  00041	b8 fe ff ff ff	 mov	 eax, -2
  00046	e9 0e 02 00 00	 jmp	 $LN1@deflatePar
$LN2@deflatePar:

; 577  :     s = strm->state;

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00050	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00054	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 578  : 
; 579  : #ifdef FASTEST
; 580  :     if (level != 0) level = 1;
; 581  : #else
; 582  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  00059	83 7c 24 58 ff	 cmp	 DWORD PTR level$[rsp], -1
  0005e	75 08		 jne	 SHORT $LN3@deflatePar
  00060	c7 44 24 58 06
	00 00 00	 mov	 DWORD PTR level$[rsp], 6
$LN3@deflatePar:

; 583  : #endif
; 584  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00068	83 7c 24 58 00	 cmp	 DWORD PTR level$[rsp], 0
  0006d	7c 15		 jl	 SHORT $LN5@deflatePar
  0006f	83 7c 24 58 09	 cmp	 DWORD PTR level$[rsp], 9
  00074	7f 0e		 jg	 SHORT $LN5@deflatePar
  00076	83 7c 24 60 00	 cmp	 DWORD PTR strategy$[rsp], 0
  0007b	7c 07		 jl	 SHORT $LN5@deflatePar
  0007d	83 7c 24 60 04	 cmp	 DWORD PTR strategy$[rsp], 4
  00082	7e 0a		 jle	 SHORT $LN4@deflatePar
$LN5@deflatePar:

; 585  :         return Z_STREAM_ERROR;

  00084	b8 fe ff ff ff	 mov	 eax, -2
  00089	e9 cb 01 00 00	 jmp	 $LN1@deflatePar
$LN4@deflatePar:

; 586  :     }
; 587  :     func = configuration_table[s->level].func;

  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00093	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  0009a	48 6b c0 10	 imul	 rax, rax, 16
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  000a5	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  000aa	48 89 44 24 28	 mov	 QWORD PTR func$[rsp], rax

; 588  : 
; 589  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&

  000af	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000b4	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [rax+176]
  000ba	39 44 24 60	 cmp	 DWORD PTR strategy$[rsp], eax
  000be	75 1c		 jne	 SHORT $LN7@deflatePar
  000c0	48 63 44 24 58	 movsxd	 rax, DWORD PTR level$[rsp]
  000c5	48 6b c0 10	 imul	 rax, rax, 16
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  000d0	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  000d5	48 39 44 24 28	 cmp	 QWORD PTR func$[rsp], rax
  000da	74 46		 je	 SHORT $LN6@deflatePar
$LN7@deflatePar:
  000dc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000e1	83 b8 18 17 00
	00 00		 cmp	 DWORD PTR [rax+5912], 0
  000e8	74 38		 je	 SHORT $LN6@deflatePar

; 590  :         s->high_water) {
; 591  :         /* Flush the last buffer: */
; 592  :         int err = deflate(strm, Z_BLOCK);

  000ea	ba 05 00 00 00	 mov	 edx, 5
  000ef	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  000f4	e8 00 00 00 00	 call	 deflate
  000f9	89 44 24 30	 mov	 DWORD PTR err$1[rsp], eax

; 593  :         if (err == Z_STREAM_ERROR)

  000fd	83 7c 24 30 fe	 cmp	 DWORD PTR err$1[rsp], -2
  00102	75 09		 jne	 SHORT $LN8@deflatePar

; 594  :             return err;

  00104	8b 44 24 30	 mov	 eax, DWORD PTR err$1[rsp]
  00108	e9 4c 01 00 00	 jmp	 $LN1@deflatePar
$LN8@deflatePar:

; 595  :         if (strm->avail_out == 0)

  0010d	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00112	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00116	75 0a		 jne	 SHORT $LN9@deflatePar

; 596  :             return Z_BUF_ERROR;

  00118	b8 fb ff ff ff	 mov	 eax, -5
  0011d	e9 37 01 00 00	 jmp	 $LN1@deflatePar
$LN9@deflatePar:
$LN6@deflatePar:

; 597  :     }
; 598  :     if (s->level != level) {

  00122	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00127	8b 4c 24 58	 mov	 ecx, DWORD PTR level$[rsp]
  0012b	39 88 ac 00 00
	00		 cmp	 DWORD PTR [rax+172], ecx
  00131	0f 84 11 01 00
	00		 je	 $LN10@deflatePar

; 599  :         if (s->level == 0 && s->matches != 0) {

  00137	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0013c	83 b8 ac 00 00
	00 00		 cmp	 DWORD PTR [rax+172], 0
  00143	75 75		 jne	 SHORT $LN11@deflatePar
  00145	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0014a	83 b8 08 17 00
	00 00		 cmp	 DWORD PTR [rax+5896], 0
  00151	74 67		 je	 SHORT $LN11@deflatePar

; 600  :             if (s->matches == 1)

  00153	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00158	83 b8 08 17 00
	00 01		 cmp	 DWORD PTR [rax+5896], 1
  0015f	75 0c		 jne	 SHORT $LN12@deflatePar

; 601  :                 slide_hash(s);

  00161	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00166	e8 00 00 00 00	 call	 slide_hash
  0016b	eb 1b		 jmp	 SHORT $LN13@deflatePar
$LN12@deflatePar:

; 602  :             else
; 603  :                 CLEAR_HASH(s);

  0016d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00172	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00175	ff c8		 dec	 eax
  00177	8b c0		 mov	 eax, eax
  00179	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0017e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00182	33 d2		 xor	 edx, edx
  00184	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
$LN13@deflatePar:
  00188	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0018d	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00190	ff c8		 dec	 eax
  00192	8b c0		 mov	 eax, eax
  00194	48 d1 e0	 shl	 rax, 1
  00197	4c 8b c0	 mov	 r8, rax
  0019a	33 d2		 xor	 edx, edx
  0019c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001a1	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  001a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memset

; 604  :             s->matches = 0;

  001ab	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001b0	c7 80 08 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5896], 0
$LN11@deflatePar:

; 605  :         }
; 606  :         s->level = level;

  001ba	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001bf	8b 4c 24 58	 mov	 ecx, DWORD PTR level$[rsp]
  001c3	89 88 ac 00 00
	00		 mov	 DWORD PTR [rax+172], ecx

; 607  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  001c9	48 63 44 24 58	 movsxd	 rax, DWORD PTR level$[rsp]
  001ce	48 6b c0 10	 imul	 rax, rax, 16
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  001d9	0f b7 44 01 02	 movzx	 eax, WORD PTR [rcx+rax+2]
  001de	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001e3	89 81 a8 00 00
	00		 mov	 DWORD PTR [rcx+168], eax

; 608  :         s->good_match       = configuration_table[level].good_length;

  001e9	48 63 44 24 58	 movsxd	 rax, DWORD PTR level$[rsp]
  001ee	48 6b c0 10	 imul	 rax, rax, 16
  001f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  001f9	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  001fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00202	89 81 b4 00 00
	00		 mov	 DWORD PTR [rcx+180], eax

; 609  :         s->nice_match       = configuration_table[level].nice_length;

  00208	48 63 44 24 58	 movsxd	 rax, DWORD PTR level$[rsp]
  0020d	48 6b c0 10	 imul	 rax, rax, 16
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  00218	0f b7 44 01 04	 movzx	 eax, WORD PTR [rcx+rax+4]
  0021d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00222	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 610  :         s->max_chain_length = configuration_table[level].max_chain;

  00228	48 63 44 24 58	 movsxd	 rax, DWORD PTR level$[rsp]
  0022d	48 6b c0 10	 imul	 rax, rax, 16
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  00238	0f b7 44 01 06	 movzx	 eax, WORD PTR [rcx+rax+6]
  0023d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00242	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax
$LN10@deflatePar:

; 611  :     }
; 612  :     s->strategy = strategy;

  00248	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0024d	8b 4c 24 60	 mov	 ecx, DWORD PTR strategy$[rsp]
  00251	89 88 b0 00 00
	00		 mov	 DWORD PTR [rax+176], ecx

; 613  :     return Z_OK;

  00257	33 c0		 xor	 eax, eax
$LN1@deflatePar:

; 614  : }

  00259	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0025d	5f		 pop	 rdi
  0025e	c3		 ret	 0
deflateParams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateTune
_TEXT	SEGMENT
s$ = 32
strm$ = 64
good_length$ = 72
max_lazy$ = 80
nice_length$ = 88
max_chain$ = 96
deflateTune PROC					; COMDAT

; 623  : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00018	48 8b fc	 mov	 rdi, rsp
  0001b	b9 0c 00 00 00	 mov	 ecx, 12
  00020	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00025	f3 ab		 rep stosd
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00033	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 624  :     deflate_state *s;
; 625  : 
; 626  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0003d	e8 00 00 00 00	 call	 deflateStateCheck
  00042	85 c0		 test	 eax, eax
  00044	74 07		 je	 SHORT $LN2@deflateTun
  00046	b8 fe ff ff ff	 mov	 eax, -2
  0004b	eb 4c		 jmp	 SHORT $LN1@deflateTun
$LN2@deflateTun:

; 627  :     s = strm->state;

  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00052	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00056	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 628  :     s->good_match = (uInt)good_length;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00060	8b 4c 24 48	 mov	 ecx, DWORD PTR good_length$[rsp]
  00064	89 88 b4 00 00
	00		 mov	 DWORD PTR [rax+180], ecx

; 629  :     s->max_lazy_match = (uInt)max_lazy;

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0006f	8b 4c 24 50	 mov	 ecx, DWORD PTR max_lazy$[rsp]
  00073	89 88 a8 00 00
	00		 mov	 DWORD PTR [rax+168], ecx

; 630  :     s->nice_match = nice_length;

  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0007e	8b 4c 24 58	 mov	 ecx, DWORD PTR nice_length$[rsp]
  00082	89 88 b8 00 00
	00		 mov	 DWORD PTR [rax+184], ecx

; 631  :     s->max_chain_length = (uInt)max_chain;

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0008d	8b 4c 24 60	 mov	 ecx, DWORD PTR max_chain$[rsp]
  00091	89 88 a4 00 00
	00		 mov	 DWORD PTR [rax+164], ecx

; 632  :     return Z_OK;

  00097	33 c0		 xor	 eax, eax
$LN1@deflateTun:

; 633  : }

  00099	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009d	5f		 pop	 rdi
  0009e	c3		 ret	 0
deflateTune ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateBound
_TEXT	SEGMENT
s$ = 32
complen$ = 40
wraplen$ = 44
str$1 = 48
tv77 = 56
tv80 = 60
tv128 = 64
tv136 = 65
strm$ = 96
sourceLen$ = 104
deflateBound PROC					; COMDAT

; 655  : {

$LN27:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 14 00 00 00	 mov	 ecx, 20
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 656  :     deflate_state *s;
; 657  :     uLong complen, wraplen;
; 658  : 
; 659  :     /* conservative upper bound for compressed data */
; 660  :     complen = sourceLen +

  0002e	8b 44 24 68	 mov	 eax, DWORD PTR sourceLen$[rsp]
  00032	83 c0 07	 add	 eax, 7
  00035	c1 e8 03	 shr	 eax, 3
  00038	8b 4c 24 68	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  0003c	03 c8		 add	 ecx, eax
  0003e	8b c1		 mov	 eax, ecx
  00040	8b 4c 24 68	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  00044	83 c1 3f	 add	 ecx, 63			; 0000003fH
  00047	c1 e9 06	 shr	 ecx, 6
  0004a	8d 44 08 05	 lea	 eax, DWORD PTR [rax+rcx+5]
  0004e	89 44 24 28	 mov	 DWORD PTR complen$[rsp], eax

; 661  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
; 662  : 
; 663  :     /* if can't get parameters, return conservative bound plus zlib wrapper */
; 664  :     if (deflateStateCheck(strm))

  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strm$[rsp]
  00057	e8 00 00 00 00	 call	 deflateStateCheck
  0005c	85 c0		 test	 eax, eax
  0005e	74 0c		 je	 SHORT $LN10@deflateBou

; 665  :         return complen + 6;

  00060	8b 44 24 28	 mov	 eax, DWORD PTR complen$[rsp]
  00064	83 c0 06	 add	 eax, 6
  00067	e9 b0 01 00 00	 jmp	 $LN1@deflateBou
$LN10@deflateBou:

; 666  : 
; 667  :     /* compute wrapper length */
; 668  :     s = strm->state;

  0006c	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00071	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00075	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 669  :     switch (s->wrap) {

  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0007f	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00082	89 44 24 38	 mov	 DWORD PTR tv77[rsp], eax
  00086	83 7c 24 38 00	 cmp	 DWORD PTR tv77[rsp], 0
  0008b	74 13		 je	 SHORT $LN11@deflateBou
  0008d	83 7c 24 38 01	 cmp	 DWORD PTR tv77[rsp], 1
  00092	74 19		 je	 SHORT $LN12@deflateBou
  00094	83 7c 24 38 02	 cmp	 DWORD PTR tv77[rsp], 2
  00099	74 42		 je	 SHORT $LN13@deflateBou
  0009b	e9 25 01 00 00	 jmp	 $LN19@deflateBou
$LN11@deflateBou:

; 670  :     case 0:                                 /* raw deflate */
; 671  :         wraplen = 0;

  000a0	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR wraplen$[rsp], 0

; 672  :         break;

  000a8	e9 20 01 00 00	 jmp	 $LN2@deflateBou
$LN12@deflateBou:

; 673  :     case 1:                                 /* zlib wrapper */
; 674  :         wraplen = 6 + (s->strstart ? 4 : 0);

  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000b2	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  000b9	74 0a		 je	 SHORT $LN23@deflateBou
  000bb	c7 44 24 3c 04
	00 00 00	 mov	 DWORD PTR tv80[rsp], 4
  000c3	eb 08		 jmp	 SHORT $LN24@deflateBou
$LN23@deflateBou:
  000c5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN24@deflateBou:
  000cd	8b 44 24 3c	 mov	 eax, DWORD PTR tv80[rsp]
  000d1	83 c0 06	 add	 eax, 6
  000d4	89 44 24 2c	 mov	 DWORD PTR wraplen$[rsp], eax

; 675  :         break;

  000d8	e9 f0 00 00 00	 jmp	 $LN2@deflateBou
$LN13@deflateBou:

; 676  : #ifdef GZIP
; 677  :     case 2:                                 /* gzip wrapper */
; 678  :         wraplen = 18;

  000dd	c7 44 24 2c 12
	00 00 00	 mov	 DWORD PTR wraplen$[rsp], 18

; 679  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ea	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000ef	0f 84 ce 00 00
	00		 je	 $LN14@deflateBou

; 680  :             Bytef *str;
; 681  :             if (s->gzhead->extra != Z_NULL)

  000f5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000fa	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000fe	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00103	74 18		 je	 SHORT $LN15@deflateBou

; 682  :                 wraplen += 2 + s->gzhead->extra_len;

  00105	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0010a	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0010e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00111	8b 4c 24 2c	 mov	 ecx, DWORD PTR wraplen$[rsp]
  00115	8d 44 01 02	 lea	 eax, DWORD PTR [rcx+rax+2]
  00119	89 44 24 2c	 mov	 DWORD PTR wraplen$[rsp], eax
$LN15@deflateBou:

; 683  :             str = s->gzhead->name;

  0011d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00122	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00126	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0012a	48 89 44 24 30	 mov	 QWORD PTR str$1[rsp], rax

; 684  :             if (str != Z_NULL)

  0012f	48 83 7c 24 30
	00		 cmp	 QWORD PTR str$1[rsp], 0
  00135	74 2c		 je	 SHORT $LN16@deflateBou
$LN6@deflateBou:

; 685  :                 do {
; 686  :                     wraplen++;

  00137	8b 44 24 2c	 mov	 eax, DWORD PTR wraplen$[rsp]
  0013b	ff c0		 inc	 eax
  0013d	89 44 24 2c	 mov	 DWORD PTR wraplen$[rsp], eax

; 687  :                 } while (*str++);

  00141	48 8b 44 24 30	 mov	 rax, QWORD PTR str$1[rsp]
  00146	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00149	88 44 24 40	 mov	 BYTE PTR tv128[rsp], al
  0014d	48 8b 44 24 30	 mov	 rax, QWORD PTR str$1[rsp]
  00152	48 ff c0	 inc	 rax
  00155	48 89 44 24 30	 mov	 QWORD PTR str$1[rsp], rax
  0015a	0f b6 44 24 40	 movzx	 eax, BYTE PTR tv128[rsp]
  0015f	85 c0		 test	 eax, eax
  00161	75 d4		 jne	 SHORT $LN6@deflateBou
$LN16@deflateBou:

; 688  :             str = s->gzhead->comment;

  00163	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00168	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0016c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00170	48 89 44 24 30	 mov	 QWORD PTR str$1[rsp], rax

; 689  :             if (str != Z_NULL)

  00175	48 83 7c 24 30
	00		 cmp	 QWORD PTR str$1[rsp], 0
  0017b	74 2c		 je	 SHORT $LN17@deflateBou
$LN9@deflateBou:

; 690  :                 do {
; 691  :                     wraplen++;

  0017d	8b 44 24 2c	 mov	 eax, DWORD PTR wraplen$[rsp]
  00181	ff c0		 inc	 eax
  00183	89 44 24 2c	 mov	 DWORD PTR wraplen$[rsp], eax

; 692  :                 } while (*str++);

  00187	48 8b 44 24 30	 mov	 rax, QWORD PTR str$1[rsp]
  0018c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0018f	88 44 24 41	 mov	 BYTE PTR tv136[rsp], al
  00193	48 8b 44 24 30	 mov	 rax, QWORD PTR str$1[rsp]
  00198	48 ff c0	 inc	 rax
  0019b	48 89 44 24 30	 mov	 QWORD PTR str$1[rsp], rax
  001a0	0f b6 44 24 41	 movzx	 eax, BYTE PTR tv136[rsp]
  001a5	85 c0		 test	 eax, eax
  001a7	75 d4		 jne	 SHORT $LN9@deflateBou
$LN17@deflateBou:

; 693  :             if (s->gzhead->hcrc)

  001a9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001ae	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001b2	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  001b6	74 0b		 je	 SHORT $LN18@deflateBou

; 694  :                 wraplen += 2;

  001b8	8b 44 24 2c	 mov	 eax, DWORD PTR wraplen$[rsp]
  001bc	83 c0 02	 add	 eax, 2
  001bf	89 44 24 2c	 mov	 DWORD PTR wraplen$[rsp], eax
$LN18@deflateBou:
$LN14@deflateBou:

; 695  :         }
; 696  :         break;

  001c3	eb 08		 jmp	 SHORT $LN2@deflateBou
$LN19@deflateBou:

; 697  : #endif
; 698  :     default:                                /* for compiler happiness */
; 699  :         wraplen = 6;

  001c5	c7 44 24 2c 06
	00 00 00	 mov	 DWORD PTR wraplen$[rsp], 6
$LN2@deflateBou:

; 700  :     }
; 701  : 
; 702  :     /* if not default parameters, return conservative bound */
; 703  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  001cd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001d2	83 78 48 0f	 cmp	 DWORD PTR [rax+72], 15
  001d6	75 0b		 jne	 SHORT $LN21@deflateBou
  001d8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001dd	83 78 78 0f	 cmp	 DWORD PTR [rax+120], 15
  001e1	74 0e		 je	 SHORT $LN20@deflateBou
$LN21@deflateBou:

; 704  :         return complen + wraplen;

  001e3	8b 44 24 2c	 mov	 eax, DWORD PTR wraplen$[rsp]
  001e7	8b 4c 24 28	 mov	 ecx, DWORD PTR complen$[rsp]
  001eb	03 c8		 add	 ecx, eax
  001ed	8b c1		 mov	 eax, ecx
  001ef	eb 2b		 jmp	 SHORT $LN1@deflateBou
$LN20@deflateBou:

; 705  : 
; 706  :     /* default settings: return tight bound for that case */
; 707  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +

  001f1	8b 44 24 68	 mov	 eax, DWORD PTR sourceLen$[rsp]
  001f5	c1 e8 0c	 shr	 eax, 12
  001f8	8b 4c 24 68	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  001fc	03 c8		 add	 ecx, eax
  001fe	8b c1		 mov	 eax, ecx
  00200	8b 4c 24 68	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  00204	c1 e9 0e	 shr	 ecx, 14
  00207	03 c1		 add	 eax, ecx
  00209	8b 4c 24 68	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  0020d	c1 e9 19	 shr	 ecx, 25
  00210	8b 54 24 2c	 mov	 edx, DWORD PTR wraplen$[rsp]
  00214	03 d0		 add	 edx, eax
  00216	8b c2		 mov	 eax, edx
  00218	8d 44 01 07	 lea	 eax, DWORD PTR [rcx+rax+7]
$LN1@deflateBou:

; 708  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 709  : }

  0021c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00220	5f		 pop	 rdi
  00221	c3		 ret	 0
deflateBound ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT putShortMSB
_TEXT	SEGMENT
s$ = 48
b$ = 56
putShortMSB PROC					; COMDAT

; 719  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 08 00 00 00	 mov	 ecx, 8
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 720  :     put_byte(s, (Byte)(b >> 8));

  0002e	8b 44 24 38	 mov	 eax, DWORD PTR b$[rsp]
  00032	c1 e8 08	 shr	 eax, 8
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0003a	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0003d	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  00042	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00046	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0004e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00051	ff c0		 inc	 eax
  00053	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00058	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 721  :     put_byte(s, (Byte)(b & 0xff));

  0005b	8b 44 24 38	 mov	 eax, DWORD PTR b$[rsp]
  0005f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00064	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00069	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0006c	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  00071	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00075	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0007d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00080	ff c0		 inc	 eax
  00082	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00087	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 722  : }

  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
putShortMSB ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT flush_pending
_TEXT	SEGMENT
len$ = 32
s$ = 40
strm$ = 64
flush_pending PROC					; COMDAT

; 732  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 733  :     unsigned len;
; 734  :     deflate_state *s = strm->state;

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0002f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00033	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 735  : 
; 736  :     _tr_flush_bits(s);

  00038	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0003d	e8 00 00 00 00	 call	 _tr_flush_bits

; 737  :     len = s->pending;

  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00047	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0004a	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 738  :     if (len > strm->avail_out) len = strm->avail_out;

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00053	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00056	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  0005a	76 0c		 jbe	 SHORT $LN2@flush_pend
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00061	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00064	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN2@flush_pend:

; 739  :     if (len == 0) return;

  00068	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  0006d	75 05		 jne	 SHORT $LN3@flush_pend
  0006f	e9 a8 00 00 00	 jmp	 $LN1@flush_pend
$LN3@flush_pend:

; 740  : 
; 741  :     zmemcpy(strm->next_out, s->pending_out, len);

  00074	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00078	44 8b c0	 mov	 r8d, eax
  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00080	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00089	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 742  :     strm->next_out  += len;

  00093	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0009c	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000a5	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 743  :     s->pending_out  += len;

  000a9	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000b2	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000bb	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 744  :     strm->total_out += len;

  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c4	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000c7	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000d0	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 745  :     strm->avail_out -= len;

  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d8	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000dc	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000df	2b c1		 sub	 eax, ecx
  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000e6	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 746  :     s->pending      -= len;

  000e9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000ee	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000f2	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000f5	2b c1		 sub	 eax, ecx
  000f7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000fc	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 747  :     if (s->pending == 0) {

  000ff	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00104	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00108	75 12		 jne	 SHORT $LN4@flush_pend

; 748  :         s->pending_out = s->pending_buf;

  0010a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0010f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00114	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00118	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
$LN4@flush_pend:
$LN1@flush_pend:

; 749  :     }
; 750  : }

  0011c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00120	5f		 pop	 rdi
  00121	c3		 ret	 0
flush_pending ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflateCopy
_TEXT	SEGMENT
ds$ = 32
ss$ = 40
overlay$ = 48
dest$ = 80
source$ = 88
deflateCopy PROC					; COMDAT

; 1105 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1106 : #ifdef MAXSEG_64K
; 1107 :     return Z_STREAM_ERROR;
; 1108 : #else
; 1109 :     deflate_state *ds;
; 1110 :     deflate_state *ss;
; 1111 :     ushf *overlay;
; 1112 : 
; 1113 : 
; 1114 :     if (deflateStateCheck(source) || dest == Z_NULL) {

  0002f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR source$[rsp]
  00034	e8 00 00 00 00	 call	 deflateStateCheck
  00039	85 c0		 test	 eax, eax
  0003b	75 08		 jne	 SHORT $LN3@deflateCop
  0003d	48 83 7c 24 50
	00		 cmp	 QWORD PTR dest$[rsp], 0
  00043	75 0a		 jne	 SHORT $LN2@deflateCop
$LN3@deflateCop:

; 1115 :         return Z_STREAM_ERROR;

  00045	b8 fe ff ff ff	 mov	 eax, -2
  0004a	e9 cb 02 00 00	 jmp	 $LN1@deflateCop
$LN2@deflateCop:

; 1116 :     }
; 1117 : 
; 1118 :     ss = source->state;

  0004f	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00054	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00058	48 89 44 24 28	 mov	 QWORD PTR ss$[rsp], rax

; 1119 : 
; 1120 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  0005d	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  00063	48 8b 54 24 58	 mov	 rdx, QWORD PTR source$[rsp]
  00068	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1121 : 
; 1122 :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  00073	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  00079	ba 01 00 00 00	 mov	 edx, 1
  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00083	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00087	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0008c	ff 50 30	 call	 QWORD PTR [rax+48]
  0008f	48 89 44 24 20	 mov	 QWORD PTR ds$[rsp], rax

; 1123 :     if (ds == Z_NULL) return Z_MEM_ERROR;

  00094	48 83 7c 24 20
	00		 cmp	 QWORD PTR ds$[rsp], 0
  0009a	75 0a		 jne	 SHORT $LN4@deflateCop
  0009c	b8 fc ff ff ff	 mov	 eax, -4
  000a1	e9 74 02 00 00	 jmp	 $LN1@deflateCop
$LN4@deflateCop:

; 1124 :     dest->state = (struct internal_state FAR *) ds;

  000a6	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  000b0	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1125 :     zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));

  000b4	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  000ba	48 8b 54 24 28	 mov	 rdx, QWORD PTR ss$[rsp]
  000bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1126 :     ds->strm = dest;

  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  000cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  000d4	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1127 : 
; 1128 :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  000d7	41 b8 02 00 00
	00		 mov	 r8d, 2
  000dd	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  000e2	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  000e5	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000ea	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000ee	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000f3	ff 50 30	 call	 QWORD PTR [rax+48]
  000f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  000fb	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 1129 :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  000ff	41 b8 02 00 00
	00		 mov	 r8d, 2
  00105	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  0010a	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  0010d	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00112	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00116	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0011b	ff 50 30	 call	 QWORD PTR [rax+48]
  0011e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  00123	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1130 :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  00127	41 b8 02 00 00
	00		 mov	 r8d, 2
  0012d	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  00132	8b 50 74	 mov	 edx, DWORD PTR [rax+116]
  00135	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0013a	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0013e	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00143	ff 50 30	 call	 QWORD PTR [rax+48]
  00146	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  0014b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 1131 :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  0014f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00155	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  0015a	8b 90 f0 16 00
	00		 mov	 edx, DWORD PTR [rax+5872]
  00160	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00165	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00169	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0016e	ff 50 30	 call	 QWORD PTR [rax+48]
  00171	48 89 44 24 30	 mov	 QWORD PTR overlay$[rsp], rax

; 1132 :     ds->pending_buf = (uchf *) overlay;

  00176	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  0017b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR overlay$[rsp]
  00180	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1133 : 
; 1134 :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||

  00184	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  00189	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  0018e	74 24		 je	 SHORT $LN6@deflateCop
  00190	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  00195	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0019a	74 18		 je	 SHORT $LN6@deflateCop
  0019c	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  001a1	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  001a6	74 0c		 je	 SHORT $LN6@deflateCop
  001a8	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  001ad	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  001b2	75 14		 jne	 SHORT $LN5@deflateCop
$LN6@deflateCop:

; 1135 :         ds->pending_buf == Z_NULL) {
; 1136 :         deflateEnd (dest);

  001b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  001b9	e8 00 00 00 00	 call	 deflateEnd

; 1137 :         return Z_MEM_ERROR;

  001be	b8 fc ff ff ff	 mov	 eax, -4
  001c3	e9 52 01 00 00	 jmp	 $LN1@deflateCop
$LN5@deflateCop:

; 1138 :     }
; 1139 :     /* following zmemcpy do not work for 16-bit MSDOS */
; 1140 :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  001c8	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  001cd	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  001d0	d1 e0		 shl	 eax, 1
  001d2	8b c0		 mov	 eax, eax
  001d4	44 8b c0	 mov	 r8d, eax
  001d7	48 8b 44 24 28	 mov	 rax, QWORD PTR ss$[rsp]
  001dc	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  001e0	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  001e5	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1141 :     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));

  001ef	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  001f4	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  001f7	48 d1 e0	 shl	 rax, 1
  001fa	4c 8b c0	 mov	 r8, rax
  001fd	48 8b 44 24 28	 mov	 rax, QWORD PTR ss$[rsp]
  00202	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00206	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  0020b	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1142 :     zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));

  00215	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  0021a	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0021d	48 d1 e0	 shl	 rax, 1
  00220	4c 8b c0	 mov	 r8, rax
  00223	48 8b 44 24 28	 mov	 rax, QWORD PTR ss$[rsp]
  00228	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  0022c	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  00231	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1143 :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  0023b	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  00240	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00243	44 8b c0	 mov	 r8d, eax
  00246	48 8b 44 24 28	 mov	 rax, QWORD PTR ss$[rsp]
  0024b	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0024f	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  00254	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1144 : 
; 1145 :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  0025e	48 8b 44 24 28	 mov	 rax, QWORD PTR ss$[rsp]
  00263	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ss$[rsp]
  00268	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0026c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00270	48 2b c1	 sub	 rax, rcx
  00273	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  00278	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0027c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  00281	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1146 :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  00285	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  0028a	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00290	33 d2		 xor	 edx, edx
  00292	b9 02 00 00 00	 mov	 ecx, 2
  00297	48 f7 f1	 div	 rcx
  0029a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR overlay$[rsp]
  0029f	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  002a3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  002a8	48 89 81 f8 16
	00 00		 mov	 QWORD PTR [rcx+5880], rax

; 1147 :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  002af	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  002b4	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  002ba	48 6b c0 03	 imul	 rax, rax, 3
  002be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  002c3	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  002c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  002cc	48 89 81 e8 16
	00 00		 mov	 QWORD PTR [rcx+5864], rax

; 1148 : 
; 1149 :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  002d3	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  002d8	48 05 bc 00 00
	00		 add	 rax, 188		; 000000bcH
  002de	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  002e3	48 89 81 40 0b
	00 00		 mov	 QWORD PTR [rcx+2880], rax

; 1150 :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  002ea	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  002ef	48 05 b0 09 00
	00		 add	 rax, 2480		; 000009b0H
  002f5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  002fa	48 89 81 58 0b
	00 00		 mov	 QWORD PTR [rcx+2904], rax

; 1151 :     ds->bl_desc.dyn_tree = ds->bl_tree;

  00301	48 8b 44 24 20	 mov	 rax, QWORD PTR ds$[rsp]
  00306	48 05 a4 0a 00
	00		 add	 rax, 2724		; 00000aa4H
  0030c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ds$[rsp]
  00311	48 89 81 70 0b
	00 00		 mov	 QWORD PTR [rcx+2928], rax

; 1152 : 
; 1153 :     return Z_OK;

  00318	33 c0		 xor	 eax, eax
$LN1@deflateCop:

; 1154 : #endif /* MAXSEG_64K */
; 1155 : }

  0031a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0031e	5f		 pop	 rdi
  0031f	c3		 ret	 0
deflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT read_buf
_TEXT	SEGMENT
len$ = 32
strm$ = 64
buf$ = 72
size$ = 80
read_buf PROC						; COMDAT

; 1168 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1169 :     unsigned len = strm->avail_in;

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00039	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003c	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 1170 : 
; 1171 :     if (len > size) len = size;

  00040	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00044	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  00048	76 08		 jbe	 SHORT $LN2@read_buf
  0004a	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0004e	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN2@read_buf:

; 1172 :     if (len == 0) return 0;

  00052	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  00057	75 07		 jne	 SHORT $LN3@read_buf
  00059	33 c0		 xor	 eax, eax
  0005b	e9 ba 00 00 00	 jmp	 $LN1@read_buf
$LN3@read_buf:

; 1173 : 
; 1174 :     strm->avail_in  -= len;

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00065	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00069	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0006c	2b c1		 sub	 eax, ecx
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00073	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1175 : 
; 1176 :     zmemcpy(buf, strm->next_in, len);

  00076	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0007a	44 8b c0	 mov	 r8d, eax
  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00082	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00085	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1177 :     if (strm->state->wrap == 1) {

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00095	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00099	83 78 2c 01	 cmp	 DWORD PTR [rax+44], 1
  0009d	75 21		 jne	 SHORT $LN4@read_buf

; 1178 :         strm->adler = adler32(strm->adler, buf, len);

  0009f	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  000a4	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ae	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000b1	e8 00 00 00 00	 call	 adler32
  000b6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000bb	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 1179 :     }

  000be	eb 2e		 jmp	 SHORT $LN5@read_buf
$LN4@read_buf:

; 1180 : #ifdef GZIP
; 1181 :     else if (strm->state->wrap == 2) {

  000c0	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c5	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000c9	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  000cd	75 1f		 jne	 SHORT $LN6@read_buf

; 1182 :         strm->adler = crc32(strm->adler, buf, len);

  000cf	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  000d4	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000de	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000e1	e8 00 00 00 00	 call	 crc32
  000e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000eb	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN6@read_buf:
$LN5@read_buf:

; 1183 :     }
; 1184 : #endif
; 1185 :     strm->next_in  += len;

  000ee	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000f2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000f7	48 03 01	 add	 rax, QWORD PTR [rcx]
  000fa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000ff	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1186 :     strm->total_in += len;

  00102	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00107	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0010a	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00113	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 1187 : 
; 1188 :     return len;

  00116	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
$LN1@read_buf:

; 1189 : }

  0011a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011e	5f		 pop	 rdi
  0011f	c3		 ret	 0
read_buf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT lm_init
_TEXT	SEGMENT
s$ = 48
lm_init	PROC						; COMDAT

; 1196 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1197 :     s->window_size = (ulg)2L*s->w_size;

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0002f	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00032	d1 e0		 shl	 eax, 1
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00039	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1198 : 
; 1199 :     CLEAR_HASH(s);

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00041	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00044	ff c8		 dec	 eax
  00046	8b c0		 mov	 eax, eax
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0004d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00051	33 d2		 xor	 edx, edx
  00053	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0005c	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0005f	ff c8		 dec	 eax
  00061	8b c0		 mov	 eax, eax
  00063	48 d1 e0	 shl	 rax, 1
  00066	4c 8b c0	 mov	 r8, rax
  00069	33 d2		 xor	 edx, edx
  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00070	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memset

; 1200 : 
; 1201 :     /* Set the default configuration parameters:
; 1202 :      */
; 1203 :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0007f	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  00086	48 6b c0 10	 imul	 rax, rax, 16
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  00091	0f b7 44 01 02	 movzx	 eax, WORD PTR [rcx+rax+2]
  00096	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0009b	89 81 a8 00 00
	00		 mov	 DWORD PTR [rcx+168], eax

; 1204 :     s->good_match       = configuration_table[s->level].good_length;

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000a6	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  000ad	48 6b c0 10	 imul	 rax, rax, 16
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  000b8	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  000bc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000c1	89 81 b4 00 00
	00		 mov	 DWORD PTR [rcx+180], eax

; 1205 :     s->nice_match       = configuration_table[s->level].nice_length;

  000c7	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000cc	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  000d3	48 6b c0 10	 imul	 rax, rax, 16
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  000de	0f b7 44 01 04	 movzx	 eax, WORD PTR [rcx+rax+4]
  000e3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000e8	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 1206 :     s->max_chain_length = configuration_table[s->level].max_chain;

  000ee	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000f3	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  000fa	48 6b c0 10	 imul	 rax, rax, 16
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  00105	0f b7 44 01 06	 movzx	 eax, WORD PTR [rcx+rax+6]
  0010a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0010f	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax

; 1207 : 
; 1208 :     s->strstart = 0;

  00115	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0011a	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 1209 :     s->block_start = 0L;

  00124	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00129	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0

; 1210 :     s->lookahead = 0;

  00133	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00138	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 1211 :     s->insert = 0;

  00142	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00147	c7 80 0c 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5900], 0

; 1212 :     s->match_length = s->prev_length = MIN_MATCH-1;

  00151	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00156	c7 80 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+160], 2
  00160	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00165	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1213 :     s->match_available = 0;

  0016f	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00174	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 1214 :     s->ins_h = 0;

  0017e	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00183	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 1215 : #ifndef FASTEST
; 1216 : #ifdef ASMV
; 1217 :     match_init(); /* initialize the asm code */

  0018a	e8 00 00 00 00	 call	 match_init

; 1218 : #endif
; 1219 : #endif
; 1220 : }

  0018f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00193	5f		 pop	 rdi
  00194	c3		 ret	 0
lm_init	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT fill_window
_TEXT	SEGMENT
n$ = 32
more$ = 36
wsize$ = 40
str$1 = 44
curr$2 = 48
init$3 = 52
tv353 = 56
tv364 = 64
s$ = 96
fill_window PROC					; COMDAT

; 1484 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 14 00 00 00	 mov	 ecx, 20
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1485 :     unsigned n;
; 1486 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1487 :     uInt wsize = s->w_size;

  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0002f	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00032	89 44 24 28	 mov	 DWORD PTR wsize$[rsp], eax
$LN4@fill_windo:

; 1488 : 
; 1489 :     Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
; 1490 : 
; 1491 :     do {
; 1492 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00036	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0003b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00040	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  00046	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00049	2b c1		 sub	 eax, ecx
  0004b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00050	2b 81 94 00 00
	00		 sub	 eax, DWORD PTR [rcx+148]
  00056	89 44 24 24	 mov	 DWORD PTR more$[rsp], eax

; 1493 : 
; 1494 :         /* Deal with !@#$% 64K limit: */
; 1495 :         if (sizeof(int) <= 2) {

  0005a	33 c0		 xor	 eax, eax
  0005c	85 c0		 test	 eax, eax
  0005e	74 3e		 je	 SHORT $LN7@fill_windo

; 1496 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {

  00060	83 7c 24 24 00	 cmp	 DWORD PTR more$[rsp], 0
  00065	75 26		 jne	 SHORT $LN8@fill_windo
  00067	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0006c	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  00073	75 18		 jne	 SHORT $LN8@fill_windo
  00075	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0007a	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00081	75 0a		 jne	 SHORT $LN8@fill_windo

; 1497 :                 more = wsize;

  00083	8b 44 24 28	 mov	 eax, DWORD PTR wsize$[rsp]
  00087	89 44 24 24	 mov	 DWORD PTR more$[rsp], eax
  0008b	eb 11		 jmp	 SHORT $LN9@fill_windo
$LN8@fill_windo:

; 1498 : 
; 1499 :             } else if (more == (unsigned)(-1)) {

  0008d	83 7c 24 24 ff	 cmp	 DWORD PTR more$[rsp], -1 ; ffffffffH
  00092	75 0a		 jne	 SHORT $LN10@fill_windo

; 1500 :                 /* Very unlikely, but possible on 16 bit machine if
; 1501 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1502 :                  */
; 1503 :                 more--;

  00094	8b 44 24 24	 mov	 eax, DWORD PTR more$[rsp]
  00098	ff c8		 dec	 eax
  0009a	89 44 24 24	 mov	 DWORD PTR more$[rsp], eax
$LN10@fill_windo:
$LN9@fill_windo:
$LN7@fill_windo:

; 1504 :             }
; 1505 :         }
; 1506 : 
; 1507 :         /* If the window is almost full and there is insufficient lookahead,
; 1508 :          * move the upper half to the lower one to make room in the upper half.
; 1509 :          */
; 1510 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000a3	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000a6	8b 4c 24 28	 mov	 ecx, DWORD PTR wsize$[rsp]
  000aa	8d 84 01 fa fe
	ff ff		 lea	 eax, DWORD PTR [rcx+rax-262]
  000b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000b6	39 81 94 00 00
	00		 cmp	 DWORD PTR [rcx+148], eax
  000bc	0f 82 a1 00 00
	00		 jb	 $LN11@fill_windo

; 1511 : 
; 1512 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize - more);

  000c2	0f ae e8	 lfence
  000c5	8b 44 24 24	 mov	 eax, DWORD PTR more$[rsp]
  000c9	8b 4c 24 28	 mov	 ecx, DWORD PTR wsize$[rsp]
  000cd	2b c8		 sub	 ecx, eax
  000cf	8b c1		 mov	 eax, ecx
  000d1	8b c0		 mov	 eax, eax
  000d3	8b 4c 24 28	 mov	 ecx, DWORD PTR wsize$[rsp]
  000d7	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  000dc	48 03 4a 50	 add	 rcx, QWORD PTR [rdx+80]
  000e0	44 8b c0	 mov	 r8d, eax
  000e3	48 8b d1	 mov	 rdx, rcx
  000e6	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000eb	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1513 :             s->match_start -= wsize;

  000f5	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000fa	8b 4c 24 28	 mov	 ecx, DWORD PTR wsize$[rsp]
  000fe	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [rax+152]
  00104	2b c1		 sub	 eax, ecx
  00106	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0010b	89 81 98 00 00
	00		 mov	 DWORD PTR [rcx+152], eax

; 1514 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */

  00111	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00116	8b 4c 24 28	 mov	 ecx, DWORD PTR wsize$[rsp]
  0011a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00120	2b c1		 sub	 eax, ecx
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00127	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1515 :             s->block_start -= (long) wsize;

  0012d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00132	8b 4c 24 28	 mov	 ecx, DWORD PTR wsize$[rsp]
  00136	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0013c	2b c1		 sub	 eax, ecx
  0013e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00143	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 1516 :             slide_hash(s);

  00149	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0014e	e8 00 00 00 00	 call	 slide_hash

; 1517 :             more += wsize;

  00153	8b 44 24 28	 mov	 eax, DWORD PTR wsize$[rsp]
  00157	8b 4c 24 24	 mov	 ecx, DWORD PTR more$[rsp]
  0015b	03 c8		 add	 ecx, eax
  0015d	8b c1		 mov	 eax, ecx
  0015f	89 44 24 24	 mov	 DWORD PTR more$[rsp], eax
$LN11@fill_windo:

; 1518 :         }
; 1519 :         if (s->strm->avail_in == 0) break;

  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00168	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0016b	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0016f	75 05		 jne	 SHORT $LN12@fill_windo
  00171	e9 0d 02 00 00	 jmp	 $LN3@fill_windo
$LN12@fill_windo:

; 1520 : 
; 1521 :         /* If there was no sliding:
; 1522 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1523 :          *    more == window_size - lookahead - strstart
; 1524 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1525 :          * => more >= window_size - 2*WSIZE + 2
; 1526 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1527 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1528 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1529 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1530 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1531 :          */
; 1532 :         Assert(more >= 2, "more < 2");
; 1533 : 
; 1534 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  00176	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0017b	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00181	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00186	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0018a	48 03 c8	 add	 rcx, rax
  0018d	48 8b c1	 mov	 rax, rcx
  00190	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00195	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  0019b	48 03 c1	 add	 rax, rcx
  0019e	44 8b 44 24 24	 mov	 r8d, DWORD PTR more$[rsp]
  001a3	48 8b d0	 mov	 rdx, rax
  001a6	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001ab	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001ae	e8 00 00 00 00	 call	 read_buf
  001b3	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 1535 :         s->lookahead += n;

  001b7	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001bc	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  001c2	03 44 24 20	 add	 eax, DWORD PTR n$[rsp]
  001c6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001cb	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1536 : 
; 1537 :         /* Initialize the hash value now that we have some input: */
; 1538 :         if (s->lookahead + s->insert >= MIN_MATCH) {

  001d1	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001d6	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  001dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001e1	03 81 0c 17 00
	00		 add	 eax, DWORD PTR [rcx+5900]
  001e7	83 f8 03	 cmp	 eax, 3
  001ea	0f 82 70 01 00
	00		 jb	 $LN13@fill_windo

; 1539 :             uInt str = s->strstart - s->insert;

  001f0	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001fa	8b 89 0c 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5900]
  00200	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00206	2b c1		 sub	 eax, ecx
  00208	89 44 24 2c	 mov	 DWORD PTR str$1[rsp], eax

; 1540 :             s->ins_h = s->window[str];

  0020c	8b 44 24 2c	 mov	 eax, DWORD PTR str$1[rsp]
  00210	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00215	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00219	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00222	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 1541 :             UPDATE_HASH(s, s->ins_h, s->window[str + 1]);

  00225	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0022a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00230	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00235	48 89 4c 24 38	 mov	 QWORD PTR tv353[rsp], rcx
  0023a	0f b6 c8	 movzx	 ecx, al
  0023d	48 8b 44 24 38	 mov	 rax, QWORD PTR tv353[rsp]
  00242	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00245	d3 e0		 shl	 eax, cl
  00247	8b 4c 24 2c	 mov	 ecx, DWORD PTR str$1[rsp]
  0024b	ff c1		 inc	 ecx
  0024d	8b c9		 mov	 ecx, ecx
  0024f	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  00254	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00258	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0025c	33 c1		 xor	 eax, ecx
  0025e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00263	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  00266	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0026b	89 41 70	 mov	 DWORD PTR [rcx+112], eax
$LN5@fill_windo:

; 1542 : #if MIN_MATCH != 3
; 1543 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1544 : #endif
; 1545 :             while (s->insert) {

  0026e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00273	83 b8 0c 17 00
	00 00		 cmp	 DWORD PTR [rax+5900], 0
  0027a	0f 84 e0 00 00
	00		 je	 $LN6@fill_windo

; 1546 :                 UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  00280	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00285	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0028b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00290	48 89 4c 24 40	 mov	 QWORD PTR tv364[rsp], rcx
  00295	0f b6 c8	 movzx	 ecx, al
  00298	48 8b 44 24 40	 mov	 rax, QWORD PTR tv364[rsp]
  0029d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002a0	d3 e0		 shl	 eax, cl
  002a2	8b 4c 24 2c	 mov	 ecx, DWORD PTR str$1[rsp]
  002a6	83 c1 02	 add	 ecx, 2
  002a9	8b c9		 mov	 ecx, ecx
  002ab	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  002b0	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  002b4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002b8	33 c1		 xor	 eax, ecx
  002ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002bf	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  002c2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002c7	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 1547 : #ifndef FASTEST
; 1548 :                 s->prev[str & s->w_mask] = s->head[s->ins_h];

  002ca	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002cf	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002d2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002d7	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  002db	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  002e0	8b 52 4c	 mov	 edx, DWORD PTR [rdx+76]
  002e3	44 8b 44 24 2c	 mov	 r8d, DWORD PTR str$1[rsp]
  002e8	44 23 c2	 and	 r8d, edx
  002eb	41 8b d0	 mov	 edx, r8d
  002ee	8b d2		 mov	 edx, edx
  002f0	4c 8b 44 24 60	 mov	 r8, QWORD PTR s$[rsp]
  002f5	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  002f9	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  002fd	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax

; 1549 : #endif
; 1550 :                 s->head[s->ins_h] = (Pos)str;

  00302	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00307	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0030a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0030f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00313	0f b7 54 24 2c	 movzx	 edx, WORD PTR str$1[rsp]
  00318	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 1551 :                 str++;

  0031c	8b 44 24 2c	 mov	 eax, DWORD PTR str$1[rsp]
  00320	ff c0		 inc	 eax
  00322	89 44 24 2c	 mov	 DWORD PTR str$1[rsp], eax

; 1552 :                 s->insert--;

  00326	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0032b	8b 80 0c 17 00
	00		 mov	 eax, DWORD PTR [rax+5900]
  00331	ff c8		 dec	 eax
  00333	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00338	89 81 0c 17 00
	00		 mov	 DWORD PTR [rcx+5900], eax

; 1553 :                 if (s->lookahead + s->insert < MIN_MATCH)

  0033e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00343	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00349	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0034e	03 81 0c 17 00
	00		 add	 eax, DWORD PTR [rcx+5900]
  00354	83 f8 03	 cmp	 eax, 3
  00357	73 02		 jae	 SHORT $LN14@fill_windo

; 1554 :                     break;

  00359	eb 05		 jmp	 SHORT $LN6@fill_windo
$LN14@fill_windo:

; 1555 :             }

  0035b	e9 0e ff ff ff	 jmp	 $LN5@fill_windo
$LN6@fill_windo:
$LN13@fill_windo:

; 1556 :         }
; 1557 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1558 :          * but this is not important since only literal bytes will be emitted.
; 1559 :          */
; 1560 : 
; 1561 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  00360	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00365	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  0036f	73 12		 jae	 SHORT $LN15@fill_windo
  00371	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00376	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00379	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0037d	0f 85 b3 fc ff
	ff		 jne	 $LN4@fill_windo
$LN15@fill_windo:
$LN3@fill_windo:

; 1562 : 
; 1563 :     /* If the WIN_INIT bytes after the end of the current data have never been
; 1564 :      * written, then zero those bytes in order to avoid memory check reports of
; 1565 :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 1566 :      * the longest match routines.  Update the high water mark for the next
; 1567 :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 1568 :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 1569 :      */
; 1570 :     if (s->high_water < s->window_size) {

  00383	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00388	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0038d	8b 49 58	 mov	 ecx, DWORD PTR [rcx+88]
  00390	39 88 18 17 00
	00		 cmp	 DWORD PTR [rax+5912], ecx
  00396	0f 83 30 01 00
	00		 jae	 $LN16@fill_windo

; 1571 :         ulg curr = s->strstart + (ulg)(s->lookahead);

  0039c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  003a1	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  003a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003ac	03 81 9c 00 00
	00		 add	 eax, DWORD PTR [rcx+156]
  003b2	89 44 24 30	 mov	 DWORD PTR curr$2[rsp], eax

; 1572 :         ulg init;
; 1573 : 
; 1574 :         if (s->high_water < curr) {

  003b6	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  003bb	8b 4c 24 30	 mov	 ecx, DWORD PTR curr$2[rsp]
  003bf	39 88 18 17 00
	00		 cmp	 DWORD PTR [rax+5912], ecx
  003c5	73 5f		 jae	 SHORT $LN17@fill_windo

; 1575 :             /* Previous high water mark below current data -- zero WIN_INIT
; 1576 :              * bytes or up to end of window, whichever is less.
; 1577 :              */
; 1578 :             init = s->window_size - curr;

  003c7	0f ae e8	 lfence
  003ca	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  003cf	8b 4c 24 30	 mov	 ecx, DWORD PTR curr$2[rsp]
  003d3	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  003d6	2b c1		 sub	 eax, ecx
  003d8	89 44 24 34	 mov	 DWORD PTR init$3[rsp], eax

; 1579 :             if (init > WIN_INIT)

  003dc	81 7c 24 34 02
	01 00 00	 cmp	 DWORD PTR init$3[rsp], 258 ; 00000102H
  003e4	76 08		 jbe	 SHORT $LN19@fill_windo

; 1580 :                 init = WIN_INIT;

  003e6	c7 44 24 34 02
	01 00 00	 mov	 DWORD PTR init$3[rsp], 258 ; 00000102H
$LN19@fill_windo:

; 1581 :             zmemzero(s->window + curr, (unsigned)init);

  003ee	8b 44 24 34	 mov	 eax, DWORD PTR init$3[rsp]
  003f2	8b 4c 24 30	 mov	 ecx, DWORD PTR curr$2[rsp]
  003f6	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  003fb	48 03 4a 50	 add	 rcx, QWORD PTR [rdx+80]
  003ff	44 8b c0	 mov	 r8d, eax
  00402	33 d2		 xor	 edx, edx
  00404	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memset

; 1582 :             s->high_water = curr + init;

  0040a	8b 44 24 34	 mov	 eax, DWORD PTR init$3[rsp]
  0040e	8b 4c 24 30	 mov	 ecx, DWORD PTR curr$2[rsp]
  00412	03 c8		 add	 ecx, eax
  00414	8b c1		 mov	 eax, ecx
  00416	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0041b	89 81 18 17 00
	00		 mov	 DWORD PTR [rcx+5912], eax

; 1583 :         }

  00421	e9 a6 00 00 00	 jmp	 $LN18@fill_windo
$LN17@fill_windo:

; 1584 :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  00426	8b 44 24 30	 mov	 eax, DWORD PTR curr$2[rsp]
  0042a	05 02 01 00 00	 add	 eax, 258		; 00000102H
  0042f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00434	39 81 18 17 00
	00		 cmp	 DWORD PTR [rcx+5912], eax
  0043a	0f 83 8c 00 00
	00		 jae	 $LN20@fill_windo

; 1585 :             /* High water mark at or above current data, but below current data
; 1586 :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 1587 :              * to end of window, whichever is less.
; 1588 :              */
; 1589 :             init = (ulg)curr + WIN_INIT - s->high_water;

  00440	0f ae e8	 lfence
  00443	8b 44 24 30	 mov	 eax, DWORD PTR curr$2[rsp]
  00447	05 02 01 00 00	 add	 eax, 258		; 00000102H
  0044c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00451	2b 81 18 17 00
	00		 sub	 eax, DWORD PTR [rcx+5912]
  00457	89 44 24 34	 mov	 DWORD PTR init$3[rsp], eax

; 1590 :             if (init > s->window_size - s->high_water)

  0045b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00460	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00465	8b 89 18 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5912]
  0046b	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0046e	2b c1		 sub	 eax, ecx
  00470	39 44 24 34	 cmp	 DWORD PTR init$3[rsp], eax
  00474	76 19		 jbe	 SHORT $LN21@fill_windo

; 1591 :                 init = s->window_size - s->high_water;

  00476	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0047b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00480	8b 89 18 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5912]
  00486	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00489	2b c1		 sub	 eax, ecx
  0048b	89 44 24 34	 mov	 DWORD PTR init$3[rsp], eax
$LN21@fill_windo:

; 1592 :             zmemzero(s->window + s->high_water, (unsigned)init);

  0048f	8b 44 24 34	 mov	 eax, DWORD PTR init$3[rsp]
  00493	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00498	8b 89 18 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5912]
  0049e	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  004a3	48 03 4a 50	 add	 rcx, QWORD PTR [rdx+80]
  004a7	44 8b c0	 mov	 r8d, eax
  004aa	33 d2		 xor	 edx, edx
  004ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memset

; 1593 :             s->high_water += init;

  004b2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  004b7	8b 80 18 17 00
	00		 mov	 eax, DWORD PTR [rax+5912]
  004bd	03 44 24 34	 add	 eax, DWORD PTR init$3[rsp]
  004c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  004c6	89 81 18 17 00
	00		 mov	 DWORD PTR [rcx+5912], eax
$LN20@fill_windo:
$LN18@fill_windo:
$LN16@fill_windo:

; 1594 :         }
; 1595 :     }
; 1596 : 
; 1597 :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 1598 :            "not enough room for search");
; 1599 : }

  004cc	48 83 c4 50	 add	 rsp, 80			; 00000050H
  004d0	5f		 pop	 rdi
  004d1	c3		 ret	 0
fill_window ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_stored
_TEXT	SEGMENT
min_block$ = 32
len$ = 36
left$ = 40
have$ = 44
last$ = 48
used$ = 52
tv71 = 56
tv139 = 60
tv466 = 64
tv288 = 72
tv302 = 80
tv385 = 84
tv389 = 88
tv402 = 92
tv408 = 96
tv423 = 100
s$ = 128
flush$ = 136
deflate_stored PROC					; COMDAT

; 1646 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 1c 00 00 00	 mov	 ecx, 28
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 1647 :     /* Smallest worthy block size when not flushing or finishing. By default
; 1648 :      * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
; 1649 :      * large input and output buffers, the stored block size will be larger.
; 1650 :      */
; 1651 :     unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);

  00031	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00039	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0003c	83 e8 05	 sub	 eax, 5
  0003f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00047	3b 41 44	 cmp	 eax, DWORD PTR [rcx+68]
  0004a	76 11		 jbe	 SHORT $LN31@deflate_st
  0004c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00054	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00057	89 44 24 38	 mov	 DWORD PTR tv71[rsp], eax
  0005b	eb 12		 jmp	 SHORT $LN32@deflate_st
$LN31@deflate_st:
  0005d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00065	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00068	83 e8 05	 sub	 eax, 5
  0006b	89 44 24 38	 mov	 DWORD PTR tv71[rsp], eax
$LN32@deflate_st:
  0006f	8b 44 24 38	 mov	 eax, DWORD PTR tv71[rsp]
  00073	89 44 24 20	 mov	 DWORD PTR min_block$[rsp], eax

; 1652 : 
; 1653 :     /* Copy as many min_block or larger stored blocks directly to next_out as
; 1654 :      * possible. If flushing, copy the remaining available input to next_out as
; 1655 :      * stored blocks, if there is enough space.
; 1656 :      */
; 1657 :     unsigned len, left, have, last = 0;

  00077	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR last$[rsp], 0

; 1658 :     unsigned used = s->strm->avail_in;

  0007f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00087	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0008d	89 44 24 34	 mov	 DWORD PTR used$[rsp], eax
$LN4@deflate_st:

; 1659 :     do {
; 1660 :         /* Set len to the maximum size block that we can copy directly with the
; 1661 :          * available input data and output space. Set left to how much of that
; 1662 :          * would be copied from what's left in the window.
; 1663 :          */
; 1664 :         len = MAX_STORED;       /* maximum deflate stored block length */

  00091	c7 44 24 24 ff
	ff 00 00	 mov	 DWORD PTR len$[rsp], 65535 ; 0000ffffH

; 1665 :         have = (s->bi_valid + 42) >> 3;         /* number of header bytes */

  00099	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000a1	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  000a7	83 c0 2a	 add	 eax, 42			; 0000002aH
  000aa	c1 f8 03	 sar	 eax, 3
  000ad	89 44 24 2c	 mov	 DWORD PTR have$[rsp], eax

; 1666 :         if (s->strm->avail_out < have)          /* need room for header */

  000b1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bc	8b 4c 24 2c	 mov	 ecx, DWORD PTR have$[rsp]
  000c0	39 48 18	 cmp	 DWORD PTR [rax+24], ecx
  000c3	73 05		 jae	 SHORT $LN5@deflate_st

; 1667 :             break;

  000c5	e9 5e 03 00 00	 jmp	 $LN3@deflate_st
$LN5@deflate_st:

; 1668 :             /* maximum stored block length that will fit in avail_out: */
; 1669 :         have = s->strm->avail_out - have;

  000ca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	8b 4c 24 2c	 mov	 ecx, DWORD PTR have$[rsp]
  000d9	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000dc	2b c1		 sub	 eax, ecx
  000de	89 44 24 2c	 mov	 DWORD PTR have$[rsp], eax

; 1670 :         left = s->strstart - s->block_start;    /* bytes left in window */

  000e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000ea	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f2	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  000f8	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  000fe	2b c1		 sub	 eax, ecx
  00100	89 44 24 28	 mov	 DWORD PTR left$[rsp], eax

; 1671 :         if (len > (ulg)left + s->strm->avail_in)

  00104	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0010c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00112	8b 4c 24 28	 mov	 ecx, DWORD PTR left$[rsp]
  00116	03 c8		 add	 ecx, eax
  00118	8b c1		 mov	 eax, ecx
  0011a	39 44 24 24	 cmp	 DWORD PTR len$[rsp], eax
  0011e	76 1a		 jbe	 SHORT $LN6@deflate_st

; 1672 :             len = left + s->strm->avail_in;     /* limit len to the input */

  00120	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00128	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0012b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0012e	8b 4c 24 28	 mov	 ecx, DWORD PTR left$[rsp]
  00132	03 c8		 add	 ecx, eax
  00134	8b c1		 mov	 eax, ecx
  00136	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax
$LN6@deflate_st:

; 1673 :         if (len > have)

  0013a	8b 44 24 2c	 mov	 eax, DWORD PTR have$[rsp]
  0013e	39 44 24 24	 cmp	 DWORD PTR len$[rsp], eax
  00142	76 08		 jbe	 SHORT $LN7@deflate_st

; 1674 :             len = have;                         /* limit len to the output */

  00144	8b 44 24 2c	 mov	 eax, DWORD PTR have$[rsp]
  00148	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax
$LN7@deflate_st:

; 1675 : 
; 1676 :         /* If the stored block would be less than min_block in length, or if
; 1677 :          * unable to copy all of the available input when flushing, then try
; 1678 :          * copying to the window and the pending buffer instead. Also don't
; 1679 :          * write an empty block when flushing -- deflate() does that.
; 1680 :          */
; 1681 :         if (len < min_block && ((len == 0 && flush != Z_FINISH) ||

  0014c	8b 44 24 20	 mov	 eax, DWORD PTR min_block$[rsp]
  00150	39 44 24 24	 cmp	 DWORD PTR len$[rsp], eax
  00154	73 3c		 jae	 SHORT $LN8@deflate_st
  00156	83 7c 24 24 00	 cmp	 DWORD PTR len$[rsp], 0
  0015b	75 0a		 jne	 SHORT $LN10@deflate_st
  0015d	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00165	75 26		 jne	 SHORT $LN9@deflate_st
$LN10@deflate_st:
  00167	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  0016f	74 1c		 je	 SHORT $LN9@deflate_st
  00171	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00179	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0017f	8b 4c 24 28	 mov	 ecx, DWORD PTR left$[rsp]
  00183	03 c8		 add	 ecx, eax
  00185	8b c1		 mov	 eax, ecx
  00187	39 44 24 24	 cmp	 DWORD PTR len$[rsp], eax
  0018b	74 05		 je	 SHORT $LN8@deflate_st
$LN9@deflate_st:

; 1682 :                                 flush == Z_NO_FLUSH ||
; 1683 :                                 len != left + s->strm->avail_in))
; 1684 :             break;

  0018d	e9 96 02 00 00	 jmp	 $LN3@deflate_st
$LN8@deflate_st:

; 1685 : 
; 1686 :         /* Make a dummy stored block in pending to get the header bytes,
; 1687 :          * including any pending bits. This also updates the debugging counts.
; 1688 :          */
; 1689 :         last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;

  00192	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  0019a	75 26		 jne	 SHORT $LN33@deflate_st
  0019c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a7	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001aa	8b 4c 24 28	 mov	 ecx, DWORD PTR left$[rsp]
  001ae	03 c8		 add	 ecx, eax
  001b0	8b c1		 mov	 eax, ecx
  001b2	39 44 24 24	 cmp	 DWORD PTR len$[rsp], eax
  001b6	75 0a		 jne	 SHORT $LN33@deflate_st
  001b8	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv139[rsp], 1
  001c0	eb 08		 jmp	 SHORT $LN34@deflate_st
$LN33@deflate_st:
  001c2	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN34@deflate_st:
  001ca	8b 44 24 3c	 mov	 eax, DWORD PTR tv139[rsp]
  001ce	89 44 24 30	 mov	 DWORD PTR last$[rsp], eax

; 1690 :         _tr_stored_block(s, (char *)0, 0L, last);

  001d2	44 8b 4c 24 30	 mov	 r9d, DWORD PTR last$[rsp]
  001d7	45 33 c0	 xor	 r8d, r8d
  001da	33 d2		 xor	 edx, edx
  001dc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001e4	e8 00 00 00 00	 call	 _tr_stored_block

; 1691 : 
; 1692 :         /* Replace the lengths in the dummy stored block with len. */
; 1693 :         s->pending_buf[s->pending - 4] = len;

  001e9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001f1	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001f4	83 e8 04	 sub	 eax, 4
  001f7	8b c0		 mov	 eax, eax
  001f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00201	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00205	0f b6 54 24 24	 movzx	 edx, BYTE PTR len$[rsp]
  0020a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1694 :         s->pending_buf[s->pending - 3] = len >> 8;

  0020d	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00211	c1 e8 08	 shr	 eax, 8
  00214	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0021c	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0021f	83 e9 03	 sub	 ecx, 3
  00222	8b c9		 mov	 ecx, ecx
  00224	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0022c	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00230	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1695 :         s->pending_buf[s->pending - 2] = ~len;

  00233	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00237	f7 d0		 not	 eax
  00239	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00241	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00244	83 e9 02	 sub	 ecx, 2
  00247	8b c9		 mov	 ecx, ecx
  00249	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00251	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00255	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1696 :         s->pending_buf[s->pending - 1] = ~len >> 8;

  00258	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  0025c	f7 d0		 not	 eax
  0025e	c1 e8 08	 shr	 eax, 8
  00261	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00269	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0026c	ff c9		 dec	 ecx
  0026e	8b c9		 mov	 ecx, ecx
  00270	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00278	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0027c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1697 : 
; 1698 :         /* Write the stored block header bytes. */
; 1699 :         flush_pending(s->strm);

  0027f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00287	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0028a	e8 00 00 00 00	 call	 flush_pending

; 1700 : 
; 1701 : #ifdef ZLIB_DEBUG
; 1702 :         /* Update debugging counts for the data about to be copied. */
; 1703 :         s->compressed_len += len << 3;
; 1704 :         s->bits_sent += len << 3;
; 1705 : #endif
; 1706 : 
; 1707 :         /* Copy uncompressed bytes from the window to next_out. */
; 1708 :         if (left) {

  0028f	83 7c 24 28 00	 cmp	 DWORD PTR left$[rsp], 0
  00294	0f 84 ed 00 00
	00		 je	 $LN11@deflate_st

; 1709 :             if (left > len)

  0029a	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  0029e	39 44 24 28	 cmp	 DWORD PTR left$[rsp], eax
  002a2	76 08		 jbe	 SHORT $LN12@deflate_st

; 1710 :                 left = len;

  002a4	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  002a8	89 44 24 28	 mov	 DWORD PTR left$[rsp], eax
$LN12@deflate_st:

; 1711 :             zmemcpy(s->strm->next_out, s->window + s->block_start, left);

  002ac	8b 44 24 28	 mov	 eax, DWORD PTR left$[rsp]
  002b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002b8	48 63 89 84 00
	00 00		 movsxd	 rcx, DWORD PTR [rcx+132]
  002bf	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  002c7	48 03 4a 50	 add	 rcx, QWORD PTR [rdx+80]
  002cb	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  002d3	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  002d6	48 89 54 24 40	 mov	 QWORD PTR tv466[rsp], rdx
  002db	44 8b c0	 mov	 r8d, eax
  002de	48 8b d1	 mov	 rdx, rcx
  002e1	48 8b 44 24 40	 mov	 rax, QWORD PTR tv466[rsp]
  002e6	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1712 :             s->strm->next_out += left;

  002f0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002f8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002fb	8b 4c 24 28	 mov	 ecx, DWORD PTR left$[rsp]
  002ff	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  00303	48 8b c1	 mov	 rax, rcx
  00306	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0030e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00311	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1713 :             s->strm->avail_out -= left;

  00315	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0031d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00320	8b 4c 24 28	 mov	 ecx, DWORD PTR left$[rsp]
  00324	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00327	2b c1		 sub	 eax, ecx
  00329	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00331	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00334	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 1714 :             s->strm->total_out += left;

  00337	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0033f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00342	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00345	03 44 24 28	 add	 eax, DWORD PTR left$[rsp]
  00349	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00351	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00354	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1715 :             s->block_start += left;

  00357	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0035f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00365	03 44 24 28	 add	 eax, DWORD PTR left$[rsp]
  00369	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00371	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 1716 :             len -= left;

  00377	8b 44 24 28	 mov	 eax, DWORD PTR left$[rsp]
  0037b	8b 4c 24 24	 mov	 ecx, DWORD PTR len$[rsp]
  0037f	2b c8		 sub	 ecx, eax
  00381	8b c1		 mov	 eax, ecx
  00383	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax
$LN11@deflate_st:

; 1717 :         }
; 1718 : 
; 1719 :         /* Copy uncompressed bytes directly from next_in to next_out, updating
; 1720 :          * the check value.
; 1721 :          */
; 1722 :         if (len) {

  00387	83 7c 24 24 00	 cmp	 DWORD PTR len$[rsp], 0
  0038c	0f 84 8b 00 00
	00		 je	 $LN13@deflate_st

; 1723 :             read_buf(s->strm, s->strm->next_out, len);

  00392	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0039a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0039d	44 8b 44 24 24	 mov	 r8d, DWORD PTR len$[rsp]
  003a2	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  003a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003ae	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003b1	e8 00 00 00 00	 call	 read_buf

; 1724 :             s->strm->next_out += len;

  003b6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003be	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c1	8b 4c 24 24	 mov	 ecx, DWORD PTR len$[rsp]
  003c5	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  003c9	48 8b c1	 mov	 rax, rcx
  003cc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003d4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003d7	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1725 :             s->strm->avail_out -= len;

  003db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003e3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003e6	8b 4c 24 24	 mov	 ecx, DWORD PTR len$[rsp]
  003ea	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003ed	2b c1		 sub	 eax, ecx
  003ef	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003f7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003fa	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 1726 :             s->strm->total_out += len;

  003fd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00405	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00408	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0040b	03 44 24 24	 add	 eax, DWORD PTR len$[rsp]
  0040f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00417	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0041a	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
$LN13@deflate_st:

; 1727 :         }
; 1728 :     } while (last == 0);

  0041d	83 7c 24 30 00	 cmp	 DWORD PTR last$[rsp], 0
  00422	0f 84 69 fc ff
	ff		 je	 $LN4@deflate_st
$LN3@deflate_st:

; 1729 : 
; 1730 :     /* Update the sliding window with the last s->w_size bytes of the copied
; 1731 :      * data, or append all of the copied data to the existing window if less
; 1732 :      * than s->w_size bytes were copied. Also update the number of bytes to
; 1733 :      * insert in the hash tables, in the event that deflateParams() switches to
; 1734 :      * a non-zero compression level.
; 1735 :      */
; 1736 :     used -= s->strm->avail_in;      /* number of input bytes directly copied */

  00428	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00430	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00433	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00436	8b 4c 24 34	 mov	 ecx, DWORD PTR used$[rsp]
  0043a	2b c8		 sub	 ecx, eax
  0043c	8b c1		 mov	 eax, ecx
  0043e	89 44 24 34	 mov	 DWORD PTR used$[rsp], eax

; 1737 :     if (used) {

  00442	83 7c 24 34 00	 cmp	 DWORD PTR used$[rsp], 0
  00447	0f 84 2f 02 00
	00		 je	 $LN14@deflate_st

; 1738 :         /* If any input was used, then no unused input remains in the window,
; 1739 :          * therefore s->block_start == s->strstart.
; 1740 :          */
; 1741 :         if (used >= s->w_size) {    /* supplant the previous history */

  0044d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00455	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00458	39 44 24 34	 cmp	 DWORD PTR used$[rsp], eax
  0045c	72 6f		 jb	 SHORT $LN15@deflate_st

; 1742 :             s->matches = 2;         /* clear hash */

  0045e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00466	c7 80 08 17 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+5896], 2

; 1743 :             zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);

  00470	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00478	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0047b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00483	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00486	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0048e	8b 52 44	 mov	 edx, DWORD PTR [rdx+68]
  00491	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00494	48 2b ca	 sub	 rcx, rdx
  00497	44 8b c0	 mov	 r8d, eax
  0049a	48 8b d1	 mov	 rdx, rcx
  0049d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004a5	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  004a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1744 :             s->strstart = s->w_size;

  004af	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004b7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004bf	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  004c2	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1745 :         }

  004c8	e9 29 01 00 00	 jmp	 $LN16@deflate_st
$LN15@deflate_st:

; 1746 :         else {
; 1747 :             if (s->window_size - s->strstart <= used) {

  004cd	0f ae e8	 lfence
  004d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004d8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004e0	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  004e6	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  004e9	2b c1		 sub	 eax, ecx
  004eb	3b 44 24 34	 cmp	 eax, DWORD PTR used$[rsp]
  004ef	0f 87 95 00 00
	00		 ja	 $LN17@deflate_st

; 1748 :                 /* Slide the window down. */
; 1749 :                 s->strstart -= s->w_size;

  004f5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004fd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00505	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  00508	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0050e	2b c1		 sub	 eax, ecx
  00510	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00518	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1750 :                 zmemcpy(s->window, s->window + s->w_size, s->strstart);

  0051e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00526	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0052c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00534	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  00537	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0053f	48 03 4a 50	 add	 rcx, QWORD PTR [rdx+80]
  00543	44 8b c0	 mov	 r8d, eax
  00546	48 8b d1	 mov	 rdx, rcx
  00549	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00551	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  00555	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1751 :                 if (s->matches < 2)

  0055b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00563	83 b8 08 17 00
	00 02		 cmp	 DWORD PTR [rax+5896], 2
  0056a	73 1e		 jae	 SHORT $LN18@deflate_st

; 1752 :                     s->matches++;   /* add a pending slide_hash() */

  0056c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00574	8b 80 08 17 00
	00		 mov	 eax, DWORD PTR [rax+5896]
  0057a	ff c0		 inc	 eax
  0057c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00584	89 81 08 17 00
	00		 mov	 DWORD PTR [rcx+5896], eax
$LN18@deflate_st:
$LN17@deflate_st:

; 1753 :             }
; 1754 :             zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);

  0058a	8b 44 24 34	 mov	 eax, DWORD PTR used$[rsp]
  0058e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00596	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00599	8b 54 24 34	 mov	 edx, DWORD PTR used$[rsp]
  0059d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  005a0	48 2b ca	 sub	 rcx, rdx
  005a3	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  005ab	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [rdx+148]
  005b1	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  005b9	49 03 50 50	 add	 rdx, QWORD PTR [r8+80]
  005bd	48 89 54 24 48	 mov	 QWORD PTR tv288[rsp], rdx
  005c2	44 8b c0	 mov	 r8d, eax
  005c5	48 8b d1	 mov	 rdx, rcx
  005c8	48 8b 44 24 48	 mov	 rax, QWORD PTR tv288[rsp]
  005cd	48 8b c8	 mov	 rcx, rax
  005d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1755 :             s->strstart += used;

  005d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005de	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  005e4	03 44 24 34	 add	 eax, DWORD PTR used$[rsp]
  005e8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005f0	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax
$LN16@deflate_st:

; 1756 :         }
; 1757 :         s->block_start = s->strstart;

  005f6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005fe	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00606	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0060c	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 1758 :         s->insert += MIN(used, s->w_size - s->insert);

  00612	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0061a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00622	8b 89 0c 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5900]
  00628	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0062b	2b c1		 sub	 eax, ecx
  0062d	39 44 24 34	 cmp	 DWORD PTR used$[rsp], eax
  00631	76 21		 jbe	 SHORT $LN35@deflate_st
  00633	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0063b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00643	8b 89 0c 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5900]
  00649	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0064c	2b c1		 sub	 eax, ecx
  0064e	89 44 24 50	 mov	 DWORD PTR tv302[rsp], eax
  00652	eb 08		 jmp	 SHORT $LN36@deflate_st
$LN35@deflate_st:
  00654	8b 44 24 34	 mov	 eax, DWORD PTR used$[rsp]
  00658	89 44 24 50	 mov	 DWORD PTR tv302[rsp], eax
$LN36@deflate_st:
  0065c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00664	8b 80 0c 17 00
	00		 mov	 eax, DWORD PTR [rax+5900]
  0066a	03 44 24 50	 add	 eax, DWORD PTR tv302[rsp]
  0066e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00676	89 81 0c 17 00
	00		 mov	 DWORD PTR [rcx+5900], eax
$LN14@deflate_st:

; 1759 :     }
; 1760 :     if (s->high_water < s->strstart)

  0067c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00684	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0068c	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00692	39 88 18 17 00
	00		 cmp	 DWORD PTR [rax+5912], ecx
  00698	73 1c		 jae	 SHORT $LN19@deflate_st

; 1761 :         s->high_water = s->strstart;

  0069a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006aa	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  006b0	89 88 18 17 00
	00		 mov	 DWORD PTR [rax+5912], ecx
$LN19@deflate_st:

; 1762 : 
; 1763 :     /* If the last block was written to next_out, then done. */
; 1764 :     if (last)

  006b6	83 7c 24 30 00	 cmp	 DWORD PTR last$[rsp], 0
  006bb	74 0a		 je	 SHORT $LN20@deflate_st

; 1765 :         return finish_done;

  006bd	b8 03 00 00 00	 mov	 eax, 3
  006c2	e9 13 04 00 00	 jmp	 $LN1@deflate_st
$LN20@deflate_st:

; 1766 : 
; 1767 :     /* If flushing and all input has been consumed, then done. */
; 1768 :     if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
; 1769 :         s->strm->avail_in == 0 && (long)s->strstart == s->block_start)

  006c7	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  006cf	74 43		 je	 SHORT $LN21@deflate_st
  006d1	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  006d9	74 39		 je	 SHORT $LN21@deflate_st
  006db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006e3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006e6	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  006ea	75 28		 jne	 SHORT $LN21@deflate_st
  006ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006f4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006fc	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00702	39 88 94 00 00
	00		 cmp	 DWORD PTR [rax+148], ecx
  00708	75 0a		 jne	 SHORT $LN21@deflate_st

; 1770 :         return block_done;

  0070a	b8 01 00 00 00	 mov	 eax, 1
  0070f	e9 c6 03 00 00	 jmp	 $LN1@deflate_st
$LN21@deflate_st:

; 1771 : 
; 1772 :     /* Fill the window with any remaining input. */
; 1773 :     have = s->window_size - s->strstart - 1;

  00714	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0071c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00724	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0072a	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  0072d	2b c1		 sub	 eax, ecx
  0072f	ff c8		 dec	 eax
  00731	89 44 24 2c	 mov	 DWORD PTR have$[rsp], eax

; 1774 :     if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {

  00735	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0073d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00740	8b 4c 24 2c	 mov	 ecx, DWORD PTR have$[rsp]
  00744	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00747	0f 86 f4 00 00
	00		 jbe	 $LN22@deflate_st
  0074d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00755	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0075d	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  00760	39 88 84 00 00
	00		 cmp	 DWORD PTR [rax+132], ecx
  00766	0f 8c d5 00 00
	00		 jl	 $LN22@deflate_st

; 1775 :         /* Slide the window down. */
; 1776 :         s->block_start -= s->w_size;

  0076c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00774	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0077c	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  0077f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00785	2b c1		 sub	 eax, ecx
  00787	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0078f	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 1777 :         s->strstart -= s->w_size;

  00795	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0079d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007a5	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  007a8	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  007ae	2b c1		 sub	 eax, ecx
  007b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007b8	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1778 :         zmemcpy(s->window, s->window + s->w_size, s->strstart);

  007be	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007c6	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  007cc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007d4	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  007d7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  007df	48 03 4a 50	 add	 rcx, QWORD PTR [rdx+80]
  007e3	44 8b c0	 mov	 r8d, eax
  007e6	48 8b d1	 mov	 rdx, rcx
  007e9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007f1	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  007f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 1779 :         if (s->matches < 2)

  007fb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00803	83 b8 08 17 00
	00 02		 cmp	 DWORD PTR [rax+5896], 2
  0080a	73 1e		 jae	 SHORT $LN23@deflate_st

; 1780 :             s->matches++;           /* add a pending slide_hash() */

  0080c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00814	8b 80 08 17 00
	00		 mov	 eax, DWORD PTR [rax+5896]
  0081a	ff c0		 inc	 eax
  0081c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00824	89 81 08 17 00
	00		 mov	 DWORD PTR [rcx+5896], eax
$LN23@deflate_st:

; 1781 :         have += s->w_size;          /* more space now */

  0082a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00832	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00835	8b 4c 24 2c	 mov	 ecx, DWORD PTR have$[rsp]
  00839	03 c8		 add	 ecx, eax
  0083b	8b c1		 mov	 eax, ecx
  0083d	89 44 24 2c	 mov	 DWORD PTR have$[rsp], eax
$LN22@deflate_st:

; 1782 :     }
; 1783 :     if (have > s->strm->avail_in)

  00841	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00849	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0084c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0084f	39 44 24 2c	 cmp	 DWORD PTR have$[rsp], eax
  00853	76 12		 jbe	 SHORT $LN24@deflate_st

; 1784 :         have = s->strm->avail_in;

  00855	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0085d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00860	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00863	89 44 24 2c	 mov	 DWORD PTR have$[rsp], eax
$LN24@deflate_st:

; 1785 :     if (have) {

  00867	83 7c 24 2c 00	 cmp	 DWORD PTR have$[rsp], 0
  0086c	74 52		 je	 SHORT $LN25@deflate_st

; 1786 :         read_buf(s->strm, s->window + s->strstart, have);

  0086e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00876	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0087c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00884	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00888	44 8b 44 24 2c	 mov	 r8d, DWORD PTR have$[rsp]
  0088d	48 8b d0	 mov	 rdx, rax
  00890	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00898	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0089b	e8 00 00 00 00	 call	 read_buf

; 1787 :         s->strstart += have;

  008a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008a8	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  008ae	03 44 24 2c	 add	 eax, DWORD PTR have$[rsp]
  008b2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008ba	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax
$LN25@deflate_st:

; 1788 :     }
; 1789 :     if (s->high_water < s->strstart)

  008c0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008c8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008d0	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  008d6	39 88 18 17 00
	00		 cmp	 DWORD PTR [rax+5912], ecx
  008dc	73 1c		 jae	 SHORT $LN26@deflate_st

; 1790 :         s->high_water = s->strstart;

  008de	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008e6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008ee	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  008f4	89 88 18 17 00
	00		 mov	 DWORD PTR [rax+5912], ecx
$LN26@deflate_st:

; 1791 : 
; 1792 :     /* There was not enough avail_out to write a complete worthy or flushed
; 1793 :      * stored block to next_out. Write a stored block to pending instead, if we
; 1794 :      * have enough input for a worthy block, or if flushing and there is enough
; 1795 :      * room for the remaining input as a stored block in the pending buffer.
; 1796 :      */
; 1797 :     have = (s->bi_valid + 42) >> 3;         /* number of header bytes */

  008fa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00902	8b 80 14 17 00
	00		 mov	 eax, DWORD PTR [rax+5908]
  00908	83 c0 2a	 add	 eax, 42			; 0000002aH
  0090b	c1 f8 03	 sar	 eax, 3
  0090e	89 44 24 2c	 mov	 DWORD PTR have$[rsp], eax

; 1798 :         /* maximum stored block length that will fit in pending: */
; 1799 :     have = MIN(s->pending_buf_size - have, MAX_STORED);

  00912	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0091a	8b 4c 24 2c	 mov	 ecx, DWORD PTR have$[rsp]
  0091e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00921	2b c1		 sub	 eax, ecx
  00923	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00928	76 0a		 jbe	 SHORT $LN37@deflate_st
  0092a	c7 44 24 54 ff
	ff 00 00	 mov	 DWORD PTR tv385[rsp], 65535 ; 0000ffffH
  00932	eb 15		 jmp	 SHORT $LN38@deflate_st
$LN37@deflate_st:
  00934	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0093c	8b 4c 24 2c	 mov	 ecx, DWORD PTR have$[rsp]
  00940	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00943	2b c1		 sub	 eax, ecx
  00945	89 44 24 54	 mov	 DWORD PTR tv385[rsp], eax
$LN38@deflate_st:
  00949	8b 44 24 54	 mov	 eax, DWORD PTR tv385[rsp]
  0094d	89 44 24 2c	 mov	 DWORD PTR have$[rsp], eax

; 1800 :     min_block = MIN(have, s->w_size);

  00951	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00959	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0095c	39 44 24 2c	 cmp	 DWORD PTR have$[rsp], eax
  00960	76 11		 jbe	 SHORT $LN39@deflate_st
  00962	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0096a	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0096d	89 44 24 58	 mov	 DWORD PTR tv389[rsp], eax
  00971	eb 08		 jmp	 SHORT $LN40@deflate_st
$LN39@deflate_st:
  00973	8b 44 24 2c	 mov	 eax, DWORD PTR have$[rsp]
  00977	89 44 24 58	 mov	 DWORD PTR tv389[rsp], eax
$LN40@deflate_st:
  0097b	8b 44 24 58	 mov	 eax, DWORD PTR tv389[rsp]
  0097f	89 44 24 20	 mov	 DWORD PTR min_block$[rsp], eax

; 1801 :     left = s->strstart - s->block_start;

  00983	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0098b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00993	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00999	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0099f	2b c1		 sub	 eax, ecx
  009a1	89 44 24 28	 mov	 DWORD PTR left$[rsp], eax

; 1802 :     if (left >= min_block ||

  009a5	8b 44 24 20	 mov	 eax, DWORD PTR min_block$[rsp]
  009a9	39 44 24 28	 cmp	 DWORD PTR left$[rsp], eax
  009ad	73 46		 jae	 SHORT $LN28@deflate_st
  009af	83 7c 24 28 00	 cmp	 DWORD PTR left$[rsp], 0
  009b4	75 0e		 jne	 SHORT $LN29@deflate_st
  009b6	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  009be	0f 85 f9 00 00
	00		 jne	 $LN27@deflate_st
$LN29@deflate_st:
  009c4	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  009cc	0f 84 eb 00 00
	00		 je	 $LN27@deflate_st
  009d2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009da	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009dd	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  009e1	0f 85 d6 00 00
	00		 jne	 $LN27@deflate_st
  009e7	8b 44 24 2c	 mov	 eax, DWORD PTR have$[rsp]
  009eb	39 44 24 28	 cmp	 DWORD PTR left$[rsp], eax
  009ef	0f 87 c8 00 00
	00		 ja	 $LN27@deflate_st
$LN28@deflate_st:

; 1803 :         ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
; 1804 :          s->strm->avail_in == 0 && left <= have)) {
; 1805 :         len = MIN(left, have);

  009f5	8b 44 24 2c	 mov	 eax, DWORD PTR have$[rsp]
  009f9	39 44 24 28	 cmp	 DWORD PTR left$[rsp], eax
  009fd	76 0a		 jbe	 SHORT $LN41@deflate_st
  009ff	8b 44 24 2c	 mov	 eax, DWORD PTR have$[rsp]
  00a03	89 44 24 5c	 mov	 DWORD PTR tv402[rsp], eax
  00a07	eb 08		 jmp	 SHORT $LN42@deflate_st
$LN41@deflate_st:
  00a09	8b 44 24 28	 mov	 eax, DWORD PTR left$[rsp]
  00a0d	89 44 24 5c	 mov	 DWORD PTR tv402[rsp], eax
$LN42@deflate_st:
  00a11	8b 44 24 5c	 mov	 eax, DWORD PTR tv402[rsp]
  00a15	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 1806 :         last = flush == Z_FINISH && s->strm->avail_in == 0 &&

  00a19	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00a21	75 25		 jne	 SHORT $LN43@deflate_st
  00a23	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a2b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a2e	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00a32	75 14		 jne	 SHORT $LN43@deflate_st
  00a34	8b 44 24 28	 mov	 eax, DWORD PTR left$[rsp]
  00a38	39 44 24 24	 cmp	 DWORD PTR len$[rsp], eax
  00a3c	75 0a		 jne	 SHORT $LN43@deflate_st
  00a3e	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv408[rsp], 1
  00a46	eb 08		 jmp	 SHORT $LN44@deflate_st
$LN43@deflate_st:
  00a48	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv408[rsp], 0
$LN44@deflate_st:
  00a50	8b 44 24 60	 mov	 eax, DWORD PTR tv408[rsp]
  00a54	89 44 24 30	 mov	 DWORD PTR last$[rsp], eax

; 1807 :                len == left ? 1 : 0;
; 1808 :         _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);

  00a58	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a60	48 63 80 84 00
	00 00		 movsxd	 rax, DWORD PTR [rax+132]
  00a67	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a6f	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00a73	44 8b 4c 24 30	 mov	 r9d, DWORD PTR last$[rsp]
  00a78	44 8b 44 24 24	 mov	 r8d, DWORD PTR len$[rsp]
  00a7d	48 8b d0	 mov	 rdx, rax
  00a80	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a88	e8 00 00 00 00	 call	 _tr_stored_block

; 1809 :         s->block_start += len;

  00a8d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a95	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00a9b	03 44 24 24	 add	 eax, DWORD PTR len$[rsp]
  00a9f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aa7	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 1810 :         flush_pending(s->strm);

  00aad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ab5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00ab8	e8 00 00 00 00	 call	 flush_pending
$LN27@deflate_st:

; 1811 :     }
; 1812 : 
; 1813 :     /* We've done all we can with the available input and output. */
; 1814 :     return last ? finish_started : need_more;

  00abd	83 7c 24 30 00	 cmp	 DWORD PTR last$[rsp], 0
  00ac2	74 0a		 je	 SHORT $LN45@deflate_st
  00ac4	c7 44 24 64 02
	00 00 00	 mov	 DWORD PTR tv423[rsp], 2
  00acc	eb 08		 jmp	 SHORT $LN46@deflate_st
$LN45@deflate_st:
  00ace	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv423[rsp], 0
$LN46@deflate_st:
  00ad6	8b 44 24 64	 mov	 eax, DWORD PTR tv423[rsp]
$LN1@deflate_st:

; 1815 : }

  00ada	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00ade	5f		 pop	 rdi
  00adf	c3		 ret	 0
deflate_stored ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_fast
_TEXT	SEGMENT
hash_head$ = 32
bflush$ = 36
len$1 = 40
dist$2 = 44
cc$3 = 48
tv523 = 56
tv227 = 64
tv247 = 68
tv603 = 72
tv307 = 80
tv646 = 88
tv377 = 96
tv399 = 104
tv413 = 112
tv427 = 120
tv451 = 128
s$ = 160
flush$ = 168
deflate_fast PROC					; COMDAT

; 1827 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+160]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@deflate_fa:

; 1828 :     IPos hash_head;       /* head of the hash chain */
; 1829 :     int bflush;           /* set if current block must be flushed */
; 1830 : 
; 1831 :     for (;;) {
; 1832 :         /* Make sure that we always have enough lookahead, except
; 1833 :          * at the end of the input file. We need MAX_MATCH bytes
; 1834 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1835 :          * string following the next match.
; 1836 :          */
; 1837 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00034	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0003c	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00046	73 48		 jae	 SHORT $LN8@deflate_fa

; 1838 :             fill_window(s);

  00048	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00050	e8 00 00 00 00	 call	 fill_window

; 1839 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00055	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005d	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00067	73 11		 jae	 SHORT $LN9@deflate_fa
  00069	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  00071	75 07		 jne	 SHORT $LN9@deflate_fa

; 1840 :                 return need_more;

  00073	33 c0		 xor	 eax, eax
  00075	e9 02 0a 00 00	 jmp	 $LN1@deflate_fa
$LN9@deflate_fa:

; 1841 :             }
; 1842 :             if (s->lookahead == 0) break; /* flush the current block */

  0007a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00082	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00089	75 05		 jne	 SHORT $LN10@deflate_fa
  0008b	e9 f9 07 00 00	 jmp	 $LN3@deflate_fa
$LN10@deflate_fa:
$LN8@deflate_fa:

; 1843 :         }
; 1844 : 
; 1845 :         /* Insert the string window[strstart .. strstart+2] in the
; 1846 :          * dictionary, and set hash_head to the head of the hash chain:
; 1847 :          */
; 1848 :         hash_head = NIL;

  00090	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0

; 1849 :         if (s->lookahead >= MIN_MATCH) {

  00098	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000a0	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  000a7	0f 82 09 01 00
	00		 jb	 $LN11@deflate_fa

; 1850 :             INSERT_STRING(s, s->strstart, hash_head);

  000ad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000bb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c3	48 89 4c 24 38	 mov	 QWORD PTR tv523[rsp], rcx
  000c8	0f b6 c8	 movzx	 ecx, al
  000cb	48 8b 44 24 38	 mov	 rax, QWORD PTR tv523[rsp]
  000d0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000d3	d3 e0		 shl	 eax, cl
  000d5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000dd	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  000e3	83 c1 02	 add	 ecx, 2
  000e6	8b c9		 mov	 ecx, ecx
  000e8	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  000f0	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  000f4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000f8	33 c1		 xor	 eax, ecx
  000fa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00102	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  00105	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0010d	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  00110	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00118	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0011b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00123	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00127	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0012f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  00137	45 8b 40 4c	 mov	 r8d, DWORD PTR [r8+76]
  0013b	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [rdx+148]
  00141	41 23 d0	 and	 edx, r8d
  00144	8b d2		 mov	 edx, edx
  00146	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  0014e	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  00152	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00156	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax
  0015b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00163	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0016b	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0016e	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00174	23 c1		 and	 eax, ecx
  00176	8b c0		 mov	 eax, eax
  00178	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00180	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00184	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00188	89 44 24 20	 mov	 DWORD PTR hash_head$[rsp], eax
  0018c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00194	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00197	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0019f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  001a3	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  001ab	0f b7 92 94 00
	00 00		 movzx	 edx, WORD PTR [rdx+148]
  001b2	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
$LN11@deflate_fa:

; 1851 :         }
; 1852 : 
; 1853 :         /* Find the longest match, discarding those <= prev_length.
; 1854 :          * At this point we have always match_length < MIN_MATCH
; 1855 :          */
; 1856 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  001b6	83 7c 24 20 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  001bb	74 4b		 je	 SHORT $LN12@deflate_fa
  001bd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001c5	8b 4c 24 20	 mov	 ecx, DWORD PTR hash_head$[rsp]
  001c9	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  001cf	2b c1		 sub	 eax, ecx
  001d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001d9	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  001dc	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  001e2	3b c1		 cmp	 eax, ecx
  001e4	77 22		 ja	 SHORT $LN12@deflate_fa

; 1857 :             /* To simplify the code, we prevent matches with the string
; 1858 :              * of window index 0 (in particular we have to avoid a match
; 1859 :              * of the string with itself at the start of the input file).
; 1860 :              */
; 1861 :             s->match_length = longest_match (s, hash_head);

  001e6	0f ae e8	 lfence
  001e9	8b 54 24 20	 mov	 edx, DWORD PTR hash_head$[rsp]
  001ed	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001f5	e8 00 00 00 00	 call	 longest_match
  001fa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00202	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN12@deflate_fa:

; 1862 :             /* longest_match() sets match_start */
; 1863 :         }
; 1864 :         if (s->match_length >= MIN_MATCH) {

  00208	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00210	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  00217	0f 82 76 04 00
	00		 jb	 $LN13@deflate_fa

; 1865 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1866 : 
; 1867 :             _tr_tally_dist(s, s->strstart - s->match_start,

  0021d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00225	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0022b	83 e8 03	 sub	 eax, 3
  0022e	88 44 24 28	 mov	 BYTE PTR len$1[rsp], al
  00232	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0023a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00242	8b 89 98 00 00
	00		 mov	 ecx, DWORD PTR [rcx+152]
  00248	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0024e	2b c1		 sub	 eax, ecx
  00250	66 89 44 24 2c	 mov	 WORD PTR dist$2[rsp], ax
  00255	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0025d	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00263	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0026b	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00272	0f b7 54 24 2c	 movzx	 edx, WORD PTR dist$2[rsp]
  00277	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  0027b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00283	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00289	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00291	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00298	0f b6 54 24 28	 movzx	 edx, BYTE PTR len$1[rsp]
  0029d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  002a0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002a8	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  002ae	ff c0		 inc	 eax
  002b0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002b8	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  002be	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$2[rsp]
  002c3	66 ff c8	 dec	 ax
  002c6	66 89 44 24 2c	 mov	 WORD PTR dist$2[rsp], ax
  002cb	0f b6 44 24 28	 movzx	 eax, BYTE PTR len$1[rsp]
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_length_code
  002d7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002db	05 01 01 00 00	 add	 eax, 257		; 00000101H
  002e0	48 98		 cdqe
  002e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002ea	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  002f2	66 ff c0	 inc	 ax
  002f5	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR len$1[rsp]
  002fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_length_code
  00301	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00305	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  0030b	48 63 c9	 movsxd	 rcx, ecx
  0030e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00316	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  0031e	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$2[rsp]
  00323	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00328	7d 19		 jge	 SHORT $LN24@deflate_fa
  0032a	0f ae e8	 lfence
  0032d	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$2[rsp]
  00332	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  00339	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0033d	89 44 24 40	 mov	 DWORD PTR tv227[rsp], eax
  00341	eb 21		 jmp	 SHORT $LN25@deflate_fa
$LN24@deflate_fa:
  00343	0f ae e8	 lfence
  00346	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$2[rsp]
  0034b	c1 f8 07	 sar	 eax, 7
  0034e	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00353	48 98		 cdqe
  00355	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  0035c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00360	89 44 24 40	 mov	 DWORD PTR tv227[rsp], eax
$LN25@deflate_fa:
  00364	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv227[rsp]
  00369	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00371	0f b7 84 81 b0
	09 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2480]
  00379	66 ff c0	 inc	 ax
  0037c	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR tv227[rsp]
  00381	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00389	66 89 84 8a b0
	09 00 00	 mov	 WORD PTR [rdx+rcx*4+2480], ax
  00391	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00399	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  0039f	ff c8		 dec	 eax
  003a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003a9	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  003af	75 0a		 jne	 SHORT $LN26@deflate_fa
  003b1	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv247[rsp], 1
  003b9	eb 08		 jmp	 SHORT $LN27@deflate_fa
$LN26@deflate_fa:
  003bb	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv247[rsp], 0
$LN27@deflate_fa:
  003c3	8b 44 24 44	 mov	 eax, DWORD PTR tv247[rsp]
  003c7	89 44 24 24	 mov	 DWORD PTR bflush$[rsp], eax

; 1868 :                            s->match_length - MIN_MATCH, bflush);
; 1869 : 
; 1870 :             s->lookahead -= s->match_length;

  003cb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003d3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003db	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  003e1	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  003e7	2b c1		 sub	 eax, ecx
  003e9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003f1	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1871 : 
; 1872 :             /* Insert new strings in the hash table only if the match length
; 1873 :              * is not too large. This saves time but degrades compression.
; 1874 :              */
; 1875 : #ifndef FASTEST
; 1876 :             if (s->match_length <= s->max_insert_length &&

  003f7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00407	8b 89 a8 00 00
	00		 mov	 ecx, DWORD PTR [rcx+168]
  0040d	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  00413	0f 87 ae 01 00
	00		 ja	 $LN15@deflate_fa
  00419	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00421	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  00428	0f 82 99 01 00
	00		 jb	 $LN15@deflate_fa

; 1877 :                 s->lookahead >= MIN_MATCH) {
; 1878 :                 s->match_length--; /* string at strstart already in table */

  0042e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00436	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0043c	ff c8		 dec	 eax
  0043e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00446	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN7@deflate_fa:

; 1879 :                 do {
; 1880 :                     s->strstart++;

  0044c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00454	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0045a	ff c0		 inc	 eax
  0045c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00464	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1881 :                     INSERT_STRING(s, s->strstart, hash_head);

  0046a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00472	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00478	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00480	48 89 4c 24 48	 mov	 QWORD PTR tv603[rsp], rcx
  00485	0f b6 c8	 movzx	 ecx, al
  00488	48 8b 44 24 48	 mov	 rax, QWORD PTR tv603[rsp]
  0048d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00490	d3 e0		 shl	 eax, cl
  00492	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0049a	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  004a0	83 c1 02	 add	 ecx, 2
  004a3	8b c9		 mov	 ecx, ecx
  004a5	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  004ad	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  004b1	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  004b5	33 c1		 xor	 eax, ecx
  004b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004bf	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  004c2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004ca	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  004cd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004d5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004d8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004e0	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  004e4	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  004ec	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  004f4	45 8b 40 4c	 mov	 r8d, DWORD PTR [r8+76]
  004f8	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [rdx+148]
  004fe	41 23 d0	 and	 edx, r8d
  00501	8b d2		 mov	 edx, edx
  00503	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  0050b	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  0050f	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00513	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax
  00518	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00520	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00528	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0052b	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00531	23 c1		 and	 eax, ecx
  00533	8b c0		 mov	 eax, eax
  00535	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0053d	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00541	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00545	89 44 24 20	 mov	 DWORD PTR hash_head$[rsp], eax
  00549	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00551	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00554	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0055c	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00560	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00568	0f b7 92 94 00
	00 00		 movzx	 edx, WORD PTR [rdx+148]
  0056f	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 1882 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1883 :                      * always MIN_MATCH bytes ahead.
; 1884 :                      */
; 1885 :                 } while (--s->match_length != 0);

  00573	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0057b	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00581	ff c8		 dec	 eax
  00583	89 44 24 50	 mov	 DWORD PTR tv307[rsp], eax
  00587	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0058f	8b 4c 24 50	 mov	 ecx, DWORD PTR tv307[rsp]
  00593	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx
  00599	83 7c 24 50 00	 cmp	 DWORD PTR tv307[rsp], 0
  0059e	0f 85 a8 fe ff
	ff		 jne	 $LN7@deflate_fa

; 1886 :                 s->strstart++;

  005a4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005ac	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  005b2	ff c0		 inc	 eax
  005b4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005bc	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1887 :             } else

  005c2	e9 c7 00 00 00	 jmp	 $LN16@deflate_fa
$LN15@deflate_fa:

; 1888 : #endif
; 1889 :             {
; 1890 :                 s->strstart += s->match_length;

  005c7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005cf	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  005d5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005dd	03 81 88 00 00
	00		 add	 eax, DWORD PTR [rcx+136]
  005e3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005eb	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1891 :                 s->match_length = 0;

  005f1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005f9	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 1892 :                 s->ins_h = s->window[s->strstart];

  00603	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0060b	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00611	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00619	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0061d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00621	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00629	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 1893 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  0062c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00634	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0063a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00642	48 89 4c 24 58	 mov	 QWORD PTR tv646[rsp], rcx
  00647	0f b6 c8	 movzx	 ecx, al
  0064a	48 8b 44 24 58	 mov	 rax, QWORD PTR tv646[rsp]
  0064f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00652	d3 e0		 shl	 eax, cl
  00654	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0065c	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00662	ff c1		 inc	 ecx
  00664	8b c9		 mov	 ecx, ecx
  00666	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0066e	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00672	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00676	33 c1		 xor	 eax, ecx
  00678	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00680	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  00683	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0068b	89 41 70	 mov	 DWORD PTR [rcx+112], eax
$LN16@deflate_fa:

; 1894 : #if MIN_MATCH != 3
; 1895 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1896 : #endif
; 1897 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1898 :                  * matter since it will be recomputed at next deflate call.
; 1899 :                  */
; 1900 :             }
; 1901 :         } else {

  0068e	e9 2b 01 00 00	 jmp	 $LN14@deflate_fa
$LN13@deflate_fa:

; 1902 :             /* No match, output a literal byte */
; 1903 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1904 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  00693	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0069b	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  006a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006a9	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  006ad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006b1	88 44 24 30	 mov	 BYTE PTR cc$3[rsp], al
  006b5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006bd	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  006c3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006cb	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  006d2	33 d2		 xor	 edx, edx
  006d4	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  006d8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006e0	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  006e6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006ee	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  006f5	0f b6 54 24 30	 movzx	 edx, BYTE PTR cc$3[rsp]
  006fa	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  006fd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00705	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  0070b	ff c0		 inc	 eax
  0070d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00715	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  0071b	0f b6 44 24 30	 movzx	 eax, BYTE PTR cc$3[rsp]
  00720	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00728	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  00730	66 ff c0	 inc	 ax
  00733	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR cc$3[rsp]
  00738	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00740	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  00748	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00750	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00756	ff c8		 dec	 eax
  00758	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00760	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00766	75 0a		 jne	 SHORT $LN28@deflate_fa
  00768	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv377[rsp], 1
  00770	eb 08		 jmp	 SHORT $LN29@deflate_fa
$LN28@deflate_fa:
  00772	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv377[rsp], 0
$LN29@deflate_fa:
  0077a	8b 44 24 60	 mov	 eax, DWORD PTR tv377[rsp]
  0077e	89 44 24 24	 mov	 DWORD PTR bflush$[rsp], eax

; 1905 :             s->lookahead--;

  00782	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0078a	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00790	ff c8		 dec	 eax
  00792	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0079a	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1906 :             s->strstart++;

  007a0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007a8	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  007ae	ff c0		 inc	 eax
  007b0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007b8	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax
$LN14@deflate_fa:

; 1907 :         }
; 1908 :         if (bflush) FLUSH_BLOCK(s, 0);

  007be	83 7c 24 24 00	 cmp	 DWORD PTR bflush$[rsp], 0
  007c3	0f 84 bb 00 00
	00		 je	 $LN17@deflate_fa
  007c9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007d1	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  007d8	7c 27		 jl	 SHORT $LN30@deflate_fa
  007da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007e2	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  007e8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007f0	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  007f4	48 03 c8	 add	 rcx, rax
  007f7	48 8b c1	 mov	 rax, rcx
  007fa	48 89 44 24 68	 mov	 QWORD PTR tv399[rsp], rax
  007ff	eb 09		 jmp	 SHORT $LN31@deflate_fa
$LN30@deflate_fa:
  00801	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv399[rsp], 0
$LN31@deflate_fa:
  0080a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00812	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0081a	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00820	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00826	2b c1		 sub	 eax, ecx
  00828	45 33 c9	 xor	 r9d, r9d
  0082b	44 8b c0	 mov	 r8d, eax
  0082e	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv399[rsp]
  00833	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0083b	e8 00 00 00 00	 call	 _tr_flush_block
  00840	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00848	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00850	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00856	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  0085c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00864	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00867	e8 00 00 00 00	 call	 flush_pending
  0086c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00874	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00877	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0087b	75 07		 jne	 SHORT $LN18@deflate_fa
  0087d	33 c0		 xor	 eax, eax
  0087f	e9 f8 01 00 00	 jmp	 $LN1@deflate_fa
$LN18@deflate_fa:
$LN17@deflate_fa:

; 1909 :     }

  00884	e9 ab f7 ff ff	 jmp	 $LN2@deflate_fa
$LN3@deflate_fa:

; 1910 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  00889	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00891	83 b8 94 00 00
	00 02		 cmp	 DWORD PTR [rax+148], 2
  00898	73 14		 jae	 SHORT $LN32@deflate_fa
  0089a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008a2	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  008a8	89 44 24 70	 mov	 DWORD PTR tv413[rsp], eax
  008ac	eb 08		 jmp	 SHORT $LN33@deflate_fa
$LN32@deflate_fa:
  008ae	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv413[rsp], 2
$LN33@deflate_fa:
  008b6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008be	8b 4c 24 70	 mov	 ecx, DWORD PTR tv413[rsp]
  008c2	89 88 0c 17 00
	00		 mov	 DWORD PTR [rax+5900], ecx

; 1911 :     if (flush == Z_FINISH) {

  008c8	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  008d0	0f 85 cb 00 00
	00		 jne	 $LN19@deflate_fa

; 1912 :         FLUSH_BLOCK(s, 1);

  008d6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008de	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  008e5	7c 27		 jl	 SHORT $LN34@deflate_fa
  008e7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008ef	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  008f5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008fd	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00901	48 03 c8	 add	 rcx, rax
  00904	48 8b c1	 mov	 rax, rcx
  00907	48 89 44 24 78	 mov	 QWORD PTR tv427[rsp], rax
  0090c	eb 09		 jmp	 SHORT $LN35@deflate_fa
$LN34@deflate_fa:
  0090e	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv427[rsp], 0
$LN35@deflate_fa:
  00917	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0091f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00927	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  0092d	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00933	2b c1		 sub	 eax, ecx
  00935	41 b9 01 00 00
	00		 mov	 r9d, 1
  0093b	44 8b c0	 mov	 r8d, eax
  0093e	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv427[rsp]
  00943	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0094b	e8 00 00 00 00	 call	 _tr_flush_block
  00950	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00958	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00960	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00966	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  0096c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00974	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00977	e8 00 00 00 00	 call	 flush_pending
  0097c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00984	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00987	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0098b	75 0a		 jne	 SHORT $LN20@deflate_fa
  0098d	b8 02 00 00 00	 mov	 eax, 2
  00992	e9 e5 00 00 00	 jmp	 $LN1@deflate_fa
$LN20@deflate_fa:

; 1913 :         return finish_done;

  00997	b8 03 00 00 00	 mov	 eax, 3
  0099c	e9 db 00 00 00	 jmp	 $LN1@deflate_fa
$LN19@deflate_fa:

; 1914 :     }
; 1915 :     if (s->last_lit)

  009a1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009a9	83 b8 f4 16 00
	00 00		 cmp	 DWORD PTR [rax+5876], 0
  009b0	0f 84 c1 00 00
	00		 je	 $LN21@deflate_fa

; 1916 :         FLUSH_BLOCK(s, 0);

  009b6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009be	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  009c5	7c 2a		 jl	 SHORT $LN36@deflate_fa
  009c7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009cf	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  009d5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009dd	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  009e1	48 03 c8	 add	 rcx, rax
  009e4	48 8b c1	 mov	 rax, rcx
  009e7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv451[rsp], rax
  009ef	eb 0c		 jmp	 SHORT $LN37@deflate_fa
$LN36@deflate_fa:
  009f1	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv451[rsp], 0
$LN37@deflate_fa:
  009fd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a05	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a0d	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00a13	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00a19	2b c1		 sub	 eax, ecx
  00a1b	45 33 c9	 xor	 r9d, r9d
  00a1e	44 8b c0	 mov	 r8d, eax
  00a21	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv451[rsp]
  00a29	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a31	e8 00 00 00 00	 call	 _tr_flush_block
  00a36	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a3e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a46	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00a4c	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00a52	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a5a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00a5d	e8 00 00 00 00	 call	 flush_pending
  00a62	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a6a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a6d	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00a71	75 04		 jne	 SHORT $LN22@deflate_fa
  00a73	33 c0		 xor	 eax, eax
  00a75	eb 05		 jmp	 SHORT $LN1@deflate_fa
$LN22@deflate_fa:
$LN21@deflate_fa:

; 1917 :     return block_done;

  00a77	b8 01 00 00 00	 mov	 eax, 1
$LN1@deflate_fa:

; 1918 : }

  00a7c	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00a83	5f		 pop	 rdi
  00a84	c3		 ret	 0
deflate_fast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_slow
_TEXT	SEGMENT
hash_head$ = 32
bflush$ = 36
max_insert$1 = 40
len$2 = 44
dist$3 = 48
cc$4 = 52
cc$5 = 53
tv608 = 56
tv254 = 64
tv274 = 68
tv285 = 72
tv709 = 80
tv329 = 88
tv350 = 96
tv401 = 104
tv415 = 112
tv483 = 120
tv489 = 124
tv503 = 128
tv527 = 136
s$ = 160
flush$ = 168
deflate_slow PROC					; COMDAT

; 1929 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+160]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@deflate_sl:

; 1930 :     IPos hash_head;          /* head of hash chain */
; 1931 :     int bflush;              /* set if current block must be flushed */
; 1932 : 
; 1933 :     /* Process the input block. */
; 1934 :     for (;;) {
; 1935 :         /* Make sure that we always have enough lookahead, except
; 1936 :          * at the end of the input file. We need MAX_MATCH bytes
; 1937 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1938 :          * string following the next match.
; 1939 :          */
; 1940 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00034	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0003c	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00046	73 48		 jae	 SHORT $LN8@deflate_sl

; 1941 :             fill_window(s);

  00048	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00050	e8 00 00 00 00	 call	 fill_window

; 1942 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00055	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005d	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00067	73 11		 jae	 SHORT $LN9@deflate_sl
  00069	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  00071	75 07		 jne	 SHORT $LN9@deflate_sl

; 1943 :                 return need_more;

  00073	33 c0		 xor	 eax, eax
  00075	e9 b4 0c 00 00	 jmp	 $LN1@deflate_sl
$LN9@deflate_sl:

; 1944 :             }
; 1945 :             if (s->lookahead == 0) break; /* flush the current block */

  0007a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00082	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00089	75 05		 jne	 SHORT $LN10@deflate_sl
  0008b	e9 88 09 00 00	 jmp	 $LN3@deflate_sl
$LN10@deflate_sl:
$LN8@deflate_sl:

; 1946 :         }
; 1947 : 
; 1948 :         /* Insert the string window[strstart .. strstart+2] in the
; 1949 :          * dictionary, and set hash_head to the head of the hash chain:
; 1950 :          */
; 1951 :         hash_head = NIL;

  00090	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0

; 1952 :         if (s->lookahead >= MIN_MATCH) {

  00098	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000a0	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  000a7	0f 82 09 01 00
	00		 jb	 $LN11@deflate_sl

; 1953 :             INSERT_STRING(s, s->strstart, hash_head);

  000ad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000bb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c3	48 89 4c 24 38	 mov	 QWORD PTR tv608[rsp], rcx
  000c8	0f b6 c8	 movzx	 ecx, al
  000cb	48 8b 44 24 38	 mov	 rax, QWORD PTR tv608[rsp]
  000d0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000d3	d3 e0		 shl	 eax, cl
  000d5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000dd	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  000e3	83 c1 02	 add	 ecx, 2
  000e6	8b c9		 mov	 ecx, ecx
  000e8	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  000f0	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  000f4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000f8	33 c1		 xor	 eax, ecx
  000fa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00102	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  00105	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0010d	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  00110	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00118	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0011b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00123	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00127	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0012f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  00137	45 8b 40 4c	 mov	 r8d, DWORD PTR [r8+76]
  0013b	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [rdx+148]
  00141	41 23 d0	 and	 edx, r8d
  00144	8b d2		 mov	 edx, edx
  00146	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  0014e	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  00152	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00156	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax
  0015b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00163	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0016b	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0016e	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00174	23 c1		 and	 eax, ecx
  00176	8b c0		 mov	 eax, eax
  00178	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00180	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00184	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00188	89 44 24 20	 mov	 DWORD PTR hash_head$[rsp], eax
  0018c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00194	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00197	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0019f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  001a3	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  001ab	0f b7 92 94 00
	00 00		 movzx	 edx, WORD PTR [rdx+148]
  001b2	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
$LN11@deflate_sl:

; 1954 :         }
; 1955 : 
; 1956 :         /* Find the longest match, discarding those <= prev_length.
; 1957 :          */
; 1958 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  001b6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001be	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001c6	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  001cc	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx
  001d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001da	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001e2	8b 89 98 00 00
	00		 mov	 ecx, DWORD PTR [rcx+152]
  001e8	89 88 8c 00 00
	00		 mov	 DWORD PTR [rax+140], ecx

; 1959 :         s->match_length = MIN_MATCH-1;

  001ee	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001f6	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1960 : 
; 1961 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&

  00200	83 7c 24 20 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  00205	0f 84 db 00 00
	00		 je	 $LN12@deflate_sl
  0020b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00213	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0021b	8b 89 a8 00 00
	00		 mov	 ecx, DWORD PTR [rcx+168]
  00221	39 88 a0 00 00
	00		 cmp	 DWORD PTR [rax+160], ecx
  00227	0f 83 b9 00 00
	00		 jae	 $LN12@deflate_sl
  0022d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00235	8b 4c 24 20	 mov	 ecx, DWORD PTR hash_head$[rsp]
  00239	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0023f	2b c1		 sub	 eax, ecx
  00241	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00249	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  0024c	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  00252	3b c1		 cmp	 eax, ecx
  00254	0f 87 8c 00 00
	00		 ja	 $LN12@deflate_sl

; 1962 :             s->strstart - hash_head <= MAX_DIST(s)) {
; 1963 :             /* To simplify the code, we prevent matches with the string
; 1964 :              * of window index 0 (in particular we have to avoid a match
; 1965 :              * of the string with itself at the start of the input file).
; 1966 :              */
; 1967 :             s->match_length = longest_match (s, hash_head);

  0025a	0f ae e8	 lfence
  0025d	8b 54 24 20	 mov	 edx, DWORD PTR hash_head$[rsp]
  00261	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00269	e8 00 00 00 00	 call	 longest_match
  0026e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00276	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 1968 :             /* longest_match() sets match_start */
; 1969 : 
; 1970 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED

  0027c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00284	83 b8 88 00 00
	00 05		 cmp	 DWORD PTR [rax+136], 5
  0028b	77 59		 ja	 SHORT $LN13@deflate_sl
  0028d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00295	83 b8 b0 00 00
	00 01		 cmp	 DWORD PTR [rax+176], 1
  0029c	74 36		 je	 SHORT $LN14@deflate_sl
  0029e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002a6	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  002ad	75 37		 jne	 SHORT $LN13@deflate_sl
  002af	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002bf	8b 89 98 00 00
	00		 mov	 ecx, DWORD PTR [rcx+152]
  002c5	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  002cb	2b c1		 sub	 eax, ecx
  002cd	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002d2	76 12		 jbe	 SHORT $LN13@deflate_sl
$LN14@deflate_sl:

; 1971 : #if TOO_FAR <= 32767
; 1972 :                 || (s->match_length == MIN_MATCH &&
; 1973 :                     s->strstart - s->match_start > TOO_FAR)
; 1974 : #endif
; 1975 :                 )) {
; 1976 : 
; 1977 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1978 :                  * but we will ignore the current match anyway.
; 1979 :                  */
; 1980 :                 s->match_length = MIN_MATCH-1;

  002d4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002dc	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2
$LN13@deflate_sl:
$LN12@deflate_sl:

; 1981 :             }
; 1982 :         }
; 1983 :         /* If there was a match at the previous step and the current
; 1984 :          * match is not better, output the previous match:
; 1985 :          */
; 1986 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  002e6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002ee	83 b8 a0 00 00
	00 03		 cmp	 DWORD PTR [rax+160], 3
  002f5	0f 82 be 04 00
	00		 jb	 $LN15@deflate_sl
  002fb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00303	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0030b	8b 89 a0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+160]
  00311	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  00317	0f 87 9c 04 00
	00		 ja	 $LN15@deflate_sl

; 1987 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  0031d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00325	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0032b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00333	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  00339	8d 44 08 fd	 lea	 eax, DWORD PTR [rax+rcx-3]
  0033d	89 44 24 28	 mov	 DWORD PTR max_insert$1[rsp], eax

; 1988 :             /* Do not insert strings in hash table beyond this. */
; 1989 : 
; 1990 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1991 : 
; 1992 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,

  00341	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00349	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  0034f	83 e8 03	 sub	 eax, 3
  00352	88 44 24 2c	 mov	 BYTE PTR len$2[rsp], al
  00356	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0035e	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00364	ff c8		 dec	 eax
  00366	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0036e	2b 81 8c 00 00
	00		 sub	 eax, DWORD PTR [rcx+140]
  00374	66 89 44 24 30	 mov	 WORD PTR dist$3[rsp], ax
  00379	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00381	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00387	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0038f	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00396	0f b7 54 24 30	 movzx	 edx, WORD PTR dist$3[rsp]
  0039b	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  0039f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003a7	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  003ad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003b5	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  003bc	0f b6 54 24 2c	 movzx	 edx, BYTE PTR len$2[rsp]
  003c1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  003c4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003cc	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  003d2	ff c0		 inc	 eax
  003d4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003dc	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  003e2	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$3[rsp]
  003e7	66 ff c8	 dec	 ax
  003ea	66 89 44 24 30	 mov	 WORD PTR dist$3[rsp], ax
  003ef	0f b6 44 24 2c	 movzx	 eax, BYTE PTR len$2[rsp]
  003f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_length_code
  003fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ff	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00404	48 98		 cdqe
  00406	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0040e	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  00416	66 ff c0	 inc	 ax
  00419	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR len$2[rsp]
  0041e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_length_code
  00425	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00429	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  0042f	48 63 c9	 movsxd	 rcx, ecx
  00432	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0043a	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  00442	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$3[rsp]
  00447	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0044c	7d 19		 jge	 SHORT $LN30@deflate_sl
  0044e	0f ae e8	 lfence
  00451	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$3[rsp]
  00456	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  0045d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00461	89 44 24 40	 mov	 DWORD PTR tv254[rsp], eax
  00465	eb 21		 jmp	 SHORT $LN31@deflate_sl
$LN30@deflate_sl:
  00467	0f ae e8	 lfence
  0046a	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$3[rsp]
  0046f	c1 f8 07	 sar	 eax, 7
  00472	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00477	48 98		 cdqe
  00479	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  00480	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00484	89 44 24 40	 mov	 DWORD PTR tv254[rsp], eax
$LN31@deflate_sl:
  00488	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv254[rsp]
  0048d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00495	0f b7 84 81 b0
	09 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2480]
  0049d	66 ff c0	 inc	 ax
  004a0	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR tv254[rsp]
  004a5	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  004ad	66 89 84 8a b0
	09 00 00	 mov	 WORD PTR [rdx+rcx*4+2480], ax
  004b5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004bd	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  004c3	ff c8		 dec	 eax
  004c5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004cd	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  004d3	75 0a		 jne	 SHORT $LN32@deflate_sl
  004d5	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv274[rsp], 1
  004dd	eb 08		 jmp	 SHORT $LN33@deflate_sl
$LN32@deflate_sl:
  004df	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv274[rsp], 0
$LN33@deflate_sl:
  004e7	8b 44 24 44	 mov	 eax, DWORD PTR tv274[rsp]
  004eb	89 44 24 24	 mov	 DWORD PTR bflush$[rsp], eax

; 1993 :                            s->prev_length - MIN_MATCH, bflush);
; 1994 : 
; 1995 :             /* Insert in hash table all strings up to the end of the match.
; 1996 :              * strstart-1 and strstart are already inserted. If there is not
; 1997 :              * enough lookahead, the last two strings are not inserted in
; 1998 :              * the hash table.
; 1999 :              */
; 2000 :             s->lookahead -= s->prev_length-1;

  004ef	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004f7	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  004fd	ff c8		 dec	 eax
  004ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00507	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  0050d	2b c8		 sub	 ecx, eax
  0050f	8b c1		 mov	 eax, ecx
  00511	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00519	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 2001 :             s->prev_length -= 2;

  0051f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00527	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  0052d	83 e8 02	 sub	 eax, 2
  00530	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00538	89 81 a0 00 00
	00		 mov	 DWORD PTR [rcx+160], eax
$LN7@deflate_sl:

; 2002 :             do {
; 2003 :                 if (++s->strstart <= max_insert) {

  0053e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00546	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0054c	ff c0		 inc	 eax
  0054e	89 44 24 48	 mov	 DWORD PTR tv285[rsp], eax
  00552	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0055a	8b 4c 24 48	 mov	 ecx, DWORD PTR tv285[rsp]
  0055e	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx
  00564	8b 44 24 28	 mov	 eax, DWORD PTR max_insert$1[rsp]
  00568	39 44 24 48	 cmp	 DWORD PTR tv285[rsp], eax
  0056c	0f 87 09 01 00
	00		 ja	 $LN17@deflate_sl

; 2004 :                     INSERT_STRING(s, s->strstart, hash_head);

  00572	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0057a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00580	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00588	48 89 4c 24 50	 mov	 QWORD PTR tv709[rsp], rcx
  0058d	0f b6 c8	 movzx	 ecx, al
  00590	48 8b 44 24 50	 mov	 rax, QWORD PTR tv709[rsp]
  00595	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00598	d3 e0		 shl	 eax, cl
  0059a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005a2	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  005a8	83 c1 02	 add	 ecx, 2
  005ab	8b c9		 mov	 ecx, ecx
  005ad	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  005b5	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  005b9	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  005bd	33 c1		 xor	 eax, ecx
  005bf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005c7	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  005ca	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005d2	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  005d5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005dd	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  005e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005e8	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  005ec	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  005f4	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  005fc	45 8b 40 4c	 mov	 r8d, DWORD PTR [r8+76]
  00600	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [rdx+148]
  00606	41 23 d0	 and	 edx, r8d
  00609	8b d2		 mov	 edx, edx
  0060b	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  00613	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  00617	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0061b	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax
  00620	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00628	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00630	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00633	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00639	23 c1		 and	 eax, ecx
  0063b	8b c0		 mov	 eax, eax
  0063d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00645	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00649	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0064d	89 44 24 20	 mov	 DWORD PTR hash_head$[rsp], eax
  00651	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00659	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0065c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00664	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00668	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00670	0f b7 92 94 00
	00 00		 movzx	 edx, WORD PTR [rdx+148]
  00677	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
$LN17@deflate_sl:

; 2005 :                 }
; 2006 :             } while (--s->prev_length != 0);

  0067b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00683	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  00689	ff c8		 dec	 eax
  0068b	89 44 24 58	 mov	 DWORD PTR tv329[rsp], eax
  0068f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00697	8b 4c 24 58	 mov	 ecx, DWORD PTR tv329[rsp]
  0069b	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx
  006a1	83 7c 24 58 00	 cmp	 DWORD PTR tv329[rsp], 0
  006a6	0f 85 92 fe ff
	ff		 jne	 $LN7@deflate_sl

; 2007 :             s->match_available = 0;

  006ac	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006b4	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 2008 :             s->match_length = MIN_MATCH-1;

  006be	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006c6	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 2009 :             s->strstart++;

  006d0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006d8	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  006de	ff c0		 inc	 eax
  006e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006e8	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 2010 : 
; 2011 :             if (bflush) FLUSH_BLOCK(s, 0);

  006ee	83 7c 24 24 00	 cmp	 DWORD PTR bflush$[rsp], 0
  006f3	0f 84 bb 00 00
	00		 je	 $LN18@deflate_sl
  006f9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00701	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00708	7c 27		 jl	 SHORT $LN34@deflate_sl
  0070a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00712	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00718	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00720	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00724	48 03 c8	 add	 rcx, rax
  00727	48 8b c1	 mov	 rax, rcx
  0072a	48 89 44 24 60	 mov	 QWORD PTR tv350[rsp], rax
  0072f	eb 09		 jmp	 SHORT $LN35@deflate_sl
$LN34@deflate_sl:
  00731	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv350[rsp], 0
$LN35@deflate_sl:
  0073a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00742	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0074a	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00750	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00756	2b c1		 sub	 eax, ecx
  00758	45 33 c9	 xor	 r9d, r9d
  0075b	44 8b c0	 mov	 r8d, eax
  0075e	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv350[rsp]
  00763	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0076b	e8 00 00 00 00	 call	 _tr_flush_block
  00770	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00778	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00780	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00786	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  0078c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00794	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00797	e8 00 00 00 00	 call	 flush_pending
  0079c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007a7	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  007ab	75 07		 jne	 SHORT $LN19@deflate_sl
  007ad	33 c0		 xor	 eax, eax
  007af	e9 7a 05 00 00	 jmp	 $LN1@deflate_sl
$LN19@deflate_sl:
$LN18@deflate_sl:
  007b4	e9 5a 02 00 00	 jmp	 $LN16@deflate_sl
$LN15@deflate_sl:

; 2012 : 
; 2013 :         } else if (s->match_available) {

  007b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007c1	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  007c8	0f 84 f7 01 00
	00		 je	 $LN20@deflate_sl

; 2014 :             /* If there was no match at the previous position, output a
; 2015 :              * single literal. If there was a match but the current match
; 2016 :              * is longer, truncate the previous match to a single literal.
; 2017 :              */
; 2018 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 2019 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  007ce	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007d6	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  007dc	ff c8		 dec	 eax
  007de	8b c0		 mov	 eax, eax
  007e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007e8	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  007ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007f0	88 44 24 34	 mov	 BYTE PTR cc$4[rsp], al
  007f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007fc	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00802	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0080a	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00811	33 d2		 xor	 edx, edx
  00813	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  00817	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0081f	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00825	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0082d	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00834	0f b6 54 24 34	 movzx	 edx, BYTE PTR cc$4[rsp]
  00839	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0083c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00844	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  0084a	ff c0		 inc	 eax
  0084c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00854	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  0085a	0f b6 44 24 34	 movzx	 eax, BYTE PTR cc$4[rsp]
  0085f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00867	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  0086f	66 ff c0	 inc	 ax
  00872	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR cc$4[rsp]
  00877	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0087f	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  00887	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0088f	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00895	ff c8		 dec	 eax
  00897	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0089f	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  008a5	75 0a		 jne	 SHORT $LN36@deflate_sl
  008a7	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv401[rsp], 1
  008af	eb 08		 jmp	 SHORT $LN37@deflate_sl
$LN36@deflate_sl:
  008b1	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv401[rsp], 0
$LN37@deflate_sl:
  008b9	8b 44 24 68	 mov	 eax, DWORD PTR tv401[rsp]
  008bd	89 44 24 24	 mov	 DWORD PTR bflush$[rsp], eax

; 2020 :             if (bflush) {

  008c1	83 7c 24 24 00	 cmp	 DWORD PTR bflush$[rsp], 0
  008c6	0f 84 a3 00 00
	00		 je	 $LN22@deflate_sl

; 2021 :                 FLUSH_BLOCK_ONLY(s, 0);

  008cc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008d4	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  008db	7c 27		 jl	 SHORT $LN38@deflate_sl
  008dd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008e5	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  008eb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008f3	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  008f7	48 03 c8	 add	 rcx, rax
  008fa	48 8b c1	 mov	 rax, rcx
  008fd	48 89 44 24 70	 mov	 QWORD PTR tv415[rsp], rax
  00902	eb 09		 jmp	 SHORT $LN39@deflate_sl
$LN38@deflate_sl:
  00904	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv415[rsp], 0
$LN39@deflate_sl:
  0090d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00915	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0091d	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00923	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00929	2b c1		 sub	 eax, ecx
  0092b	45 33 c9	 xor	 r9d, r9d
  0092e	44 8b c0	 mov	 r8d, eax
  00931	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv415[rsp]
  00936	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0093e	e8 00 00 00 00	 call	 _tr_flush_block
  00943	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0094b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00953	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00959	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  0095f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00967	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0096a	e8 00 00 00 00	 call	 flush_pending
$LN22@deflate_sl:

; 2022 :             }
; 2023 :             s->strstart++;

  0096f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00977	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0097d	ff c0		 inc	 eax
  0097f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00987	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 2024 :             s->lookahead--;

  0098d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00995	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0099b	ff c8		 dec	 eax
  0099d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009a5	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 2025 :             if (s->strm->avail_out == 0) return need_more;

  009ab	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009b6	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  009ba	75 07		 jne	 SHORT $LN23@deflate_sl
  009bc	33 c0		 xor	 eax, eax
  009be	e9 6b 03 00 00	 jmp	 $LN1@deflate_sl
$LN23@deflate_sl:

; 2026 :         } else {

  009c3	eb 4e		 jmp	 SHORT $LN21@deflate_sl
$LN20@deflate_sl:

; 2027 :             /* There is no previous match to compare with, wait for
; 2028 :              * the next step to decide.
; 2029 :              */
; 2030 :             s->match_available = 1;

  009c5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009cd	c7 80 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+144], 1

; 2031 :             s->strstart++;

  009d7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009df	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  009e5	ff c0		 inc	 eax
  009e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009ef	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 2032 :             s->lookahead--;

  009f5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009fd	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00a03	ff c8		 dec	 eax
  00a05	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a0d	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax
$LN21@deflate_sl:
$LN16@deflate_sl:

; 2033 :         }
; 2034 :     }

  00a13	e9 1c f6 ff ff	 jmp	 $LN2@deflate_sl
$LN3@deflate_sl:

; 2035 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 2036 :     if (s->match_available) {

  00a18	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a20	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  00a27	0f 84 05 01 00
	00		 je	 $LN24@deflate_sl

; 2037 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 2038 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00a2d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a35	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00a3b	ff c8		 dec	 eax
  00a3d	8b c0		 mov	 eax, eax
  00a3f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a47	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00a4b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a4f	88 44 24 35	 mov	 BYTE PTR cc$5[rsp], al
  00a53	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a5b	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00a61	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a69	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00a70	33 d2		 xor	 edx, edx
  00a72	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  00a76	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a7e	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00a84	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a8c	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00a93	0f b6 54 24 35	 movzx	 edx, BYTE PTR cc$5[rsp]
  00a98	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00a9b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aa3	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00aa9	ff c0		 inc	 eax
  00aab	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ab3	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  00ab9	0f b6 44 24 35	 movzx	 eax, BYTE PTR cc$5[rsp]
  00abe	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ac6	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  00ace	66 ff c0	 inc	 ax
  00ad1	0f b6 4c 24 35	 movzx	 ecx, BYTE PTR cc$5[rsp]
  00ad6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00ade	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  00ae6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aee	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00af4	ff c8		 dec	 eax
  00af6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00afe	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00b04	75 0a		 jne	 SHORT $LN40@deflate_sl
  00b06	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv483[rsp], 1
  00b0e	eb 08		 jmp	 SHORT $LN41@deflate_sl
$LN40@deflate_sl:
  00b10	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv483[rsp], 0
$LN41@deflate_sl:
  00b18	8b 44 24 78	 mov	 eax, DWORD PTR tv483[rsp]
  00b1c	89 44 24 24	 mov	 DWORD PTR bflush$[rsp], eax

; 2039 :         s->match_available = 0;

  00b20	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b28	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0
$LN24@deflate_sl:

; 2040 :     }
; 2041 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  00b32	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b3a	83 b8 94 00 00
	00 02		 cmp	 DWORD PTR [rax+148], 2
  00b41	73 14		 jae	 SHORT $LN42@deflate_sl
  00b43	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b4b	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00b51	89 44 24 7c	 mov	 DWORD PTR tv489[rsp], eax
  00b55	eb 08		 jmp	 SHORT $LN43@deflate_sl
$LN42@deflate_sl:
  00b57	c7 44 24 7c 02
	00 00 00	 mov	 DWORD PTR tv489[rsp], 2
$LN43@deflate_sl:
  00b5f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b67	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv489[rsp]
  00b6b	89 88 0c 17 00
	00		 mov	 DWORD PTR [rax+5900], ecx

; 2042 :     if (flush == Z_FINISH) {

  00b71	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00b79	0f 85 d4 00 00
	00		 jne	 $LN25@deflate_sl

; 2043 :         FLUSH_BLOCK(s, 1);

  00b7f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b87	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00b8e	7c 2a		 jl	 SHORT $LN44@deflate_sl
  00b90	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b98	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00b9e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ba6	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00baa	48 03 c8	 add	 rcx, rax
  00bad	48 8b c1	 mov	 rax, rcx
  00bb0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv503[rsp], rax
  00bb8	eb 0c		 jmp	 SHORT $LN45@deflate_sl
$LN44@deflate_sl:
  00bba	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv503[rsp], 0
$LN45@deflate_sl:
  00bc6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bce	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bd6	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00bdc	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00be2	2b c1		 sub	 eax, ecx
  00be4	41 b9 01 00 00
	00		 mov	 r9d, 1
  00bea	44 8b c0	 mov	 r8d, eax
  00bed	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv503[rsp]
  00bf5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bfd	e8 00 00 00 00	 call	 _tr_flush_block
  00c02	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c0a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c12	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00c18	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00c1e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c26	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00c29	e8 00 00 00 00	 call	 flush_pending
  00c2e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c36	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c39	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00c3d	75 0a		 jne	 SHORT $LN26@deflate_sl
  00c3f	b8 02 00 00 00	 mov	 eax, 2
  00c44	e9 e5 00 00 00	 jmp	 $LN1@deflate_sl
$LN26@deflate_sl:

; 2044 :         return finish_done;

  00c49	b8 03 00 00 00	 mov	 eax, 3
  00c4e	e9 db 00 00 00	 jmp	 $LN1@deflate_sl
$LN25@deflate_sl:

; 2045 :     }
; 2046 :     if (s->last_lit)

  00c53	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c5b	83 b8 f4 16 00
	00 00		 cmp	 DWORD PTR [rax+5876], 0
  00c62	0f 84 c1 00 00
	00		 je	 $LN27@deflate_sl

; 2047 :         FLUSH_BLOCK(s, 0);

  00c68	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c70	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00c77	7c 2a		 jl	 SHORT $LN46@deflate_sl
  00c79	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c81	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00c87	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c8f	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00c93	48 03 c8	 add	 rcx, rax
  00c96	48 8b c1	 mov	 rax, rcx
  00c99	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv527[rsp], rax
  00ca1	eb 0c		 jmp	 SHORT $LN47@deflate_sl
$LN46@deflate_sl:
  00ca3	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv527[rsp], 0
$LN47@deflate_sl:
  00caf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00cb7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00cbf	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00cc5	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00ccb	2b c1		 sub	 eax, ecx
  00ccd	45 33 c9	 xor	 r9d, r9d
  00cd0	44 8b c0	 mov	 r8d, eax
  00cd3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv527[rsp]
  00cdb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ce3	e8 00 00 00 00	 call	 _tr_flush_block
  00ce8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00cf0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00cf8	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00cfe	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00d04	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d0c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00d0f	e8 00 00 00 00	 call	 flush_pending
  00d14	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d1c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d1f	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00d23	75 04		 jne	 SHORT $LN28@deflate_sl
  00d25	33 c0		 xor	 eax, eax
  00d27	eb 05		 jmp	 SHORT $LN1@deflate_sl
$LN28@deflate_sl:
$LN27@deflate_sl:

; 2048 :     return block_done;

  00d29	b8 01 00 00 00	 mov	 eax, 1
$LN1@deflate_sl:

; 2049 : }

  00d2e	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00d35	5f		 pop	 rdi
  00d36	c3		 ret	 0
deflate_slow ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_rle
_TEXT	SEGMENT
bflush$ = 32
prev$ = 36
scan$ = 40
strend$ = 48
len$1 = 56
dist$2 = 60
cc$3 = 64
tv230 = 68
tv250 = 72
tv298 = 76
tv320 = 80
tv344 = 88
tv368 = 96
s$ = 128
flush$ = 136
deflate_rle PROC					; COMDAT

; 2060 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 1c 00 00 00	 mov	 ecx, 28
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@deflate_rl:

; 2061 :     int bflush;             /* set if current block must be flushed */
; 2062 :     uInt prev;              /* byte at distance one to match */
; 2063 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 2064 : 
; 2065 :     for (;;) {
; 2066 :         /* Make sure that we always have enough lookahead, except
; 2067 :          * at the end of the input file. We need MAX_MATCH bytes
; 2068 :          * for the longest run, plus one for the unrolled loop.
; 2069 :          */
; 2070 :         if (s->lookahead <= MAX_MATCH) {

  00031	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00039	81 b8 9c 00 00
	00 02 01 00 00	 cmp	 DWORD PTR [rax+156], 258 ; 00000102H
  00043	77 48		 ja	 SHORT $LN8@deflate_rl

; 2071 :             fill_window(s);

  00045	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0004d	e8 00 00 00 00	 call	 fill_window

; 2072 :             if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {

  00052	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005a	81 b8 9c 00 00
	00 02 01 00 00	 cmp	 DWORD PTR [rax+156], 258 ; 00000102H
  00064	77 11		 ja	 SHORT $LN9@deflate_rl
  00066	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  0006e	75 07		 jne	 SHORT $LN9@deflate_rl

; 2073 :                 return need_more;

  00070	33 c0		 xor	 eax, eax
  00072	e9 25 08 00 00	 jmp	 $LN1@deflate_rl
$LN9@deflate_rl:

; 2074 :             }
; 2075 :             if (s->lookahead == 0) break; /* flush the current block */

  00077	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0007f	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00086	75 05		 jne	 SHORT $LN10@deflate_rl
  00088	e9 52 06 00 00	 jmp	 $LN3@deflate_rl
$LN10@deflate_rl:
$LN8@deflate_rl:

; 2076 :         }
; 2077 : 
; 2078 :         /* See how many times the previous byte repeats */
; 2079 :         s->match_length = 0;

  0008d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00095	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 2080 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  0009f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000a7	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  000ae	0f 82 1e 02 00
	00		 jb	 $LN11@deflate_rl
  000b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000bc	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  000c3	0f 86 09 02 00
	00		 jbe	 $LN11@deflate_rl

; 2081 :             scan = s->window + s->strstart - 1;

  000c9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000d1	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  000d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000df	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000e3	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  000e8	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax

; 2082 :             prev = *scan;

  000ed	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  000f2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f5	89 44 24 24	 mov	 DWORD PTR prev$[rsp], eax

; 2083 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  000f9	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  000fe	48 ff c0	 inc	 rax
  00101	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00106	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0010b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0010e	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  00112	0f 85 ba 01 00
	00		 jne	 $LN12@deflate_rl
  00118	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0011d	48 ff c0	 inc	 rax
  00120	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00125	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0012a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012d	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  00131	0f 85 9b 01 00
	00		 jne	 $LN12@deflate_rl
  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0013c	48 ff c0	 inc	 rax
  0013f	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00144	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00149	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0014c	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  00150	0f 85 7c 01 00
	00		 jne	 $LN12@deflate_rl

; 2084 :                 strend = s->window + s->strstart + MAX_MATCH;

  00156	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0015e	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00164	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0016c	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00170	48 8d 84 01 02
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+258]
  00178	48 89 44 24 30	 mov	 QWORD PTR strend$[rsp], rax
$LN7@deflate_rl:

; 2085 :                 do {
; 2086 :                 } while (prev == *++scan && prev == *++scan &&
; 2087 :                          prev == *++scan && prev == *++scan &&
; 2088 :                          prev == *++scan && prev == *++scan &&
; 2089 :                          prev == *++scan && prev == *++scan &&

  0017d	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00182	48 ff c0	 inc	 rax
  00185	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  0018a	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0018f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00192	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  00196	0f 85 d5 00 00
	00		 jne	 $LN13@deflate_rl
  0019c	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001a1	48 ff c0	 inc	 rax
  001a4	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  001a9	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001ae	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b1	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  001b5	0f 85 b6 00 00
	00		 jne	 $LN13@deflate_rl
  001bb	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001c0	48 ff c0	 inc	 rax
  001c3	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  001c8	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001cd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d0	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  001d4	0f 85 97 00 00
	00		 jne	 $LN13@deflate_rl
  001da	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001df	48 ff c0	 inc	 rax
  001e2	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  001e7	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001ec	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001ef	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  001f3	75 7c		 jne	 SHORT $LN13@deflate_rl
  001f5	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001fa	48 ff c0	 inc	 rax
  001fd	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00202	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00207	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0020a	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  0020e	75 61		 jne	 SHORT $LN13@deflate_rl
  00210	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00215	48 ff c0	 inc	 rax
  00218	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  0021d	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00222	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00225	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  00229	75 46		 jne	 SHORT $LN13@deflate_rl
  0022b	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00230	48 ff c0	 inc	 rax
  00233	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00238	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0023d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00240	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  00244	75 2b		 jne	 SHORT $LN13@deflate_rl
  00246	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0024b	48 ff c0	 inc	 rax
  0024e	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00253	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00258	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0025b	39 44 24 24	 cmp	 DWORD PTR prev$[rsp], eax
  0025f	75 10		 jne	 SHORT $LN13@deflate_rl
  00261	48 8b 44 24 30	 mov	 rax, QWORD PTR strend$[rsp]
  00266	48 39 44 24 28	 cmp	 QWORD PTR scan$[rsp], rax
  0026b	0f 82 0c ff ff
	ff		 jb	 $LN7@deflate_rl
$LN13@deflate_rl:

; 2090 :                          scan < strend);
; 2091 :                 s->match_length = MAX_MATCH - (uInt)(strend - scan);

  00271	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00276	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strend$[rsp]
  0027b	48 2b c8	 sub	 rcx, rax
  0027e	48 8b c1	 mov	 rax, rcx
  00281	b9 02 01 00 00	 mov	 ecx, 258		; 00000102H
  00286	2b c8		 sub	 ecx, eax
  00288	8b c1		 mov	 eax, ecx
  0028a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00292	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 2092 :                 if (s->match_length > s->lookahead)

  00298	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a8	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  002ae	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  002b4	76 1c		 jbe	 SHORT $LN14@deflate_rl

; 2093 :                     s->match_length = s->lookahead;

  002b6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002be	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002c6	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  002cc	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx
$LN14@deflate_rl:
$LN12@deflate_rl:
$LN11@deflate_rl:

; 2094 :             }
; 2095 :             Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
; 2096 :         }
; 2097 : 
; 2098 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 2099 :         if (s->match_length >= MIN_MATCH) {

  002d2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002da	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  002e1	0f 82 02 02 00
	00		 jb	 $LN15@deflate_rl

; 2100 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 2101 : 
; 2102 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  002e7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002ef	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002f5	83 e8 03	 sub	 eax, 3
  002f8	88 44 24 38	 mov	 BYTE PTR len$1[rsp], al
  002fc	b8 01 00 00 00	 mov	 eax, 1
  00301	66 89 44 24 3c	 mov	 WORD PTR dist$2[rsp], ax
  00306	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0030e	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00314	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0031c	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00323	0f b7 54 24 3c	 movzx	 edx, WORD PTR dist$2[rsp]
  00328	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  0032c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00334	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  0033a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00342	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00349	0f b6 54 24 38	 movzx	 edx, BYTE PTR len$1[rsp]
  0034e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00351	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00359	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  0035f	ff c0		 inc	 eax
  00361	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00369	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  0036f	0f b7 44 24 3c	 movzx	 eax, WORD PTR dist$2[rsp]
  00374	66 ff c8	 dec	 ax
  00377	66 89 44 24 3c	 mov	 WORD PTR dist$2[rsp], ax
  0037c	0f b6 44 24 38	 movzx	 eax, BYTE PTR len$1[rsp]
  00381	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_length_code
  00388	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0038c	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00391	48 98		 cdqe
  00393	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0039b	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  003a3	66 ff c0	 inc	 ax
  003a6	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR len$1[rsp]
  003ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_length_code
  003b2	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003b6	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  003bc	48 63 c9	 movsxd	 rcx, ecx
  003bf	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  003c7	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  003cf	0f b7 44 24 3c	 movzx	 eax, WORD PTR dist$2[rsp]
  003d4	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  003d9	7d 19		 jge	 SHORT $LN24@deflate_rl
  003db	0f ae e8	 lfence
  003de	0f b7 44 24 3c	 movzx	 eax, WORD PTR dist$2[rsp]
  003e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  003ea	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ee	89 44 24 44	 mov	 DWORD PTR tv230[rsp], eax
  003f2	eb 21		 jmp	 SHORT $LN25@deflate_rl
$LN24@deflate_rl:
  003f4	0f ae e8	 lfence
  003f7	0f b7 44 24 3c	 movzx	 eax, WORD PTR dist$2[rsp]
  003fc	c1 f8 07	 sar	 eax, 7
  003ff	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00404	48 98		 cdqe
  00406	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  0040d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00411	89 44 24 44	 mov	 DWORD PTR tv230[rsp], eax
$LN25@deflate_rl:
  00415	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv230[rsp]
  0041a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00422	0f b7 84 81 b0
	09 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2480]
  0042a	66 ff c0	 inc	 ax
  0042d	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR tv230[rsp]
  00432	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0043a	66 89 84 8a b0
	09 00 00	 mov	 WORD PTR [rdx+rcx*4+2480], ax
  00442	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0044a	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00450	ff c8		 dec	 eax
  00452	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0045a	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00460	75 0a		 jne	 SHORT $LN26@deflate_rl
  00462	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv250[rsp], 1
  0046a	eb 08		 jmp	 SHORT $LN27@deflate_rl
$LN26@deflate_rl:
  0046c	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv250[rsp], 0
$LN27@deflate_rl:
  00474	8b 44 24 48	 mov	 eax, DWORD PTR tv250[rsp]
  00478	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 2103 : 
; 2104 :             s->lookahead -= s->match_length;

  0047c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00484	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0048c	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  00492	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00498	2b c1		 sub	 eax, ecx
  0049a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004a2	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 2105 :             s->strstart += s->match_length;

  004a8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004b0	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  004b6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004be	03 81 88 00 00
	00		 add	 eax, DWORD PTR [rcx+136]
  004c4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004cc	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 2106 :             s->match_length = 0;

  004d2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004da	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 2107 :         } else {

  004e4	e9 2b 01 00 00	 jmp	 $LN16@deflate_rl
$LN15@deflate_rl:

; 2108 :             /* No match, output a literal byte */
; 2109 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 2110 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  004e9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004f1	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  004f7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004ff	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00503	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00507	88 44 24 40	 mov	 BYTE PTR cc$3[rsp], al
  0050b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00513	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00519	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00521	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00528	33 d2		 xor	 edx, edx
  0052a	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  0052e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00536	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  0053c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00544	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  0054b	0f b6 54 24 40	 movzx	 edx, BYTE PTR cc$3[rsp]
  00550	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00553	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0055b	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00561	ff c0		 inc	 eax
  00563	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0056b	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  00571	0f b6 44 24 40	 movzx	 eax, BYTE PTR cc$3[rsp]
  00576	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0057e	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  00586	66 ff c0	 inc	 ax
  00589	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR cc$3[rsp]
  0058e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00596	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  0059e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005a6	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  005ac	ff c8		 dec	 eax
  005ae	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005b6	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  005bc	75 0a		 jne	 SHORT $LN28@deflate_rl
  005be	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv298[rsp], 1
  005c6	eb 08		 jmp	 SHORT $LN29@deflate_rl
$LN28@deflate_rl:
  005c8	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv298[rsp], 0
$LN29@deflate_rl:
  005d0	8b 44 24 4c	 mov	 eax, DWORD PTR tv298[rsp]
  005d4	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 2111 :             s->lookahead--;

  005d8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005e0	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  005e6	ff c8		 dec	 eax
  005e8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005f0	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 2112 :             s->strstart++;

  005f6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005fe	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00604	ff c0		 inc	 eax
  00606	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0060e	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax
$LN16@deflate_rl:

; 2113 :         }
; 2114 :         if (bflush) FLUSH_BLOCK(s, 0);

  00614	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  00619	0f 84 bb 00 00
	00		 je	 $LN17@deflate_rl
  0061f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00627	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  0062e	7c 27		 jl	 SHORT $LN30@deflate_rl
  00630	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00638	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0063e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00646	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0064a	48 03 c8	 add	 rcx, rax
  0064d	48 8b c1	 mov	 rax, rcx
  00650	48 89 44 24 50	 mov	 QWORD PTR tv320[rsp], rax
  00655	eb 09		 jmp	 SHORT $LN31@deflate_rl
$LN30@deflate_rl:
  00657	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv320[rsp], 0
$LN31@deflate_rl:
  00660	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00668	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00670	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00676	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0067c	2b c1		 sub	 eax, ecx
  0067e	45 33 c9	 xor	 r9d, r9d
  00681	44 8b c0	 mov	 r8d, eax
  00684	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv320[rsp]
  00689	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00691	e8 00 00 00 00	 call	 _tr_flush_block
  00696	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0069e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006a6	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  006ac	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  006b2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006ba	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006bd	e8 00 00 00 00	 call	 flush_pending
  006c2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006cd	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  006d1	75 07		 jne	 SHORT $LN18@deflate_rl
  006d3	33 c0		 xor	 eax, eax
  006d5	e9 c2 01 00 00	 jmp	 $LN1@deflate_rl
$LN18@deflate_rl:
$LN17@deflate_rl:

; 2115 :     }

  006da	e9 52 f9 ff ff	 jmp	 $LN2@deflate_rl
$LN3@deflate_rl:

; 2116 :     s->insert = 0;

  006df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006e7	c7 80 0c 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5900], 0

; 2117 :     if (flush == Z_FINISH) {

  006f1	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  006f9	0f 85 cb 00 00
	00		 jne	 $LN19@deflate_rl

; 2118 :         FLUSH_BLOCK(s, 1);

  006ff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00707	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  0070e	7c 27		 jl	 SHORT $LN32@deflate_rl
  00710	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00718	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0071e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00726	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0072a	48 03 c8	 add	 rcx, rax
  0072d	48 8b c1	 mov	 rax, rcx
  00730	48 89 44 24 58	 mov	 QWORD PTR tv344[rsp], rax
  00735	eb 09		 jmp	 SHORT $LN33@deflate_rl
$LN32@deflate_rl:
  00737	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv344[rsp], 0
$LN33@deflate_rl:
  00740	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00748	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00750	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00756	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0075c	2b c1		 sub	 eax, ecx
  0075e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00764	44 8b c0	 mov	 r8d, eax
  00767	48 8b 54 24 58	 mov	 rdx, QWORD PTR tv344[rsp]
  0076c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00774	e8 00 00 00 00	 call	 _tr_flush_block
  00779	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00781	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00789	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0078f	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00795	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0079d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007a0	e8 00 00 00 00	 call	 flush_pending
  007a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007b0	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  007b4	75 0a		 jne	 SHORT $LN20@deflate_rl
  007b6	b8 02 00 00 00	 mov	 eax, 2
  007bb	e9 dc 00 00 00	 jmp	 $LN1@deflate_rl
$LN20@deflate_rl:

; 2119 :         return finish_done;

  007c0	b8 03 00 00 00	 mov	 eax, 3
  007c5	e9 d2 00 00 00	 jmp	 $LN1@deflate_rl
$LN19@deflate_rl:

; 2120 :     }
; 2121 :     if (s->last_lit)

  007ca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007d2	83 b8 f4 16 00
	00 00		 cmp	 DWORD PTR [rax+5876], 0
  007d9	0f 84 b8 00 00
	00		 je	 $LN21@deflate_rl

; 2122 :         FLUSH_BLOCK(s, 0);

  007df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007e7	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  007ee	7c 27		 jl	 SHORT $LN34@deflate_rl
  007f0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007f8	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  007fe	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00806	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0080a	48 03 c8	 add	 rcx, rax
  0080d	48 8b c1	 mov	 rax, rcx
  00810	48 89 44 24 60	 mov	 QWORD PTR tv368[rsp], rax
  00815	eb 09		 jmp	 SHORT $LN35@deflate_rl
$LN34@deflate_rl:
  00817	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv368[rsp], 0
$LN35@deflate_rl:
  00820	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00828	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00830	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00836	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0083c	2b c1		 sub	 eax, ecx
  0083e	45 33 c9	 xor	 r9d, r9d
  00841	44 8b c0	 mov	 r8d, eax
  00844	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv368[rsp]
  00849	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00851	e8 00 00 00 00	 call	 _tr_flush_block
  00856	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0085e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00866	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0086c	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00872	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0087a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0087d	e8 00 00 00 00	 call	 flush_pending
  00882	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0088a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0088d	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00891	75 04		 jne	 SHORT $LN22@deflate_rl
  00893	33 c0		 xor	 eax, eax
  00895	eb 05		 jmp	 SHORT $LN1@deflate_rl
$LN22@deflate_rl:
$LN21@deflate_rl:

; 2123 :     return block_done;

  00897	b8 01 00 00 00	 mov	 eax, 1
$LN1@deflate_rl:

; 2124 : }

  0089c	48 83 c4 70	 add	 rsp, 112		; 00000070H
  008a0	5f		 pop	 rdi
  008a1	c3		 ret	 0
deflate_rle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\deflate.c
;	COMDAT deflate_huff
_TEXT	SEGMENT
bflush$ = 32
cc$1 = 36
tv141 = 40
tv163 = 48
tv187 = 56
tv211 = 64
s$ = 96
flush$ = 104
deflate_huff PROC					; COMDAT

; 2133 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 14 00 00 00	 mov	 ecx, 20
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@deflate_hu:

; 2134 :     int bflush;             /* set if current block must be flushed */
; 2135 : 
; 2136 :     for (;;) {
; 2137 :         /* Make sure that we have a literal to write. */
; 2138 :         if (s->lookahead == 0) {

  0002e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00033	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  0003a	75 2b		 jne	 SHORT $LN5@deflate_hu

; 2139 :             fill_window(s);

  0003c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 fill_window

; 2140 :             if (s->lookahead == 0) {

  00046	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0004b	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00052	75 13		 jne	 SHORT $LN6@deflate_hu

; 2141 :                 if (flush == Z_NO_FLUSH)

  00054	83 7c 24 68 00	 cmp	 DWORD PTR flush$[rsp], 0
  00059	75 07		 jne	 SHORT $LN7@deflate_hu

; 2142 :                     return need_more;

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 34 03 00 00	 jmp	 $LN1@deflate_hu
$LN7@deflate_hu:

; 2143 :                 break;      /* flush the current block */

  00062	e9 b7 01 00 00	 jmp	 $LN3@deflate_hu
$LN6@deflate_hu:
$LN5@deflate_hu:

; 2144 :             }
; 2145 :         }
; 2146 : 
; 2147 :         /* Output a literal byte */
; 2148 :         s->match_length = 0;

  00067	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0006c	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 2149 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 2150 :         _tr_tally_lit (s, s->window[s->strstart], bflush);

  00076	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0007b	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00081	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00086	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0008a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008e	88 44 24 24	 mov	 BYTE PTR cc$1[rsp], al
  00092	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00097	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  0009d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000a2	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  000a9	33 d2		 xor	 edx, edx
  000ab	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  000af	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b4	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  000ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000bf	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  000c6	0f b6 54 24 24	 movzx	 edx, BYTE PTR cc$1[rsp]
  000cb	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  000ce	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000d3	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  000d9	ff c0		 inc	 eax
  000db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e0	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  000e6	0f b6 44 24 24	 movzx	 eax, BYTE PTR cc$1[rsp]
  000eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000f0	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  000f8	66 ff c0	 inc	 ax
  000fb	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR cc$1[rsp]
  00100	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  00105	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  0010d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00112	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00118	ff c8		 dec	 eax
  0011a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0011f	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00125	75 0a		 jne	 SHORT $LN15@deflate_hu
  00127	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv141[rsp], 1
  0012f	eb 08		 jmp	 SHORT $LN16@deflate_hu
$LN15@deflate_hu:
  00131	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
$LN16@deflate_hu:
  00139	8b 44 24 28	 mov	 eax, DWORD PTR tv141[rsp]
  0013d	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 2151 :         s->lookahead--;

  00141	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00146	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0014c	ff c8		 dec	 eax
  0014e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00153	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 2152 :         s->strstart++;

  00159	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0015e	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00164	ff c0		 inc	 eax
  00166	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0016b	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 2153 :         if (bflush) FLUSH_BLOCK(s, 0);

  00171	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  00176	0f 84 9d 00 00
	00		 je	 $LN8@deflate_hu
  0017c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00181	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00188	7c 21		 jl	 SHORT $LN17@deflate_hu
  0018a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0018f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00195	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0019a	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0019e	48 03 c8	 add	 rcx, rax
  001a1	48 8b c1	 mov	 rax, rcx
  001a4	48 89 44 24 30	 mov	 QWORD PTR tv163[rsp], rax
  001a9	eb 09		 jmp	 SHORT $LN18@deflate_hu
$LN17@deflate_hu:
  001ab	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv163[rsp], 0
$LN18@deflate_hu:
  001b4	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001be	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  001c4	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  001ca	2b c1		 sub	 eax, ecx
  001cc	45 33 c9	 xor	 r9d, r9d
  001cf	44 8b c0	 mov	 r8d, eax
  001d2	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv163[rsp]
  001d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001dc	e8 00 00 00 00	 call	 _tr_flush_block
  001e1	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001eb	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  001f1	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  001f7	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001fc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001ff	e8 00 00 00 00	 call	 flush_pending
  00204	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00209	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00210	75 07		 jne	 SHORT $LN9@deflate_hu
  00212	33 c0		 xor	 eax, eax
  00214	e9 7d 01 00 00	 jmp	 $LN1@deflate_hu
$LN9@deflate_hu:
$LN8@deflate_hu:

; 2154 :     }

  00219	e9 10 fe ff ff	 jmp	 $LN2@deflate_hu
$LN3@deflate_hu:

; 2155 :     s->insert = 0;

  0021e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00223	c7 80 0c 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5900], 0

; 2156 :     if (flush == Z_FINISH) {

  0022d	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  00232	0f 85 ad 00 00
	00		 jne	 $LN10@deflate_hu

; 2157 :         FLUSH_BLOCK(s, 1);

  00238	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0023d	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00244	7c 21		 jl	 SHORT $LN19@deflate_hu
  00246	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0024b	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00251	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00256	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0025a	48 03 c8	 add	 rcx, rax
  0025d	48 8b c1	 mov	 rax, rcx
  00260	48 89 44 24 38	 mov	 QWORD PTR tv187[rsp], rax
  00265	eb 09		 jmp	 SHORT $LN20@deflate_hu
$LN19@deflate_hu:
  00267	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv187[rsp], 0
$LN20@deflate_hu:
  00270	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00275	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0027a	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00280	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00286	2b c1		 sub	 eax, ecx
  00288	41 b9 01 00 00
	00		 mov	 r9d, 1
  0028e	44 8b c0	 mov	 r8d, eax
  00291	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv187[rsp]
  00296	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0029b	e8 00 00 00 00	 call	 _tr_flush_block
  002a0	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002aa	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  002b0	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  002b6	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002bb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002be	e8 00 00 00 00	 call	 flush_pending
  002c3	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002c8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002cb	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  002cf	75 0a		 jne	 SHORT $LN11@deflate_hu
  002d1	b8 02 00 00 00	 mov	 eax, 2
  002d6	e9 bb 00 00 00	 jmp	 $LN1@deflate_hu
$LN11@deflate_hu:

; 2158 :         return finish_done;

  002db	b8 03 00 00 00	 mov	 eax, 3
  002e0	e9 b1 00 00 00	 jmp	 $LN1@deflate_hu
$LN10@deflate_hu:

; 2159 :     }
; 2160 :     if (s->last_lit)

  002e5	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002ea	83 b8 f4 16 00
	00 00		 cmp	 DWORD PTR [rax+5876], 0
  002f1	0f 84 9a 00 00
	00		 je	 $LN12@deflate_hu

; 2161 :         FLUSH_BLOCK(s, 0);

  002f7	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002fc	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00303	7c 21		 jl	 SHORT $LN21@deflate_hu
  00305	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0030a	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00310	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00315	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00319	48 03 c8	 add	 rcx, rax
  0031c	48 8b c1	 mov	 rax, rcx
  0031f	48 89 44 24 40	 mov	 QWORD PTR tv211[rsp], rax
  00324	eb 09		 jmp	 SHORT $LN22@deflate_hu
$LN21@deflate_hu:
  00326	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv211[rsp], 0
$LN22@deflate_hu:
  0032f	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00334	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00339	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  0033f	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00345	2b c1		 sub	 eax, ecx
  00347	45 33 c9	 xor	 r9d, r9d
  0034a	44 8b c0	 mov	 r8d, eax
  0034d	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv211[rsp]
  00352	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00357	e8 00 00 00 00	 call	 _tr_flush_block
  0035c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00361	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00366	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0036c	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00372	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00377	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0037a	e8 00 00 00 00	 call	 flush_pending
  0037f	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00384	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00387	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0038b	75 04		 jne	 SHORT $LN13@deflate_hu
  0038d	33 c0		 xor	 eax, eax
  0038f	eb 05		 jmp	 SHORT $LN1@deflate_hu
$LN13@deflate_hu:
$LN12@deflate_hu:

; 2162 :     return block_done;

  00391	b8 01 00 00 00	 mov	 eax, 1
$LN1@deflate_hu:

; 2163 : }

  00396	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0039a	5f		 pop	 rdi
  0039b	c3		 ret	 0
deflate_huff ENDP
_TEXT	ENDS
END
