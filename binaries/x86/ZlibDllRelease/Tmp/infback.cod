; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

	TITLE	e:\cpython\externals\zlib-1.2.11\infback.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type@		; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@	; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ ; `string'
EXTRN	_inflate_fast:PROC
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ DB 'invalid distanc'
	DB	'e too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code@ DB 'invalid distance code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ DB 'invalid literal/le'
	DB	'ngth code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set@ DB 'invalid distances set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ DB 'invalid literal/le'
	DB	'ngths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ DB 'invalid c'
	DB	'ode -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ DB 'invalid bit length r'
	DB	'epeat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@ DB 'invalid code lengths '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ DB 'too many len'
	DB	'gth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ DB 'invalid stored bl'
	DB	'ock lengths', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type@ DB 'invalid block type', 00H ; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__55962C33_inffixed@h DB 01H
__B796723E_infback@c DB 01H
PUBLIC	_inflateBackEnd@4
PUBLIC	_inflateBack@20
PUBLIC	_inflateBackInit_@20
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT _inflateBackInit_@20
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_window$ = 16						; size = 4
_version$ = 20						; size = 4
_stream_size$ = 24					; size = 4
_inflateBackInit_@20 PROC				; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00011	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00016	83 7d 14 00	 cmp	 DWORD PTR _version$[ebp], 0
  0001a	74 28		 je	 SHORT $LN3@inflateBac
  0001c	b8 01 00 00 00	 mov	 eax, 1
  00021	6b c8 00	 imul	 ecx, eax, 0
  00024	8b 55 14	 mov	 edx, DWORD PTR _version$[ebp]
  00027	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0002b	b9 01 00 00 00	 mov	 ecx, 1
  00030	6b d1 00	 imul	 edx, ecx, 0
  00033	0f be 8a 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_06CJNJFBNP@1?42?411@[edx]
  0003a	3b c1		 cmp	 eax, ecx
  0003c	75 06		 jne	 SHORT $LN3@inflateBac
  0003e	83 7d 18 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  00042	74 0a		 je	 SHORT $LN2@inflateBac
$LN3@inflateBac:

; 38   :         stream_size != (int)(sizeof(z_stream)))
; 39   :         return Z_VERSION_ERROR;

  00044	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00049	e9 d9 00 00 00	 jmp	 $LN1@inflateBac
$LN2@inflateBac:

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  0004e	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00052	74 12		 je	 SHORT $LN5@inflateBac
  00054	83 7d 10 00	 cmp	 DWORD PTR _window$[ebp], 0
  00058	74 0c		 je	 SHORT $LN5@inflateBac
  0005a	83 7d 0c 08	 cmp	 DWORD PTR _windowBits$[ebp], 8
  0005e	7c 06		 jl	 SHORT $LN5@inflateBac
  00060	83 7d 0c 0f	 cmp	 DWORD PTR _windowBits$[ebp], 15 ; 0000000fH
  00064	7e 0a		 jle	 SHORT $LN4@inflateBac
$LN5@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  00066	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0006b	e9 b7 00 00 00	 jmp	 $LN1@inflateBac
$LN4@inflateBac:

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  00070	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00073	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 44   :     if (strm->zalloc == (alloc_func)0) {

  0007a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0007d	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00081	75 14		 jne	 SHORT $LN6@inflateBac

; 45   : #ifdef Z_SOLO
; 46   :         return Z_STREAM_ERROR;
; 47   : #else
; 48   :         strm->zalloc = zcalloc;

  00083	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00086	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], OFFSET _zcalloc

; 49   :         strm->opaque = (voidpf)0;

  0008d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00090	c7 42 28 00 00
	00 00		 mov	 DWORD PTR [edx+40], 0
$LN6@inflateBac:

; 50   : #endif
; 51   :     }
; 52   :     if (strm->zfree == (free_func)0)

  00097	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0009a	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0009e	75 0a		 jne	 SHORT $LN7@inflateBac

; 53   : #ifdef Z_SOLO
; 54   :         return Z_STREAM_ERROR;
; 55   : #else
; 56   :     strm->zfree = zcfree;

  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000a3	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], OFFSET _zcfree
$LN7@inflateBac:

; 57   : #endif
; 58   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,

  000aa	8b f4		 mov	 esi, esp
  000ac	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  000b1	6a 01		 push	 1
  000b3	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000b6	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000b9	50		 push	 eax
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000bd	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000c0	ff d2		 call	 edx
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c5	3b f4		 cmp	 esi, esp
  000c7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000cc	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 59   :                                                sizeof(struct inflate_state));
; 60   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000cf	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  000d3	75 07		 jne	 SHORT $LN8@inflateBac
  000d5	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000da	eb 4b		 jmp	 SHORT $LN1@inflateBac
$LN8@inflateBac:

; 61   :     Tracev((stderr, "inflate: allocated\n"));
; 62   :     strm->state = (struct internal_state FAR *)state;

  000dc	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000df	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000e2	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 63   :     state->dmax = 32768U;

  000e5	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000e8	c7 42 18 00 80
	00 00		 mov	 DWORD PTR [edx+24], 32768 ; 00008000H

; 64   :     state->wbits = (uInt)windowBits;

  000ef	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000f2	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000f5	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 65   :     state->wsize = 1U << windowBits;

  000f8	ba 01 00 00 00	 mov	 edx, 1
  000fd	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  00100	d3 e2		 shl	 edx, cl
  00102	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00105	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 66   :     state->window = window;

  00108	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0010b	8b 55 10	 mov	 edx, DWORD PTR _window$[ebp]
  0010e	89 51 38	 mov	 DWORD PTR [ecx+56], edx

; 67   :     state->wnext = 0;

  00111	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00114	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 68   :     state->whave = 0;

  0011b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0011e	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 69   :     return Z_OK;

  00125	33 c0		 xor	 eax, eax
$LN1@inflateBac:

; 70   : }

  00127	5e		 pop	 esi
  00128	83 c4 04	 add	 esp, 4
  0012b	3b ec		 cmp	 ebp, esp
  0012d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 14 00	 ret	 20			; 00000014H
_inflateBackInit_@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 85   : #ifdef BUILDFIXED
; 86   :     static int virgin = 1;
; 87   :     static code *lenfix, *distfix;
; 88   :     static code fixed[544];
; 89   : 
; 90   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 91   :     if (virgin) {
; 92   :         unsigned sym, bits;
; 93   :         static code *next;
; 94   : 
; 95   :         /* literal/length table */
; 96   :         sym = 0;
; 97   :         while (sym < 144) state->lens[sym++] = 8;
; 98   :         while (sym < 256) state->lens[sym++] = 9;
; 99   :         while (sym < 280) state->lens[sym++] = 7;
; 100  :         while (sym < 288) state->lens[sym++] = 8;
; 101  :         next = fixed;
; 102  :         lenfix = next;
; 103  :         bits = 9;
; 104  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 105  : 
; 106  :         /* distance table */
; 107  :         sym = 0;
; 108  :         while (sym < 32) state->lens[sym++] = 5;
; 109  :         distfix = next;
; 110  :         bits = 5;
; 111  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 112  : 
; 113  :         /* do this just once */
; 114  :         virgin = 0;
; 115  :     }
; 116  : #else /* !BUILDFIXED */
; 117  : #   include "inffixed.h"
; 118  : #endif /* BUILDFIXED */
; 119  :     state->lencode = lenfix;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00010	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 120  :     state->lenbits = 9;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0001a	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 121  :     state->distcode = distfix;

  00021	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00024	c7 42 54 00 00
	00 00		 mov	 DWORD PTR [edx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 122  :     state->distbits = 5;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002e	c7 40 5c 05 00
	00 00		 mov	 DWORD PTR [eax+92], 5

; 123  : }

  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT _inflateBack@20
_TEXT	SEGMENT
tv790 = -96						; size = 4
tv464 = -92						; size = 4
tv141 = -88						; size = 4
tv79 = -84						; size = 4
tv75 = -80						; size = 4
_ret$ = -76						; size = 4
_len$ = -72						; size = 4
_last$ = -64						; size = 4
_here$ = -52						; size = 4
_from$ = -44						; size = 4
_copy$ = -40						; size = 4
_bits$ = -36						; size = 4
_hold$ = -32						; size = 4
_left$ = -28						; size = 4
_have$ = -24						; size = 4
_put$ = -20						; size = 4
_next$ = -12						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_in$ = 12						; size = 4
_in_desc$ = 16						; size = 4
_out$ = 20						; size = 4
_out_desc$ = 24						; size = 4
_inflateBack@20 PROC					; COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d a0	 lea	 edi, DWORD PTR [ebp-96]
  0000b	b9 18 00 00 00	 mov	 ecx, 24			; 00000018H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 257  :     struct inflate_state FAR *state;
; 258  :     z_const unsigned char FAR *next;    /* next input */
; 259  :     unsigned char FAR *put;     /* next output */
; 260  :     unsigned have, left;        /* available input and output */
; 261  :     unsigned long hold;         /* bit buffer */
; 262  :     unsigned bits;              /* bits in bit buffer */
; 263  :     unsigned copy;              /* number of stored or match bytes to copy */
; 264  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 265  :     code here;                  /* current decoding table entry */
; 266  :     code last;                  /* parent table entry */
; 267  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 268  :     int ret;                    /* return code */
; 269  :     static const unsigned short order[19] = /* permutation of code lengths */
; 270  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 271  : 
; 272  :     /* Check that the strm exists and that the state was initialized */
; 273  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00021	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00025	74 09		 je	 SHORT $LN254@inflateBac
  00027	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002a	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0002e	75 0a		 jne	 SHORT $LN253@inflateBac
$LN254@inflateBac:

; 274  :         return Z_STREAM_ERROR;

  00030	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00035	e9 21 14 00 00	 jmp	 $LN1@inflateBac
$LN253@inflateBac:

; 275  :     state = (struct inflate_state FAR *)strm->state;

  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00040	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 276  : 
; 277  :     /* Reset the state */
; 278  :     strm->msg = Z_NULL;

  00043	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00046	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 279  :     state->mode = TYPE;

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00050	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 280  :     state->last = 0;

  00057	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005a	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 281  :     state->whave = 0;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00064	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 282  :     next = strm->next_in;

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0006e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00070	89 55 f4	 mov	 DWORD PTR _next$[ebp], edx

; 283  :     have = next != Z_NULL ? strm->avail_in : 0;

  00073	83 7d f4 00	 cmp	 DWORD PTR _next$[ebp], 0
  00077	74 0b		 je	 SHORT $LN343@inflateBac
  00079	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0007c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007f	89 4d b0	 mov	 DWORD PTR tv75[ebp], ecx
  00082	eb 07		 jmp	 SHORT $LN344@inflateBac
$LN343@inflateBac:
  00084	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN344@inflateBac:
  0008b	8b 55 b0	 mov	 edx, DWORD PTR tv75[ebp]
  0008e	89 55 e8	 mov	 DWORD PTR _have$[ebp], edx

; 284  :     hold = 0;

  00091	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0

; 285  :     bits = 0;

  00098	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0

; 286  :     put = state->window;

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000a2	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000a5	89 4d ec	 mov	 DWORD PTR _put$[ebp], ecx

; 287  :     left = state->wsize;

  000a8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000ab	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  000ae	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
$LN4@inflateBac:

; 288  : 
; 289  :     /* Inflate until end of block marked as last */
; 290  :     for (;;)
; 291  :         switch (state->mode) {

  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000b4	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000b7	89 55 ac	 mov	 DWORD PTR tv79[ebp], edx
  000ba	8b 45 ac	 mov	 eax, DWORD PTR tv79[ebp]
  000bd	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  000c2	89 45 ac	 mov	 DWORD PTR tv79[ebp], eax
  000c5	83 7d ac 12	 cmp	 DWORD PTR tv79[ebp], 18	; 00000012H
  000c9	0f 87 6a 13 00
	00		 ja	 $LN341@inflateBac
  000cf	8b 4d ac	 mov	 ecx, DWORD PTR tv79[ebp]
  000d2	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN385@inflateBac[ecx]
  000d9	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN386@inflateBac[edx*4]
$LN255@inflateBac:

; 292  :         case TYPE:
; 293  :             /* determine and dispatch block type */
; 294  :             if (state->last) {

  000e0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000e3	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000e7	74 2f		 je	 SHORT $LN13@inflateBac
$LN9@inflateBac:

; 295  :                 BYTEBITS();

  000e9	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  000ec	83 e1 07	 and	 ecx, 7
  000ef	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  000f2	d3 ea		 shr	 edx, cl
  000f4	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  000f7	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  000fa	83 e0 07	 and	 eax, 7
  000fd	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00100	2b c8		 sub	 ecx, eax
  00102	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  00105	33 d2		 xor	 edx, edx
  00107	75 e0		 jne	 SHORT $LN9@inflateBac

; 296  :                 state->mode = DONE;

  00109	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0010c	c7 40 04 50 3f
	00 00		 mov	 DWORD PTR [eax+4], 16208 ; 00003f50H

; 297  :                 break;

  00113	e9 2a 13 00 00	 jmp	 $LN5@inflateBac
$LN13@inflateBac:

; 298  :             }
; 299  :             NEEDBITS(3);

  00118	83 7d dc 03	 cmp	 DWORD PTR _bits$[ebp], 3
  0011c	73 6f		 jae	 SHORT $LN10@inflateBac
$LN20@inflateBac:
  0011e	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00122	75 33		 jne	 SHORT $LN18@inflateBac
  00124	8b f4		 mov	 esi, esp
  00126	8d 4d f4	 lea	 ecx, DWORD PTR _next$[ebp]
  00129	51		 push	 ecx
  0012a	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  0012d	52		 push	 edx
  0012e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00131	83 c4 08	 add	 esp, 8
  00134	3b f4		 cmp	 esi, esp
  00136	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013b	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  0013e	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00142	75 13		 jne	 SHORT $LN18@inflateBac
  00144	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0014b	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00152	e9 f0 12 00 00	 jmp	 $inf_leave$393
$LN18@inflateBac:
  00157	33 c0		 xor	 eax, eax
  00159	75 c3		 jne	 SHORT $LN20@inflateBac
  0015b	8b 4d e8	 mov	 ecx, DWORD PTR _have$[ebp]
  0015e	83 e9 01	 sub	 ecx, 1
  00161	89 4d e8	 mov	 DWORD PTR _have$[ebp], ecx
  00164	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  00167	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0016a	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  0016d	d3 e0		 shl	 eax, cl
  0016f	03 45 e0	 add	 eax, DWORD PTR _hold$[ebp]
  00172	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  00175	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  00178	83 c1 01	 add	 ecx, 1
  0017b	89 4d f4	 mov	 DWORD PTR _next$[ebp], ecx
  0017e	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  00181	83 c2 08	 add	 edx, 8
  00184	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  00187	33 c0		 xor	 eax, eax
  00189	75 93		 jne	 SHORT $LN20@inflateBac
  0018b	eb 8b		 jmp	 SHORT $LN13@inflateBac
$LN10@inflateBac:
  0018d	33 c9		 xor	 ecx, ecx
  0018f	75 87		 jne	 SHORT $LN13@inflateBac

; 300  :             state->last = BITS(1);

  00191	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  00194	83 e2 01	 and	 edx, 1
  00197	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0019a	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN23@inflateBac:

; 301  :             DROPBITS(1);

  0019d	8b 4d e0	 mov	 ecx, DWORD PTR _hold$[ebp]
  001a0	d1 e9		 shr	 ecx, 1
  001a2	89 4d e0	 mov	 DWORD PTR _hold$[ebp], ecx
  001a5	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  001a8	83 ea 01	 sub	 edx, 1
  001ab	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  001ae	33 c0		 xor	 eax, eax
  001b0	75 eb		 jne	 SHORT $LN23@inflateBac

; 302  :             switch (BITS(2)) {

  001b2	8b 4d e0	 mov	 ecx, DWORD PTR _hold$[ebp]
  001b5	83 e1 03	 and	 ecx, 3
  001b8	89 4d a8	 mov	 DWORD PTR tv141[ebp], ecx
  001bb	83 7d a8 03	 cmp	 DWORD PTR tv141[ebp], 3
  001bf	77 51		 ja	 SHORT $LN28@inflateBac
  001c1	8b 55 a8	 mov	 edx, DWORD PTR tv141[ebp]
  001c4	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN387@inflateBac[edx*4]
$LN259@inflateBac:

; 303  :             case 0:                             /* stored block */
; 304  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 305  :                         state->last ? " (last)" : ""));
; 306  :                 state->mode = STORED;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  001ce	c7 40 04 41 3f
	00 00		 mov	 DWORD PTR [eax+4], 16193 ; 00003f41H

; 307  :                 break;

  001d5	eb 3b		 jmp	 SHORT $LN28@inflateBac
$LN260@inflateBac:

; 308  :             case 1:                             /* fixed block */
; 309  :                 fixedtables(state);

  001d7	0f ae e8	 lfence
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 _fixedtables
  001e3	83 c4 04	 add	 esp, 4

; 310  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 311  :                         state->last ? " (last)" : ""));
; 312  :                 state->mode = LEN;              /* decode codes */

  001e6	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001e9	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H

; 313  :                 break;

  001f0	eb 20		 jmp	 SHORT $LN28@inflateBac
$LN261@inflateBac:

; 314  :             case 2:                             /* dynamic block */
; 315  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 316  :                         state->last ? " (last)" : ""));
; 317  :                 state->mode = TABLE;

  001f2	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  001f5	c7 40 04 44 3f
	00 00		 mov	 DWORD PTR [eax+4], 16196 ; 00003f44H

; 318  :                 break;

  001fc	eb 14		 jmp	 SHORT $LN28@inflateBac
$LN262@inflateBac:

; 319  :             case 3:
; 320  :                 strm->msg = (char *)"invalid block type";

  001fe	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00201	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 321  :                 state->mode = BAD;

  00208	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0020b	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H
$LN28@inflateBac:

; 322  :             }
; 323  :             DROPBITS(2);

  00212	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  00215	c1 e8 02	 shr	 eax, 2
  00218	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  0021b	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  0021e	83 e9 02	 sub	 ecx, 2
  00221	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  00224	33 d2		 xor	 edx, edx
  00226	75 ea		 jne	 SHORT $LN28@inflateBac

; 324  :             break;

  00228	e9 15 12 00 00	 jmp	 $LN5@inflateBac
$LN31@inflateBac:

; 325  : 
; 326  :         case STORED:
; 327  :             /* get and verify stored block length */
; 328  :             BYTEBITS();                         /* go to byte boundary */

  0022d	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00230	83 e1 07	 and	 ecx, 7
  00233	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  00236	d3 e8		 shr	 eax, cl
  00238	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  0023b	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  0023e	83 e1 07	 and	 ecx, 7
  00241	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  00244	2b d1		 sub	 edx, ecx
  00246	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  00249	33 c0		 xor	 eax, eax
  0024b	75 e0		 jne	 SHORT $LN31@inflateBac
$LN35@inflateBac:

; 329  :             NEEDBITS(32);

  0024d	83 7d dc 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00251	73 6f		 jae	 SHORT $LN32@inflateBac
$LN42@inflateBac:
  00253	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00257	75 33		 jne	 SHORT $LN40@inflateBac
  00259	8b f4		 mov	 esi, esp
  0025b	8d 4d f4	 lea	 ecx, DWORD PTR _next$[ebp]
  0025e	51		 push	 ecx
  0025f	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00262	52		 push	 edx
  00263	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00266	83 c4 08	 add	 esp, 8
  00269	3b f4		 cmp	 esi, esp
  0026b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00270	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  00273	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00277	75 13		 jne	 SHORT $LN40@inflateBac
  00279	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00280	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00287	e9 bb 11 00 00	 jmp	 $inf_leave$393
$LN40@inflateBac:
  0028c	33 c0		 xor	 eax, eax
  0028e	75 c3		 jne	 SHORT $LN42@inflateBac
  00290	8b 4d e8	 mov	 ecx, DWORD PTR _have$[ebp]
  00293	83 e9 01	 sub	 ecx, 1
  00296	89 4d e8	 mov	 DWORD PTR _have$[ebp], ecx
  00299	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  0029c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0029f	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  002a2	d3 e0		 shl	 eax, cl
  002a4	03 45 e0	 add	 eax, DWORD PTR _hold$[ebp]
  002a7	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  002aa	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  002ad	83 c1 01	 add	 ecx, 1
  002b0	89 4d f4	 mov	 DWORD PTR _next$[ebp], ecx
  002b3	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  002b6	83 c2 08	 add	 edx, 8
  002b9	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  002bc	33 c0		 xor	 eax, eax
  002be	75 93		 jne	 SHORT $LN42@inflateBac
  002c0	eb 8b		 jmp	 SHORT $LN35@inflateBac
$LN32@inflateBac:
  002c2	33 c9		 xor	 ecx, ecx
  002c4	75 87		 jne	 SHORT $LN35@inflateBac

; 330  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  002c6	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  002c9	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  002cf	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  002d2	c1 e8 10	 shr	 eax, 16			; 00000010H
  002d5	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  002da	3b d0		 cmp	 edx, eax
  002dc	74 19		 je	 SHORT $LN266@inflateBac

; 331  :                 strm->msg = (char *)"invalid stored block lengths";

  002de	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  002e1	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@

; 332  :                 state->mode = BAD;

  002e8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  002eb	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 333  :                 break;

  002f2	e9 4b 11 00 00	 jmp	 $LN5@inflateBac
$LN266@inflateBac:

; 334  :             }
; 335  :             state->length = (unsigned)hold & 0xffff;

  002f7	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  002fa	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  002ff	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00302	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN45@inflateBac:

; 336  :             Tracev((stderr, "inflate:       stored length %u\n",
; 337  :                     state->length));
; 338  :             INITBITS();

  00305	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  0030c	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00313	33 d2		 xor	 edx, edx
  00315	75 ee		 jne	 SHORT $LN45@inflateBac
$LN46@inflateBac:

; 339  : 
; 340  :             /* copy stored block from input to output */
; 341  :             while (state->length != 0) {

  00317	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0031a	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0031e	0f 84 fe 00 00
	00		 je	 $LN47@inflateBac

; 342  :                 copy = state->length;

  00324	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00327	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0032a	89 55 d8	 mov	 DWORD PTR _copy$[ebp], edx
$LN50@inflateBac:

; 343  :                 PULL();

  0032d	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00331	75 33		 jne	 SHORT $LN48@inflateBac
  00333	8b f4		 mov	 esi, esp
  00335	8d 45 f4	 lea	 eax, DWORD PTR _next$[ebp]
  00338	50		 push	 eax
  00339	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  0033c	51		 push	 ecx
  0033d	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00340	83 c4 08	 add	 esp, 8
  00343	3b f4		 cmp	 esi, esp
  00345	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0034a	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  0034d	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00351	75 13		 jne	 SHORT $LN48@inflateBac
  00353	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0035a	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00361	e9 e1 10 00 00	 jmp	 $inf_leave$393
$LN48@inflateBac:
  00366	33 d2		 xor	 edx, edx
  00368	75 c3		 jne	 SHORT $LN50@inflateBac
$LN53@inflateBac:

; 344  :                 ROOM();

  0036a	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  0036e	75 46		 jne	 SHORT $LN51@inflateBac
  00370	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00373	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00376	89 4d ec	 mov	 DWORD PTR _put$[ebp], ecx
  00379	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0037c	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0037f	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  00382	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00385	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  00388	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  0038b	8b f4		 mov	 esi, esp
  0038d	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00390	50		 push	 eax
  00391	8b 4d ec	 mov	 ecx, DWORD PTR _put$[ebp]
  00394	51		 push	 ecx
  00395	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  00398	52		 push	 edx
  00399	ff 55 14	 call	 DWORD PTR _out$[ebp]
  0039c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0039f	3b f4		 cmp	 esi, esp
  003a1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003a6	85 c0		 test	 eax, eax
  003a8	74 0c		 je	 SHORT $LN51@inflateBac
  003aa	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  003b1	e9 91 10 00 00	 jmp	 $inf_leave$393
$LN51@inflateBac:
  003b6	33 c0		 xor	 eax, eax
  003b8	75 b0		 jne	 SHORT $LN53@inflateBac

; 345  :                 if (copy > have) copy = have;

  003ba	8b 4d d8	 mov	 ecx, DWORD PTR _copy$[ebp]
  003bd	3b 4d e8	 cmp	 ecx, DWORD PTR _have$[ebp]
  003c0	76 06		 jbe	 SHORT $LN271@inflateBac
  003c2	8b 55 e8	 mov	 edx, DWORD PTR _have$[ebp]
  003c5	89 55 d8	 mov	 DWORD PTR _copy$[ebp], edx
$LN271@inflateBac:

; 346  :                 if (copy > left) copy = left;

  003c8	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  003cb	3b 45 e4	 cmp	 eax, DWORD PTR _left$[ebp]
  003ce	76 06		 jbe	 SHORT $LN272@inflateBac
  003d0	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  003d3	89 4d d8	 mov	 DWORD PTR _copy$[ebp], ecx
$LN272@inflateBac:

; 347  :                 zmemcpy(put, next, copy);

  003d6	8b 55 d8	 mov	 edx, DWORD PTR _copy$[ebp]
  003d9	52		 push	 edx
  003da	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  003dd	50		 push	 eax
  003de	8b 4d ec	 mov	 ecx, DWORD PTR _put$[ebp]
  003e1	51		 push	 ecx
  003e2	e8 00 00 00 00	 call	 _memcpy
  003e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  :                 have -= copy;

  003ea	8b 55 e8	 mov	 edx, DWORD PTR _have$[ebp]
  003ed	2b 55 d8	 sub	 edx, DWORD PTR _copy$[ebp]
  003f0	89 55 e8	 mov	 DWORD PTR _have$[ebp], edx

; 349  :                 next += copy;

  003f3	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  003f6	03 45 d8	 add	 eax, DWORD PTR _copy$[ebp]
  003f9	89 45 f4	 mov	 DWORD PTR _next$[ebp], eax

; 350  :                 left -= copy;

  003fc	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  003ff	2b 4d d8	 sub	 ecx, DWORD PTR _copy$[ebp]
  00402	89 4d e4	 mov	 DWORD PTR _left$[ebp], ecx

; 351  :                 put += copy;

  00405	8b 55 ec	 mov	 edx, DWORD PTR _put$[ebp]
  00408	03 55 d8	 add	 edx, DWORD PTR _copy$[ebp]
  0040b	89 55 ec	 mov	 DWORD PTR _put$[ebp], edx

; 352  :                 state->length -= copy;

  0040e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00411	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00414	2b 4d d8	 sub	 ecx, DWORD PTR _copy$[ebp]
  00417	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0041a	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 353  :             }

  0041d	e9 f5 fe ff ff	 jmp	 $LN46@inflateBac
$LN47@inflateBac:

; 354  :             Tracev((stderr, "inflate:       stored end\n"));
; 355  :             state->mode = TYPE;

  00422	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00425	c7 40 04 3f 3f
	00 00		 mov	 DWORD PTR [eax+4], 16191 ; 00003f3fH

; 356  :             break;

  0042c	e9 11 10 00 00	 jmp	 $LN5@inflateBac
$LN57@inflateBac:

; 357  : 
; 358  :         case TABLE:
; 359  :             /* get dynamic table entries descriptor */
; 360  :             NEEDBITS(14);

  00431	83 7d dc 0e	 cmp	 DWORD PTR _bits$[ebp], 14 ; 0000000eH
  00435	73 6f		 jae	 SHORT $LN54@inflateBac
$LN64@inflateBac:
  00437	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  0043b	75 33		 jne	 SHORT $LN62@inflateBac
  0043d	8b f4		 mov	 esi, esp
  0043f	8d 4d f4	 lea	 ecx, DWORD PTR _next$[ebp]
  00442	51		 push	 ecx
  00443	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00446	52		 push	 edx
  00447	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0044a	83 c4 08	 add	 esp, 8
  0044d	3b f4		 cmp	 esi, esp
  0044f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00454	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  00457	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  0045b	75 13		 jne	 SHORT $LN62@inflateBac
  0045d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00464	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0046b	e9 d7 0f 00 00	 jmp	 $inf_leave$393
$LN62@inflateBac:
  00470	33 c0		 xor	 eax, eax
  00472	75 c3		 jne	 SHORT $LN64@inflateBac
  00474	8b 4d e8	 mov	 ecx, DWORD PTR _have$[ebp]
  00477	83 e9 01	 sub	 ecx, 1
  0047a	89 4d e8	 mov	 DWORD PTR _have$[ebp], ecx
  0047d	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  00480	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00483	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00486	d3 e0		 shl	 eax, cl
  00488	03 45 e0	 add	 eax, DWORD PTR _hold$[ebp]
  0048b	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  0048e	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  00491	83 c1 01	 add	 ecx, 1
  00494	89 4d f4	 mov	 DWORD PTR _next$[ebp], ecx
  00497	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  0049a	83 c2 08	 add	 edx, 8
  0049d	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  004a0	33 c0		 xor	 eax, eax
  004a2	75 93		 jne	 SHORT $LN64@inflateBac
  004a4	eb 8b		 jmp	 SHORT $LN57@inflateBac
$LN54@inflateBac:
  004a6	33 c9		 xor	 ecx, ecx
  004a8	75 87		 jne	 SHORT $LN57@inflateBac

; 361  :             state->nlen = BITS(5) + 257;

  004aa	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  004ad	83 e2 1f	 and	 edx, 31			; 0000001fH
  004b0	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  004b6	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  004b9	89 50 64	 mov	 DWORD PTR [eax+100], edx
$LN67@inflateBac:

; 362  :             DROPBITS(5);

  004bc	8b 4d e0	 mov	 ecx, DWORD PTR _hold$[ebp]
  004bf	c1 e9 05	 shr	 ecx, 5
  004c2	89 4d e0	 mov	 DWORD PTR _hold$[ebp], ecx
  004c5	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  004c8	83 ea 05	 sub	 edx, 5
  004cb	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  004ce	33 c0		 xor	 eax, eax
  004d0	75 ea		 jne	 SHORT $LN67@inflateBac

; 363  :             state->ndist = BITS(5) + 1;

  004d2	8b 4d e0	 mov	 ecx, DWORD PTR _hold$[ebp]
  004d5	83 e1 1f	 and	 ecx, 31			; 0000001fH
  004d8	83 c1 01	 add	 ecx, 1
  004db	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  004de	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
$LN70@inflateBac:

; 364  :             DROPBITS(5);

  004e1	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  004e4	c1 e8 05	 shr	 eax, 5
  004e7	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  004ea	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  004ed	83 e9 05	 sub	 ecx, 5
  004f0	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  004f3	33 d2		 xor	 edx, edx
  004f5	75 ea		 jne	 SHORT $LN70@inflateBac

; 365  :             state->ncode = BITS(4) + 4;

  004f7	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  004fa	83 e0 0f	 and	 eax, 15			; 0000000fH
  004fd	83 c0 04	 add	 eax, 4
  00500	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00503	89 41 60	 mov	 DWORD PTR [ecx+96], eax
$LN73@inflateBac:

; 366  :             DROPBITS(4);

  00506	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  00509	c1 ea 04	 shr	 edx, 4
  0050c	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  0050f	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  00512	83 e8 04	 sub	 eax, 4
  00515	89 45 dc	 mov	 DWORD PTR _bits$[ebp], eax
  00518	33 c9		 xor	 ecx, ecx
  0051a	75 ea		 jne	 SHORT $LN73@inflateBac

; 367  : #ifndef PKZIP_BUG_WORKAROUND
; 368  :             if (state->nlen > 286 || state->ndist > 30) {

  0051c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0051f	81 7a 64 1e 01
	00 00		 cmp	 DWORD PTR [edx+100], 286 ; 0000011eH
  00526	77 09		 ja	 SHORT $LN277@inflateBac
  00528	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0052b	83 78 68 1e	 cmp	 DWORD PTR [eax+104], 30	; 0000001eH
  0052f	76 19		 jbe	 SHORT $LN276@inflateBac
$LN277@inflateBac:

; 369  :                 strm->msg = (char *)"too many length or distance symbols";

  00531	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00534	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@

; 370  :                 state->mode = BAD;

  0053b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0053e	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 371  :                 break;

  00545	e9 f8 0e 00 00	 jmp	 $LN5@inflateBac
$LN276@inflateBac:

; 372  :             }
; 373  : #endif
; 374  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 375  : 
; 376  :             /* get code length code lengths (not a typo) */
; 377  :             state->have = 0;

  0054a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0054d	c7 40 6c 00 00
	00 00		 mov	 DWORD PTR [eax+108], 0
$LN74@inflateBac:

; 378  :             while (state->have < state->ncode) {

  00554	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00557	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0055a	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  0055d	3b 42 60	 cmp	 eax, DWORD PTR [edx+96]
  00560	0f 83 c2 00 00
	00		 jae	 $LN90@inflateBac
$LN79@inflateBac:

; 379  :                 NEEDBITS(3);

  00566	83 7d dc 03	 cmp	 DWORD PTR _bits$[ebp], 3
  0056a	73 6f		 jae	 SHORT $LN76@inflateBac
$LN86@inflateBac:
  0056c	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00570	75 33		 jne	 SHORT $LN84@inflateBac
  00572	8b f4		 mov	 esi, esp
  00574	8d 4d f4	 lea	 ecx, DWORD PTR _next$[ebp]
  00577	51		 push	 ecx
  00578	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  0057b	52		 push	 edx
  0057c	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0057f	83 c4 08	 add	 esp, 8
  00582	3b f4		 cmp	 esi, esp
  00584	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00589	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  0058c	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00590	75 13		 jne	 SHORT $LN84@inflateBac
  00592	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00599	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  005a0	e9 a2 0e 00 00	 jmp	 $inf_leave$393
$LN84@inflateBac:
  005a5	33 c0		 xor	 eax, eax
  005a7	75 c3		 jne	 SHORT $LN86@inflateBac
  005a9	8b 4d e8	 mov	 ecx, DWORD PTR _have$[ebp]
  005ac	83 e9 01	 sub	 ecx, 1
  005af	89 4d e8	 mov	 DWORD PTR _have$[ebp], ecx
  005b2	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  005b5	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  005b8	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  005bb	d3 e0		 shl	 eax, cl
  005bd	03 45 e0	 add	 eax, DWORD PTR _hold$[ebp]
  005c0	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  005c3	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  005c6	83 c1 01	 add	 ecx, 1
  005c9	89 4d f4	 mov	 DWORD PTR _next$[ebp], ecx
  005cc	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  005cf	83 c2 08	 add	 edx, 8
  005d2	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  005d5	33 c0		 xor	 eax, eax
  005d7	75 93		 jne	 SHORT $LN86@inflateBac
  005d9	eb 8b		 jmp	 SHORT $LN79@inflateBac
$LN76@inflateBac:
  005db	33 c9		 xor	 ecx, ecx
  005dd	75 87		 jne	 SHORT $LN79@inflateBac

; 380  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  005df	0f ae e8	 lfence
  005e2	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  005e5	83 e2 07	 and	 edx, 7
  005e8	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  005eb	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  005ee	0f b7 04 4d 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  005f6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  005f9	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  005fe	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00601	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00604	83 c0 01	 add	 eax, 1
  00607	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0060a	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
$LN89@inflateBac:

; 381  :                 DROPBITS(3);

  0060d	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  00610	c1 ea 03	 shr	 edx, 3
  00613	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  00616	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  00619	83 e8 03	 sub	 eax, 3
  0061c	89 45 dc	 mov	 DWORD PTR _bits$[ebp], eax
  0061f	33 c9		 xor	 ecx, ecx
  00621	75 ea		 jne	 SHORT $LN89@inflateBac

; 382  :             }

  00623	e9 2c ff ff ff	 jmp	 $LN74@inflateBac
$LN90@inflateBac:

; 383  :             while (state->have < 19)

  00628	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0062b	83 7a 6c 13	 cmp	 DWORD PTR [edx+108], 19	; 00000013H
  0062f	73 29		 jae	 SHORT $LN91@inflateBac

; 384  :                 state->lens[order[state->have++]] = 0;

  00631	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00634	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00637	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  0063f	33 c0		 xor	 eax, eax
  00641	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00644	66 89 44 51 74	 mov	 WORD PTR [ecx+edx*2+116], ax
  00649	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0064c	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0064f	83 c0 01	 add	 eax, 1
  00652	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00655	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  00658	eb ce		 jmp	 SHORT $LN90@inflateBac
$LN91@inflateBac:

; 385  :             state->next = state->codes;

  0065a	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0065d	81 c2 34 05 00
	00		 add	 edx, 1332		; 00000534H
  00663	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00666	89 50 70	 mov	 DWORD PTR [eax+112], edx

; 386  :             state->lencode = (code const FAR *)(state->next);

  00669	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0066c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0066f	8b 42 70	 mov	 eax, DWORD PTR [edx+112]
  00672	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 387  :             state->lenbits = 7;

  00675	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00678	c7 41 58 07 00
	00 00		 mov	 DWORD PTR [ecx+88], 7

; 388  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  0067f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00682	81 c2 f4 02 00
	00		 add	 edx, 756		; 000002f4H
  00688	52		 push	 edx
  00689	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0068c	83 c0 58	 add	 eax, 88			; 00000058H
  0068f	50		 push	 eax
  00690	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00693	83 c1 70	 add	 ecx, 112		; 00000070H
  00696	51		 push	 ecx
  00697	6a 13		 push	 19			; 00000013H
  00699	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0069c	83 c2 74	 add	 edx, 116		; 00000074H
  0069f	52		 push	 edx
  006a0	6a 00		 push	 0
  006a2	e8 00 00 00 00	 call	 _inflate_table
  006a7	83 c4 18	 add	 esp, 24			; 00000018H
  006aa	89 45 b4	 mov	 DWORD PTR _ret$[ebp], eax

; 389  :                                 &(state->lenbits), state->work);
; 390  :             if (ret) {

  006ad	83 7d b4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  006b1	74 19		 je	 SHORT $LN280@inflateBac

; 391  :                 strm->msg = (char *)"invalid code lengths set";

  006b3	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  006b6	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@

; 392  :                 state->mode = BAD;

  006bd	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  006c0	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 393  :                 break;

  006c7	e9 76 0d 00 00	 jmp	 $LN5@inflateBac
$LN280@inflateBac:

; 394  :             }
; 395  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 396  : 
; 397  :             /* get length and distance code code lengths */
; 398  :             state->have = 0;

  006cc	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  006cf	c7 42 6c 00 00
	00 00		 mov	 DWORD PTR [edx+108], 0
$LN92@inflateBac:

; 399  :             while (state->have < state->nlen + state->ndist) {

  006d6	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  006d9	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  006dc	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  006df	03 4a 68	 add	 ecx, DWORD PTR [edx+104]
  006e2	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  006e5	39 48 6c	 cmp	 DWORD PTR [eax+108], ecx
  006e8	0f 83 f2 03 00
	00		 jae	 $LN93@inflateBac
$LN96@inflateBac:

; 400  :                 for (;;) {
; 401  :                     here = state->lencode[BITS(state->lenbits)];

  006ee	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  006f1	ba 01 00 00 00	 mov	 edx, 1
  006f6	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  006f9	d3 e2		 shl	 edx, cl
  006fb	83 ea 01	 sub	 edx, 1
  006fe	23 55 e0	 and	 edx, DWORD PTR _hold$[ebp]
  00701	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00704	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00707	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  0070a	89 55 cc	 mov	 DWORD PTR _here$[ebp], edx

; 402  :                     if ((unsigned)(here.bits) <= bits) break;

  0070d	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00711	3b 45 dc	 cmp	 eax, DWORD PTR _bits$[ebp]
  00714	77 02		 ja	 SHORT $LN102@inflateBac
  00716	eb 72		 jmp	 SHORT $LN95@inflateBac
$LN102@inflateBac:

; 403  :                     PULLBYTE();

  00718	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  0071c	75 33		 jne	 SHORT $LN100@inflateBac
  0071e	8b f4		 mov	 esi, esp
  00720	8d 4d f4	 lea	 ecx, DWORD PTR _next$[ebp]
  00723	51		 push	 ecx
  00724	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00727	52		 push	 edx
  00728	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0072b	83 c4 08	 add	 esp, 8
  0072e	3b f4		 cmp	 esi, esp
  00730	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00735	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  00738	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  0073c	75 13		 jne	 SHORT $LN100@inflateBac
  0073e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00745	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0074c	e9 f6 0c 00 00	 jmp	 $inf_leave$393
$LN100@inflateBac:
  00751	33 c0		 xor	 eax, eax
  00753	75 c3		 jne	 SHORT $LN102@inflateBac
  00755	8b 4d e8	 mov	 ecx, DWORD PTR _have$[ebp]
  00758	83 e9 01	 sub	 ecx, 1
  0075b	89 4d e8	 mov	 DWORD PTR _have$[ebp], ecx
  0075e	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  00761	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00764	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00767	d3 e0		 shl	 eax, cl
  00769	03 45 e0	 add	 eax, DWORD PTR _hold$[ebp]
  0076c	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  0076f	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  00772	83 c1 01	 add	 ecx, 1
  00775	89 4d f4	 mov	 DWORD PTR _next$[ebp], ecx
  00778	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  0077b	83 c2 08	 add	 edx, 8
  0077e	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  00781	33 c0		 xor	 eax, eax
  00783	75 93		 jne	 SHORT $LN102@inflateBac

; 404  :                 }

  00785	e9 64 ff ff ff	 jmp	 $LN96@inflateBac
$LN95@inflateBac:

; 405  :                 if (here.val < 16) {

  0078a	0f b7 4d ce	 movzx	 ecx, WORD PTR _here$[ebp+2]
  0078e	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00791	7d 45		 jge	 SHORT $LN284@inflateBac
  00793	0f ae e8	 lfence
$LN105@inflateBac:

; 406  :                     DROPBITS(here.bits);

  00796	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  0079a	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  0079d	d3 ea		 shr	 edx, cl
  0079f	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  007a2	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  007a6	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  007a9	2b c8		 sub	 ecx, eax
  007ab	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  007ae	33 d2		 xor	 edx, edx
  007b0	75 e4		 jne	 SHORT $LN105@inflateBac

; 407  :                     state->lens[state->have++] = here.val;

  007b2	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  007b5	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  007b8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  007bb	66 8b 45 ce	 mov	 ax, WORD PTR _here$[ebp+2]
  007bf	66 89 44 4a 74	 mov	 WORD PTR [edx+ecx*2+116], ax
  007c4	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  007c7	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  007ca	83 c2 01	 add	 edx, 1
  007cd	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  007d0	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 408  :                 }

  007d3	e9 03 03 00 00	 jmp	 $LN285@inflateBac
$LN284@inflateBac:

; 409  :                 else {
; 410  :                     if (here.val == 16) {

  007d8	0f b7 4d ce	 movzx	 ecx, WORD PTR _here$[ebp+2]
  007dc	83 f9 10	 cmp	 ecx, 16			; 00000010H
  007df	0f 85 f5 00 00
	00		 jne	 $LN286@inflateBac
$LN109@inflateBac:

; 411  :                         NEEDBITS(here.bits + 2);

  007e5	0f b6 55 cd	 movzx	 edx, BYTE PTR _here$[ebp+1]
  007e9	83 c2 02	 add	 edx, 2
  007ec	39 55 dc	 cmp	 DWORD PTR _bits$[ebp], edx
  007ef	73 6f		 jae	 SHORT $LN106@inflateBac
$LN116@inflateBac:
  007f1	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  007f5	75 33		 jne	 SHORT $LN114@inflateBac
  007f7	8b f4		 mov	 esi, esp
  007f9	8d 45 f4	 lea	 eax, DWORD PTR _next$[ebp]
  007fc	50		 push	 eax
  007fd	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00800	51		 push	 ecx
  00801	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00804	83 c4 08	 add	 esp, 8
  00807	3b f4		 cmp	 esi, esp
  00809	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0080e	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  00811	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00815	75 13		 jne	 SHORT $LN114@inflateBac
  00817	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0081e	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00825	e9 1d 0c 00 00	 jmp	 $inf_leave$393
$LN114@inflateBac:
  0082a	33 d2		 xor	 edx, edx
  0082c	75 c3		 jne	 SHORT $LN116@inflateBac
  0082e	8b 45 e8	 mov	 eax, DWORD PTR _have$[ebp]
  00831	83 e8 01	 sub	 eax, 1
  00834	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  00837	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  0083a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0083d	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00840	d3 e2		 shl	 edx, cl
  00842	03 55 e0	 add	 edx, DWORD PTR _hold$[ebp]
  00845	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  00848	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  0084b	83 c0 01	 add	 eax, 1
  0084e	89 45 f4	 mov	 DWORD PTR _next$[ebp], eax
  00851	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00854	83 c1 08	 add	 ecx, 8
  00857	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  0085a	33 d2		 xor	 edx, edx
  0085c	75 93		 jne	 SHORT $LN116@inflateBac
  0085e	eb 85		 jmp	 SHORT $LN109@inflateBac
$LN106@inflateBac:
  00860	33 c0		 xor	 eax, eax
  00862	75 81		 jne	 SHORT $LN109@inflateBac
$LN119@inflateBac:

; 412  :                         DROPBITS(here.bits);

  00864	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00868	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  0086b	d3 ea		 shr	 edx, cl
  0086d	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  00870	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00874	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00877	2b c8		 sub	 ecx, eax
  00879	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  0087c	33 d2		 xor	 edx, edx
  0087e	75 e4		 jne	 SHORT $LN119@inflateBac

; 413  :                         if (state->have == 0) {

  00880	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00883	83 78 6c 00	 cmp	 DWORD PTR [eax+108], 0
  00887	75 19		 jne	 SHORT $LN290@inflateBac

; 414  :                             strm->msg = (char *)"invalid bit length repeat";

  00889	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0088c	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@

; 415  :                             state->mode = BAD;

  00893	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00896	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 416  :                             break;

  0089d	e9 3e 02 00 00	 jmp	 $LN93@inflateBac
$LN290@inflateBac:

; 417  :                         }
; 418  :                         len = (unsigned)(state->lens[state->have - 1]);

  008a2	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  008a5	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  008a8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  008ab	0f b7 44 4a 72	 movzx	 eax, WORD PTR [edx+ecx*2+114]
  008b0	89 45 b8	 mov	 DWORD PTR _len$[ebp], eax

; 419  :                         copy = 3 + BITS(2);

  008b3	8b 4d e0	 mov	 ecx, DWORD PTR _hold$[ebp]
  008b6	83 e1 03	 and	 ecx, 3
  008b9	83 c1 03	 add	 ecx, 3
  008bc	89 4d d8	 mov	 DWORD PTR _copy$[ebp], ecx
$LN122@inflateBac:

; 420  :                         DROPBITS(2);

  008bf	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  008c2	c1 ea 02	 shr	 edx, 2
  008c5	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  008c8	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  008cb	83 e8 02	 sub	 eax, 2
  008ce	89 45 dc	 mov	 DWORD PTR _bits$[ebp], eax
  008d1	33 c9		 xor	 ecx, ecx
  008d3	75 ea		 jne	 SHORT $LN122@inflateBac

; 421  :                     }

  008d5	e9 9a 01 00 00	 jmp	 $LN287@inflateBac
$LN286@inflateBac:

; 422  :                     else if (here.val == 17) {

  008da	0f b7 55 ce	 movzx	 edx, WORD PTR _here$[ebp+2]
  008de	83 fa 11	 cmp	 edx, 17			; 00000011H
  008e1	0f 85 c9 00 00
	00		 jne	 $LN143@inflateBac
$LN126@inflateBac:

; 423  :                         NEEDBITS(here.bits + 3);

  008e7	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  008eb	83 c0 03	 add	 eax, 3
  008ee	39 45 dc	 cmp	 DWORD PTR _bits$[ebp], eax
  008f1	73 6f		 jae	 SHORT $LN123@inflateBac
$LN133@inflateBac:
  008f3	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  008f7	75 33		 jne	 SHORT $LN131@inflateBac
  008f9	8b f4		 mov	 esi, esp
  008fb	8d 4d f4	 lea	 ecx, DWORD PTR _next$[ebp]
  008fe	51		 push	 ecx
  008ff	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00902	52		 push	 edx
  00903	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00906	83 c4 08	 add	 esp, 8
  00909	3b f4		 cmp	 esi, esp
  0090b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00910	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  00913	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00917	75 13		 jne	 SHORT $LN131@inflateBac
  00919	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00920	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00927	e9 1b 0b 00 00	 jmp	 $inf_leave$393
$LN131@inflateBac:
  0092c	33 c0		 xor	 eax, eax
  0092e	75 c3		 jne	 SHORT $LN133@inflateBac
  00930	8b 4d e8	 mov	 ecx, DWORD PTR _have$[ebp]
  00933	83 e9 01	 sub	 ecx, 1
  00936	89 4d e8	 mov	 DWORD PTR _have$[ebp], ecx
  00939	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  0093c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0093f	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00942	d3 e0		 shl	 eax, cl
  00944	03 45 e0	 add	 eax, DWORD PTR _hold$[ebp]
  00947	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  0094a	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  0094d	83 c1 01	 add	 ecx, 1
  00950	89 4d f4	 mov	 DWORD PTR _next$[ebp], ecx
  00953	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  00956	83 c2 08	 add	 edx, 8
  00959	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  0095c	33 c0		 xor	 eax, eax
  0095e	75 93		 jne	 SHORT $LN133@inflateBac
  00960	eb 85		 jmp	 SHORT $LN126@inflateBac
$LN123@inflateBac:
  00962	33 c9		 xor	 ecx, ecx
  00964	75 81		 jne	 SHORT $LN126@inflateBac
$LN136@inflateBac:

; 424  :                         DROPBITS(here.bits);

  00966	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  0096a	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  0096d	d3 ea		 shr	 edx, cl
  0096f	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  00972	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00976	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00979	2b c8		 sub	 ecx, eax
  0097b	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  0097e	33 d2		 xor	 edx, edx
  00980	75 e4		 jne	 SHORT $LN136@inflateBac

; 425  :                         len = 0;

  00982	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 426  :                         copy = 3 + BITS(3);

  00989	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  0098c	83 e0 07	 and	 eax, 7
  0098f	83 c0 03	 add	 eax, 3
  00992	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax
$LN139@inflateBac:

; 427  :                         DROPBITS(3);

  00995	8b 4d e0	 mov	 ecx, DWORD PTR _hold$[ebp]
  00998	c1 e9 03	 shr	 ecx, 3
  0099b	89 4d e0	 mov	 DWORD PTR _hold$[ebp], ecx
  0099e	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  009a1	83 ea 03	 sub	 edx, 3
  009a4	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  009a7	33 c0		 xor	 eax, eax
  009a9	75 ea		 jne	 SHORT $LN139@inflateBac

; 428  :                     }

  009ab	e9 c4 00 00 00	 jmp	 $LN287@inflateBac
$LN143@inflateBac:

; 429  :                     else {
; 430  :                         NEEDBITS(here.bits + 7);

  009b0	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  009b4	83 c1 07	 add	 ecx, 7
  009b7	39 4d dc	 cmp	 DWORD PTR _bits$[ebp], ecx
  009ba	73 6f		 jae	 SHORT $LN140@inflateBac
$LN150@inflateBac:
  009bc	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  009c0	75 33		 jne	 SHORT $LN148@inflateBac
  009c2	8b f4		 mov	 esi, esp
  009c4	8d 55 f4	 lea	 edx, DWORD PTR _next$[ebp]
  009c7	52		 push	 edx
  009c8	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  009cb	50		 push	 eax
  009cc	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  009cf	83 c4 08	 add	 esp, 8
  009d2	3b f4		 cmp	 esi, esp
  009d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  009d9	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  009dc	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  009e0	75 13		 jne	 SHORT $LN148@inflateBac
  009e2	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  009e9	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  009f0	e9 52 0a 00 00	 jmp	 $inf_leave$393
$LN148@inflateBac:
  009f5	33 c9		 xor	 ecx, ecx
  009f7	75 c3		 jne	 SHORT $LN150@inflateBac
  009f9	8b 55 e8	 mov	 edx, DWORD PTR _have$[ebp]
  009fc	83 ea 01	 sub	 edx, 1
  009ff	89 55 e8	 mov	 DWORD PTR _have$[ebp], edx
  00a02	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  00a05	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00a08	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a0b	d3 e2		 shl	 edx, cl
  00a0d	03 55 e0	 add	 edx, DWORD PTR _hold$[ebp]
  00a10	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  00a13	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  00a16	83 c0 01	 add	 eax, 1
  00a19	89 45 f4	 mov	 DWORD PTR _next$[ebp], eax
  00a1c	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a1f	83 c1 08	 add	 ecx, 8
  00a22	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  00a25	33 d2		 xor	 edx, edx
  00a27	75 93		 jne	 SHORT $LN150@inflateBac
  00a29	eb 85		 jmp	 SHORT $LN143@inflateBac
$LN140@inflateBac:
  00a2b	33 c0		 xor	 eax, eax
  00a2d	75 81		 jne	 SHORT $LN143@inflateBac
$LN153@inflateBac:

; 431  :                         DROPBITS(here.bits);

  00a2f	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00a33	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  00a36	d3 ea		 shr	 edx, cl
  00a38	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  00a3b	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00a3f	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a42	2b c8		 sub	 ecx, eax
  00a44	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  00a47	33 d2		 xor	 edx, edx
  00a49	75 e4		 jne	 SHORT $LN153@inflateBac

; 432  :                         len = 0;

  00a4b	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 433  :                         copy = 11 + BITS(7);

  00a52	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  00a55	83 e0 7f	 and	 eax, 127		; 0000007fH
  00a58	83 c0 0b	 add	 eax, 11			; 0000000bH
  00a5b	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax
$LN156@inflateBac:

; 434  :                         DROPBITS(7);

  00a5e	8b 4d e0	 mov	 ecx, DWORD PTR _hold$[ebp]
  00a61	c1 e9 07	 shr	 ecx, 7
  00a64	89 4d e0	 mov	 DWORD PTR _hold$[ebp], ecx
  00a67	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  00a6a	83 ea 07	 sub	 edx, 7
  00a6d	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  00a70	33 c0		 xor	 eax, eax
  00a72	75 ea		 jne	 SHORT $LN156@inflateBac
$LN287@inflateBac:

; 435  :                     }
; 436  :                     if (state->have + copy > state->nlen + state->ndist) {

  00a74	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a77	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00a7a	03 55 d8	 add	 edx, DWORD PTR _copy$[ebp]
  00a7d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00a80	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00a83	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00a86	03 48 68	 add	 ecx, DWORD PTR [eax+104]
  00a89	3b d1		 cmp	 edx, ecx
  00a8b	76 16		 jbe	 SHORT $LN157@inflateBac

; 437  :                         strm->msg = (char *)"invalid bit length repeat";

  00a8d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00a90	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@

; 438  :                         state->mode = BAD;

  00a97	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00a9a	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 439  :                         break;

  00aa1	eb 3d		 jmp	 SHORT $LN93@inflateBac
$LN157@inflateBac:

; 440  :                     }
; 441  :                     while (copy--)

  00aa3	8b 45 d8	 mov	 eax, DWORD PTR _copy$[ebp]
  00aa6	89 45 a4	 mov	 DWORD PTR tv464[ebp], eax
  00aa9	8b 4d d8	 mov	 ecx, DWORD PTR _copy$[ebp]
  00aac	83 e9 01	 sub	 ecx, 1
  00aaf	89 4d d8	 mov	 DWORD PTR _copy$[ebp], ecx
  00ab2	83 7d a4 00	 cmp	 DWORD PTR tv464[ebp], 0
  00ab6	74 23		 je	 SHORT $LN285@inflateBac

; 442  :                         state->lens[state->have++] = (unsigned short)len;

  00ab8	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00abb	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00abe	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ac1	66 8b 55 b8	 mov	 dx, WORD PTR _len$[ebp]
  00ac5	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00aca	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00acd	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00ad0	83 c1 01	 add	 ecx, 1
  00ad3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00ad6	89 4a 6c	 mov	 DWORD PTR [edx+108], ecx
  00ad9	eb c8		 jmp	 SHORT $LN157@inflateBac
$LN285@inflateBac:

; 443  :                 }
; 444  :             }

  00adb	e9 f6 fb ff ff	 jmp	 $LN92@inflateBac
$LN93@inflateBac:

; 445  : 
; 446  :             /* handle error breaks in while */
; 447  :             if (state->mode == BAD) break;

  00ae0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00ae3	81 78 04 51 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16209 ; 00003f51H
  00aea	75 05		 jne	 SHORT $LN298@inflateBac
  00aec	e9 51 09 00 00	 jmp	 $LN5@inflateBac
$LN298@inflateBac:

; 448  : 
; 449  :             /* check for end-of-block code (better have one) */
; 450  :             if (state->lens[256] == 0) {

  00af1	b9 02 00 00 00	 mov	 ecx, 2
  00af6	c1 e1 08	 shl	 ecx, 8
  00af9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00afc	0f b7 44 0a 74	 movzx	 eax, WORD PTR [edx+ecx+116]
  00b01	85 c0		 test	 eax, eax
  00b03	75 19		 jne	 SHORT $LN299@inflateBac

; 451  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00b05	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00b08	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@

; 452  :                 state->mode = BAD;

  00b0f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00b12	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 453  :                 break;

  00b19	e9 24 09 00 00	 jmp	 $LN5@inflateBac
$LN299@inflateBac:

; 454  :             }
; 455  : 
; 456  :             /* build code tables -- note: do not change the lenbits or distbits
; 457  :                values here (9 and 6) without reading the comments in inftrees.h
; 458  :                concerning the ENOUGH constants, which depend on those values */
; 459  :             state->next = state->codes;

  00b1e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00b21	05 34 05 00 00	 add	 eax, 1332		; 00000534H
  00b26	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b29	89 41 70	 mov	 DWORD PTR [ecx+112], eax

; 460  :             state->lencode = (code const FAR *)(state->next);

  00b2c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00b2f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00b32	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00b35	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 461  :             state->lenbits = 9;

  00b38	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00b3b	c7 42 58 09 00
	00 00		 mov	 DWORD PTR [edx+88], 9

; 462  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00b42	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00b45	05 f4 02 00 00	 add	 eax, 756		; 000002f4H
  00b4a	50		 push	 eax
  00b4b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b4e	83 c1 58	 add	 ecx, 88			; 00000058H
  00b51	51		 push	 ecx
  00b52	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00b55	83 c2 70	 add	 edx, 112		; 00000070H
  00b58	52		 push	 edx
  00b59	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00b5c	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00b5f	51		 push	 ecx
  00b60	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00b63	83 c2 74	 add	 edx, 116		; 00000074H
  00b66	52		 push	 edx
  00b67	6a 01		 push	 1
  00b69	e8 00 00 00 00	 call	 _inflate_table
  00b6e	83 c4 18	 add	 esp, 24			; 00000018H
  00b71	89 45 b4	 mov	 DWORD PTR _ret$[ebp], eax

; 463  :                                 &(state->lenbits), state->work);
; 464  :             if (ret) {

  00b74	83 7d b4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00b78	74 19		 je	 SHORT $LN300@inflateBac

; 465  :                 strm->msg = (char *)"invalid literal/lengths set";

  00b7a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b7d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@

; 466  :                 state->mode = BAD;

  00b84	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b87	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 467  :                 break;

  00b8e	e9 af 08 00 00	 jmp	 $LN5@inflateBac
$LN300@inflateBac:

; 468  :             }
; 469  :             state->distcode = (code const FAR *)(state->next);

  00b93	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00b96	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00b99	8b 48 70	 mov	 ecx, DWORD PTR [eax+112]
  00b9c	89 4a 54	 mov	 DWORD PTR [edx+84], ecx

; 470  :             state->distbits = 6;

  00b9f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00ba2	c7 42 5c 06 00
	00 00		 mov	 DWORD PTR [edx+92], 6

; 471  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00ba9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00bac	05 f4 02 00 00	 add	 eax, 756		; 000002f4H
  00bb1	50		 push	 eax
  00bb2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00bb5	83 c1 5c	 add	 ecx, 92			; 0000005cH
  00bb8	51		 push	 ecx
  00bb9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00bbc	83 c2 70	 add	 edx, 112		; 00000070H
  00bbf	52		 push	 edx
  00bc0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00bc3	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00bc6	51		 push	 ecx
  00bc7	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00bca	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  00bcd	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00bd0	8d 54 41 74	 lea	 edx, DWORD PTR [ecx+eax*2+116]
  00bd4	52		 push	 edx
  00bd5	6a 02		 push	 2
  00bd7	e8 00 00 00 00	 call	 _inflate_table
  00bdc	83 c4 18	 add	 esp, 24			; 00000018H
  00bdf	89 45 b4	 mov	 DWORD PTR _ret$[ebp], eax

; 472  :                             &(state->next), &(state->distbits), state->work);
; 473  :             if (ret) {

  00be2	83 7d b4 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00be6	74 19		 je	 SHORT $LN301@inflateBac

; 474  :                 strm->msg = (char *)"invalid distances set";

  00be8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00beb	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@

; 475  :                 state->mode = BAD;

  00bf2	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00bf5	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 476  :                 break;

  00bfc	e9 41 08 00 00	 jmp	 $LN5@inflateBac
$LN301@inflateBac:

; 477  :             }
; 478  :             Tracev((stderr, "inflate:       codes ok\n"));
; 479  :             state->mode = LEN;

  00c01	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00c04	c7 42 04 48 3f
	00 00		 mov	 DWORD PTR [edx+4], 16200 ; 00003f48H
$LN302@inflateBac:

; 480  : 
; 481  :         case LEN:
; 482  :             /* use inflate_fast() if we have enough input and output */
; 483  :             if (have >= 6 && left >= 258) {

  00c0b	83 7d e8 06	 cmp	 DWORD PTR _have$[ebp], 6
  00c0f	0f 82 b7 00 00
	00		 jb	 $LN167@inflateBac
  00c15	81 7d e4 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  00c1c	0f 82 aa 00 00
	00		 jb	 $LN167@inflateBac
  00c22	0f ae e8	 lfence
$LN161@inflateBac:

; 484  :                 RESTORE();

  00c25	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c28	8b 4d ec	 mov	 ecx, DWORD PTR _put$[ebp]
  00c2b	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00c2e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00c31	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00c34	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00c37	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c3a	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  00c3d	89 11		 mov	 DWORD PTR [ecx], edx
  00c3f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c42	8b 4d e8	 mov	 ecx, DWORD PTR _have$[ebp]
  00c45	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00c48	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00c4b	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  00c4e	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  00c51	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c54	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  00c57	89 51 40	 mov	 DWORD PTR [ecx+64], edx
  00c5a	33 c0		 xor	 eax, eax
  00c5c	75 c7		 jne	 SHORT $LN161@inflateBac

; 485  :                 if (state->whave < state->wsize)

  00c5e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c61	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00c64	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  00c67	3b 42 2c	 cmp	 eax, DWORD PTR [edx+44]
  00c6a	73 0f		 jae	 SHORT $LN304@inflateBac

; 486  :                     state->whave = state->wsize - left;

  00c6c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c6f	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00c72	2b 55 e4	 sub	 edx, DWORD PTR _left$[ebp]
  00c75	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00c78	89 50 30	 mov	 DWORD PTR [eax+48], edx
$LN304@inflateBac:

; 487  :                 inflate_fast(strm, state->wsize);

  00c7b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c7e	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00c81	52		 push	 edx
  00c82	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c85	50		 push	 eax
  00c86	e8 00 00 00 00	 call	 _inflate_fast
  00c8b	83 c4 08	 add	 esp, 8
$LN164@inflateBac:

; 488  :                 LOAD();

  00c8e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c91	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00c94	89 55 ec	 mov	 DWORD PTR _put$[ebp], edx
  00c97	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c9a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00c9d	89 4d e4	 mov	 DWORD PTR _left$[ebp], ecx
  00ca0	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00ca3	8b 02		 mov	 eax, DWORD PTR [edx]
  00ca5	89 45 f4	 mov	 DWORD PTR _next$[ebp], eax
  00ca8	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00cab	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00cae	89 55 e8	 mov	 DWORD PTR _have$[ebp], edx
  00cb1	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00cb4	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00cb7	89 4d e0	 mov	 DWORD PTR _hold$[ebp], ecx
  00cba	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00cbd	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00cc0	89 45 dc	 mov	 DWORD PTR _bits$[ebp], eax
  00cc3	33 c9		 xor	 ecx, ecx
  00cc5	75 c7		 jne	 SHORT $LN164@inflateBac

; 489  :                 break;

  00cc7	e9 76 07 00 00	 jmp	 $LN5@inflateBac
$LN167@inflateBac:

; 490  :             }
; 491  : 
; 492  :             /* get a literal, length, or end-of-block code */
; 493  :             for (;;) {
; 494  :                 here = state->lencode[BITS(state->lenbits)];

  00ccc	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00ccf	b8 01 00 00 00	 mov	 eax, 1
  00cd4	8b 4a 58	 mov	 ecx, DWORD PTR [edx+88]
  00cd7	d3 e0		 shl	 eax, cl
  00cd9	83 e8 01	 sub	 eax, 1
  00cdc	23 45 e0	 and	 eax, DWORD PTR _hold$[ebp]
  00cdf	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ce2	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00ce5	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00ce8	89 45 cc	 mov	 DWORD PTR _here$[ebp], eax

; 495  :                 if ((unsigned)(here.bits) <= bits) break;

  00ceb	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00cef	3b 4d dc	 cmp	 ecx, DWORD PTR _bits$[ebp]
  00cf2	77 02		 ja	 SHORT $LN173@inflateBac
  00cf4	eb 72		 jmp	 SHORT $LN166@inflateBac
$LN173@inflateBac:

; 496  :                 PULLBYTE();

  00cf6	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00cfa	75 33		 jne	 SHORT $LN171@inflateBac
  00cfc	8b f4		 mov	 esi, esp
  00cfe	8d 55 f4	 lea	 edx, DWORD PTR _next$[ebp]
  00d01	52		 push	 edx
  00d02	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00d05	50		 push	 eax
  00d06	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00d09	83 c4 08	 add	 esp, 8
  00d0c	3b f4		 cmp	 esi, esp
  00d0e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00d13	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  00d16	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d1a	75 13		 jne	 SHORT $LN171@inflateBac
  00d1c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00d23	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00d2a	e9 18 07 00 00	 jmp	 $inf_leave$393
$LN171@inflateBac:
  00d2f	33 c9		 xor	 ecx, ecx
  00d31	75 c3		 jne	 SHORT $LN173@inflateBac
  00d33	8b 55 e8	 mov	 edx, DWORD PTR _have$[ebp]
  00d36	83 ea 01	 sub	 edx, 1
  00d39	89 55 e8	 mov	 DWORD PTR _have$[ebp], edx
  00d3c	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  00d3f	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00d42	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d45	d3 e2		 shl	 edx, cl
  00d47	03 55 e0	 add	 edx, DWORD PTR _hold$[ebp]
  00d4a	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  00d4d	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  00d50	83 c0 01	 add	 eax, 1
  00d53	89 45 f4	 mov	 DWORD PTR _next$[ebp], eax
  00d56	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00d59	83 c1 08	 add	 ecx, 8
  00d5c	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  00d5f	33 d2		 xor	 edx, edx
  00d61	75 93		 jne	 SHORT $LN173@inflateBac

; 497  :             }

  00d63	e9 64 ff ff ff	 jmp	 $LN167@inflateBac
$LN166@inflateBac:

; 498  :             if (here.op && (here.op & 0xf0) == 0) {

  00d68	0f b6 45 cc	 movzx	 eax, BYTE PTR _here$[ebp]
  00d6c	85 c0		 test	 eax, eax
  00d6e	0f 84 e4 00 00
	00		 je	 $LN188@inflateBac
  00d74	0f b6 4d cc	 movzx	 ecx, BYTE PTR _here$[ebp]
  00d78	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00d7e	0f 85 d4 00 00
	00		 jne	 $LN188@inflateBac

; 499  :                 last = here;

  00d84	8b 55 cc	 mov	 edx, DWORD PTR _here$[ebp]
  00d87	89 55 c0	 mov	 DWORD PTR _last$[ebp], edx
$LN176@inflateBac:

; 500  :                 for (;;) {
; 501  :                     here = state->lencode[last.val +

  00d8a	0f b7 45 c2	 movzx	 eax, WORD PTR _last$[ebp+2]
  00d8e	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00d92	0f b6 55 c0	 movzx	 edx, BYTE PTR _last$[ebp]
  00d96	03 ca		 add	 ecx, edx
  00d98	ba 01 00 00 00	 mov	 edx, 1
  00d9d	d3 e2		 shl	 edx, cl
  00d9f	83 ea 01	 sub	 edx, 1
  00da2	23 55 e0	 and	 edx, DWORD PTR _hold$[ebp]
  00da5	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00da9	d3 ea		 shr	 edx, cl
  00dab	03 c2		 add	 eax, edx
  00dad	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00db0	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00db3	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  00db6	89 45 cc	 mov	 DWORD PTR _here$[ebp], eax

; 502  :                             (BITS(last.bits + last.op) >> last.bits)];
; 503  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00db9	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00dbd	0f b6 55 cd	 movzx	 edx, BYTE PTR _here$[ebp+1]
  00dc1	03 ca		 add	 ecx, edx
  00dc3	3b 4d dc	 cmp	 ecx, DWORD PTR _bits$[ebp]
  00dc6	77 02		 ja	 SHORT $LN182@inflateBac
  00dc8	eb 72		 jmp	 SHORT $LN185@inflateBac
$LN182@inflateBac:

; 504  :                     PULLBYTE();

  00dca	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00dce	75 33		 jne	 SHORT $LN180@inflateBac
  00dd0	8b f4		 mov	 esi, esp
  00dd2	8d 45 f4	 lea	 eax, DWORD PTR _next$[ebp]
  00dd5	50		 push	 eax
  00dd6	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00dd9	51		 push	 ecx
  00dda	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00ddd	83 c4 08	 add	 esp, 8
  00de0	3b f4		 cmp	 esi, esp
  00de2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00de7	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  00dea	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00dee	75 13		 jne	 SHORT $LN180@inflateBac
  00df0	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00df7	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00dfe	e9 44 06 00 00	 jmp	 $inf_leave$393
$LN180@inflateBac:
  00e03	33 d2		 xor	 edx, edx
  00e05	75 c3		 jne	 SHORT $LN182@inflateBac
  00e07	8b 45 e8	 mov	 eax, DWORD PTR _have$[ebp]
  00e0a	83 e8 01	 sub	 eax, 1
  00e0d	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  00e10	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  00e13	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00e16	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00e19	d3 e2		 shl	 edx, cl
  00e1b	03 55 e0	 add	 edx, DWORD PTR _hold$[ebp]
  00e1e	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  00e21	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  00e24	83 c0 01	 add	 eax, 1
  00e27	89 45 f4	 mov	 DWORD PTR _next$[ebp], eax
  00e2a	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00e2d	83 c1 08	 add	 ecx, 8
  00e30	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  00e33	33 d2		 xor	 edx, edx
  00e35	75 93		 jne	 SHORT $LN182@inflateBac

; 505  :                 }

  00e37	e9 4e ff ff ff	 jmp	 $LN176@inflateBac
$LN185@inflateBac:

; 506  :                 DROPBITS(last.bits);

  00e3c	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00e40	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  00e43	d3 e8		 shr	 eax, cl
  00e45	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  00e48	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00e4c	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  00e4f	2b d1		 sub	 edx, ecx
  00e51	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  00e54	33 c0		 xor	 eax, eax
  00e56	75 e4		 jne	 SHORT $LN185@inflateBac
$LN188@inflateBac:

; 507  :             }
; 508  :             DROPBITS(here.bits);

  00e58	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  00e5c	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  00e5f	d3 ea		 shr	 edx, cl
  00e61	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  00e64	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  00e68	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00e6b	2b c8		 sub	 ecx, eax
  00e6d	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  00e70	33 d2		 xor	 edx, edx
  00e72	75 e4		 jne	 SHORT $LN188@inflateBac

; 509  :             state->length = (unsigned)here.val;

  00e74	0f b7 45 ce	 movzx	 eax, WORD PTR _here$[ebp+2]
  00e78	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00e7b	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 510  : 
; 511  :             /* process literal */
; 512  :             if (here.op == 0) {

  00e7e	0f b6 55 cc	 movzx	 edx, BYTE PTR _here$[ebp]
  00e82	85 d2		 test	 edx, edx
  00e84	75 7c		 jne	 SHORT $LN312@inflateBac
$LN191@inflateBac:

; 513  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 514  :                         "inflate:         literal '%c'\n" :
; 515  :                         "inflate:         literal 0x%02x\n", here.val));
; 516  :                 ROOM();

  00e86	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  00e8a	75 46		 jne	 SHORT $LN189@inflateBac
  00e8c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00e8f	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00e92	89 4d ec	 mov	 DWORD PTR _put$[ebp], ecx
  00e95	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00e98	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00e9b	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  00e9e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ea1	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  00ea4	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  00ea7	8b f4		 mov	 esi, esp
  00ea9	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00eac	50		 push	 eax
  00ead	8b 4d ec	 mov	 ecx, DWORD PTR _put$[ebp]
  00eb0	51		 push	 ecx
  00eb1	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  00eb4	52		 push	 edx
  00eb5	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00eb8	83 c4 0c	 add	 esp, 12			; 0000000cH
  00ebb	3b f4		 cmp	 esi, esp
  00ebd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00ec2	85 c0		 test	 eax, eax
  00ec4	74 0c		 je	 SHORT $LN189@inflateBac
  00ec6	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00ecd	e9 75 05 00 00	 jmp	 $inf_leave$393
$LN189@inflateBac:
  00ed2	33 c0		 xor	 eax, eax
  00ed4	75 b0		 jne	 SHORT $LN191@inflateBac

; 517  :                 *put++ = (unsigned char)(state->length);

  00ed6	8b 4d ec	 mov	 ecx, DWORD PTR _put$[ebp]
  00ed9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00edc	8a 42 44	 mov	 al, BYTE PTR [edx+68]
  00edf	88 01		 mov	 BYTE PTR [ecx], al
  00ee1	8b 4d ec	 mov	 ecx, DWORD PTR _put$[ebp]
  00ee4	83 c1 01	 add	 ecx, 1
  00ee7	89 4d ec	 mov	 DWORD PTR _put$[ebp], ecx

; 518  :                 left--;

  00eea	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  00eed	83 ea 01	 sub	 edx, 1
  00ef0	89 55 e4	 mov	 DWORD PTR _left$[ebp], edx

; 519  :                 state->mode = LEN;

  00ef3	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00ef6	c7 40 04 48 3f
	00 00		 mov	 DWORD PTR [eax+4], 16200 ; 00003f48H

; 520  :                 break;

  00efd	e9 40 05 00 00	 jmp	 $LN5@inflateBac
$LN312@inflateBac:

; 521  :             }
; 522  : 
; 523  :             /* process end of block */
; 524  :             if (here.op & 32) {

  00f02	0f b6 4d cc	 movzx	 ecx, BYTE PTR _here$[ebp]
  00f06	83 e1 20	 and	 ecx, 32			; 00000020H
  00f09	74 0f		 je	 SHORT $LN315@inflateBac

; 525  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 526  :                 state->mode = TYPE;

  00f0b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00f0e	c7 42 04 3f 3f
	00 00		 mov	 DWORD PTR [edx+4], 16191 ; 00003f3fH

; 527  :                 break;

  00f15	e9 28 05 00 00	 jmp	 $LN5@inflateBac
$LN315@inflateBac:

; 528  :             }
; 529  : 
; 530  :             /* invalid code */
; 531  :             if (here.op & 64) {

  00f1a	0f b6 45 cc	 movzx	 eax, BYTE PTR _here$[ebp]
  00f1e	83 e0 40	 and	 eax, 64			; 00000040H
  00f21	74 19		 je	 SHORT $LN316@inflateBac

; 532  :                 strm->msg = (char *)"invalid literal/length code";

  00f23	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00f26	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 533  :                 state->mode = BAD;

  00f2d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00f30	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 534  :                 break;

  00f37	e9 06 05 00 00	 jmp	 $LN5@inflateBac
$LN316@inflateBac:

; 535  :             }
; 536  : 
; 537  :             /* length code -- get extra bits, if any */
; 538  :             state->extra = (unsigned)(here.op) & 15;

  00f3c	0f b6 45 cc	 movzx	 eax, BYTE PTR _here$[ebp]
  00f40	83 e0 0f	 and	 eax, 15			; 0000000fH
  00f43	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f46	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 539  :             if (state->extra != 0) {

  00f49	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00f4c	83 7a 4c 00	 cmp	 DWORD PTR [edx+76], 0
  00f50	0f 84 be 00 00
	00		 je	 $LN208@inflateBac
$LN195@inflateBac:

; 540  :                 NEEDBITS(state->extra);

  00f56	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00f59	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f5c	3b 48 4c	 cmp	 ecx, DWORD PTR [eax+76]
  00f5f	73 6f		 jae	 SHORT $LN192@inflateBac
$LN202@inflateBac:
  00f61	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f65	75 33		 jne	 SHORT $LN200@inflateBac
  00f67	8b f4		 mov	 esi, esp
  00f69	8d 55 f4	 lea	 edx, DWORD PTR _next$[ebp]
  00f6c	52		 push	 edx
  00f6d	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  00f70	50		 push	 eax
  00f71	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00f74	83 c4 08	 add	 esp, 8
  00f77	3b f4		 cmp	 esi, esp
  00f79	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00f7e	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  00f81	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f85	75 13		 jne	 SHORT $LN200@inflateBac
  00f87	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00f8e	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00f95	e9 ad 04 00 00	 jmp	 $inf_leave$393
$LN200@inflateBac:
  00f9a	33 c9		 xor	 ecx, ecx
  00f9c	75 c3		 jne	 SHORT $LN202@inflateBac
  00f9e	8b 55 e8	 mov	 edx, DWORD PTR _have$[ebp]
  00fa1	83 ea 01	 sub	 edx, 1
  00fa4	89 55 e8	 mov	 DWORD PTR _have$[ebp], edx
  00fa7	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  00faa	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00fad	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00fb0	d3 e2		 shl	 edx, cl
  00fb2	03 55 e0	 add	 edx, DWORD PTR _hold$[ebp]
  00fb5	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  00fb8	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  00fbb	83 c0 01	 add	 eax, 1
  00fbe	89 45 f4	 mov	 DWORD PTR _next$[ebp], eax
  00fc1	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  00fc4	83 c1 08	 add	 ecx, 8
  00fc7	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  00fca	33 d2		 xor	 edx, edx
  00fcc	75 93		 jne	 SHORT $LN202@inflateBac
  00fce	eb 86		 jmp	 SHORT $LN195@inflateBac
$LN192@inflateBac:
  00fd0	33 c0		 xor	 eax, eax
  00fd2	75 82		 jne	 SHORT $LN195@inflateBac

; 541  :                 state->length += BITS(state->extra);

  00fd4	0f ae e8	 lfence
  00fd7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00fda	ba 01 00 00 00	 mov	 edx, 1
  00fdf	8b 49 4c	 mov	 ecx, DWORD PTR [ecx+76]
  00fe2	d3 e2		 shl	 edx, cl
  00fe4	83 ea 01	 sub	 edx, 1
  00fe7	23 55 e0	 and	 edx, DWORD PTR _hold$[ebp]
  00fea	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00fed	03 50 44	 add	 edx, DWORD PTR [eax+68]
  00ff0	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ff3	89 51 44	 mov	 DWORD PTR [ecx+68], edx
$LN205@inflateBac:

; 542  :                 DROPBITS(state->extra);

  00ff6	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00ff9	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  00ffc	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  00fff	d3 e8		 shr	 eax, cl
  01001	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  01004	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01007	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  0100a	2b 51 4c	 sub	 edx, DWORD PTR [ecx+76]
  0100d	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  01010	33 c0		 xor	 eax, eax
  01012	75 e2		 jne	 SHORT $LN205@inflateBac
$LN208@inflateBac:

; 543  :             }
; 544  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 545  : 
; 546  :             /* get distance code */
; 547  :             for (;;) {
; 548  :                 here = state->distcode[BITS(state->distbits)];

  01014	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01017	ba 01 00 00 00	 mov	 edx, 1
  0101c	8b 49 5c	 mov	 ecx, DWORD PTR [ecx+92]
  0101f	d3 e2		 shl	 edx, cl
  01021	83 ea 01	 sub	 edx, 1
  01024	23 55 e0	 and	 edx, DWORD PTR _hold$[ebp]
  01027	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0102a	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  0102d	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  01030	89 55 cc	 mov	 DWORD PTR _here$[ebp], edx

; 549  :                 if ((unsigned)(here.bits) <= bits) break;

  01033	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  01037	3b 45 dc	 cmp	 eax, DWORD PTR _bits$[ebp]
  0103a	77 02		 ja	 SHORT $LN214@inflateBac
  0103c	eb 72		 jmp	 SHORT $LN207@inflateBac
$LN214@inflateBac:

; 550  :                 PULLBYTE();

  0103e	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  01042	75 33		 jne	 SHORT $LN212@inflateBac
  01044	8b f4		 mov	 esi, esp
  01046	8d 4d f4	 lea	 ecx, DWORD PTR _next$[ebp]
  01049	51		 push	 ecx
  0104a	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  0104d	52		 push	 edx
  0104e	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  01051	83 c4 08	 add	 esp, 8
  01054	3b f4		 cmp	 esi, esp
  01056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0105b	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  0105e	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  01062	75 13		 jne	 SHORT $LN212@inflateBac
  01064	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0106b	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  01072	e9 d0 03 00 00	 jmp	 $inf_leave$393
$LN212@inflateBac:
  01077	33 c0		 xor	 eax, eax
  01079	75 c3		 jne	 SHORT $LN214@inflateBac
  0107b	8b 4d e8	 mov	 ecx, DWORD PTR _have$[ebp]
  0107e	83 e9 01	 sub	 ecx, 1
  01081	89 4d e8	 mov	 DWORD PTR _have$[ebp], ecx
  01084	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  01087	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0108a	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  0108d	d3 e0		 shl	 eax, cl
  0108f	03 45 e0	 add	 eax, DWORD PTR _hold$[ebp]
  01092	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  01095	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  01098	83 c1 01	 add	 ecx, 1
  0109b	89 4d f4	 mov	 DWORD PTR _next$[ebp], ecx
  0109e	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  010a1	83 c2 08	 add	 edx, 8
  010a4	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  010a7	33 c0		 xor	 eax, eax
  010a9	75 93		 jne	 SHORT $LN214@inflateBac

; 551  :             }

  010ab	e9 64 ff ff ff	 jmp	 $LN208@inflateBac
$LN207@inflateBac:

; 552  :             if ((here.op & 0xf0) == 0) {

  010b0	0f b6 4d cc	 movzx	 ecx, BYTE PTR _here$[ebp]
  010b4	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  010ba	0f 85 d4 00 00
	00		 jne	 $LN229@inflateBac

; 553  :                 last = here;

  010c0	8b 55 cc	 mov	 edx, DWORD PTR _here$[ebp]
  010c3	89 55 c0	 mov	 DWORD PTR _last$[ebp], edx
$LN217@inflateBac:

; 554  :                 for (;;) {
; 555  :                     here = state->distcode[last.val +

  010c6	0f b7 45 c2	 movzx	 eax, WORD PTR _last$[ebp+2]
  010ca	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  010ce	0f b6 55 c0	 movzx	 edx, BYTE PTR _last$[ebp]
  010d2	03 ca		 add	 ecx, edx
  010d4	ba 01 00 00 00	 mov	 edx, 1
  010d9	d3 e2		 shl	 edx, cl
  010db	83 ea 01	 sub	 edx, 1
  010de	23 55 e0	 and	 edx, DWORD PTR _hold$[ebp]
  010e1	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  010e5	d3 ea		 shr	 edx, cl
  010e7	03 c2		 add	 eax, edx
  010e9	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  010ec	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  010ef	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  010f2	89 45 cc	 mov	 DWORD PTR _here$[ebp], eax

; 556  :                             (BITS(last.bits + last.op) >> last.bits)];
; 557  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  010f5	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  010f9	0f b6 55 cd	 movzx	 edx, BYTE PTR _here$[ebp+1]
  010fd	03 ca		 add	 ecx, edx
  010ff	3b 4d dc	 cmp	 ecx, DWORD PTR _bits$[ebp]
  01102	77 02		 ja	 SHORT $LN223@inflateBac
  01104	eb 72		 jmp	 SHORT $LN226@inflateBac
$LN223@inflateBac:

; 558  :                     PULLBYTE();

  01106	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  0110a	75 33		 jne	 SHORT $LN221@inflateBac
  0110c	8b f4		 mov	 esi, esp
  0110e	8d 45 f4	 lea	 eax, DWORD PTR _next$[ebp]
  01111	50		 push	 eax
  01112	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  01115	51		 push	 ecx
  01116	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  01119	83 c4 08	 add	 esp, 8
  0111c	3b f4		 cmp	 esi, esp
  0111e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01123	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  01126	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  0112a	75 13		 jne	 SHORT $LN221@inflateBac
  0112c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  01133	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0113a	e9 08 03 00 00	 jmp	 $inf_leave$393
$LN221@inflateBac:
  0113f	33 d2		 xor	 edx, edx
  01141	75 c3		 jne	 SHORT $LN223@inflateBac
  01143	8b 45 e8	 mov	 eax, DWORD PTR _have$[ebp]
  01146	83 e8 01	 sub	 eax, 1
  01149	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  0114c	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  0114f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  01152	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  01155	d3 e2		 shl	 edx, cl
  01157	03 55 e0	 add	 edx, DWORD PTR _hold$[ebp]
  0115a	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  0115d	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  01160	83 c0 01	 add	 eax, 1
  01163	89 45 f4	 mov	 DWORD PTR _next$[ebp], eax
  01166	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  01169	83 c1 08	 add	 ecx, 8
  0116c	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  0116f	33 d2		 xor	 edx, edx
  01171	75 93		 jne	 SHORT $LN223@inflateBac

; 559  :                 }

  01173	e9 4e ff ff ff	 jmp	 $LN217@inflateBac
$LN226@inflateBac:

; 560  :                 DROPBITS(last.bits);

  01178	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0117c	8b 45 e0	 mov	 eax, DWORD PTR _hold$[ebp]
  0117f	d3 e8		 shr	 eax, cl
  01181	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  01184	0f b6 4d c1	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01188	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  0118b	2b d1		 sub	 edx, ecx
  0118d	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  01190	33 c0		 xor	 eax, eax
  01192	75 e4		 jne	 SHORT $LN226@inflateBac
$LN229@inflateBac:

; 561  :             }
; 562  :             DROPBITS(here.bits);

  01194	0f b6 4d cd	 movzx	 ecx, BYTE PTR _here$[ebp+1]
  01198	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  0119b	d3 ea		 shr	 edx, cl
  0119d	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  011a0	0f b6 45 cd	 movzx	 eax, BYTE PTR _here$[ebp+1]
  011a4	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  011a7	2b c8		 sub	 ecx, eax
  011a9	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  011ac	33 d2		 xor	 edx, edx
  011ae	75 e4		 jne	 SHORT $LN229@inflateBac

; 563  :             if (here.op & 64) {

  011b0	0f b6 45 cc	 movzx	 eax, BYTE PTR _here$[ebp]
  011b4	83 e0 40	 and	 eax, 64			; 00000040H
  011b7	74 19		 je	 SHORT $LN327@inflateBac

; 564  :                 strm->msg = (char *)"invalid distance code";

  011b9	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  011bc	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code@

; 565  :                 state->mode = BAD;

  011c3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  011c6	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 566  :                 break;

  011cd	e9 70 02 00 00	 jmp	 $LN5@inflateBac
$LN327@inflateBac:

; 567  :             }
; 568  :             state->offset = (unsigned)here.val;

  011d2	0f b7 45 ce	 movzx	 eax, WORD PTR _here$[ebp+2]
  011d6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  011d9	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 569  : 
; 570  :             /* get distance extra bits, if any */
; 571  :             state->extra = (unsigned)(here.op) & 15;

  011dc	0f b6 55 cc	 movzx	 edx, BYTE PTR _here$[ebp]
  011e0	83 e2 0f	 and	 edx, 15			; 0000000fH
  011e3	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  011e6	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 572  :             if (state->extra != 0) {

  011e9	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  011ec	83 79 4c 00	 cmp	 DWORD PTR [ecx+76], 0
  011f0	0f 84 bb 00 00
	00		 je	 $LN328@inflateBac
$LN233@inflateBac:

; 573  :                 NEEDBITS(state->extra);

  011f6	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  011f9	8b 45 dc	 mov	 eax, DWORD PTR _bits$[ebp]
  011fc	3b 42 4c	 cmp	 eax, DWORD PTR [edx+76]
  011ff	73 6f		 jae	 SHORT $LN230@inflateBac
$LN240@inflateBac:
  01201	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  01205	75 33		 jne	 SHORT $LN238@inflateBac
  01207	8b f4		 mov	 esi, esp
  01209	8d 4d f4	 lea	 ecx, DWORD PTR _next$[ebp]
  0120c	51		 push	 ecx
  0120d	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  01210	52		 push	 edx
  01211	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  01214	83 c4 08	 add	 esp, 8
  01217	3b f4		 cmp	 esi, esp
  01219	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0121e	89 45 e8	 mov	 DWORD PTR _have$[ebp], eax
  01221	83 7d e8 00	 cmp	 DWORD PTR _have$[ebp], 0
  01225	75 13		 jne	 SHORT $LN238@inflateBac
  01227	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0122e	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  01235	e9 0d 02 00 00	 jmp	 $inf_leave$393
$LN238@inflateBac:
  0123a	33 c0		 xor	 eax, eax
  0123c	75 c3		 jne	 SHORT $LN240@inflateBac
  0123e	8b 4d e8	 mov	 ecx, DWORD PTR _have$[ebp]
  01241	83 e9 01	 sub	 ecx, 1
  01244	89 4d e8	 mov	 DWORD PTR _have$[ebp], ecx
  01247	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  0124a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0124d	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  01250	d3 e0		 shl	 eax, cl
  01252	03 45 e0	 add	 eax, DWORD PTR _hold$[ebp]
  01255	89 45 e0	 mov	 DWORD PTR _hold$[ebp], eax
  01258	8b 4d f4	 mov	 ecx, DWORD PTR _next$[ebp]
  0125b	83 c1 01	 add	 ecx, 1
  0125e	89 4d f4	 mov	 DWORD PTR _next$[ebp], ecx
  01261	8b 55 dc	 mov	 edx, DWORD PTR _bits$[ebp]
  01264	83 c2 08	 add	 edx, 8
  01267	89 55 dc	 mov	 DWORD PTR _bits$[ebp], edx
  0126a	33 c0		 xor	 eax, eax
  0126c	75 93		 jne	 SHORT $LN240@inflateBac
  0126e	eb 86		 jmp	 SHORT $LN233@inflateBac
$LN230@inflateBac:
  01270	33 c9		 xor	 ecx, ecx
  01272	75 82		 jne	 SHORT $LN233@inflateBac

; 574  :                 state->offset += BITS(state->extra);

  01274	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01277	b8 01 00 00 00	 mov	 eax, 1
  0127c	8b 4a 4c	 mov	 ecx, DWORD PTR [edx+76]
  0127f	d3 e0		 shl	 eax, cl
  01281	83 e8 01	 sub	 eax, 1
  01284	23 45 e0	 and	 eax, DWORD PTR _hold$[ebp]
  01287	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0128a	03 41 48	 add	 eax, DWORD PTR [ecx+72]
  0128d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  01290	89 42 48	 mov	 DWORD PTR [edx+72], eax
$LN243@inflateBac:

; 575  :                 DROPBITS(state->extra);

  01293	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01296	8b 55 e0	 mov	 edx, DWORD PTR _hold$[ebp]
  01299	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0129c	d3 ea		 shr	 edx, cl
  0129e	89 55 e0	 mov	 DWORD PTR _hold$[ebp], edx
  012a1	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  012a4	8b 4d dc	 mov	 ecx, DWORD PTR _bits$[ebp]
  012a7	2b 48 4c	 sub	 ecx, DWORD PTR [eax+76]
  012aa	89 4d dc	 mov	 DWORD PTR _bits$[ebp], ecx
  012ad	33 d2		 xor	 edx, edx
  012af	75 e2		 jne	 SHORT $LN243@inflateBac
$LN328@inflateBac:

; 576  :             }
; 577  :             if (state->offset > state->wsize - (state->whave < state->wsize ?

  012b1	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  012b4	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  012b7	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  012ba	3b 51 2c	 cmp	 edx, DWORD PTR [ecx+44]
  012bd	73 08		 jae	 SHORT $LN345@inflateBac
  012bf	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  012c2	89 45 a0	 mov	 DWORD PTR tv790[ebp], eax
  012c5	eb 07		 jmp	 SHORT $LN346@inflateBac
$LN345@inflateBac:
  012c7	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR tv790[ebp], 0
$LN346@inflateBac:
  012ce	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  012d1	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  012d4	2b 55 a0	 sub	 edx, DWORD PTR tv790[ebp]
  012d7	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  012da	39 50 48	 cmp	 DWORD PTR [eax+72], edx
  012dd	76 19		 jbe	 SHORT $LN249@inflateBac

; 578  :                                                 left : 0)) {
; 579  :                 strm->msg = (char *)"invalid distance too far back";

  012df	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  012e2	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 580  :                 state->mode = BAD;

  012e9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  012ec	c7 42 04 51 3f
	00 00		 mov	 DWORD PTR [edx+4], 16209 ; 00003f51H

; 581  :                 break;

  012f3	e9 4a 01 00 00	 jmp	 $LN5@inflateBac
$LN249@inflateBac:

; 582  :             }
; 583  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 584  : 
; 585  :             /* copy match from window to output */
; 586  :             do {
; 587  :                 ROOM();

  012f8	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  012fc	75 46		 jne	 SHORT $LN247@inflateBac
  012fe	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01301	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  01304	89 4d ec	 mov	 DWORD PTR _put$[ebp], ecx
  01307	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0130a	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0130d	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax
  01310	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01313	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  01316	89 51 30	 mov	 DWORD PTR [ecx+48], edx
  01319	8b f4		 mov	 esi, esp
  0131b	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  0131e	50		 push	 eax
  0131f	8b 4d ec	 mov	 ecx, DWORD PTR _put$[ebp]
  01322	51		 push	 ecx
  01323	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  01326	52		 push	 edx
  01327	ff 55 14	 call	 DWORD PTR _out$[ebp]
  0132a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0132d	3b f4		 cmp	 esi, esp
  0132f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01334	85 c0		 test	 eax, eax
  01336	74 0c		 je	 SHORT $LN247@inflateBac
  01338	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0133f	e9 03 01 00 00	 jmp	 $inf_leave$393
$LN247@inflateBac:
  01344	33 c0		 xor	 eax, eax
  01346	75 b0		 jne	 SHORT $LN249@inflateBac

; 588  :                 copy = state->wsize - state->offset;

  01348	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0134b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0134e	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  01351	2b 42 48	 sub	 eax, DWORD PTR [edx+72]
  01354	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax

; 589  :                 if (copy < left) {

  01357	8b 4d d8	 mov	 ecx, DWORD PTR _copy$[ebp]
  0135a	3b 4d e4	 cmp	 ecx, DWORD PTR _left$[ebp]
  0135d	73 14		 jae	 SHORT $LN334@inflateBac

; 590  :                     from = put + copy;

  0135f	8b 55 ec	 mov	 edx, DWORD PTR _put$[ebp]
  01362	03 55 d8	 add	 edx, DWORD PTR _copy$[ebp]
  01365	89 55 d4	 mov	 DWORD PTR _from$[ebp], edx

; 591  :                     copy = left - copy;

  01368	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  0136b	2b 45 d8	 sub	 eax, DWORD PTR _copy$[ebp]
  0136e	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax

; 592  :                 }

  01371	eb 15		 jmp	 SHORT $LN335@inflateBac
$LN334@inflateBac:

; 593  :                 else {
; 594  :                     from = put - state->offset;

  01373	0f ae e8	 lfence
  01376	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  01379	8b 55 ec	 mov	 edx, DWORD PTR _put$[ebp]
  0137c	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  0137f	89 55 d4	 mov	 DWORD PTR _from$[ebp], edx

; 595  :                     copy = left;

  01382	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  01385	89 45 d8	 mov	 DWORD PTR _copy$[ebp], eax
$LN335@inflateBac:

; 596  :                 }
; 597  :                 if (copy > state->length) copy = state->length;

  01388	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0138b	8b 55 d8	 mov	 edx, DWORD PTR _copy$[ebp]
  0138e	3b 51 44	 cmp	 edx, DWORD PTR [ecx+68]
  01391	76 09		 jbe	 SHORT $LN336@inflateBac
  01393	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01396	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  01399	89 4d d8	 mov	 DWORD PTR _copy$[ebp], ecx
$LN336@inflateBac:

; 598  :                 state->length -= copy;

  0139c	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0139f	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  013a2	2b 45 d8	 sub	 eax, DWORD PTR _copy$[ebp]
  013a5	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  013a8	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 599  :                 left -= copy;

  013ab	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  013ae	2b 55 d8	 sub	 edx, DWORD PTR _copy$[ebp]
  013b1	89 55 e4	 mov	 DWORD PTR _left$[ebp], edx
$LN252@inflateBac:

; 600  :                 do {
; 601  :                     *put++ = *from++;

  013b4	8b 45 ec	 mov	 eax, DWORD PTR _put$[ebp]
  013b7	8b 4d d4	 mov	 ecx, DWORD PTR _from$[ebp]
  013ba	8a 11		 mov	 dl, BYTE PTR [ecx]
  013bc	88 10		 mov	 BYTE PTR [eax], dl
  013be	8b 45 ec	 mov	 eax, DWORD PTR _put$[ebp]
  013c1	83 c0 01	 add	 eax, 1
  013c4	89 45 ec	 mov	 DWORD PTR _put$[ebp], eax
  013c7	8b 4d d4	 mov	 ecx, DWORD PTR _from$[ebp]
  013ca	83 c1 01	 add	 ecx, 1
  013cd	89 4d d4	 mov	 DWORD PTR _from$[ebp], ecx

; 602  :                 } while (--copy);

  013d0	8b 55 d8	 mov	 edx, DWORD PTR _copy$[ebp]
  013d3	83 ea 01	 sub	 edx, 1
  013d6	89 55 d8	 mov	 DWORD PTR _copy$[ebp], edx
  013d9	75 d9		 jne	 SHORT $LN252@inflateBac

; 603  :             } while (state->length != 0);

  013db	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  013de	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  013e2	0f 85 10 ff ff
	ff		 jne	 $LN249@inflateBac

; 604  :             break;

  013e8	eb 58		 jmp	 SHORT $LN5@inflateBac
$LN337@inflateBac:

; 605  : 
; 606  :         case DONE:
; 607  :             /* inflate stream terminated properly -- write leftover output */
; 608  :             ret = Z_STREAM_END;

  013ea	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 609  :             if (left < state->wsize) {

  013f1	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  013f4	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  013f7	3b 51 2c	 cmp	 edx, DWORD PTR [ecx+44]
  013fa	73 32		 jae	 SHORT $LN338@inflateBac

; 610  :                 if (out(out_desc, state->window, state->wsize - left))

  013fc	0f ae e8	 lfence
  013ff	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  01402	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  01405	2b 4d e4	 sub	 ecx, DWORD PTR _left$[ebp]
  01408	8b f4		 mov	 esi, esp
  0140a	51		 push	 ecx
  0140b	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0140e	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  01411	50		 push	 eax
  01412	8b 4d 18	 mov	 ecx, DWORD PTR _out_desc$[ebp]
  01415	51		 push	 ecx
  01416	ff 55 14	 call	 DWORD PTR _out$[ebp]
  01419	83 c4 0c	 add	 esp, 12			; 0000000cH
  0141c	3b f4		 cmp	 esi, esp
  0141e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01423	85 c0		 test	 eax, eax
  01425	74 07		 je	 SHORT $LN338@inflateBac

; 611  :                     ret = Z_BUF_ERROR;

  01427	c7 45 b4 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
$LN338@inflateBac:

; 612  :             }
; 613  :             goto inf_leave;

  0142e	eb 17		 jmp	 SHORT $inf_leave$393
$LN340@inflateBac:

; 614  : 
; 615  :         case BAD:
; 616  :             ret = Z_DATA_ERROR;

  01430	c7 45 b4 fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH

; 617  :             goto inf_leave;

  01437	eb 0e		 jmp	 SHORT $inf_leave$393
$LN341@inflateBac:

; 618  : 
; 619  :         default:                /* can't happen, but makes compilers happy */
; 620  :             ret = Z_STREAM_ERROR;

  01439	c7 45 b4 fe ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -2 ; fffffffeH

; 621  :             goto inf_leave;

  01440	eb 05		 jmp	 SHORT $inf_leave$393
$LN5@inflateBac:

; 622  :         }

  01442	e9 6a ec ff ff	 jmp	 $LN4@inflateBac
$inf_leave$393:

; 623  : 
; 624  :     /* Return unused input */
; 625  :   inf_leave:
; 626  :     strm->next_in = next;

  01447	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0144a	8b 45 f4	 mov	 eax, DWORD PTR _next$[ebp]
  0144d	89 02		 mov	 DWORD PTR [edx], eax

; 627  :     strm->avail_in = have;

  0144f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01452	8b 55 e8	 mov	 edx, DWORD PTR _have$[ebp]
  01455	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 628  :     return ret;

  01458	8b 45 b4	 mov	 eax, DWORD PTR _ret$[ebp]
$LN1@inflateBac:

; 629  : }

  0145b	52		 push	 edx
  0145c	8b cd		 mov	 ecx, ebp
  0145e	50		 push	 eax
  0145f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN392@inflateBac
  01465	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0146a	58		 pop	 eax
  0146b	5a		 pop	 edx
  0146c	5f		 pop	 edi
  0146d	5e		 pop	 esi
  0146e	83 c4 60	 add	 esp, 96			; 00000060H
  01471	3b ec		 cmp	 ebp, esp
  01473	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01478	8b e5		 mov	 esp, ebp
  0147a	5d		 pop	 ebp
  0147b	c2 14 00	 ret	 20			; 00000014H
  0147e	66 90		 npad	 2
$LN392@inflateBac:
  01480	03 00 00 00	 DD	 3
  01484	00 00 00 00	 DD	 $LN391@inflateBac
$LN391@inflateBac:
  01488	f4 ff ff ff	 DD	 -12			; fffffff4H
  0148c	04 00 00 00	 DD	 4
  01490	00 00 00 00	 DD	 $LN388@inflateBac
  01494	cc ff ff ff	 DD	 -52			; ffffffccH
  01498	04 00 00 00	 DD	 4
  0149c	00 00 00 00	 DD	 $LN389@inflateBac
  014a0	c0 ff ff ff	 DD	 -64			; ffffffc0H
  014a4	04 00 00 00	 DD	 4
  014a8	00 00 00 00	 DD	 $LN390@inflateBac
$LN390@inflateBac:
  014ac	6c		 DB	 108			; 0000006cH
  014ad	61		 DB	 97			; 00000061H
  014ae	73		 DB	 115			; 00000073H
  014af	74		 DB	 116			; 00000074H
  014b0	00		 DB	 0
$LN389@inflateBac:
  014b1	68		 DB	 104			; 00000068H
  014b2	65		 DB	 101			; 00000065H
  014b3	72		 DB	 114			; 00000072H
  014b4	65		 DB	 101			; 00000065H
  014b5	00		 DB	 0
$LN388@inflateBac:
  014b6	6e		 DB	 110			; 0000006eH
  014b7	65		 DB	 101			; 00000065H
  014b8	78		 DB	 120			; 00000078H
  014b9	74		 DB	 116			; 00000074H
  014ba	00		 DB	 0
  014bb	90		 npad	 1
$LN386@inflateBac:
  014bc	00 00 00 00	 DD	 $LN255@inflateBac
  014c0	00 00 00 00	 DD	 $LN31@inflateBac
  014c4	00 00 00 00	 DD	 $LN57@inflateBac
  014c8	00 00 00 00	 DD	 $LN302@inflateBac
  014cc	00 00 00 00	 DD	 $LN337@inflateBac
  014d0	00 00 00 00	 DD	 $LN340@inflateBac
  014d4	00 00 00 00	 DD	 $LN341@inflateBac
$LN385@inflateBac:
  014d8	00		 DB	 0
  014d9	06		 DB	 6
  014da	01		 DB	 1
  014db	06		 DB	 6
  014dc	06		 DB	 6
  014dd	02		 DB	 2
  014de	06		 DB	 6
  014df	06		 DB	 6
  014e0	06		 DB	 6
  014e1	03		 DB	 3
  014e2	06		 DB	 6
  014e3	06		 DB	 6
  014e4	06		 DB	 6
  014e5	06		 DB	 6
  014e6	06		 DB	 6
  014e7	06		 DB	 6
  014e8	06		 DB	 6
  014e9	04		 DB	 4
  014ea	05		 DB	 5
  014eb	90		 npad	 1
$LN387@inflateBac:
  014ec	00 00 00 00	 DD	 $LN259@inflateBac
  014f0	00 00 00 00	 DD	 $LN260@inflateBac
  014f4	00 00 00 00	 DD	 $LN261@inflateBac
  014f8	00 00 00 00	 DD	 $LN262@inflateBac
_inflateBack@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\infback.c
;	COMDAT _inflateBackEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateBackEnd@4 PROC					; COMDAT

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00009	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 634  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  0000e	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00012	74 12		 je	 SHORT $LN3@inflateBac
  00014	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00017	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0001b	74 09		 je	 SHORT $LN3@inflateBac
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00020	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00024	75 07		 jne	 SHORT $LN2@inflateBac
$LN3@inflateBac:

; 635  :         return Z_STREAM_ERROR;

  00026	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002b	eb 2e		 jmp	 SHORT $LN1@inflateBac
$LN2@inflateBac:

; 636  :     ZFREE(strm, strm->state);

  0002d	8b f4		 mov	 esi, esp
  0002f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00032	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00039	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0003c	52		 push	 edx
  0003d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00040	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00043	ff d1		 call	 ecx
  00045	83 c4 08	 add	 esp, 8
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 637  :     strm->state = Z_NULL;

  0004f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00052	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 638  :     Tracev((stderr, "inflate: end\n"));
; 639  :     return Z_OK;

  00059	33 c0		 xor	 eax, eax
$LN1@inflateBac:

; 640  : }

  0005b	5e		 pop	 esi
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	5d		 pop	 ebp
  00064	c2 04 00	 ret	 4
_inflateBackEnd@4 ENDP
_TEXT	ENDS
END
