; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

	TITLE	e:\cpython\externals\zlib-1.2.11\adler32.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__ABDB54D7_adler32@c DB 01H
PUBLIC	_adler32_combine@12
PUBLIC	_adler32@12
PUBLIC	_adler32_z@12
PUBLIC	__JustMyCode_Default
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__allmul:PROC
EXTRN	__allrem:PROC
EXTRN	__allshl:PROC
EXTRN	__allshr:PROC
EXTRN	__aulldiv:PROC
EXTRN	__aullshr:PROC
EXTRN	__chkstk:PROC
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT _adler32_z@12
_TEXT	SEGMENT
tv297 = -16						; size = 4
tv82 = -12						; size = 4
_n$ = -8						; size = 4
_sum2$ = -4						; size = 4
_adler$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_adler32_z@12 PROC					; COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 68   :     unsigned long sum2;
; 69   :     unsigned n;
; 70   : 
; 71   :     /* split Adler-32 into component sums */
; 72   :     sum2 = (adler >> 16) & 0xffff;

  00021	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  00024	c1 e8 10	 shr	 eax, 16			; 00000010H
  00027	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002c	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax

; 73   :     adler &= 0xffff;

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _adler$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx

; 74   : 
; 75   :     /* in case user likes doing a byte at a time, keep it fast */
; 76   :     if (len == 1) {

  0003b	83 7d 10 01	 cmp	 DWORD PTR _len$[ebp], 1
  0003f	75 55		 jne	 SHORT $LN13@adler32_z

; 77   :         adler += buf[0];

  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	6b c2 00	 imul	 eax, edx, 0
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0004c	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00050	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00053	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx

; 78   :         if (adler >= BASE)

  00056	81 7d 08 f1 ff
	00 00		 cmp	 DWORD PTR _adler$[ebp], 65521 ; 0000fff1H
  0005d	72 0b		 jb	 SHORT $LN14@adler32_z

; 79   :             adler -= BASE;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  00062	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00067	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
$LN14@adler32_z:

; 80   :         sum2 += adler;

  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  0006d	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00070	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx

; 81   :         if (sum2 >= BASE)

  00073	81 7d fc f1 ff
	00 00		 cmp	 DWORD PTR _sum2$[ebp], 65521 ; 0000fff1H
  0007a	72 0c		 jb	 SHORT $LN15@adler32_z

; 82   :             sum2 -= BASE;

  0007c	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  0007f	81 ea f1 ff 00
	00		 sub	 edx, 65521		; 0000fff1H
  00085	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
$LN15@adler32_z:

; 83   :         return adler | (sum2 << 16);

  00088	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  0008b	c1 e0 10	 shl	 eax, 16			; 00000010H
  0008e	0b 45 08	 or	 eax, DWORD PTR _adler$[ebp]
  00091	e9 1c 05 00 00	 jmp	 $LN1@adler32_z
$LN13@adler32_z:

; 84   :     }
; 85   : 
; 86   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 87   :     if (buf == Z_NULL)

  00096	83 7d 0c 00	 cmp	 DWORD PTR _buf$[ebp], 0
  0009a	75 0a		 jne	 SHORT $LN16@adler32_z

; 88   :         return 1L;

  0009c	b8 01 00 00 00	 mov	 eax, 1
  000a1	e9 0c 05 00 00	 jmp	 $LN1@adler32_z
$LN16@adler32_z:

; 89   : 
; 90   :     /* in case short lengths are provided, keep it somewhat fast */
; 91   :     if (len < 16) {

  000a6	83 7d 10 10	 cmp	 DWORD PTR _len$[ebp], 16 ; 00000010H
  000aa	73 66		 jae	 SHORT $LN4@adler32_z
$LN2@adler32_z:

; 92   :         while (len--) {

  000ac	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  000af	89 45 f4	 mov	 DWORD PTR tv82[ebp], eax
  000b2	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  000b5	83 e9 01	 sub	 ecx, 1
  000b8	89 4d 10	 mov	 DWORD PTR _len$[ebp], ecx
  000bb	83 7d f4 00	 cmp	 DWORD PTR tv82[ebp], 0
  000bf	74 20		 je	 SHORT $LN3@adler32_z

; 93   :             adler += *buf++;

  000c1	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  000c4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000c7	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  000ca	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  000cd	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  000d0	83 c1 01	 add	 ecx, 1
  000d3	89 4d 0c	 mov	 DWORD PTR _buf$[ebp], ecx

; 94   :             sum2 += adler;

  000d6	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  000d9	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  000dc	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx

; 95   :         }

  000df	eb cb		 jmp	 SHORT $LN2@adler32_z
$LN3@adler32_z:

; 96   :         if (adler >= BASE)

  000e1	81 7d 08 f1 ff
	00 00		 cmp	 DWORD PTR _adler$[ebp], 65521 ; 0000fff1H
  000e8	72 0b		 jb	 SHORT $LN18@adler32_z

; 97   :             adler -= BASE;

  000ea	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  000ed	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000f2	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
$LN18@adler32_z:

; 98   :         MOD28(sum2);            /* only added so many BASE's */

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  000f8	33 d2		 xor	 edx, edx
  000fa	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  000ff	f7 f1		 div	 ecx
  00101	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx

; 99   :         return adler | (sum2 << 16);

  00104	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  00107	c1 e0 10	 shl	 eax, 16			; 00000010H
  0010a	0b 45 08	 or	 eax, DWORD PTR _adler$[ebp]
  0010d	e9 a0 04 00 00	 jmp	 $LN1@adler32_z
$LN4@adler32_z:

; 100  :     }
; 101  : 
; 102  :     /* do length NMAX blocks -- requires just one modulo operation */
; 103  :     while (len >= NMAX) {

  00112	81 7d 10 b0 15
	00 00		 cmp	 DWORD PTR _len$[ebp], 5552 ; 000015b0H
  00119	0f 82 2d 02 00
	00		 jb	 $LN5@adler32_z

; 104  :         len -= NMAX;

  0011f	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00122	81 ea b0 15 00
	00		 sub	 edx, 5552		; 000015b0H
  00128	89 55 10	 mov	 DWORD PTR _len$[ebp], edx

; 105  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  0012b	c7 45 f8 5b 01
	00 00		 mov	 DWORD PTR _n$[ebp], 347	; 0000015bH
$LN8@adler32_z:

; 106  :         do {
; 107  :             DO16(buf);          /* 16 sums unrolled */

  00132	b8 01 00 00 00	 mov	 eax, 1
  00137	6b c8 00	 imul	 ecx, eax, 0
  0013a	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0013d	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00141	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  00144	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  00147	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  0014a	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0014d	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx
  00150	ba 01 00 00 00	 mov	 edx, 1
  00155	c1 e2 00	 shl	 edx, 0
  00158	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0015b	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0015f	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00162	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00165	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  00168	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0016b	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
  0016e	b8 01 00 00 00	 mov	 eax, 1
  00173	d1 e0		 shl	 eax, 1
  00175	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00178	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0017c	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0017f	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  00182	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  00185	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  00188	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax
  0018b	b9 01 00 00 00	 mov	 ecx, 1
  00190	6b d1 03	 imul	 edx, ecx, 3
  00193	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00196	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0019a	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0019d	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  001a0	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  001a3	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001a6	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
  001a9	b8 01 00 00 00	 mov	 eax, 1
  001ae	c1 e0 02	 shl	 eax, 2
  001b1	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  001b4	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  001b8	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001bb	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  001be	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  001c1	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  001c4	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax
  001c7	b9 01 00 00 00	 mov	 ecx, 1
  001cc	6b d1 05	 imul	 edx, ecx, 5
  001cf	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001d2	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  001d6	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  001d9	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  001dc	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  001df	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001e2	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
  001e5	b8 01 00 00 00	 mov	 eax, 1
  001ea	6b c8 06	 imul	 ecx, eax, 6
  001ed	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  001f0	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  001f4	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  001f7	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  001fa	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  001fd	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00200	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx
  00203	ba 01 00 00 00	 mov	 edx, 1
  00208	6b c2 07	 imul	 eax, edx, 7
  0020b	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0020e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00212	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00215	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  00218	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  0021b	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  0021e	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax
  00221	b9 01 00 00 00	 mov	 ecx, 1
  00226	c1 e1 03	 shl	 ecx, 3
  00229	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0022c	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00230	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  00233	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  00236	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  00239	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0023c	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx
  0023f	ba 01 00 00 00	 mov	 edx, 1
  00244	6b c2 09	 imul	 eax, edx, 9
  00247	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0024a	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  0024e	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00251	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  00254	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  00257	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  0025a	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax
  0025d	b9 01 00 00 00	 mov	 ecx, 1
  00262	6b d1 0a	 imul	 edx, ecx, 10
  00265	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00268	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0026c	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0026f	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00272	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  00275	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00278	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
  0027b	b8 01 00 00 00	 mov	 eax, 1
  00280	6b c8 0b	 imul	 ecx, eax, 11
  00283	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00286	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0028a	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  0028d	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  00290	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  00293	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00296	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx
  00299	ba 01 00 00 00	 mov	 edx, 1
  0029e	6b c2 0c	 imul	 eax, edx, 12
  002a1	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  002a4	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  002a8	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  002ab	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  002ae	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  002b1	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  002b4	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax
  002b7	b9 01 00 00 00	 mov	 ecx, 1
  002bc	6b d1 0d	 imul	 edx, ecx, 13
  002bf	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  002c2	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  002c6	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  002c9	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  002cc	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  002cf	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  002d2	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
  002d5	b8 01 00 00 00	 mov	 eax, 1
  002da	6b c8 0e	 imul	 ecx, eax, 14
  002dd	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  002e0	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  002e4	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  002e7	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  002ea	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  002ed	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  002f0	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx
  002f3	ba 01 00 00 00	 mov	 edx, 1
  002f8	6b c2 0f	 imul	 eax, edx, 15
  002fb	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  002fe	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00302	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00305	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  00308	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  0030b	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  0030e	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax

; 108  :             buf += 16;

  00311	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00314	83 c1 10	 add	 ecx, 16			; 00000010H
  00317	89 4d 0c	 mov	 DWORD PTR _buf$[ebp], ecx

; 109  :         } while (--n);

  0031a	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  0031d	83 ea 01	 sub	 edx, 1
  00320	89 55 f8	 mov	 DWORD PTR _n$[ebp], edx
  00323	0f 85 09 fe ff
	ff		 jne	 $LN8@adler32_z

; 110  :         MOD(adler);

  00329	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  0032c	33 d2		 xor	 edx, edx
  0032e	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00333	f7 f1		 div	 ecx
  00335	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx

; 111  :         MOD(sum2);

  00338	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  0033b	33 d2		 xor	 edx, edx
  0033d	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00342	f7 f1		 div	 ecx
  00344	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx

; 112  :     }

  00347	e9 c6 fd ff ff	 jmp	 $LN4@adler32_z
$LN5@adler32_z:

; 113  : 
; 114  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 115  :     if (len) {                  /* avoid modulos if none remaining */

  0034c	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00350	0f 84 53 02 00
	00		 je	 $LN19@adler32_z
$LN9@adler32_z:

; 116  :         while (len >= 16) {

  00356	83 7d 10 10	 cmp	 DWORD PTR _len$[ebp], 16 ; 00000010H
  0035a	0f 82 f6 01 00
	00		 jb	 $LN11@adler32_z

; 117  :             len -= 16;

  00360	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00363	83 ea 10	 sub	 edx, 16			; 00000010H
  00366	89 55 10	 mov	 DWORD PTR _len$[ebp], edx

; 118  :             DO16(buf);

  00369	b8 01 00 00 00	 mov	 eax, 1
  0036e	6b c8 00	 imul	 ecx, eax, 0
  00371	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00374	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00378	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  0037b	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  0037e	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  00381	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00384	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx
  00387	ba 01 00 00 00	 mov	 edx, 1
  0038c	c1 e2 00	 shl	 edx, 0
  0038f	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00392	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00396	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00399	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0039c	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  0039f	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003a2	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
  003a5	b8 01 00 00 00	 mov	 eax, 1
  003aa	d1 e0		 shl	 eax, 1
  003ac	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  003af	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  003b3	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003b6	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  003b9	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  003bc	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  003bf	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax
  003c2	b9 01 00 00 00	 mov	 ecx, 1
  003c7	6b d1 03	 imul	 edx, ecx, 3
  003ca	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  003cd	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  003d1	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003d4	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  003d7	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  003da	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003dd	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
  003e0	b8 01 00 00 00	 mov	 eax, 1
  003e5	c1 e0 02	 shl	 eax, 2
  003e8	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  003eb	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  003ef	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003f2	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  003f5	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  003f8	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  003fb	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax
  003fe	b9 01 00 00 00	 mov	 ecx, 1
  00403	6b d1 05	 imul	 edx, ecx, 5
  00406	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00409	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  0040d	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00410	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00413	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  00416	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00419	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
  0041c	b8 01 00 00 00	 mov	 eax, 1
  00421	6b c8 06	 imul	 ecx, eax, 6
  00424	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00427	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0042b	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  0042e	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  00431	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  00434	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00437	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx
  0043a	ba 01 00 00 00	 mov	 edx, 1
  0043f	6b c2 07	 imul	 eax, edx, 7
  00442	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00445	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00449	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0044c	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  0044f	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  00452	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  00455	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax
  00458	b9 01 00 00 00	 mov	 ecx, 1
  0045d	c1 e1 03	 shl	 ecx, 3
  00460	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00463	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  00467	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  0046a	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  0046d	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  00470	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00473	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx
  00476	ba 01 00 00 00	 mov	 edx, 1
  0047b	6b c2 09	 imul	 eax, edx, 9
  0047e	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00481	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00485	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00488	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  0048b	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  0048e	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  00491	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax
  00494	b9 01 00 00 00	 mov	 ecx, 1
  00499	6b d1 0a	 imul	 edx, ecx, 10
  0049c	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0049f	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  004a3	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  004a6	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  004a9	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  004ac	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  004af	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
  004b2	b8 01 00 00 00	 mov	 eax, 1
  004b7	6b c8 0b	 imul	 ecx, eax, 11
  004ba	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  004bd	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  004c1	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  004c4	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  004c7	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  004ca	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  004cd	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx
  004d0	ba 01 00 00 00	 mov	 edx, 1
  004d5	6b c2 0c	 imul	 eax, edx, 12
  004d8	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  004db	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  004df	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  004e2	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  004e5	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  004e8	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  004eb	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax
  004ee	b9 01 00 00 00	 mov	 ecx, 1
  004f3	6b d1 0d	 imul	 edx, ecx, 13
  004f6	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  004f9	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  004fd	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00500	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00503	8b 55 fc	 mov	 edx, DWORD PTR _sum2$[ebp]
  00506	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00509	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
  0050c	b8 01 00 00 00	 mov	 eax, 1
  00511	6b c8 0e	 imul	 ecx, eax, 14
  00514	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00517	0f b6 04 0a	 movzx	 eax, BYTE PTR [edx+ecx]
  0051b	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  0051e	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax
  00521	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  00524	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00527	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx
  0052a	ba 01 00 00 00	 mov	 edx, 1
  0052f	6b c2 0f	 imul	 eax, edx, 15
  00532	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00535	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00539	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0053c	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  0053f	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  00542	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  00545	89 45 fc	 mov	 DWORD PTR _sum2$[ebp], eax

; 119  :             buf += 16;

  00548	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0054b	83 c1 10	 add	 ecx, 16			; 00000010H
  0054e	89 4d 0c	 mov	 DWORD PTR _buf$[ebp], ecx

; 120  :         }

  00551	e9 00 fe ff ff	 jmp	 $LN9@adler32_z
$LN11@adler32_z:

; 121  :         while (len--) {

  00556	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00559	89 55 f0	 mov	 DWORD PTR tv297[ebp], edx
  0055c	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  0055f	83 e8 01	 sub	 eax, 1
  00562	89 45 10	 mov	 DWORD PTR _len$[ebp], eax
  00565	83 7d f0 00	 cmp	 DWORD PTR tv297[ebp], 0
  00569	74 20		 je	 SHORT $LN12@adler32_z

; 122  :             adler += *buf++;

  0056b	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0056e	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00571	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00574	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx
  00577	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0057a	83 c0 01	 add	 eax, 1
  0057d	89 45 0c	 mov	 DWORD PTR _buf$[ebp], eax

; 123  :             sum2 += adler;

  00580	8b 4d fc	 mov	 ecx, DWORD PTR _sum2$[ebp]
  00583	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00586	89 4d fc	 mov	 DWORD PTR _sum2$[ebp], ecx

; 124  :         }

  00589	eb cb		 jmp	 SHORT $LN11@adler32_z
$LN12@adler32_z:

; 125  :         MOD(adler);

  0058b	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  0058e	33 d2		 xor	 edx, edx
  00590	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00595	f7 f1		 div	 ecx
  00597	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx

; 126  :         MOD(sum2);

  0059a	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  0059d	33 d2		 xor	 edx, edx
  0059f	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  005a4	f7 f1		 div	 ecx
  005a6	89 55 fc	 mov	 DWORD PTR _sum2$[ebp], edx
$LN19@adler32_z:

; 127  :     }
; 128  : 
; 129  :     /* return recombined sums */
; 130  :     return adler | (sum2 << 16);

  005a9	8b 45 fc	 mov	 eax, DWORD PTR _sum2$[ebp]
  005ac	c1 e0 10	 shl	 eax, 16			; 00000010H
  005af	0b 45 08	 or	 eax, DWORD PTR _adler$[ebp]
$LN1@adler32_z:

; 131  : }

  005b2	83 c4 10	 add	 esp, 16			; 00000010H
  005b5	3b ec		 cmp	 ebp, esp
  005b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005bc	8b e5		 mov	 esp, ebp
  005be	5d		 pop	 ebp
  005bf	c2 0c 00	 ret	 12			; 0000000cH
_adler32_z@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT _adler32@12
_TEXT	SEGMENT
_adler$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_adler32@12 PROC					; COMDAT

; 138  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 139  :     return adler32_z(adler, buf, len);

  0000d	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00014	51		 push	 ecx
  00015	8b 55 08	 mov	 edx, DWORD PTR _adler$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 _adler32_z@12

; 140  : }

  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	5d		 pop	 ebp
  00026	c2 0c 00	 ret	 12			; 0000000cH
_adler32@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT _adler32_combine_
_TEXT	SEGMENT
_rem$ = -12						; size = 4
_sum2$ = -8						; size = 4
_sum1$ = -4						; size = 4
_adler1$ = 8						; size = 4
_adler2$ = 12						; size = 4
_len2$ = 16						; size = 8
_adler32_combine_ PROC					; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 148  :     unsigned long sum1;
; 149  :     unsigned long sum2;
; 150  :     unsigned rem;
; 151  : 
; 152  :     /* for negative len, return invalid adler32 as a clue for debugging */
; 153  :     if (len2 < 0)

  00025	83 7d 14 00	 cmp	 DWORD PTR _len2$[ebp+4], 0
  00029	7f 10		 jg	 SHORT $LN2@adler32_co
  0002b	7c 06		 jl	 SHORT $LN9@adler32_co
  0002d	83 7d 10 00	 cmp	 DWORD PTR _len2$[ebp], 0
  00031	73 08		 jae	 SHORT $LN2@adler32_co
$LN9@adler32_co:

; 154  :         return 0xffffffffUL;

  00033	83 c8 ff	 or	 eax, -1
  00036	e9 e0 00 00 00	 jmp	 $LN1@adler32_co
$LN2@adler32_co:

; 155  : 
; 156  :     /* the derivation of this formula is left as an exercise for the reader */
; 157  :     MOD63(len2);                /* assumes len2 >= 0 */

  0003b	0f ae e8	 lfence
  0003e	6a 00		 push	 0
  00040	68 f1 ff 00 00	 push	 65521			; 0000fff1H
  00045	8b 45 14	 mov	 eax, DWORD PTR _len2$[ebp+4]
  00048	50		 push	 eax
  00049	8b 4d 10	 mov	 ecx, DWORD PTR _len2$[ebp]
  0004c	51		 push	 ecx
  0004d	e8 00 00 00 00	 call	 __allrem
  00052	89 45 10	 mov	 DWORD PTR _len2$[ebp], eax
  00055	89 55 14	 mov	 DWORD PTR _len2$[ebp+4], edx

; 158  :     rem = (unsigned)len2;

  00058	8b 55 10	 mov	 edx, DWORD PTR _len2$[ebp]
  0005b	89 55 f4	 mov	 DWORD PTR _rem$[ebp], edx

; 159  :     sum1 = adler1 & 0xffff;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _adler1$[ebp]
  00061	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00066	89 45 fc	 mov	 DWORD PTR _sum1$[ebp], eax

; 160  :     sum2 = rem * sum1;

  00069	8b 4d f4	 mov	 ecx, DWORD PTR _rem$[ebp]
  0006c	0f af 4d fc	 imul	 ecx, DWORD PTR _sum1$[ebp]
  00070	89 4d f8	 mov	 DWORD PTR _sum2$[ebp], ecx

; 161  :     MOD(sum2);

  00073	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  00076	33 d2		 xor	 edx, edx
  00078	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0007d	f7 f1		 div	 ecx
  0007f	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 162  :     sum1 += (adler2 & 0xffff) + BASE - 1;

  00082	8b 55 0c	 mov	 edx, DWORD PTR _adler2$[ebp]
  00085	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _sum1$[ebp]
  0008e	8d 8c 10 f0 ff
	00 00		 lea	 ecx, DWORD PTR [eax+edx+65520]
  00095	89 4d fc	 mov	 DWORD PTR _sum1$[ebp], ecx

; 163  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  00098	8b 55 08	 mov	 edx, DWORD PTR _adler1$[ebp]
  0009b	c1 ea 10	 shr	 edx, 16			; 00000010H
  0009e	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  000a4	8b 45 0c	 mov	 eax, DWORD PTR _adler2$[ebp]
  000a7	c1 e8 10	 shr	 eax, 16			; 00000010H
  000aa	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000af	8d 8c 02 f1 ff
	00 00		 lea	 ecx, DWORD PTR [edx+eax+65521]
  000b6	2b 4d f4	 sub	 ecx, DWORD PTR _rem$[ebp]
  000b9	03 4d f8	 add	 ecx, DWORD PTR _sum2$[ebp]
  000bc	89 4d f8	 mov	 DWORD PTR _sum2$[ebp], ecx

; 164  :     if (sum1 >= BASE) sum1 -= BASE;

  000bf	81 7d fc f1 ff
	00 00		 cmp	 DWORD PTR _sum1$[ebp], 65521 ; 0000fff1H
  000c6	72 0c		 jb	 SHORT $LN3@adler32_co
  000c8	8b 55 fc	 mov	 edx, DWORD PTR _sum1$[ebp]
  000cb	81 ea f1 ff 00
	00		 sub	 edx, 65521		; 0000fff1H
  000d1	89 55 fc	 mov	 DWORD PTR _sum1$[ebp], edx
$LN3@adler32_co:

; 165  :     if (sum1 >= BASE) sum1 -= BASE;

  000d4	81 7d fc f1 ff
	00 00		 cmp	 DWORD PTR _sum1$[ebp], 65521 ; 0000fff1H
  000db	72 0b		 jb	 SHORT $LN4@adler32_co
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _sum1$[ebp]
  000e0	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000e5	89 45 fc	 mov	 DWORD PTR _sum1$[ebp], eax
$LN4@adler32_co:

; 166  :     if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);

  000e8	81 7d f8 e2 ff
	01 00		 cmp	 DWORD PTR _sum2$[ebp], 131042 ; 0001ffe2H
  000ef	72 0c		 jb	 SHORT $LN5@adler32_co
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _sum2$[ebp]
  000f4	81 e9 e2 ff 01
	00		 sub	 ecx, 131042		; 0001ffe2H
  000fa	89 4d f8	 mov	 DWORD PTR _sum2$[ebp], ecx
$LN5@adler32_co:

; 167  :     if (sum2 >= BASE) sum2 -= BASE;

  000fd	81 7d f8 f1 ff
	00 00		 cmp	 DWORD PTR _sum2$[ebp], 65521 ; 0000fff1H
  00104	72 0c		 jb	 SHORT $LN6@adler32_co
  00106	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00109	81 ea f1 ff 00
	00		 sub	 edx, 65521		; 0000fff1H
  0010f	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
$LN6@adler32_co:

; 168  :     return sum1 | (sum2 << 16);

  00112	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  00115	c1 e0 10	 shl	 eax, 16			; 00000010H
  00118	0b 45 fc	 or	 eax, DWORD PTR _sum1$[ebp]
$LN1@adler32_co:

; 169  : }

  0011b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011e	3b ec		 cmp	 ebp, esp
  00120	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
_adler32_combine_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT _adler32_combine@12
_TEXT	SEGMENT
_adler1$ = 8						; size = 4
_adler2$ = 12						; size = 4
_len2$ = 16						; size = 4
_adler32_combine@12 PROC				; COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 177  :     return adler32_combine_(adler1, adler2, len2);

  0000d	8b 45 10	 mov	 eax, DWORD PTR _len2$[ebp]
  00010	99		 cdq
  00011	52		 push	 edx
  00012	50		 push	 eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _adler2$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _adler1$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _adler32_combine_
  00020	83 c4 10	 add	 esp, 16			; 00000010H

; 178  : }

  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	5d		 pop	 ebp
  0002b	c2 0c 00	 ret	 12			; 0000000cH
_adler32_combine@12 ENDP
_TEXT	ENDS
END
