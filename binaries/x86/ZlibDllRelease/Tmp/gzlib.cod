; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

	TITLE	e:\cpython\externals\zlib-1.2.11\gzlib.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@		; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_C@_06DIJPEION@?$CFs?$CFs?$CFs@		; `string'
EXTRN	_malloc:PROC
EXTRN	_free:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_strlen:PROC
EXTRN	_wcstombs:PROC
EXTRN	__open:PROC
EXTRN	__wopen:PROC
EXTRN	__lseeki64:PROC
;	COMDAT ??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
CONST	SEGMENT
??_C@_06DIJPEION@?$CFs?$CFs?$CFs@ DB '%s%s%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@ DB '<fd:%d>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
__DB664BEB_corecrt_stdio_config@h DB 01H
__E28BBA23_corecrt_wstdio@h DB 01H
__4A1C29A8_stdio@h DB 01H
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__86DC2CC7_gzlib@c DB 01H
PUBLIC	_gz_error
PUBLIC	_gzclearerr@4
PUBLIC	_gzerror@8
PUBLIC	_gzeof@4
PUBLIC	_gzoffset@4
PUBLIC	_gzoffset64@4
PUBLIC	_gztell@4
PUBLIC	_gztell64@4
PUBLIC	_gzseek@12
PUBLIC	_gzseek64@16
PUBLIC	_gzrewind@4
PUBLIC	_gzbuffer@8
PUBLIC	_gzopen_w@8
PUBLIC	_gzdopen@8
PUBLIC	_gzopen@8
PUBLIC	_snprintf
PUBLIC	_vsnprintf
PUBLIC	___local_stdio_printf_options
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 85   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __DB664BEB_corecrt_stdio_config@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 86   :         static unsigned __int64 _OptionsStorage;
; 87   :         return &_OptionsStorage;

  0000d	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 88   :     }

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
_vsnprintf PROC						; COMDAT

; 1437 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __4A1C29A8_stdio@h
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1438 :         int const _Result = __stdio_common_vsprintf(

  0001e	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR __BufferCount$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	83 c9 02	 or	 ecx, 2
  0003a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0003d	52		 push	 edx
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00044	83 c4 1c	 add	 esp, 28			; 0000001cH
  00047	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1439 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1440 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1441 : 
; 1442 :         return _Result < 0 ? -1 : _Result;

  0004a	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  0004e	7d 09		 jge	 SHORT $LN3@vsnprintf
  00050	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv74[ebp], -1
  00057	eb 06		 jmp	 SHORT $LN4@vsnprintf
$LN3@vsnprintf:
  00059	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]
  0005c	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
$LN4@vsnprintf:
  0005f	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]

; 1443 :     }

  00062	83 c4 08	 add	 esp, 8
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
tv81 = -20						; size = 4
__Result$1 = -16					; size = 4
__Format$ = -12						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1946 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __4A1C29A8_stdio@h
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1947 :         int _Result;
; 1948 :         va_list _ArgList;
; 1949 :         __crt_va_start(_ArgList, _Format);

  00024	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00027	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1950 :     #pragma warning(suppress:28719)    // 28719
; 1951 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0002a	8b 4d 10	 mov	 ecx, DWORD PTR __Format$[ebp]
  0002d	89 4d f4	 mov	 DWORD PTR __Format$[ebp], ecx

; 1438 :         int const _Result = __stdio_common_vsprintf(

  00030	8b 55 f8	 mov	 edx, DWORD PTR __ArgList$[ebp]
  00033	52		 push	 edx
  00034	6a 00		 push	 0
  00036	8b 45 f4	 mov	 eax, DWORD PTR __Format$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR __BufferCount$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 08	 mov	 edx, DWORD PTR __Buffer$[ebp]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	83 c9 02	 or	 ecx, 2
  0004c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004f	52		 push	 edx
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00056	83 c4 1c	 add	 esp, 28			; 0000001cH
  00059	89 45 f0	 mov	 DWORD PTR __Result$1[ebp], eax

; 1439 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1440 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1441 : 
; 1442 :         return _Result < 0 ? -1 : _Result;

  0005c	83 7d f0 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  00060	7d 09		 jge	 SHORT $LN5@snprintf
  00062	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv81[ebp], -1
  00069	eb 06		 jmp	 SHORT $LN3@snprintf
$LN5@snprintf:
  0006b	8b 45 f0	 mov	 eax, DWORD PTR __Result$1[ebp]
  0006e	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
$LN3@snprintf:

; 1950 :     #pragma warning(suppress:28719)    // 28719
; 1951 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  00071	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  00074	89 4d fc	 mov	 DWORD PTR __Result$[ebp], ecx

; 1952 :         __crt_va_end(_ArgList);

  00077	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1953 :         return _Result;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 1954 :     }

  00081	83 c4 14	 add	 esp, 20			; 00000014H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c3		 ret	 0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gz_reset
_TEXT	SEGMENT
_state$ = 8						; size = 4
_gz_reset PROC						; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 78   :     state->x.have = 0;              /* no output data available */

  0000d	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00010	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 79   :     if (state->mode == GZ_READ) {   /* for reading ... */

  00016	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00019	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00020	75 1e		 jne	 SHORT $LN2@gz_reset

; 80   :         state->eof = 0;             /* not at end of file */

  00022	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00025	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 81   :         state->past = 0;            /* have not read past end yet */

  0002c	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  0002f	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 82   :         state->how = LOOK;          /* look for gzip header */

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00039	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
$LN2@gz_reset:

; 83   :     }
; 84   :     state->seek = 0;                /* no seek request pending */

  00040	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00043	c7 42 58 00 00
	00 00		 mov	 DWORD PTR [edx+88], 0

; 85   :     gz_error(state, Z_OK, NULL);    /* clear error */

  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _gz_error
  00057	83 c4 0c	 add	 esp, 12			; 0000000cH

; 86   :     state->x.pos = 0;               /* no uncompressed data yet */

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0005d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00064	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 87   :     state->strm.avail_in = 0;       /* no input data yet */

  0006b	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0006e	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 88   : }

  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_gz_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gz_open
_TEXT	SEGMENT
tv326 = -44						; size = 4
tv197 = -40						; size = 4
tv198 = -36						; size = 4
tv182 = -32						; size = 4
tv178 = -28						; size = 4
tv184 = -24						; size = 4
tv88 = -20						; size = 4
_exclusive$ = -16					; size = 4
_oflag$ = -12						; size = 4
_len$ = -8						; size = 4
_state$ = -4						; size = 4
_path$ = 8						; size = 4
_fd$ = 12						; size = 4
_mode$ = 16						; size = 4
_gz_open PROC						; COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	57		 push	 edi
  00007	8d 7d d4	 lea	 edi, DWORD PTR [ebp-44]
  0000a	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 96   :     gz_statep state;
; 97   :     z_size_t len;
; 98   :     int oflag;
; 99   : #ifdef O_CLOEXEC
; 100  :     int cloexec = 0;
; 101  : #endif
; 102  : #ifdef O_EXCL
; 103  :     int exclusive = 0;

  00020	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _exclusive$[ebp], 0

; 104  : #endif
; 105  : 
; 106  :     /* check input */
; 107  :     if (path == NULL)

  00027	83 7d 08 00	 cmp	 DWORD PTR _path$[ebp], 0
  0002b	75 07		 jne	 SHORT $LN6@gz_open

; 108  :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 c5 03 00 00	 jmp	 $LN1@gz_open
$LN6@gz_open:

; 109  : 
; 110  :     /* allocate gzFile structure to return */
; 111  :     state = (gz_statep)malloc(sizeof(gz_state));

  00034	68 a0 00 00 00	 push	 160			; 000000a0H
  00039	e8 00 00 00 00	 call	 _malloc
  0003e	83 c4 04	 add	 esp, 4
  00041	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 112  :     if (state == NULL)

  00044	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  00048	75 07		 jne	 SHORT $LN7@gz_open

; 113  :         return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 a8 03 00 00	 jmp	 $LN1@gz_open
$LN7@gz_open:

; 114  :     state->size = 0;            /* no buffers allocated yet */

  00051	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00054	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 115  :     state->want = GZBUFSIZE;    /* requested buffer size */

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0005e	c7 41 20 00 20
	00 00		 mov	 DWORD PTR [ecx+32], 8192 ; 00002000H

; 116  :     state->msg = NULL;          /* no error message yet */

  00065	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00068	c7 42 60 00 00
	00 00		 mov	 DWORD PTR [edx+96], 0

; 117  : 
; 118  :     /* interpret mode */
; 119  :     state->mode = GZ_NONE;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00072	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 120  :     state->level = Z_DEFAULT_COMPRESSION;

  00079	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0007c	c7 41 48 ff ff
	ff ff		 mov	 DWORD PTR [ecx+72], -1

; 121  :     state->strategy = Z_DEFAULT_STRATEGY;

  00083	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00086	c7 42 4c 00 00
	00 00		 mov	 DWORD PTR [edx+76], 0

; 122  :     state->direct = 0;

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00090	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
$LN2@gz_open:

; 123  :     while (*mode) {

  00097	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  0009a	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0009d	85 d2		 test	 edx, edx
  0009f	0f 84 e1 00 00
	00		 je	 $LN3@gz_open

; 124  :         if (*mode >= '0' && *mode <= '9')

  000a5	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  000a8	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ab	83 f9 30	 cmp	 ecx, 48			; 00000030H
  000ae	7c 1f		 jl	 SHORT $LN8@gz_open
  000b0	8b 55 10	 mov	 edx, DWORD PTR _mode$[ebp]
  000b3	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000b6	83 f8 39	 cmp	 eax, 57			; 00000039H
  000b9	7f 14		 jg	 SHORT $LN8@gz_open

; 125  :             state->level = *mode - '0';

  000bb	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  000be	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000c1	83 ea 30	 sub	 edx, 48			; 00000030H
  000c4	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000c7	89 50 48	 mov	 DWORD PTR [eax+72], edx
  000ca	e9 a9 00 00 00	 jmp	 $LN9@gz_open
$LN8@gz_open:

; 126  :         else
; 127  :             switch (*mode) {

  000cf	8b 4d 10	 mov	 ecx, DWORD PTR _mode$[ebp]
  000d2	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000d5	89 55 ec	 mov	 DWORD PTR tv88[ebp], edx
  000d8	8b 45 ec	 mov	 eax, DWORD PTR tv88[ebp]
  000db	83 e8 2b	 sub	 eax, 43			; 0000002bH
  000de	89 45 ec	 mov	 DWORD PTR tv88[ebp], eax
  000e1	83 7d ec 4d	 cmp	 DWORD PTR tv88[ebp], 77	; 0000004dH
  000e5	0f 87 8d 00 00
	00		 ja	 $LN9@gz_open
  000eb	8b 4d ec	 mov	 ecx, DWORD PTR tv88[ebp]
  000ee	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN55@gz_open[ecx]
  000f5	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN56@gz_open[edx*4]
$LN10@gz_open:

; 128  :             case 'r':
; 129  :                 state->mode = GZ_READ;

  000fc	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000ff	c7 40 10 4f 1c
	00 00		 mov	 DWORD PTR [eax+16], 7247 ; 00001c4fH

; 130  :                 break;

  00106	eb 70		 jmp	 SHORT $LN9@gz_open
$LN11@gz_open:

; 131  : #ifndef NO_GZCOMPRESS
; 132  :             case 'w':
; 133  :                 state->mode = GZ_WRITE;

  00108	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0010b	c7 41 10 b1 79
	00 00		 mov	 DWORD PTR [ecx+16], 31153 ; 000079b1H

; 134  :                 break;

  00112	eb 64		 jmp	 SHORT $LN9@gz_open
$LN12@gz_open:

; 135  :             case 'a':
; 136  :                 state->mode = GZ_APPEND;

  00114	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00117	c7 42 10 01 00
	00 00		 mov	 DWORD PTR [edx+16], 1

; 137  :                 break;

  0011e	eb 58		 jmp	 SHORT $LN9@gz_open
$LN13@gz_open:

; 138  : #endif
; 139  :             case '+':       /* can't read and write at the same time */
; 140  :                 free(state);

  00120	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _free
  00129	83 c4 04	 add	 esp, 4

; 141  :                 return NULL;

  0012c	33 c0		 xor	 eax, eax
  0012e	e9 c6 02 00 00	 jmp	 $LN1@gz_open

; 142  :             case 'b':       /* ignore -- will request binary anyway */
; 143  :                 break;

  00133	eb 43		 jmp	 SHORT $LN9@gz_open
$LN15@gz_open:

; 144  : #ifdef O_CLOEXEC
; 145  :             case 'e':
; 146  :                 cloexec = 1;
; 147  :                 break;
; 148  : #endif
; 149  : #ifdef O_EXCL
; 150  :             case 'x':
; 151  :                 exclusive = 1;

  00135	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _exclusive$[ebp], 1

; 152  :                 break;

  0013c	eb 3a		 jmp	 SHORT $LN9@gz_open
$LN16@gz_open:

; 153  : #endif
; 154  :             case 'f':
; 155  :                 state->strategy = Z_FILTERED;

  0013e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00141	c7 41 4c 01 00
	00 00		 mov	 DWORD PTR [ecx+76], 1

; 156  :                 break;

  00148	eb 2e		 jmp	 SHORT $LN9@gz_open
$LN17@gz_open:

; 157  :             case 'h':
; 158  :                 state->strategy = Z_HUFFMAN_ONLY;

  0014a	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0014d	c7 42 4c 02 00
	00 00		 mov	 DWORD PTR [edx+76], 2

; 159  :                 break;

  00154	eb 22		 jmp	 SHORT $LN9@gz_open
$LN18@gz_open:

; 160  :             case 'R':
; 161  :                 state->strategy = Z_RLE;

  00156	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00159	c7 40 4c 03 00
	00 00		 mov	 DWORD PTR [eax+76], 3

; 162  :                 break;

  00160	eb 16		 jmp	 SHORT $LN9@gz_open
$LN19@gz_open:

; 163  :             case 'F':
; 164  :                 state->strategy = Z_FIXED;

  00162	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00165	c7 41 4c 04 00
	00 00		 mov	 DWORD PTR [ecx+76], 4

; 165  :                 break;

  0016c	eb 0a		 jmp	 SHORT $LN9@gz_open
$LN20@gz_open:

; 166  :             case 'T':
; 167  :                 state->direct = 1;

  0016e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00171	c7 42 2c 01 00
	00 00		 mov	 DWORD PTR [edx+44], 1
$LN9@gz_open:

; 168  :                 break;
; 169  :             default:        /* could consider as an error, but just ignore */
; 170  :                 ;
; 171  :             }
; 172  :         mode++;

  00178	8b 45 10	 mov	 eax, DWORD PTR _mode$[ebp]
  0017b	83 c0 01	 add	 eax, 1
  0017e	89 45 10	 mov	 DWORD PTR _mode$[ebp], eax

; 173  :     }

  00181	e9 11 ff ff ff	 jmp	 $LN2@gz_open
$LN3@gz_open:

; 174  : 
; 175  :     /* must provide an "r", "w", or "a" */
; 176  :     if (state->mode == GZ_NONE) {

  00186	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00189	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  0018d	75 13		 jne	 SHORT $LN22@gz_open

; 177  :         free(state);

  0018f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00192	52		 push	 edx
  00193	e8 00 00 00 00	 call	 _free
  00198	83 c4 04	 add	 esp, 4

; 178  :         return NULL;

  0019b	33 c0		 xor	 eax, eax
  0019d	e9 57 02 00 00	 jmp	 $LN1@gz_open
$LN22@gz_open:

; 179  :     }
; 180  : 
; 181  :     /* can't force transparent read */
; 182  :     if (state->mode == GZ_READ) {

  001a2	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  001a5	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  001ac	75 26		 jne	 SHORT $LN23@gz_open

; 183  :         if (state->direct) {

  001ae	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  001b1	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  001b5	74 13		 je	 SHORT $LN24@gz_open

; 184  :             free(state);

  001b7	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  001ba	52		 push	 edx
  001bb	e8 00 00 00 00	 call	 _free
  001c0	83 c4 04	 add	 esp, 4

; 185  :             return NULL;

  001c3	33 c0		 xor	 eax, eax
  001c5	e9 2f 02 00 00	 jmp	 $LN1@gz_open
$LN24@gz_open:

; 186  :         }
; 187  :         state->direct = 1;      /* for empty file */

  001ca	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  001cd	c7 40 2c 01 00
	00 00		 mov	 DWORD PTR [eax+44], 1
$LN23@gz_open:

; 188  :     }
; 189  : 
; 190  :     /* save the path name for error messages */
; 191  : #ifdef WIDECHAR
; 192  :     if (fd == -2) {

  001d4	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  001d8	75 22		 jne	 SHORT $LN25@gz_open

; 193  :         len = wcstombs(NULL, path, 0);

  001da	6a 00		 push	 0
  001dc	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  001df	51		 push	 ecx
  001e0	6a 00		 push	 0
  001e2	e8 00 00 00 00	 call	 _wcstombs
  001e7	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ea	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 194  :         if (len == (z_size_t)-1)

  001ed	83 7d f8 ff	 cmp	 DWORD PTR _len$[ebp], -1
  001f1	75 07		 jne	 SHORT $LN27@gz_open

; 195  :             len = 0;

  001f3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN27@gz_open:

; 196  :     }

  001fa	eb 0f		 jmp	 SHORT $LN26@gz_open
$LN25@gz_open:

; 197  :     else
; 198  : #endif
; 199  :         len = strlen((const char *)path);

  001fc	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  001ff	52		 push	 edx
  00200	e8 00 00 00 00	 call	 _strlen
  00205	83 c4 04	 add	 esp, 4
  00208	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax
$LN26@gz_open:

; 200  :     state->path = (char *)malloc(len + 1);

  0020b	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  0020e	83 c0 01	 add	 eax, 1
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 _malloc
  00217	83 c4 04	 add	 esp, 4
  0021a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0021d	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 201  :     if (state->path == NULL) {

  00220	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00223	83 7a 18 00	 cmp	 DWORD PTR [edx+24], 0
  00227	75 13		 jne	 SHORT $LN28@gz_open

; 202  :         free(state);

  00229	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0022c	50		 push	 eax
  0022d	e8 00 00 00 00	 call	 _free
  00232	83 c4 04	 add	 esp, 4

; 203  :         return NULL;

  00235	33 c0		 xor	 eax, eax
  00237	e9 bd 01 00 00	 jmp	 $LN1@gz_open
$LN28@gz_open:

; 204  :     }
; 205  : #ifdef WIDECHAR
; 206  :     if (fd == -2)

  0023c	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  00240	75 2d		 jne	 SHORT $LN29@gz_open

; 207  :         if (len)

  00242	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  00246	74 1c		 je	 SHORT $LN31@gz_open

; 208  :             wcstombs(state->path, path, len + 1);

  00248	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  0024b	83 c1 01	 add	 ecx, 1
  0024e	51		 push	 ecx
  0024f	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  00252	52		 push	 edx
  00253	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00256	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00259	51		 push	 ecx
  0025a	e8 00 00 00 00	 call	 _wcstombs
  0025f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00262	eb 09		 jmp	 SHORT $LN32@gz_open
$LN31@gz_open:

; 209  :         else
; 210  :             *(state->path) = 0;

  00264	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00267	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0026a	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN32@gz_open:
  0026d	eb 1f		 jmp	 SHORT $LN30@gz_open
$LN29@gz_open:

; 211  :     else
; 212  : #endif
; 213  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 214  :         (void)snprintf(state->path, len + 1, "%s", (const char *)path);

  0026f	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00272	51		 push	 ecx
  00273	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00278	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  0027b	83 c2 01	 add	 edx, 1
  0027e	52		 push	 edx
  0027f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00282	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00285	51		 push	 ecx
  00286	e8 00 00 00 00	 call	 _snprintf
  0028b	83 c4 10	 add	 esp, 16			; 00000010H
$LN30@gz_open:

; 215  : #else
; 216  :         strcpy(state->path, path);
; 217  : #endif
; 218  : 
; 219  :     /* compute the flags for open() */
; 220  :     oflag =

  0028e	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00291	81 7a 10 4f 1c
	00 00		 cmp	 DWORD PTR [edx+16], 7247 ; 00001c4fH
  00298	75 09		 jne	 SHORT $LN42@gz_open
  0029a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv184[ebp], 0
  002a1	eb 41		 jmp	 SHORT $LN43@gz_open
$LN42@gz_open:
  002a3	83 7d f0 00	 cmp	 DWORD PTR _exclusive$[ebp], 0
  002a7	74 09		 je	 SHORT $LN38@gz_open
  002a9	c7 45 e4 00 04
	00 00		 mov	 DWORD PTR tv178[ebp], 1024 ; 00000400H
  002b0	eb 07		 jmp	 SHORT $LN39@gz_open
$LN38@gz_open:
  002b2	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv178[ebp], 0
$LN39@gz_open:
  002b9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  002bc	81 78 10 b1 79
	00 00		 cmp	 DWORD PTR [eax+16], 31153 ; 000079b1H
  002c3	75 09		 jne	 SHORT $LN40@gz_open
  002c5	c7 45 e0 00 02
	00 00		 mov	 DWORD PTR tv182[ebp], 512 ; 00000200H
  002cc	eb 07		 jmp	 SHORT $LN41@gz_open
$LN40@gz_open:
  002ce	c7 45 e0 08 00
	00 00		 mov	 DWORD PTR tv182[ebp], 8
$LN41@gz_open:
  002d5	8b 4d e4	 mov	 ecx, DWORD PTR tv178[ebp]
  002d8	81 c9 01 01 00
	00		 or	 ecx, 257		; 00000101H
  002de	0b 4d e0	 or	 ecx, DWORD PTR tv182[ebp]
  002e1	89 4d e8	 mov	 DWORD PTR tv184[ebp], ecx
$LN43@gz_open:
  002e4	8b 55 e8	 mov	 edx, DWORD PTR tv184[ebp]
  002e7	81 ca 00 80 00
	00		 or	 edx, 32768		; 00008000H
  002ed	89 55 f4	 mov	 DWORD PTR _oflag$[ebp], edx

; 221  : #ifdef O_LARGEFILE
; 222  :         O_LARGEFILE |
; 223  : #endif
; 224  : #ifdef O_BINARY
; 225  :         O_BINARY |
; 226  : #endif
; 227  : #ifdef O_CLOEXEC
; 228  :         (cloexec ? O_CLOEXEC : 0) |
; 229  : #endif
; 230  :         (state->mode == GZ_READ ?
; 231  :          O_RDONLY :
; 232  :          (O_WRONLY | O_CREAT |
; 233  : #ifdef O_EXCL
; 234  :           (exclusive ? O_EXCL : 0) |
; 235  : #endif
; 236  :           (state->mode == GZ_WRITE ?
; 237  :            O_TRUNC :
; 238  :            O_APPEND)));
; 239  : 
; 240  :     /* open the file with the appropriate flags (or just use fd) */
; 241  :     state->fd = fd > -1 ? fd : (

  002f0	83 7d 0c ff	 cmp	 DWORD PTR _fd$[ebp], -1
  002f4	7e 08		 jle	 SHORT $LN46@gz_open
  002f6	8b 45 0c	 mov	 eax, DWORD PTR _fd$[ebp]
  002f9	89 45 dc	 mov	 DWORD PTR tv198[ebp], eax
  002fc	eb 3e		 jmp	 SHORT $LN47@gz_open
$LN46@gz_open:
  002fe	83 7d 0c fe	 cmp	 DWORD PTR _fd$[ebp], -2	; fffffffeH
  00302	75 1a		 jne	 SHORT $LN44@gz_open
  00304	68 b6 01 00 00	 push	 438			; 000001b6H
  00309	8b 4d f4	 mov	 ecx, DWORD PTR _oflag$[ebp]
  0030c	51		 push	 ecx
  0030d	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  00310	52		 push	 edx
  00311	e8 00 00 00 00	 call	 __wopen
  00316	83 c4 0c	 add	 esp, 12			; 0000000cH
  00319	89 45 d8	 mov	 DWORD PTR tv197[ebp], eax
  0031c	eb 18		 jmp	 SHORT $LN45@gz_open
$LN44@gz_open:
  0031e	68 b6 01 00 00	 push	 438			; 000001b6H
  00323	8b 45 f4	 mov	 eax, DWORD PTR _oflag$[ebp]
  00326	50		 push	 eax
  00327	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0032a	51		 push	 ecx
  0032b	e8 00 00 00 00	 call	 __open
  00330	83 c4 0c	 add	 esp, 12			; 0000000cH
  00333	89 45 d8	 mov	 DWORD PTR tv197[ebp], eax
$LN45@gz_open:
  00336	8b 55 d8	 mov	 edx, DWORD PTR tv197[ebp]
  00339	89 55 dc	 mov	 DWORD PTR tv198[ebp], edx
$LN47@gz_open:
  0033c	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0033f	8b 4d dc	 mov	 ecx, DWORD PTR tv198[ebp]
  00342	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 242  : #ifdef WIDECHAR
; 243  :         fd == -2 ? _wopen(path, oflag, 0666) :
; 244  : #endif
; 245  :         open((const char *)path, oflag, 0666));
; 246  :     if (state->fd == -1) {

  00345	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00348	83 7a 14 ff	 cmp	 DWORD PTR [edx+20], -1
  0034c	75 22		 jne	 SHORT $LN33@gz_open

; 247  :         free(state->path);

  0034e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00351	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00354	51		 push	 ecx
  00355	e8 00 00 00 00	 call	 _free
  0035a	83 c4 04	 add	 esp, 4

; 248  :         free(state);

  0035d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00360	52		 push	 edx
  00361	e8 00 00 00 00	 call	 _free
  00366	83 c4 04	 add	 esp, 4

; 249  :         return NULL;

  00369	33 c0		 xor	 eax, eax
  0036b	e9 89 00 00 00	 jmp	 $LN1@gz_open
$LN33@gz_open:

; 250  :     }
; 251  :     if (state->mode == GZ_APPEND) {

  00370	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00373	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  00377	75 1f		 jne	 SHORT $LN34@gz_open

; 252  :         LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */

  00379	6a 02		 push	 2
  0037b	6a 00		 push	 0
  0037d	6a 00		 push	 0
  0037f	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00382	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00385	52		 push	 edx
  00386	e8 00 00 00 00	 call	 __lseeki64
  0038b	83 c4 10	 add	 esp, 16			; 00000010H

; 253  :         state->mode = GZ_WRITE;         /* simplify later checks */

  0038e	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00391	c7 40 10 b1 79
	00 00		 mov	 DWORD PTR [eax+16], 31153 ; 000079b1H
$LN34@gz_open:

; 254  :     }
; 255  : 
; 256  :     /* save the current position for rewinding (only if reading) */
; 257  :     if (state->mode == GZ_READ) {

  00398	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0039b	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  003a2	75 46		 jne	 SHORT $LN35@gz_open

; 258  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  003a4	6a 01		 push	 1
  003a6	6a 00		 push	 0
  003a8	6a 00		 push	 0
  003aa	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  003ad	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  003b0	50		 push	 eax
  003b1	e8 00 00 00 00	 call	 __lseeki64
  003b6	83 c4 10	 add	 esp, 16			; 00000010H
  003b9	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  003bc	89 41 38	 mov	 DWORD PTR [ecx+56], eax
  003bf	89 51 3c	 mov	 DWORD PTR [ecx+60], edx

; 259  :         if (state->start == -1) state->start = 0;

  003c2	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  003c5	89 55 d4	 mov	 DWORD PTR tv326[ebp], edx
  003c8	8b 45 d4	 mov	 eax, DWORD PTR tv326[ebp]
  003cb	8b 4d d4	 mov	 ecx, DWORD PTR tv326[ebp]
  003ce	8b 50 38	 mov	 edx, DWORD PTR [eax+56]
  003d1	23 51 3c	 and	 edx, DWORD PTR [ecx+60]
  003d4	83 fa ff	 cmp	 edx, -1
  003d7	75 11		 jne	 SHORT $LN35@gz_open
  003d9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  003dc	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
  003e3	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
$LN35@gz_open:

; 260  :     }
; 261  : 
; 262  :     /* initialize stream */
; 263  :     gz_reset(state);

  003ea	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  003ed	51		 push	 ecx
  003ee	e8 00 00 00 00	 call	 _gz_reset
  003f3	83 c4 04	 add	 esp, 4

; 264  : 
; 265  :     /* return stream */
; 266  :     return (gzFile)state;

  003f6	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
$LN1@gz_open:

; 267  : }

  003f9	5f		 pop	 edi
  003fa	83 c4 2c	 add	 esp, 44			; 0000002cH
  003fd	3b ec		 cmp	 ebp, esp
  003ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00404	8b e5		 mov	 esp, ebp
  00406	5d		 pop	 ebp
  00407	c3		 ret	 0
$LN56@gz_open:
  00408	00 00 00 00	 DD	 $LN13@gz_open
  0040c	00 00 00 00	 DD	 $LN19@gz_open
  00410	00 00 00 00	 DD	 $LN18@gz_open
  00414	00 00 00 00	 DD	 $LN20@gz_open
  00418	00 00 00 00	 DD	 $LN12@gz_open
  0041c	00 00 00 00	 DD	 $LN16@gz_open
  00420	00 00 00 00	 DD	 $LN17@gz_open
  00424	00 00 00 00	 DD	 $LN10@gz_open
  00428	00 00 00 00	 DD	 $LN11@gz_open
  0042c	00 00 00 00	 DD	 $LN15@gz_open
  00430	00 00 00 00	 DD	 $LN9@gz_open
$LN55@gz_open:
  00434	00		 DB	 0
  00435	0a		 DB	 10			; 0000000aH
  00436	0a		 DB	 10			; 0000000aH
  00437	0a		 DB	 10			; 0000000aH
  00438	0a		 DB	 10			; 0000000aH
  00439	0a		 DB	 10			; 0000000aH
  0043a	0a		 DB	 10			; 0000000aH
  0043b	0a		 DB	 10			; 0000000aH
  0043c	0a		 DB	 10			; 0000000aH
  0043d	0a		 DB	 10			; 0000000aH
  0043e	0a		 DB	 10			; 0000000aH
  0043f	0a		 DB	 10			; 0000000aH
  00440	0a		 DB	 10			; 0000000aH
  00441	0a		 DB	 10			; 0000000aH
  00442	0a		 DB	 10			; 0000000aH
  00443	0a		 DB	 10			; 0000000aH
  00444	0a		 DB	 10			; 0000000aH
  00445	0a		 DB	 10			; 0000000aH
  00446	0a		 DB	 10			; 0000000aH
  00447	0a		 DB	 10			; 0000000aH
  00448	0a		 DB	 10			; 0000000aH
  00449	0a		 DB	 10			; 0000000aH
  0044a	0a		 DB	 10			; 0000000aH
  0044b	0a		 DB	 10			; 0000000aH
  0044c	0a		 DB	 10			; 0000000aH
  0044d	0a		 DB	 10			; 0000000aH
  0044e	0a		 DB	 10			; 0000000aH
  0044f	01		 DB	 1
  00450	0a		 DB	 10			; 0000000aH
  00451	0a		 DB	 10			; 0000000aH
  00452	0a		 DB	 10			; 0000000aH
  00453	0a		 DB	 10			; 0000000aH
  00454	0a		 DB	 10			; 0000000aH
  00455	0a		 DB	 10			; 0000000aH
  00456	0a		 DB	 10			; 0000000aH
  00457	0a		 DB	 10			; 0000000aH
  00458	0a		 DB	 10			; 0000000aH
  00459	0a		 DB	 10			; 0000000aH
  0045a	0a		 DB	 10			; 0000000aH
  0045b	02		 DB	 2
  0045c	0a		 DB	 10			; 0000000aH
  0045d	03		 DB	 3
  0045e	0a		 DB	 10			; 0000000aH
  0045f	0a		 DB	 10			; 0000000aH
  00460	0a		 DB	 10			; 0000000aH
  00461	0a		 DB	 10			; 0000000aH
  00462	0a		 DB	 10			; 0000000aH
  00463	0a		 DB	 10			; 0000000aH
  00464	0a		 DB	 10			; 0000000aH
  00465	0a		 DB	 10			; 0000000aH
  00466	0a		 DB	 10			; 0000000aH
  00467	0a		 DB	 10			; 0000000aH
  00468	0a		 DB	 10			; 0000000aH
  00469	0a		 DB	 10			; 0000000aH
  0046a	04		 DB	 4
  0046b	0a		 DB	 10			; 0000000aH
  0046c	0a		 DB	 10			; 0000000aH
  0046d	0a		 DB	 10			; 0000000aH
  0046e	0a		 DB	 10			; 0000000aH
  0046f	05		 DB	 5
  00470	0a		 DB	 10			; 0000000aH
  00471	06		 DB	 6
  00472	0a		 DB	 10			; 0000000aH
  00473	0a		 DB	 10			; 0000000aH
  00474	0a		 DB	 10			; 0000000aH
  00475	0a		 DB	 10			; 0000000aH
  00476	0a		 DB	 10			; 0000000aH
  00477	0a		 DB	 10			; 0000000aH
  00478	0a		 DB	 10			; 0000000aH
  00479	0a		 DB	 10			; 0000000aH
  0047a	0a		 DB	 10			; 0000000aH
  0047b	07		 DB	 7
  0047c	0a		 DB	 10			; 0000000aH
  0047d	0a		 DB	 10			; 0000000aH
  0047e	0a		 DB	 10			; 0000000aH
  0047f	0a		 DB	 10			; 0000000aH
  00480	08		 DB	 8
  00481	09		 DB	 9
_gz_open ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzopen@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen@8 PROC						; COMDAT

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 274  :     return gz_open(path, -1, mode);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00010	50		 push	 eax
  00011	6a ff		 push	 -1
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 _gz_open
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : }

  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
_gzopen@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzdopen@8
_TEXT	SEGMENT
_gz$ = -8						; size = 4
_path$ = -4						; size = 4
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzdopen@8 PROC						; COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 290  :     char *path;         /* identifier for error messages */
; 291  :     gzFile gz;
; 292  : 
; 293  :     if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)

  0001e	83 7d 08 ff	 cmp	 DWORD PTR _fd$[ebp], -1
  00022	74 13		 je	 SHORT $LN3@gzdopen
  00024	6a 13		 push	 19			; 00000013H
  00026	e8 00 00 00 00	 call	 _malloc
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 fc	 mov	 DWORD PTR _path$[ebp], eax
  00031	83 7d fc 00	 cmp	 DWORD PTR _path$[ebp], 0
  00035	75 04		 jne	 SHORT $LN2@gzdopen
$LN3@gzdopen:

; 294  :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	eb 3d		 jmp	 SHORT $LN1@gzdopen
$LN2@gzdopen:

; 295  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 296  :     (void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);

  0003b	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@
  00044	6a 13		 push	 19			; 00000013H
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _path$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 _snprintf
  0004f	83 c4 10	 add	 esp, 16			; 00000010H

; 297  : #else
; 298  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */
; 299  : #endif
; 300  :     gz = gz_open(path, fd, mode);

  00052	8b 55 0c	 mov	 edx, DWORD PTR _mode$[ebp]
  00055	52		 push	 edx
  00056	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _path$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 _gz_open
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	89 45 f8	 mov	 DWORD PTR _gz$[ebp], eax

; 301  :     free(path);

  00069	8b 55 fc	 mov	 edx, DWORD PTR _path$[ebp]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 _free
  00072	83 c4 04	 add	 esp, 4

; 302  :     return gz;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _gz$[ebp]
$LN1@gzdopen:

; 303  : }

  00078	83 c4 08	 add	 esp, 8
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
_gzdopen@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzopen_w@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen_w@8 PROC					; COMDAT

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 311  :     return gz_open(path, -2, mode);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00010	50		 push	 eax
  00011	6a fe		 push	 -2			; fffffffeH
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 _gz_open
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 312  : }

  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
_gzopen_w@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzbuffer@8
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_size$ = 12						; size = 4
_gzbuffer@8 PROC					; COMDAT

; 319  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 320  :     gz_statep state;
; 321  : 
; 322  :     /* get internal structure and check integrity */
; 323  :     if (file == NULL)

  00015	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00019	75 05		 jne	 SHORT $LN2@gzbuffer

; 324  :         return -1;

  0001b	83 c8 ff	 or	 eax, -1
  0001e	eb 58		 jmp	 SHORT $LN1@gzbuffer
$LN2@gzbuffer:

; 325  :     state = (gz_statep)file;

  00020	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 326  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00029	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00030	74 11		 je	 SHORT $LN3@gzbuffer
  00032	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00035	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0003c	74 05		 je	 SHORT $LN3@gzbuffer

; 327  :         return -1;

  0003e	83 c8 ff	 or	 eax, -1
  00041	eb 35		 jmp	 SHORT $LN1@gzbuffer
$LN3@gzbuffer:

; 328  : 
; 329  :     /* make sure we haven't already allocated memory */
; 330  :     if (state->size != 0)

  00043	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00046	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0004a	74 05		 je	 SHORT $LN4@gzbuffer

; 331  :         return -1;

  0004c	83 c8 ff	 or	 eax, -1
  0004f	eb 27		 jmp	 SHORT $LN1@gzbuffer
$LN4@gzbuffer:

; 332  : 
; 333  :     /* check and set requested size */
; 334  :     if ((size << 1) < size)

  00051	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  00054	d1 e1		 shl	 ecx, 1
  00056	3b 4d 0c	 cmp	 ecx, DWORD PTR _size$[ebp]
  00059	73 05		 jae	 SHORT $LN5@gzbuffer

; 335  :         return -1;              /* need to be able to double it */

  0005b	83 c8 ff	 or	 eax, -1
  0005e	eb 18		 jmp	 SHORT $LN1@gzbuffer
$LN5@gzbuffer:

; 336  :     if (size < 2)

  00060	83 7d 0c 02	 cmp	 DWORD PTR _size$[ebp], 2
  00064	73 07		 jae	 SHORT $LN6@gzbuffer

; 337  :         size = 2;               /* need two bytes to check magic header */

  00066	c7 45 0c 02 00
	00 00		 mov	 DWORD PTR _size$[ebp], 2
$LN6@gzbuffer:

; 338  :     state->want = size;

  0006d	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00070	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00073	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 339  :     return 0;

  00076	33 c0		 xor	 eax, eax
$LN1@gzbuffer:

; 340  : }

  00078	83 c4 04	 add	 esp, 4
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
_gzbuffer@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzrewind@4
_TEXT	SEGMENT
tv132 = -12						; size = 8
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzrewind@4 PROC					; COMDAT

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 346  :     gz_statep state;
; 347  : 
; 348  :     /* get internal structure */
; 349  :     if (file == NULL)

  00025	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00029	75 05		 jne	 SHORT $LN2@gzrewind

; 350  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1
  0002e	eb 69		 jmp	 SHORT $LN1@gzrewind
$LN2@gzrewind:

; 351  :     state = (gz_statep)file;

  00030	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00033	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 352  : 
; 353  :     /* check that we're reading and that there's no error */
; 354  :     if (state->mode != GZ_READ ||

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00039	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00040	75 12		 jne	 SHORT $LN4@gzrewind
  00042	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00045	83 7a 5c 00	 cmp	 DWORD PTR [edx+92], 0
  00049	74 0e		 je	 SHORT $LN3@gzrewind
  0004b	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0004e	83 78 5c fb	 cmp	 DWORD PTR [eax+92], -5	; fffffffbH
  00052	74 05		 je	 SHORT $LN3@gzrewind
$LN4@gzrewind:

; 355  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 356  :         return -1;

  00054	83 c8 ff	 or	 eax, -1
  00057	eb 40		 jmp	 SHORT $LN1@gzrewind
$LN3@gzrewind:

; 357  : 
; 358  :     /* back up and start over */
; 359  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  00059	6a 00		 push	 0
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0005e	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00061	52		 push	 edx
  00062	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00065	50		 push	 eax
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00069	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 __lseeki64
  00072	83 c4 10	 add	 esp, 16			; 00000010H
  00075	89 45 f4	 mov	 DWORD PTR tv132[ebp], eax
  00078	89 55 f8	 mov	 DWORD PTR tv132[ebp+4], edx
  0007b	8b 45 f4	 mov	 eax, DWORD PTR tv132[ebp]
  0007e	23 45 f8	 and	 eax, DWORD PTR tv132[ebp+4]
  00081	83 f8 ff	 cmp	 eax, -1
  00084	75 05		 jne	 SHORT $LN5@gzrewind

; 360  :         return -1;

  00086	83 c8 ff	 or	 eax, -1
  00089	eb 0e		 jmp	 SHORT $LN1@gzrewind
$LN5@gzrewind:

; 361  :     gz_reset(state);

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0008e	51		 push	 ecx
  0008f	e8 00 00 00 00	 call	 _gz_reset
  00094	83 c4 04	 add	 esp, 4

; 362  :     return 0;

  00097	33 c0		 xor	 eax, eax
$LN1@gzrewind:

; 363  : }

  00099	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009c	3b ec		 cmp	 ebp, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c2 04 00	 ret	 4
_gzrewind@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzseek64@16
_TEXT	SEGMENT
tv160 = -36						; size = 4
tv291 = -32						; size = 8
tv220 = -24						; size = 8
_state$ = -16						; size = 4
_ret$ = -12						; size = 8
_n$ = -4						; size = 4
_file$ = 8						; size = 4
_offset$ = 12						; size = 8
_whence$ = 20						; size = 4
_gzseek64@16 PROC					; COMDAT

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0002b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 371  :     unsigned n;
; 372  :     z_off64_t ret;
; 373  :     gz_statep state;
; 374  : 
; 375  :     /* get internal structure and check integrity */
; 376  :     if (file == NULL)

  00030	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00034	75 0b		 jne	 SHORT $LN2@gzseek64

; 377  :         return -1;

  00036	83 c8 ff	 or	 eax, -1
  00039	83 ca ff	 or	 edx, -1
  0003c	e9 bb 02 00 00	 jmp	 $LN1@gzseek64
$LN2@gzseek64:

; 378  :     state = (gz_statep)file;

  00041	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR _state$[ebp], eax

; 379  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00047	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0004a	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00051	74 17		 je	 SHORT $LN3@gzseek64
  00053	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00056	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0005d	74 0b		 je	 SHORT $LN3@gzseek64

; 380  :         return -1;

  0005f	83 c8 ff	 or	 eax, -1
  00062	83 ca ff	 or	 edx, -1
  00065	e9 92 02 00 00	 jmp	 $LN1@gzseek64
$LN3@gzseek64:

; 381  : 
; 382  :     /* check that there's no error */
; 383  :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  0006a	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0006d	83 78 5c 00	 cmp	 DWORD PTR [eax+92], 0
  00071	74 14		 je	 SHORT $LN4@gzseek64
  00073	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00076	83 79 5c fb	 cmp	 DWORD PTR [ecx+92], -5	; fffffffbH
  0007a	74 0b		 je	 SHORT $LN4@gzseek64

; 384  :         return -1;

  0007c	83 c8 ff	 or	 eax, -1
  0007f	83 ca ff	 or	 edx, -1
  00082	e9 75 02 00 00	 jmp	 $LN1@gzseek64
$LN4@gzseek64:

; 385  : 
; 386  :     /* can only seek from start or relative to current position */
; 387  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  00087	83 7d 14 00	 cmp	 DWORD PTR _whence$[ebp], 0
  0008b	74 11		 je	 SHORT $LN5@gzseek64
  0008d	83 7d 14 01	 cmp	 DWORD PTR _whence$[ebp], 1
  00091	74 0b		 je	 SHORT $LN5@gzseek64

; 388  :         return -1;

  00093	83 c8 ff	 or	 eax, -1
  00096	83 ca ff	 or	 edx, -1
  00099	e9 5e 02 00 00	 jmp	 $LN1@gzseek64
$LN5@gzseek64:

; 389  : 
; 390  :     /* normalize offset to a SEEK_CUR specification */
; 391  :     if (whence == SEEK_SET)

  0009e	83 7d 14 00	 cmp	 DWORD PTR _whence$[ebp], 0
  000a2	75 17		 jne	 SHORT $LN6@gzseek64

; 392  :         offset -= state->x.pos;

  000a4	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000a7	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  000aa	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  000ad	8b 4d 10	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  000b0	1b 4a 0c	 sbb	 ecx, DWORD PTR [edx+12]
  000b3	89 45 0c	 mov	 DWORD PTR _offset$[ebp], eax
  000b6	89 4d 10	 mov	 DWORD PTR _offset$[ebp+4], ecx
  000b9	eb 1e		 jmp	 SHORT $LN7@gzseek64
$LN6@gzseek64:

; 393  :     else if (state->seek)

  000bb	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000be	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  000c2	74 15		 je	 SHORT $LN7@gzseek64

; 394  :         offset += state->skip;

  000c4	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000c7	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  000ca	03 48 50	 add	 ecx, DWORD PTR [eax+80]
  000cd	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  000d0	13 50 54	 adc	 edx, DWORD PTR [eax+84]
  000d3	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  000d6	89 55 10	 mov	 DWORD PTR _offset$[ebp+4], edx
$LN7@gzseek64:

; 395  :     state->seek = 0;

  000d9	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  000dc	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [eax+88], 0

; 396  : 
; 397  :     /* if within raw area while reading, just go there */
; 398  :     if (state->mode == GZ_READ && state->how == COPY &&

  000e3	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000e6	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  000ed	0f 85 e0 00 00
	00		 jne	 $LN9@gzseek64
  000f3	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000f6	83 7a 30 01	 cmp	 DWORD PTR [edx+48], 1
  000fa	0f 85 d3 00 00
	00		 jne	 $LN9@gzseek64
  00100	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00103	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00106	03 4d 0c	 add	 ecx, DWORD PTR _offset$[ebp]
  00109	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0010c	13 55 10	 adc	 edx, DWORD PTR _offset$[ebp+4]
  0010f	89 4d e8	 mov	 DWORD PTR tv220[ebp], ecx
  00112	89 55 ec	 mov	 DWORD PTR tv220[ebp+4], edx
  00115	83 7d ec 00	 cmp	 DWORD PTR tv220[ebp+4], 0
  00119	0f 8c b4 00 00
	00		 jl	 $LN9@gzseek64
  0011f	7f 0a		 jg	 SHORT $LN22@gzseek64
  00121	83 7d e8 00	 cmp	 DWORD PTR tv220[ebp], 0
  00125	0f 82 a8 00 00
	00		 jb	 $LN9@gzseek64
$LN22@gzseek64:

; 399  :             state->x.pos + offset >= 0) {
; 400  :         ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);

  0012b	0f ae e8	 lfence
  0012e	6a 01		 push	 1
  00130	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00133	33 c9		 xor	 ecx, ecx
  00135	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  00138	2b 10		 sub	 edx, DWORD PTR [eax]
  0013a	8b 45 10	 mov	 eax, DWORD PTR _offset$[ebp+4]
  0013d	1b c1		 sbb	 eax, ecx
  0013f	50		 push	 eax
  00140	52		 push	 edx
  00141	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00144	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00147	52		 push	 edx
  00148	e8 00 00 00 00	 call	 __lseeki64
  0014d	83 c4 10	 add	 esp, 16			; 00000010H
  00150	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax
  00153	89 55 f8	 mov	 DWORD PTR _ret$[ebp+4], edx

; 401  :         if (ret == -1)

  00156	8b 45 f4	 mov	 eax, DWORD PTR _ret$[ebp]
  00159	23 45 f8	 and	 eax, DWORD PTR _ret$[ebp+4]
  0015c	83 f8 ff	 cmp	 eax, -1
  0015f	75 0b		 jne	 SHORT $LN10@gzseek64

; 402  :             return -1;

  00161	83 c8 ff	 or	 eax, -1
  00164	83 ca ff	 or	 edx, -1
  00167	e9 90 01 00 00	 jmp	 $LN1@gzseek64
$LN10@gzseek64:

; 403  :         state->x.have = 0;

  0016c	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0016f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 404  :         state->eof = 0;

  00175	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00178	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 405  :         state->past = 0;

  0017f	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00182	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0

; 406  :         state->seek = 0;

  00189	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0018c	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 407  :         gz_error(state, Z_OK, NULL);

  00193	6a 00		 push	 0
  00195	6a 00		 push	 0
  00197	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0019a	52		 push	 edx
  0019b	e8 00 00 00 00	 call	 _gz_error
  001a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 408  :         state->strm.avail_in = 0;

  001a3	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001a6	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 409  :         state->x.pos += offset;

  001ad	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001b0	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001b3	03 55 0c	 add	 edx, DWORD PTR _offset$[ebp]
  001b6	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  001b9	13 45 10	 adc	 eax, DWORD PTR _offset$[ebp+4]
  001bc	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001bf	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  001c2	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 410  :         return state->x.pos;

  001c5	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  001c8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001cb	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  001ce	e9 29 01 00 00	 jmp	 $LN1@gzseek64
$LN9@gzseek64:

; 411  :     }
; 412  : 
; 413  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 414  :     if (offset < 0) {

  001d3	83 7d 10 00	 cmp	 DWORD PTR _offset$[ebp+4], 0
  001d7	7f 66		 jg	 SHORT $LN11@gzseek64
  001d9	7c 06		 jl	 SHORT $LN23@gzseek64
  001db	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  001df	73 5e		 jae	 SHORT $LN11@gzseek64
$LN23@gzseek64:

; 415  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  001e1	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  001e4	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  001eb	74 0b		 je	 SHORT $LN12@gzseek64

; 416  :             return -1;

  001ed	83 c8 ff	 or	 eax, -1
  001f0	83 ca ff	 or	 edx, -1
  001f3	e9 04 01 00 00	 jmp	 $LN1@gzseek64
$LN12@gzseek64:

; 417  :         offset += state->x.pos;

  001f8	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  001fb	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  001fe	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00201	8b 45 10	 mov	 eax, DWORD PTR _offset$[ebp+4]
  00204	13 41 0c	 adc	 eax, DWORD PTR [ecx+12]
  00207	89 55 0c	 mov	 DWORD PTR _offset$[ebp], edx
  0020a	89 45 10	 mov	 DWORD PTR _offset$[ebp+4], eax

; 418  :         if (offset < 0)                     /* before start of file! */

  0020d	83 7d 10 00	 cmp	 DWORD PTR _offset$[ebp+4], 0
  00211	7f 13		 jg	 SHORT $LN13@gzseek64
  00213	7c 06		 jl	 SHORT $LN24@gzseek64
  00215	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  00219	73 0b		 jae	 SHORT $LN13@gzseek64
$LN24@gzseek64:

; 419  :             return -1;

  0021b	83 c8 ff	 or	 eax, -1
  0021e	83 ca ff	 or	 edx, -1
  00221	e9 d6 00 00 00	 jmp	 $LN1@gzseek64
$LN13@gzseek64:

; 420  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  00226	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00229	51		 push	 ecx
  0022a	e8 00 00 00 00	 call	 _gzrewind@4
  0022f	83 f8 ff	 cmp	 eax, -1
  00232	75 0b		 jne	 SHORT $LN11@gzseek64

; 421  :             return -1;

  00234	83 c8 ff	 or	 eax, -1
  00237	83 ca ff	 or	 edx, -1
  0023a	e9 bd 00 00 00	 jmp	 $LN1@gzseek64
$LN11@gzseek64:

; 422  :     }
; 423  : 
; 424  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 425  :     if (state->mode == GZ_READ) {

  0023f	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00242	81 7a 10 4f 1c
	00 00		 cmp	 DWORD PTR [edx+16], 7247 ; 00001c4fH
  00249	75 7f		 jne	 SHORT $LN15@gzseek64

; 426  :         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?

  0024b	33 c0		 xor	 eax, eax
  0024d	75 29		 jne	 SHORT $LN18@gzseek64
  0024f	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00252	8b 11		 mov	 edx, DWORD PTR [ecx]
  00254	33 c0		 xor	 eax, eax
  00256	89 55 e0	 mov	 DWORD PTR tv291[ebp], edx
  00259	89 45 e4	 mov	 DWORD PTR tv291[ebp+4], eax
  0025c	8b 4d e4	 mov	 ecx, DWORD PTR tv291[ebp+4]
  0025f	3b 4d 10	 cmp	 ecx, DWORD PTR _offset$[ebp+4]
  00262	7f 14		 jg	 SHORT $LN18@gzseek64
  00264	7c 08		 jl	 SHORT $LN25@gzseek64
  00266	8b 55 e0	 mov	 edx, DWORD PTR tv291[ebp]
  00269	3b 55 0c	 cmp	 edx, DWORD PTR _offset$[ebp]
  0026c	77 0a		 ja	 SHORT $LN18@gzseek64
$LN25@gzseek64:
  0026e	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00271	8b 08		 mov	 ecx, DWORD PTR [eax]
  00273	89 4d dc	 mov	 DWORD PTR tv160[ebp], ecx
  00276	eb 06		 jmp	 SHORT $LN19@gzseek64
$LN18@gzseek64:
  00278	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  0027b	89 55 dc	 mov	 DWORD PTR tv160[ebp], edx
$LN19@gzseek64:
  0027e	8b 45 dc	 mov	 eax, DWORD PTR tv160[ebp]
  00281	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 427  :             (unsigned)offset : state->x.have;
; 428  :         state->x.have -= n;

  00284	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00287	8b 11		 mov	 edx, DWORD PTR [ecx]
  00289	2b 55 fc	 sub	 edx, DWORD PTR _n$[ebp]
  0028c	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0028f	89 10		 mov	 DWORD PTR [eax], edx

; 429  :         state->x.next += n;

  00291	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00294	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00297	03 55 fc	 add	 edx, DWORD PTR _n$[ebp]
  0029a	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0029d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 430  :         state->x.pos += n;

  002a0	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  002a3	33 d2		 xor	 edx, edx
  002a5	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  002a8	03 48 08	 add	 ecx, DWORD PTR [eax+8]
  002ab	13 50 0c	 adc	 edx, DWORD PTR [eax+12]
  002ae	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  002b1	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  002b4	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 431  :         offset -= n;

  002b7	33 c9		 xor	 ecx, ecx
  002b9	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  002bc	2b 55 fc	 sub	 edx, DWORD PTR _n$[ebp]
  002bf	8b 45 10	 mov	 eax, DWORD PTR _offset$[ebp+4]
  002c2	1b c1		 sbb	 eax, ecx
  002c4	89 55 0c	 mov	 DWORD PTR _offset$[ebp], edx
  002c7	89 45 10	 mov	 DWORD PTR _offset$[ebp+4], eax
$LN15@gzseek64:

; 432  :     }
; 433  : 
; 434  :     /* request skip (if not zero) */
; 435  :     if (offset) {

  002ca	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  002cd	0b 4d 10	 or	 ecx, DWORD PTR _offset$[ebp+4]
  002d0	74 19		 je	 SHORT $LN16@gzseek64

; 436  :         state->seek = 1;

  002d2	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  002d5	c7 42 58 01 00
	00 00		 mov	 DWORD PTR [edx+88], 1

; 437  :         state->skip = offset;

  002dc	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  002df	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  002e2	89 48 50	 mov	 DWORD PTR [eax+80], ecx
  002e5	8b 55 10	 mov	 edx, DWORD PTR _offset$[ebp+4]
  002e8	89 50 54	 mov	 DWORD PTR [eax+84], edx
$LN16@gzseek64:

; 438  :     }
; 439  :     return state->x.pos + offset;

  002eb	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  002ee	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002f1	03 4d 0c	 add	 ecx, DWORD PTR _offset$[ebp]
  002f4	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  002f7	13 55 10	 adc	 edx, DWORD PTR _offset$[ebp+4]
  002fa	8b c1		 mov	 eax, ecx
$LN1@gzseek64:

; 440  : }

  002fc	83 c4 24	 add	 esp, 36			; 00000024H
  002ff	3b ec		 cmp	 ebp, esp
  00301	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00306	8b e5		 mov	 esp, ebp
  00308	5d		 pop	 ebp
  00309	c2 10 00	 ret	 16			; 00000010H
_gzseek64@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzseek@12
_TEXT	SEGMENT
tv73 = -20						; size = 4
tv129 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek@12 PROC						; COMDAT

; 447  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 448  :     z_off64_t ret;
; 449  : 
; 450  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00024	8b 45 10	 mov	 eax, DWORD PTR _whence$[ebp]
  00027	50		 push	 eax
  00028	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0002b	99		 cdq
  0002c	52		 push	 edx
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _gzseek64@16
  00037	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  0003a	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 451  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00040	99		 cdq
  00041	89 45 f0	 mov	 DWORD PTR tv129[ebp], eax
  00044	89 55 f4	 mov	 DWORD PTR tv129[ebp+4], edx
  00047	8b 55 f8	 mov	 edx, DWORD PTR _ret$[ebp]
  0004a	3b 55 f0	 cmp	 edx, DWORD PTR tv129[ebp]
  0004d	75 10		 jne	 SHORT $LN3@gzseek
  0004f	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp+4]
  00052	3b 45 f4	 cmp	 eax, DWORD PTR tv129[ebp+4]
  00055	75 08		 jne	 SHORT $LN3@gzseek
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  0005a	89 4d ec	 mov	 DWORD PTR tv73[ebp], ecx
  0005d	eb 07		 jmp	 SHORT $LN4@gzseek
$LN3@gzseek:
  0005f	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
$LN4@gzseek:
  00066	8b 45 ec	 mov	 eax, DWORD PTR tv73[ebp]

; 452  : }

  00069	83 c4 14	 add	 esp, 20			; 00000014H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 0c 00	 ret	 12			; 0000000cH
_gzseek@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gztell64@4
_TEXT	SEGMENT
tv73 = -12						; size = 8
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gztell64@4 PROC					; COMDAT

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 458  :     gz_statep state;
; 459  : 
; 460  :     /* get internal structure and check integrity */
; 461  :     if (file == NULL)

  00025	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00029	75 08		 jne	 SHORT $LN2@gztell64

; 462  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1
  0002e	83 ca ff	 or	 edx, -1
  00031	eb 57		 jmp	 SHORT $LN1@gztell64
$LN2@gztell64:

; 463  :     state = (gz_statep)file;

  00033	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00036	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 464  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0003c	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00043	74 14		 je	 SHORT $LN3@gztell64
  00045	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00048	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0004f	74 08		 je	 SHORT $LN3@gztell64

; 465  :         return -1;

  00051	83 c8 ff	 or	 eax, -1
  00054	83 ca ff	 or	 edx, -1
  00057	eb 31		 jmp	 SHORT $LN1@gztell64
$LN3@gztell64:

; 466  : 
; 467  :     /* return position */
; 468  :     return state->x.pos + (state->seek ? state->skip : 0);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0005c	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00060	74 11		 je	 SHORT $LN5@gztell64
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00065	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  00068	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  0006b	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  0006e	89 45 f8	 mov	 DWORD PTR tv73[ebp+4], eax
  00071	eb 08		 jmp	 SHORT $LN6@gztell64
$LN5@gztell64:
  00073	0f 57 c0	 xorps	 xmm0, xmm0
  00076	66 0f 13 45 f4	 movlpd	 QWORD PTR tv73[ebp], xmm0
$LN6@gztell64:
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0007e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00081	03 45 f4	 add	 eax, DWORD PTR tv73[ebp]
  00084	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00087	13 55 f8	 adc	 edx, DWORD PTR tv73[ebp+4]
$LN1@gztell64:

; 469  : }

  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 04 00	 ret	 4
_gztell64@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gztell@4
_TEXT	SEGMENT
tv70 = -20						; size = 4
tv85 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_gztell@4 PROC						; COMDAT

; 474  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 475  :     z_off64_t ret;
; 476  : 
; 477  :     ret = gztell64(file);

  00024	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _gztell64@4
  0002d	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00030	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 478  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00033	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00036	99		 cdq
  00037	89 45 f0	 mov	 DWORD PTR tv85[ebp], eax
  0003a	89 55 f4	 mov	 DWORD PTR tv85[ebp+4], edx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00040	3b 4d f0	 cmp	 ecx, DWORD PTR tv85[ebp]
  00043	75 10		 jne	 SHORT $LN3@gztell
  00045	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp+4]
  00048	3b 55 f4	 cmp	 edx, DWORD PTR tv85[ebp+4]
  0004b	75 08		 jne	 SHORT $LN3@gztell
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00050	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00053	eb 07		 jmp	 SHORT $LN4@gztell
$LN3@gztell:
  00055	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
$LN4@gztell:
  0005c	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]

; 479  : }

  0005f	83 c4 14	 add	 esp, 20			; 00000014H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
_gztell@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzoffset64@4
_TEXT	SEGMENT
_state$ = -12						; size = 4
_offset$ = -8						; size = 8
_file$ = 8						; size = 4
_gzoffset64@4 PROC					; COMDAT

; 484  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 485  :     z_off64_t offset;
; 486  :     gz_statep state;
; 487  : 
; 488  :     /* get internal structure and check integrity */
; 489  :     if (file == NULL)

  00025	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00029	75 08		 jne	 SHORT $LN2@gzoffset64

; 490  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1
  0002e	83 ca ff	 or	 edx, -1
  00031	eb 7c		 jmp	 SHORT $LN1@gzoffset64
$LN2@gzoffset64:

; 491  :     state = (gz_statep)file;

  00033	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00036	89 45 f4	 mov	 DWORD PTR _state$[ebp], eax

; 492  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00039	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0003c	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00043	74 14		 je	 SHORT $LN3@gzoffset64
  00045	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00048	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0004f	74 08		 je	 SHORT $LN3@gzoffset64

; 493  :         return -1;

  00051	83 c8 ff	 or	 eax, -1
  00054	83 ca ff	 or	 edx, -1
  00057	eb 56		 jmp	 SHORT $LN1@gzoffset64
$LN3@gzoffset64:

; 494  : 
; 495  :     /* compute and return effective offset in file */
; 496  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  00059	6a 01		 push	 1
  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00062	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 __lseeki64
  0006b	83 c4 10	 add	 esp, 16			; 00000010H
  0006e	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax
  00071	89 55 fc	 mov	 DWORD PTR _offset$[ebp+4], edx

; 497  :     if (offset == -1)

  00074	8b 55 f8	 mov	 edx, DWORD PTR _offset$[ebp]
  00077	23 55 fc	 and	 edx, DWORD PTR _offset$[ebp+4]
  0007a	83 fa ff	 cmp	 edx, -1
  0007d	75 08		 jne	 SHORT $LN4@gzoffset64

; 498  :         return -1;

  0007f	83 c8 ff	 or	 eax, -1
  00082	83 ca ff	 or	 edx, -1
  00085	eb 28		 jmp	 SHORT $LN1@gzoffset64
$LN4@gzoffset64:

; 499  :     if (state->mode == GZ_READ)             /* reading */

  00087	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0008a	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00091	75 16		 jne	 SHORT $LN5@gzoffset64

; 500  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  00093	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00096	33 d2		 xor	 edx, edx
  00098	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp]
  0009b	2b 41 68	 sub	 eax, DWORD PTR [ecx+104]
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _offset$[ebp+4]
  000a1	1b ca		 sbb	 ecx, edx
  000a3	89 45 f8	 mov	 DWORD PTR _offset$[ebp], eax
  000a6	89 4d fc	 mov	 DWORD PTR _offset$[ebp+4], ecx
$LN5@gzoffset64:

; 501  :     return offset;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _offset$[ebp]
  000ac	8b 55 fc	 mov	 edx, DWORD PTR _offset$[ebp+4]
$LN1@gzoffset64:

; 502  : }

  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b2	3b ec		 cmp	 ebp, esp
  000b4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 04 00	 ret	 4
_gzoffset64@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzoffset@4
_TEXT	SEGMENT
tv70 = -20						; size = 4
tv85 = -16						; size = 8
_ret$ = -8						; size = 8
_file$ = 8						; size = 4
_gzoffset@4 PROC					; COMDAT

; 507  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 508  :     z_off64_t ret;
; 509  : 
; 510  :     ret = gzoffset64(file);

  00024	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _gzoffset64@4
  0002d	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
  00030	89 55 fc	 mov	 DWORD PTR _ret$[ebp+4], edx

; 511  :     return ret == (z_off_t)ret ? (z_off_t)ret : -1;

  00033	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00036	99		 cdq
  00037	89 45 f0	 mov	 DWORD PTR tv85[ebp], eax
  0003a	89 55 f4	 mov	 DWORD PTR tv85[ebp+4], edx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  00040	3b 4d f0	 cmp	 ecx, DWORD PTR tv85[ebp]
  00043	75 10		 jne	 SHORT $LN3@gzoffset
  00045	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp+4]
  00048	3b 55 f4	 cmp	 edx, DWORD PTR tv85[ebp+4]
  0004b	75 08		 jne	 SHORT $LN3@gzoffset
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00050	89 45 ec	 mov	 DWORD PTR tv70[ebp], eax
  00053	eb 07		 jmp	 SHORT $LN4@gzoffset
$LN3@gzoffset:
  00055	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
$LN4@gzoffset:
  0005c	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]

; 512  : }

  0005f	83 c4 14	 add	 esp, 20			; 00000014H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
_gzoffset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzeof@4
_TEXT	SEGMENT
tv72 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzeof@4 PROC						; COMDAT

; 517  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 518  :     gz_statep state;
; 519  : 
; 520  :     /* get internal structure and check integrity */
; 521  :     if (file == NULL)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00022	75 04		 jne	 SHORT $LN2@gzeof

; 522  :         return 0;

  00024	33 c0		 xor	 eax, eax
  00026	eb 43		 jmp	 SHORT $LN1@gzeof
$LN2@gzeof:

; 523  :     state = (gz_statep)file;

  00028	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0002b	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 524  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00031	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  00038	74 10		 je	 SHORT $LN3@gzeof
  0003a	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0003d	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00044	74 04		 je	 SHORT $LN3@gzeof

; 525  :         return 0;

  00046	33 c0		 xor	 eax, eax
  00048	eb 21		 jmp	 SHORT $LN1@gzeof
$LN3@gzeof:

; 526  : 
; 527  :     /* return end-of-file state */
; 528  :     return state->mode == GZ_READ ? state->past : 0;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  0004d	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00054	75 0b		 jne	 SHORT $LN5@gzeof
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00059	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0005c	89 55 f8	 mov	 DWORD PTR tv72[ebp], edx
  0005f	eb 07		 jmp	 SHORT $LN6@gzeof
$LN5@gzeof:
  00061	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN6@gzeof:
  00068	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
$LN1@gzeof:

; 529  : }

  0006b	83 c4 08	 add	 esp, 8
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
_gzeof@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzerror@8
_TEXT	SEGMENT
tv76 = -12						; size = 4
tv77 = -8						; size = 4
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_errnum$ = 12						; size = 4
_gzerror@8 PROC						; COMDAT

; 535  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 536  :     gz_statep state;
; 537  : 
; 538  :     /* get internal structure and check integrity */
; 539  :     if (file == NULL)

  00025	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00029	75 04		 jne	 SHORT $LN2@gzerror

; 540  :         return NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 69		 jmp	 SHORT $LN1@gzerror
$LN2@gzerror:

; 541  :     state = (gz_statep)file;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00032	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 542  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00038	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0003f	74 10		 je	 SHORT $LN3@gzerror
  00041	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00044	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  0004b	74 04		 je	 SHORT $LN3@gzerror

; 543  :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 47		 jmp	 SHORT $LN1@gzerror
$LN3@gzerror:

; 544  : 
; 545  :     /* return error information */
; 546  :     if (errnum != NULL)

  00051	83 7d 0c 00	 cmp	 DWORD PTR _errnum$[ebp], 0
  00055	74 0b		 je	 SHORT $LN4@gzerror

; 547  :         *errnum = state->err;

  00057	8b 45 0c	 mov	 eax, DWORD PTR _errnum$[ebp]
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0005d	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  00060	89 10		 mov	 DWORD PTR [eax], edx
$LN4@gzerror:

; 548  :     return state->err == Z_MEM_ERROR ? "out of memory" :

  00062	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00065	83 78 5c fc	 cmp	 DWORD PTR [eax+92], -4	; fffffffcH
  00069	75 09		 jne	 SHORT $LN8@gzerror
  0006b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], OFFSET ??_C@_0O@BNNCBLEN@out?5of?5memory@
  00072	eb 21		 jmp	 SHORT $LN9@gzerror
$LN8@gzerror:
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00077	83 79 60 00	 cmp	 DWORD PTR [ecx+96], 0
  0007b	75 09		 jne	 SHORT $LN6@gzerror
  0007d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], OFFSET ??_C@_00CNPNBAHC@@
  00084	eb 09		 jmp	 SHORT $LN7@gzerror
$LN6@gzerror:
  00086	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00089	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0008c	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
$LN7@gzerror:
  0008f	8b 4d f4	 mov	 ecx, DWORD PTR tv76[ebp]
  00092	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
$LN9@gzerror:
  00095	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
$LN1@gzerror:

; 549  :                                        (state->msg == NULL ? "" : state->msg);
; 550  : }

  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c2 08 00	 ret	 8
_gzerror@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gzclearerr@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclearerr@4 PROC					; COMDAT

; 555  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 556  :     gz_statep state;
; 557  : 
; 558  :     /* get internal structure and check integrity */
; 559  :     if (file == NULL)

  00015	83 7d 08 00	 cmp	 DWORD PTR _file$[ebp], 0
  00019	75 02		 jne	 SHORT $LN2@gzclearerr

; 560  :         return;

  0001b	eb 50		 jmp	 SHORT $LN1@gzclearerr
$LN2@gzclearerr:

; 561  :     state = (gz_statep)file;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00020	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 562  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00026	81 79 10 4f 1c
	00 00		 cmp	 DWORD PTR [ecx+16], 7247 ; 00001c4fH
  0002d	74 0e		 je	 SHORT $LN3@gzclearerr
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00032	81 7a 10 b1 79
	00 00		 cmp	 DWORD PTR [edx+16], 31153 ; 000079b1H
  00039	74 02		 je	 SHORT $LN3@gzclearerr

; 563  :         return;

  0003b	eb 30		 jmp	 SHORT $LN1@gzclearerr
$LN3@gzclearerr:

; 564  : 
; 565  :     /* clear error and end-of-file */
; 566  :     if (state->mode == GZ_READ) {

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00040	81 78 10 4f 1c
	00 00		 cmp	 DWORD PTR [eax+16], 7247 ; 00001c4fH
  00047	75 14		 jne	 SHORT $LN4@gzclearerr

; 567  :         state->eof = 0;

  00049	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0004c	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 568  :         state->past = 0;

  00053	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00056	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0
$LN4@gzclearerr:

; 569  :     }
; 570  :     gz_error(state, Z_OK, NULL);

  0005d	6a 00		 push	 0
  0005f	6a 00		 push	 0
  00061	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _gz_error
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@gzclearerr:

; 571  : }

  0006d	83 c4 04	 add	 esp, 4
  00070	3b ec		 cmp	 ebp, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 04 00	 ret	 4
_gzclearerr@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzlib.c
;	COMDAT _gz_error
_TEXT	SEGMENT
tv78 = -4						; size = 4
_state$ = 8						; size = 4
_err$ = 12						; size = 4
_msg$ = 16						; size = 4
_gz_error PROC						; COMDAT

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00011	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 584  :     /* free previously allocated message and clear */
; 585  :     if (state->msg != NULL) {

  00016	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00019	83 78 60 00	 cmp	 DWORD PTR [eax+96], 0
  0001d	74 22		 je	 SHORT $LN2@gz_error

; 586  :         if (state->err != Z_MEM_ERROR)

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00022	83 79 5c fc	 cmp	 DWORD PTR [ecx+92], -4	; fffffffcH
  00026	74 0f		 je	 SHORT $LN3@gz_error

; 587  :             free(state->msg);

  00028	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0002b	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _free
  00034	83 c4 04	 add	 esp, 4
$LN3@gz_error:

; 588  :         state->msg = NULL;

  00037	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  0003a	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0
$LN2@gz_error:

; 589  :     }
; 590  : 
; 591  :     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
; 592  :     if (err != Z_OK && err != Z_BUF_ERROR)

  00041	83 7d 0c 00	 cmp	 DWORD PTR _err$[ebp], 0
  00045	74 0f		 je	 SHORT $LN4@gz_error
  00047	83 7d 0c fb	 cmp	 DWORD PTR _err$[ebp], -5 ; fffffffbH
  0004b	74 09		 je	 SHORT $LN4@gz_error

; 593  :         state->x.have = 0;

  0004d	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00050	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN4@gz_error:

; 594  : 
; 595  :     /* set error code, and if no message, then done */
; 596  :     state->err = err;

  00056	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _err$[ebp]
  0005c	89 48 5c	 mov	 DWORD PTR [eax+92], ecx

; 597  :     if (msg == NULL)

  0005f	83 7d 10 00	 cmp	 DWORD PTR _msg$[ebp], 0
  00063	75 05		 jne	 SHORT $LN5@gz_error

; 598  :         return;

  00065	e9 99 00 00 00	 jmp	 $LN1@gz_error
$LN5@gz_error:

; 599  : 
; 600  :     /* for an out of memory error, return literal string when requested */
; 601  :     if (err == Z_MEM_ERROR)

  0006a	83 7d 0c fc	 cmp	 DWORD PTR _err$[ebp], -4 ; fffffffcH
  0006e	75 05		 jne	 SHORT $LN6@gz_error

; 602  :         return;

  00070	e9 8e 00 00 00	 jmp	 $LN1@gz_error
$LN6@gz_error:

; 603  : 
; 604  :     /* construct error message with path */
; 605  :     if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==

  00075	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  00078	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _strlen
  00081	83 c4 04	 add	 esp, 4
  00084	8b f0		 mov	 esi, eax
  00086	8b 4d 10	 mov	 ecx, DWORD PTR _msg$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 _strlen
  0008f	83 c4 04	 add	 esp, 4
  00092	8d 54 06 03	 lea	 edx, DWORD PTR [esi+eax+3]
  00096	52		 push	 edx
  00097	e8 00 00 00 00	 call	 _malloc
  0009c	83 c4 04	 add	 esp, 4
  0009f	89 45 fc	 mov	 DWORD PTR tv78[ebp], eax
  000a2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR tv78[ebp]
  000a8	89 48 60	 mov	 DWORD PTR [eax+96], ecx
  000ab	83 7d fc 00	 cmp	 DWORD PTR tv78[ebp], 0
  000af	75 0c		 jne	 SHORT $LN7@gz_error

; 606  :             NULL) {
; 607  :         state->err = Z_MEM_ERROR;

  000b1	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  000b4	c7 42 5c fc ff
	ff ff		 mov	 DWORD PTR [edx+92], -4	; fffffffcH

; 608  :         return;

  000bb	eb 46		 jmp	 SHORT $LN1@gz_error
$LN7@gz_error:

; 609  :     }
; 610  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 611  :     (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,

  000bd	8b 45 10	 mov	 eax, DWORD PTR _msg$[ebp]
  000c0	50		 push	 eax
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000c9	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  000cc	52		 push	 edx
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
  000d2	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  000d5	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 _strlen
  000de	83 c4 04	 add	 esp, 4
  000e1	8b f0		 mov	 esi, eax
  000e3	8b 55 10	 mov	 edx, DWORD PTR _msg$[ebp]
  000e6	52		 push	 edx
  000e7	e8 00 00 00 00	 call	 _strlen
  000ec	83 c4 04	 add	 esp, 4
  000ef	8d 44 06 03	 lea	 eax, DWORD PTR [esi+eax+3]
  000f3	50		 push	 eax
  000f4	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  000f7	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 _snprintf
  00100	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@gz_error:

; 612  :                    "%s%s%s", state->path, ": ", msg);
; 613  : #else
; 614  :     strcpy(state->msg, state->path);
; 615  :     strcat(state->msg, ": ");
; 616  :     strcat(state->msg, msg);
; 617  : #endif
; 618  : }

  00103	5e		 pop	 esi
  00104	83 c4 04	 add	 esp, 4
  00107	3b ec		 cmp	 ebp, esp
  00109	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
_gz_error ENDP
_TEXT	ENDS
END
