; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

	TITLE	e:\cpython\externals\zlib-1.2.11\inftrees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

	ORG $+2
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	04dH
	DW	0caH
	ORG $+2
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__DA0D6CC2_inftrees@c DB 01H
PUBLIC	_inflate_table
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inftrees.c
;	COMDAT _inflate_table
_TEXT	SEGMENT
tv277 = -170						; size = 2
tv188 = -168						; size = 4
_offs$ = -160						; size = 32
_count$ = -120						; size = 32
_match$ = -84						; size = 4
_extra$ = -80						; size = 4
_base$ = -76						; size = 4
_next$ = -72						; size = 4
_here$ = -64						; size = 4
_mask$ = -56						; size = 4
_low$ = -52						; size = 4
_fill$ = -48						; size = 4
_incr$ = -44						; size = 4
_huff$ = -40						; size = 4
_used$ = -36						; size = 4
_left$ = -32						; size = 4
_drop$ = -28						; size = 4
_curr$ = -24						; size = 4
_root$ = -20						; size = 4
_max$ = -16						; size = 4
_min$ = -12						; size = 4
_sym$ = -8						; size = 4
_len$ = -4						; size = 4
_type$ = 8						; size = 4
_lens$ = 12						; size = 4
_codes$ = 16						; size = 4
_table$ = 20						; size = 4
_bits$ = 24						; size = 4
_work$ = 28						; size = 4
_inflate_table PROC					; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00009	57		 push	 edi
  0000a	8d bd 54 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-172]
  00010	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00021	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     unsigned match;             /* use base and extra for symbol >= match */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
  0002d	eb 09		 jmp	 SHORT $LN4@inflate_ta
$LN2@inflate_ta:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00032	83 c0 01	 add	 eax, 1
  00035	89 45 fc	 mov	 DWORD PTR _len$[ebp], eax
$LN4@inflate_ta:
  00038	83 7d fc 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  0003c	77 0c		 ja	 SHORT $LN3@inflate_ta

; 108  :         count[len] = 0;

  0003e	33 c9		 xor	 ecx, ecx
  00040	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  00043	66 89 4c 55 88	 mov	 WORD PTR _count$[ebp+edx*2], cx
  00048	eb e5		 jmp	 SHORT $LN2@inflate_ta
$LN3@inflate_ta:

; 109  :     for (sym = 0; sym < codes; sym++)

  0004a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  00051	eb 09		 jmp	 SHORT $LN7@inflate_ta
$LN5@inflate_ta:
  00053	8b 45 f8	 mov	 eax, DWORD PTR _sym$[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 45 f8	 mov	 DWORD PTR _sym$[ebp], eax
$LN7@inflate_ta:
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _sym$[ebp]
  0005f	3b 4d 10	 cmp	 ecx, DWORD PTR _codes$[ebp]
  00062	73 24		 jae	 SHORT $LN6@inflate_ta

; 110  :         count[lens[sym]]++;

  00064	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  00067	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  0006a	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0006e	66 8b 54 4d 88	 mov	 dx, WORD PTR _count$[ebp+ecx*2]
  00073	66 83 c2 01	 add	 dx, 1
  00077	8b 45 f8	 mov	 eax, DWORD PTR _sym$[ebp]
  0007a	8b 4d 0c	 mov	 ecx, DWORD PTR _lens$[ebp]
  0007d	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00081	66 89 54 45 88	 mov	 WORD PTR _count$[ebp+eax*2], dx
  00086	eb cb		 jmp	 SHORT $LN5@inflate_ta
$LN6@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00088	8b 4d 18	 mov	 ecx, DWORD PTR _bits$[ebp]
  0008b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008d	89 55 ec	 mov	 DWORD PTR _root$[ebp], edx

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00090	c7 45 f0 0f 00
	00 00		 mov	 DWORD PTR _max$[ebp], 15 ; 0000000fH
  00097	eb 09		 jmp	 SHORT $LN10@inflate_ta
$LN8@inflate_ta:
  00099	8b 45 f0	 mov	 eax, DWORD PTR _max$[ebp]
  0009c	83 e8 01	 sub	 eax, 1
  0009f	89 45 f0	 mov	 DWORD PTR _max$[ebp], eax
$LN10@inflate_ta:
  000a2	83 7d f0 01	 cmp	 DWORD PTR _max$[ebp], 1
  000a6	72 10		 jb	 SHORT $LN9@inflate_ta

; 115  :         if (count[max] != 0) break;

  000a8	8b 4d f0	 mov	 ecx, DWORD PTR _max$[ebp]
  000ab	0f b7 54 4d 88	 movzx	 edx, WORD PTR _count$[ebp+ecx*2]
  000b0	85 d2		 test	 edx, edx
  000b2	74 02		 je	 SHORT $LN35@inflate_ta
  000b4	eb 02		 jmp	 SHORT $LN9@inflate_ta
$LN35@inflate_ta:
  000b6	eb e1		 jmp	 SHORT $LN8@inflate_ta
$LN9@inflate_ta:

; 116  :     if (root > max) root = max;

  000b8	8b 45 ec	 mov	 eax, DWORD PTR _root$[ebp]
  000bb	3b 45 f0	 cmp	 eax, DWORD PTR _max$[ebp]
  000be	76 06		 jbe	 SHORT $LN36@inflate_ta
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR _max$[ebp]
  000c3	89 4d ec	 mov	 DWORD PTR _root$[ebp], ecx
$LN36@inflate_ta:

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  000c6	83 7d f0 00	 cmp	 DWORD PTR _max$[ebp], 0
  000ca	75 4c		 jne	 SHORT $LN37@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */

  000cc	c6 45 c0 40	 mov	 BYTE PTR _here$[ebp], 64 ; 00000040H

; 119  :         here.bits = (unsigned char)1;

  000d0	c6 45 c1 01	 mov	 BYTE PTR _here$[ebp+1], 1

; 120  :         here.val = (unsigned short)0;

  000d4	33 d2		 xor	 edx, edx
  000d6	66 89 55 c2	 mov	 WORD PTR _here$[ebp+2], dx

; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000da	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  000df	8b 55 c0	 mov	 edx, DWORD PTR _here$[ebp]
  000e2	89 11		 mov	 DWORD PTR [ecx], edx
  000e4	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e9	83 c1 04	 add	 ecx, 4
  000ec	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  000ef	89 0a		 mov	 DWORD PTR [edx], ecx

; 122  :         *(*table)++ = here;

  000f1	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f6	8b 55 c0	 mov	 edx, DWORD PTR _here$[ebp]
  000f9	89 11		 mov	 DWORD PTR [ecx], edx
  000fb	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000fe	8b 08		 mov	 ecx, DWORD PTR [eax]
  00100	83 c1 04	 add	 ecx, 4
  00103	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00106	89 0a		 mov	 DWORD PTR [edx], ecx

; 123  :         *bits = 1;

  00108	8b 45 18	 mov	 eax, DWORD PTR _bits$[ebp]
  0010b	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  00111	33 c0		 xor	 eax, eax
  00113	e9 b3 04 00 00	 jmp	 $LN1@inflate_ta
$LN37@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00118	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _min$[ebp], 1
  0011f	eb 09		 jmp	 SHORT $LN13@inflate_ta
$LN11@inflate_ta:
  00121	8b 4d f4	 mov	 ecx, DWORD PTR _min$[ebp]
  00124	83 c1 01	 add	 ecx, 1
  00127	89 4d f4	 mov	 DWORD PTR _min$[ebp], ecx
$LN13@inflate_ta:
  0012a	8b 55 f4	 mov	 edx, DWORD PTR _min$[ebp]
  0012d	3b 55 f0	 cmp	 edx, DWORD PTR _max$[ebp]
  00130	73 10		 jae	 SHORT $LN12@inflate_ta

; 127  :         if (count[min] != 0) break;

  00132	8b 45 f4	 mov	 eax, DWORD PTR _min$[ebp]
  00135	0f b7 4c 45 88	 movzx	 ecx, WORD PTR _count$[ebp+eax*2]
  0013a	85 c9		 test	 ecx, ecx
  0013c	74 02		 je	 SHORT $LN38@inflate_ta
  0013e	eb 02		 jmp	 SHORT $LN12@inflate_ta
$LN38@inflate_ta:
  00140	eb df		 jmp	 SHORT $LN11@inflate_ta
$LN12@inflate_ta:

; 128  :     if (root < min) root = min;

  00142	8b 55 ec	 mov	 edx, DWORD PTR _root$[ebp]
  00145	3b 55 f4	 cmp	 edx, DWORD PTR _min$[ebp]
  00148	73 06		 jae	 SHORT $LN39@inflate_ta
  0014a	8b 45 f4	 mov	 eax, DWORD PTR _min$[ebp]
  0014d	89 45 ec	 mov	 DWORD PTR _root$[ebp], eax
$LN39@inflate_ta:

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  00150	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _left$[ebp], 1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00157	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  0015e	eb 09		 jmp	 SHORT $LN16@inflate_ta
$LN14@inflate_ta:
  00160	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00163	83 c1 01	 add	 ecx, 1
  00166	89 4d fc	 mov	 DWORD PTR _len$[ebp], ecx
$LN16@inflate_ta:
  00169	83 7d fc 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  0016d	77 24		 ja	 SHORT $LN15@inflate_ta

; 133  :         left <<= 1;

  0016f	8b 55 e0	 mov	 edx, DWORD PTR _left$[ebp]
  00172	d1 e2		 shl	 edx, 1
  00174	89 55 e0	 mov	 DWORD PTR _left$[ebp], edx

; 134  :         left -= count[len];

  00177	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  0017a	0f b7 4c 45 88	 movzx	 ecx, WORD PTR _count$[ebp+eax*2]
  0017f	8b 55 e0	 mov	 edx, DWORD PTR _left$[ebp]
  00182	2b d1		 sub	 edx, ecx
  00184	89 55 e0	 mov	 DWORD PTR _left$[ebp], edx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  00187	79 08		 jns	 SHORT $LN40@inflate_ta
  00189	83 c8 ff	 or	 eax, -1
  0018c	e9 3a 04 00 00	 jmp	 $LN1@inflate_ta
$LN40@inflate_ta:

; 136  :     }

  00191	eb cd		 jmp	 SHORT $LN14@inflate_ta
$LN15@inflate_ta:

; 137  :     if (left > 0 && (type == CODES || max != 1))

  00193	83 7d e0 00	 cmp	 DWORD PTR _left$[ebp], 0
  00197	7e 14		 jle	 SHORT $LN41@inflate_ta
  00199	83 7d 08 00	 cmp	 DWORD PTR _type$[ebp], 0
  0019d	74 06		 je	 SHORT $LN42@inflate_ta
  0019f	83 7d f0 01	 cmp	 DWORD PTR _max$[ebp], 1
  001a3	74 08		 je	 SHORT $LN41@inflate_ta
$LN42@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  001a5	83 c8 ff	 or	 eax, -1
  001a8	e9 1e 04 00 00	 jmp	 $LN1@inflate_ta
$LN41@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  001ad	b8 02 00 00 00	 mov	 eax, 2
  001b2	c1 e0 00	 shl	 eax, 0
  001b5	33 c9		 xor	 ecx, ecx
  001b7	66 89 8c 05 60
	ff ff ff	 mov	 WORD PTR _offs$[ebp+eax], cx

; 142  :     for (len = 1; len < MAXBITS; len++)

  001bf	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  001c6	eb 09		 jmp	 SHORT $LN19@inflate_ta
$LN17@inflate_ta:
  001c8	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  001cb	83 c2 01	 add	 edx, 1
  001ce	89 55 fc	 mov	 DWORD PTR _len$[ebp], edx
$LN19@inflate_ta:
  001d1	83 7d fc 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  001d5	73 22		 jae	 SHORT $LN18@inflate_ta

; 143  :         offs[len + 1] = offs[len] + count[len];

  001d7	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  001da	0f b7 8c 45 60
	ff ff ff	 movzx	 ecx, WORD PTR _offs$[ebp+eax*2]
  001e2	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  001e5	0f b7 44 55 88	 movzx	 eax, WORD PTR _count$[ebp+edx*2]
  001ea	03 c8		 add	 ecx, eax
  001ec	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  001ef	66 89 8c 55 62
	ff ff ff	 mov	 WORD PTR _offs$[ebp+edx*2+2], cx
  001f7	eb cf		 jmp	 SHORT $LN17@inflate_ta
$LN18@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001f9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  00200	eb 09		 jmp	 SHORT $LN22@inflate_ta
$LN20@inflate_ta:
  00202	8b 45 f8	 mov	 eax, DWORD PTR _sym$[ebp]
  00205	83 c0 01	 add	 eax, 1
  00208	89 45 f8	 mov	 DWORD PTR _sym$[ebp], eax
$LN22@inflate_ta:
  0020b	8b 4d f8	 mov	 ecx, DWORD PTR _sym$[ebp]
  0020e	3b 4d 10	 cmp	 ecx, DWORD PTR _codes$[ebp]
  00211	73 55		 jae	 SHORT $LN21@inflate_ta

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00213	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  00216	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00219	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0021d	85 c9		 test	 ecx, ecx
  0021f	74 45		 je	 SHORT $LN43@inflate_ta
  00221	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  00224	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00227	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0022b	0f b7 94 4d 60
	ff ff ff	 movzx	 edx, WORD PTR _offs$[ebp+ecx*2]
  00233	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  00236	66 8b 4d f8	 mov	 cx, WORD PTR _sym$[ebp]
  0023a	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  0023e	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  00241	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00244	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00248	66 8b 94 4d 60
	ff ff ff	 mov	 dx, WORD PTR _offs$[ebp+ecx*2]
  00250	66 83 c2 01	 add	 dx, 1
  00254	8b 45 f8	 mov	 eax, DWORD PTR _sym$[ebp]
  00257	8b 4d 0c	 mov	 ecx, DWORD PTR _lens$[ebp]
  0025a	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  0025e	66 89 94 45 60
	ff ff ff	 mov	 WORD PTR _offs$[ebp+eax*2], dx
$LN43@inflate_ta:
  00266	eb 9a		 jmp	 SHORT $LN20@inflate_ta
$LN21@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  00268	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  0026b	89 8d 58 ff ff
	ff		 mov	 DWORD PTR tv188[ebp], ecx
  00271	83 bd 58 ff ff
	ff 00		 cmp	 DWORD PTR tv188[ebp], 0
  00278	74 0b		 je	 SHORT $LN44@inflate_ta
  0027a	83 bd 58 ff ff
	ff 01		 cmp	 DWORD PTR tv188[ebp], 1
  00281	74 17		 je	 SHORT $LN45@inflate_ta
  00283	eb 2c		 jmp	 SHORT $LN46@inflate_ta
$LN44@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  00285	8b 55 1c	 mov	 edx, DWORD PTR _work$[ebp]
  00288	89 55 b0	 mov	 DWORD PTR _extra$[ebp], edx
  0028b	8b 45 b0	 mov	 eax, DWORD PTR _extra$[ebp]
  0028e	89 45 b4	 mov	 DWORD PTR _base$[ebp], eax

; 184  :         match = 20;

  00291	c7 45 ac 14 00
	00 00		 mov	 DWORD PTR _match$[ebp], 20 ; 00000014H

; 185  :         break;

  00298	eb 2c		 jmp	 SHORT $LN23@inflate_ta
$LN45@inflate_ta:

; 186  :     case LENS:
; 187  :         base = lbase;

  0029a	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _base$[ebp], OFFSET ?lbase@?1??inflate_table@@9@9

; 188  :         extra = lext;

  002a1	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _extra$[ebp], OFFSET ?lext@?1??inflate_table@@9@9

; 189  :         match = 257;

  002a8	c7 45 ac 01 01
	00 00		 mov	 DWORD PTR _match$[ebp], 257 ; 00000101H

; 190  :         break;

  002af	eb 15		 jmp	 SHORT $LN23@inflate_ta
$LN46@inflate_ta:

; 191  :     default:    /* DISTS */
; 192  :         base = dbase;

  002b1	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _base$[ebp], OFFSET ?dbase@?1??inflate_table@@9@9

; 193  :         extra = dext;

  002b8	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR _extra$[ebp], OFFSET ?dext@?1??inflate_table@@9@9

; 194  :         match = 0;

  002bf	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR _match$[ebp], 0
$LN23@inflate_ta:

; 195  :     }
; 196  : 
; 197  :     /* initialize state for loop */
; 198  :     huff = 0;                   /* starting code */

  002c6	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _huff$[ebp], 0

; 199  :     sym = 0;                    /* starting code symbol */

  002cd	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0

; 200  :     len = min;                  /* starting code length */

  002d4	8b 4d f4	 mov	 ecx, DWORD PTR _min$[ebp]
  002d7	89 4d fc	 mov	 DWORD PTR _len$[ebp], ecx

; 201  :     next = *table;              /* current table to fill in */

  002da	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  002dd	8b 02		 mov	 eax, DWORD PTR [edx]
  002df	89 45 b8	 mov	 DWORD PTR _next$[ebp], eax

; 202  :     curr = root;                /* current table index bits */

  002e2	8b 4d ec	 mov	 ecx, DWORD PTR _root$[ebp]
  002e5	89 4d e8	 mov	 DWORD PTR _curr$[ebp], ecx

; 203  :     drop = 0;                   /* current bits to drop from code for index */

  002e8	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _drop$[ebp], 0

; 204  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */

  002ef	c7 45 cc ff ff
	ff ff		 mov	 DWORD PTR _low$[ebp], -1

; 205  :     used = 1U << root;          /* use root table entries */

  002f6	ba 01 00 00 00	 mov	 edx, 1
  002fb	8b 4d ec	 mov	 ecx, DWORD PTR _root$[ebp]
  002fe	d3 e2		 shl	 edx, cl
  00300	89 55 dc	 mov	 DWORD PTR _used$[ebp], edx

; 206  :     mask = used - 1;            /* mask for comparing low */

  00303	8b 45 dc	 mov	 eax, DWORD PTR _used$[ebp]
  00306	83 e8 01	 sub	 eax, 1
  00309	89 45 c8	 mov	 DWORD PTR _mask$[ebp], eax

; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  0030c	83 7d 08 01	 cmp	 DWORD PTR _type$[ebp], 1
  00310	75 09		 jne	 SHORT $LN49@inflate_ta
  00312	81 7d dc 54 03
	00 00		 cmp	 DWORD PTR _used$[ebp], 852 ; 00000354H
  00319	77 0f		 ja	 SHORT $LN48@inflate_ta
$LN49@inflate_ta:
  0031b	83 7d 08 02	 cmp	 DWORD PTR _type$[ebp], 2
  0031f	75 13		 jne	 SHORT $LN27@inflate_ta
  00321	81 7d dc 50 02
	00 00		 cmp	 DWORD PTR _used$[ebp], 592 ; 00000250H
  00328	76 0a		 jbe	 SHORT $LN27@inflate_ta
$LN48@inflate_ta:

; 210  :         (type == DISTS && used > ENOUGH_DISTS))
; 211  :         return 1;

  0032a	b8 01 00 00 00	 mov	 eax, 1
  0032f	e9 97 02 00 00	 jmp	 $LN1@inflate_ta
$LN27@inflate_ta:

; 212  : 
; 213  :     /* process all codes and make table entries */
; 214  :     for (;;) {
; 215  :         /* create table entry */
; 216  :         here.bits = (unsigned char)(len - drop);

  00334	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  00337	2b 4d e4	 sub	 ecx, DWORD PTR _drop$[ebp]
  0033a	88 4d c1	 mov	 BYTE PTR _here$[ebp+1], cl

; 217  :         if (work[sym] + 1U < match) {

  0033d	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  00340	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  00343	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00347	83 c1 01	 add	 ecx, 1
  0034a	3b 4d ac	 cmp	 ecx, DWORD PTR _match$[ebp]
  0034d	73 14		 jae	 SHORT $LN50@inflate_ta

; 218  :             here.op = (unsigned char)0;

  0034f	c6 45 c0 00	 mov	 BYTE PTR _here$[ebp], 0

; 219  :             here.val = work[sym];

  00353	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  00356	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  00359	66 8b 0c 50	 mov	 cx, WORD PTR [eax+edx*2]
  0035d	66 89 4d c2	 mov	 WORD PTR _here$[ebp+2], cx

; 220  :         }

  00361	eb 49		 jmp	 SHORT $LN51@inflate_ta
$LN50@inflate_ta:

; 221  :         else if (work[sym] >= match) {

  00363	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  00366	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  00369	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0036d	3b 4d ac	 cmp	 ecx, DWORD PTR _match$[ebp]
  00370	72 30		 jb	 SHORT $LN52@inflate_ta

; 222  :             here.op = (unsigned char)(extra[work[sym] - match]);

  00372	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  00375	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  00378	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0037c	2b 4d ac	 sub	 ecx, DWORD PTR _match$[ebp]
  0037f	8b 55 b0	 mov	 edx, DWORD PTR _extra$[ebp]
  00382	8a 04 4a	 mov	 al, BYTE PTR [edx+ecx*2]
  00385	88 45 c0	 mov	 BYTE PTR _here$[ebp], al

; 223  :             here.val = base[work[sym] - match];

  00388	8b 4d f8	 mov	 ecx, DWORD PTR _sym$[ebp]
  0038b	8b 55 1c	 mov	 edx, DWORD PTR _work$[ebp]
  0038e	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00392	2b 45 ac	 sub	 eax, DWORD PTR _match$[ebp]
  00395	8b 4d b4	 mov	 ecx, DWORD PTR _base$[ebp]
  00398	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0039c	66 89 55 c2	 mov	 WORD PTR _here$[ebp+2], dx

; 224  :         }

  003a0	eb 0a		 jmp	 SHORT $LN51@inflate_ta
$LN52@inflate_ta:

; 225  :         else {
; 226  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  003a2	c6 45 c0 60	 mov	 BYTE PTR _here$[ebp], 96 ; 00000060H

; 227  :             here.val = 0;

  003a6	33 c0		 xor	 eax, eax
  003a8	66 89 45 c2	 mov	 WORD PTR _here$[ebp+2], ax
$LN51@inflate_ta:

; 228  :         }
; 229  : 
; 230  :         /* replicate for those indices with low len bits equal to huff */
; 231  :         incr = 1U << (len - drop);

  003ac	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  003af	2b 4d e4	 sub	 ecx, DWORD PTR _drop$[ebp]
  003b2	ba 01 00 00 00	 mov	 edx, 1
  003b7	d3 e2		 shl	 edx, cl
  003b9	89 55 d4	 mov	 DWORD PTR _incr$[ebp], edx

; 232  :         fill = 1U << curr;

  003bc	b8 01 00 00 00	 mov	 eax, 1
  003c1	8b 4d e8	 mov	 ecx, DWORD PTR _curr$[ebp]
  003c4	d3 e0		 shl	 eax, cl
  003c6	89 45 d0	 mov	 DWORD PTR _fill$[ebp], eax

; 233  :         min = fill;                 /* save offset to next table */

  003c9	8b 4d d0	 mov	 ecx, DWORD PTR _fill$[ebp]
  003cc	89 4d f4	 mov	 DWORD PTR _min$[ebp], ecx
$LN30@inflate_ta:

; 234  :         do {
; 235  :             fill -= incr;

  003cf	8b 55 d0	 mov	 edx, DWORD PTR _fill$[ebp]
  003d2	2b 55 d4	 sub	 edx, DWORD PTR _incr$[ebp]
  003d5	89 55 d0	 mov	 DWORD PTR _fill$[ebp], edx

; 236  :             next[(huff >> drop) + fill] = here;

  003d8	8b 45 d8	 mov	 eax, DWORD PTR _huff$[ebp]
  003db	8b 4d e4	 mov	 ecx, DWORD PTR _drop$[ebp]
  003de	d3 e8		 shr	 eax, cl
  003e0	03 45 d0	 add	 eax, DWORD PTR _fill$[ebp]
  003e3	8b 4d b8	 mov	 ecx, DWORD PTR _next$[ebp]
  003e6	8b 55 c0	 mov	 edx, DWORD PTR _here$[ebp]
  003e9	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 237  :         } while (fill != 0);

  003ec	83 7d d0 00	 cmp	 DWORD PTR _fill$[ebp], 0
  003f0	75 dd		 jne	 SHORT $LN30@inflate_ta

; 238  : 
; 239  :         /* backwards increment the len-bit code huff */
; 240  :         incr = 1U << (len - 1);

  003f2	8b 4d fc	 mov	 ecx, DWORD PTR _len$[ebp]
  003f5	83 e9 01	 sub	 ecx, 1
  003f8	b8 01 00 00 00	 mov	 eax, 1
  003fd	d3 e0		 shl	 eax, cl
  003ff	89 45 d4	 mov	 DWORD PTR _incr$[ebp], eax
$LN31@inflate_ta:

; 241  :         while (huff & incr)

  00402	8b 4d d8	 mov	 ecx, DWORD PTR _huff$[ebp]
  00405	23 4d d4	 and	 ecx, DWORD PTR _incr$[ebp]
  00408	74 0a		 je	 SHORT $LN32@inflate_ta

; 242  :             incr >>= 1;

  0040a	8b 55 d4	 mov	 edx, DWORD PTR _incr$[ebp]
  0040d	d1 ea		 shr	 edx, 1
  0040f	89 55 d4	 mov	 DWORD PTR _incr$[ebp], edx
  00412	eb ee		 jmp	 SHORT $LN31@inflate_ta
$LN32@inflate_ta:

; 243  :         if (incr != 0) {

  00414	83 7d d4 00	 cmp	 DWORD PTR _incr$[ebp], 0
  00418	74 17		 je	 SHORT $LN54@inflate_ta

; 244  :             huff &= incr - 1;

  0041a	8b 45 d4	 mov	 eax, DWORD PTR _incr$[ebp]
  0041d	83 e8 01	 sub	 eax, 1
  00420	23 45 d8	 and	 eax, DWORD PTR _huff$[ebp]
  00423	89 45 d8	 mov	 DWORD PTR _huff$[ebp], eax

; 245  :             huff += incr;

  00426	8b 4d d8	 mov	 ecx, DWORD PTR _huff$[ebp]
  00429	03 4d d4	 add	 ecx, DWORD PTR _incr$[ebp]
  0042c	89 4d d8	 mov	 DWORD PTR _huff$[ebp], ecx

; 246  :         }

  0042f	eb 07		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:

; 247  :         else
; 248  :             huff = 0;

  00431	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _huff$[ebp], 0
$LN55@inflate_ta:

; 249  : 
; 250  :         /* go to next symbol, update count, len */
; 251  :         sym++;

  00438	8b 55 f8	 mov	 edx, DWORD PTR _sym$[ebp]
  0043b	83 c2 01	 add	 edx, 1
  0043e	89 55 f8	 mov	 DWORD PTR _sym$[ebp], edx

; 252  :         if (--(count[len]) == 0) {

  00441	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00444	66 8b 4c 45 88	 mov	 cx, WORD PTR _count$[ebp+eax*2]
  00449	66 83 e9 01	 sub	 cx, 1
  0044d	66 89 8d 56 ff
	ff ff		 mov	 WORD PTR tv277[ebp], cx
  00454	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  00457	66 8b 85 56 ff
	ff ff		 mov	 ax, WORD PTR tv277[ebp]
  0045e	66 89 44 55 88	 mov	 WORD PTR _count$[ebp+edx*2], ax
  00463	0f b7 8d 56 ff
	ff ff		 movzx	 ecx, WORD PTR tv277[ebp]
  0046a	85 c9		 test	 ecx, ecx
  0046c	75 21		 jne	 SHORT $LN56@inflate_ta

; 253  :             if (len == max) break;

  0046e	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  00471	3b 55 f0	 cmp	 edx, DWORD PTR _max$[ebp]
  00474	75 05		 jne	 SHORT $LN57@inflate_ta
  00476	e9 11 01 00 00	 jmp	 $LN26@inflate_ta
$LN57@inflate_ta:

; 254  :             len = lens[work[sym]];

  0047b	8b 45 f8	 mov	 eax, DWORD PTR _sym$[ebp]
  0047e	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  00481	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00485	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  00488	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0048c	89 4d fc	 mov	 DWORD PTR _len$[ebp], ecx
$LN56@inflate_ta:

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  0048f	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  00492	3b 55 ec	 cmp	 edx, DWORD PTR _root$[ebp]
  00495	0f 86 ec 00 00
	00		 jbe	 $LN58@inflate_ta
  0049b	8b 45 d8	 mov	 eax, DWORD PTR _huff$[ebp]
  0049e	23 45 c8	 and	 eax, DWORD PTR _mask$[ebp]
  004a1	3b 45 cc	 cmp	 eax, DWORD PTR _low$[ebp]
  004a4	0f 84 dd 00 00
	00		 je	 $LN58@inflate_ta

; 259  :             /* if first time, transition to sub-tables */
; 260  :             if (drop == 0)

  004aa	83 7d e4 00	 cmp	 DWORD PTR _drop$[ebp], 0
  004ae	75 06		 jne	 SHORT $LN59@inflate_ta

; 261  :                 drop = root;

  004b0	8b 4d ec	 mov	 ecx, DWORD PTR _root$[ebp]
  004b3	89 4d e4	 mov	 DWORD PTR _drop$[ebp], ecx
$LN59@inflate_ta:

; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  004b6	8b 55 f4	 mov	 edx, DWORD PTR _min$[ebp]
  004b9	8b 45 b8	 mov	 eax, DWORD PTR _next$[ebp]
  004bc	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  004bf	89 4d b8	 mov	 DWORD PTR _next$[ebp], ecx

; 265  : 
; 266  :             /* determine length of next table */
; 267  :             curr = len - drop;

  004c2	8b 55 fc	 mov	 edx, DWORD PTR _len$[ebp]
  004c5	2b 55 e4	 sub	 edx, DWORD PTR _drop$[ebp]
  004c8	89 55 e8	 mov	 DWORD PTR _curr$[ebp], edx

; 268  :             left = (int)(1 << curr);

  004cb	b8 01 00 00 00	 mov	 eax, 1
  004d0	8b 4d e8	 mov	 ecx, DWORD PTR _curr$[ebp]
  004d3	d3 e0		 shl	 eax, cl
  004d5	89 45 e0	 mov	 DWORD PTR _left$[ebp], eax
$LN33@inflate_ta:

; 269  :             while (curr + drop < max) {

  004d8	8b 4d e8	 mov	 ecx, DWORD PTR _curr$[ebp]
  004db	03 4d e4	 add	 ecx, DWORD PTR _drop$[ebp]
  004de	3b 4d f0	 cmp	 ecx, DWORD PTR _max$[ebp]
  004e1	73 2e		 jae	 SHORT $LN34@inflate_ta

; 270  :                 left -= count[curr + drop];

  004e3	8b 55 e8	 mov	 edx, DWORD PTR _curr$[ebp]
  004e6	03 55 e4	 add	 edx, DWORD PTR _drop$[ebp]
  004e9	0f b7 44 55 88	 movzx	 eax, WORD PTR _count$[ebp+edx*2]
  004ee	8b 4d e0	 mov	 ecx, DWORD PTR _left$[ebp]
  004f1	2b c8		 sub	 ecx, eax
  004f3	89 4d e0	 mov	 DWORD PTR _left$[ebp], ecx

; 271  :                 if (left <= 0) break;

  004f6	83 7d e0 00	 cmp	 DWORD PTR _left$[ebp], 0
  004fa	7f 02		 jg	 SHORT $LN60@inflate_ta
  004fc	eb 13		 jmp	 SHORT $LN34@inflate_ta
$LN60@inflate_ta:

; 272  :                 curr++;

  004fe	8b 55 e8	 mov	 edx, DWORD PTR _curr$[ebp]
  00501	83 c2 01	 add	 edx, 1
  00504	89 55 e8	 mov	 DWORD PTR _curr$[ebp], edx

; 273  :                 left <<= 1;

  00507	8b 45 e0	 mov	 eax, DWORD PTR _left$[ebp]
  0050a	d1 e0		 shl	 eax, 1
  0050c	89 45 e0	 mov	 DWORD PTR _left$[ebp], eax

; 274  :             }

  0050f	eb c7		 jmp	 SHORT $LN33@inflate_ta
$LN34@inflate_ta:

; 275  : 
; 276  :             /* check for enough space */
; 277  :             used += 1U << curr;

  00511	ba 01 00 00 00	 mov	 edx, 1
  00516	8b 4d e8	 mov	 ecx, DWORD PTR _curr$[ebp]
  00519	d3 e2		 shl	 edx, cl
  0051b	03 55 dc	 add	 edx, DWORD PTR _used$[ebp]
  0051e	89 55 dc	 mov	 DWORD PTR _used$[ebp], edx

; 278  :             if ((type == LENS && used > ENOUGH_LENS) ||

  00521	83 7d 08 01	 cmp	 DWORD PTR _type$[ebp], 1
  00525	75 09		 jne	 SHORT $LN63@inflate_ta
  00527	81 7d dc 54 03
	00 00		 cmp	 DWORD PTR _used$[ebp], 852 ; 00000354H
  0052e	77 0f		 ja	 SHORT $LN62@inflate_ta
$LN63@inflate_ta:
  00530	83 7d 08 02	 cmp	 DWORD PTR _type$[ebp], 2
  00534	75 13		 jne	 SHORT $LN61@inflate_ta
  00536	81 7d dc 50 02
	00 00		 cmp	 DWORD PTR _used$[ebp], 592 ; 00000250H
  0053d	76 0a		 jbe	 SHORT $LN61@inflate_ta
$LN62@inflate_ta:

; 279  :                 (type == DISTS && used > ENOUGH_DISTS))
; 280  :                 return 1;

  0053f	b8 01 00 00 00	 mov	 eax, 1
  00544	e9 82 00 00 00	 jmp	 $LN1@inflate_ta
$LN61@inflate_ta:

; 281  : 
; 282  :             /* point entry in root table to sub-table */
; 283  :             low = huff & mask;

  00549	8b 45 d8	 mov	 eax, DWORD PTR _huff$[ebp]
  0054c	23 45 c8	 and	 eax, DWORD PTR _mask$[ebp]
  0054f	89 45 cc	 mov	 DWORD PTR _low$[ebp], eax

; 284  :             (*table)[low].op = (unsigned char)curr;

  00552	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  00555	8b 11		 mov	 edx, DWORD PTR [ecx]
  00557	8b 45 cc	 mov	 eax, DWORD PTR _low$[ebp]
  0055a	8a 4d e8	 mov	 cl, BYTE PTR _curr$[ebp]
  0055d	88 0c 82	 mov	 BYTE PTR [edx+eax*4], cl

; 285  :             (*table)[low].bits = (unsigned char)root;

  00560	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00563	8b 02		 mov	 eax, DWORD PTR [edx]
  00565	8b 4d cc	 mov	 ecx, DWORD PTR _low$[ebp]
  00568	8a 55 ec	 mov	 dl, BYTE PTR _root$[ebp]
  0056b	88 54 88 01	 mov	 BYTE PTR [eax+ecx*4+1], dl

; 286  :             (*table)[low].val = (unsigned short)(next - *table);

  0056f	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  00572	8b 4d b8	 mov	 ecx, DWORD PTR _next$[ebp]
  00575	2b 08		 sub	 ecx, DWORD PTR [eax]
  00577	c1 f9 02	 sar	 ecx, 2
  0057a	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  0057d	8b 02		 mov	 eax, DWORD PTR [edx]
  0057f	8b 55 cc	 mov	 edx, DWORD PTR _low$[ebp]
  00582	66 89 4c 90 02	 mov	 WORD PTR [eax+edx*4+2], cx
$LN58@inflate_ta:

; 287  :         }
; 288  :     }

  00587	e9 a8 fd ff ff	 jmp	 $LN27@inflate_ta
$LN26@inflate_ta:

; 289  : 
; 290  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 291  :        at most one remaining entry, since if the code is incomplete, the
; 292  :        maximum code length that was allowed to get this far is one bit) */
; 293  :     if (huff != 0) {

  0058c	83 7d d8 00	 cmp	 DWORD PTR _huff$[ebp], 0
  00590	74 1f		 je	 SHORT $LN64@inflate_ta

; 294  :         here.op = (unsigned char)64;            /* invalid code marker */

  00592	c6 45 c0 40	 mov	 BYTE PTR _here$[ebp], 64 ; 00000040H

; 295  :         here.bits = (unsigned char)(len - drop);

  00596	8b 45 fc	 mov	 eax, DWORD PTR _len$[ebp]
  00599	2b 45 e4	 sub	 eax, DWORD PTR _drop$[ebp]
  0059c	88 45 c1	 mov	 BYTE PTR _here$[ebp+1], al

; 296  :         here.val = (unsigned short)0;

  0059f	33 c9		 xor	 ecx, ecx
  005a1	66 89 4d c2	 mov	 WORD PTR _here$[ebp+2], cx

; 297  :         next[huff] = here;

  005a5	8b 55 d8	 mov	 edx, DWORD PTR _huff$[ebp]
  005a8	8b 45 b8	 mov	 eax, DWORD PTR _next$[ebp]
  005ab	8b 4d c0	 mov	 ecx, DWORD PTR _here$[ebp]
  005ae	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
$LN64@inflate_ta:

; 298  :     }
; 299  : 
; 300  :     /* set return parameters */
; 301  :     *table += used;

  005b1	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  005b4	8b 02		 mov	 eax, DWORD PTR [edx]
  005b6	8b 4d dc	 mov	 ecx, DWORD PTR _used$[ebp]
  005b9	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  005bc	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  005bf	89 10		 mov	 DWORD PTR [eax], edx

; 302  :     *bits = root;

  005c1	8b 4d 18	 mov	 ecx, DWORD PTR _bits$[ebp]
  005c4	8b 55 ec	 mov	 edx, DWORD PTR _root$[ebp]
  005c7	89 11		 mov	 DWORD PTR [ecx], edx

; 303  :     return 0;

  005c9	33 c0		 xor	 eax, eax
$LN1@inflate_ta:

; 304  : }

  005cb	52		 push	 edx
  005cc	8b cd		 mov	 ecx, ebp
  005ce	50		 push	 eax
  005cf	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN73@inflate_ta
  005d5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  005da	58		 pop	 eax
  005db	5a		 pop	 edx
  005dc	5f		 pop	 edi
  005dd	81 c4 ac 00 00
	00		 add	 esp, 172		; 000000acH
  005e3	3b ec		 cmp	 ebp, esp
  005e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  005ea	8b e5		 mov	 esp, ebp
  005ec	5d		 pop	 ebp
  005ed	c3		 ret	 0
  005ee	66 90		 npad	 2
$LN73@inflate_ta:
  005f0	03 00 00 00	 DD	 3
  005f4	00 00 00 00	 DD	 $LN72@inflate_ta
$LN72@inflate_ta:
  005f8	c0 ff ff ff	 DD	 -64			; ffffffc0H
  005fc	04 00 00 00	 DD	 4
  00600	00 00 00 00	 DD	 $LN69@inflate_ta
  00604	88 ff ff ff	 DD	 -120			; ffffff88H
  00608	20 00 00 00	 DD	 32			; 00000020H
  0060c	00 00 00 00	 DD	 $LN70@inflate_ta
  00610	60 ff ff ff	 DD	 -160			; ffffff60H
  00614	20 00 00 00	 DD	 32			; 00000020H
  00618	00 00 00 00	 DD	 $LN71@inflate_ta
$LN71@inflate_ta:
  0061c	6f		 DB	 111			; 0000006fH
  0061d	66		 DB	 102			; 00000066H
  0061e	66		 DB	 102			; 00000066H
  0061f	73		 DB	 115			; 00000073H
  00620	00		 DB	 0
$LN70@inflate_ta:
  00621	63		 DB	 99			; 00000063H
  00622	6f		 DB	 111			; 0000006fH
  00623	75		 DB	 117			; 00000075H
  00624	6e		 DB	 110			; 0000006eH
  00625	74		 DB	 116			; 00000074H
  00626	00		 DB	 0
$LN69@inflate_ta:
  00627	68		 DB	 104			; 00000068H
  00628	65		 DB	 101			; 00000065H
  00629	72		 DB	 114			; 00000072H
  0062a	65		 DB	 101			; 00000065H
  0062b	00		 DB	 0
_inflate_table ENDP
_TEXT	ENDS
END
