; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

	TITLE	e:\cpython\externals\zlib-1.2.11\uncompr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__876F72AD_uncompr@c DB 01H
PUBLIC	_uncompress@16
PUBLIC	_uncompress2@16
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\uncompr.c
;	COMDAT _uncompress2@16
_TEXT	SEGMENT
tv93 = -112						; size = 4
tv94 = -108						; size = 4
tv95 = -104						; size = 4
tv76 = -100						; size = 4
tv72 = -96						; size = 4
_buf$ = -85						; size = 1
_left$ = -80						; size = 4
_len$ = -76						; size = 4
_max$ = -72						; size = 4
_err$ = -68						; size = 4
_stream$ = -60						; size = 56
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress2@16 PROC					; COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	57		 push	 edi
  00007	8d 7d 90	 lea	 edi, DWORD PTR [ebp-112]
  0000a	b9 1c 00 00 00	 mov	 ecx, 28			; 0000001cH
  0000f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00014	f3 ab		 rep stosd
  00016	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  0001b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 33   :     z_stream stream;
; 34   :     int err;
; 35   :     const uInt max = (uInt)-1;

  00020	c7 45 b8 ff ff
	ff ff		 mov	 DWORD PTR _max$[ebp], -1

; 36   :     uLong len, left;
; 37   :     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
; 38   : 
; 39   :     len = *sourceLen;

  00027	8b 45 14	 mov	 eax, DWORD PTR _sourceLen$[ebp]
  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	89 4d b4	 mov	 DWORD PTR _len$[ebp], ecx

; 40   :     if (*destLen) {

  0002f	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  00032	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00035	74 13		 je	 SHORT $LN5@uncompress

; 41   :         left = *destLen;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _destLen$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	89 4d b0	 mov	 DWORD PTR _left$[ebp], ecx

; 42   :         *destLen = 0;

  0003f	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  00042	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 43   :     }

  00048	eb 0d		 jmp	 SHORT $LN6@uncompress
$LN5@uncompress:

; 44   :     else {
; 45   :         left = 1;

  0004a	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _left$[ebp], 1

; 46   :         dest = buf;

  00051	8d 45 ab	 lea	 eax, DWORD PTR _buf$[ebp]
  00054	89 45 08	 mov	 DWORD PTR _dest$[ebp], eax
$LN6@uncompress:

; 47   :     }
; 48   : 
; 49   :     stream.next_in = (z_const Bytef *)source;

  00057	8b 4d 10	 mov	 ecx, DWORD PTR _source$[ebp]
  0005a	89 4d c4	 mov	 DWORD PTR _stream$[ebp], ecx

; 50   :     stream.avail_in = 0;

  0005d	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+4], 0

; 51   :     stream.zalloc = (alloc_func)0;

  00064	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+32], 0

; 52   :     stream.zfree = (free_func)0;

  0006b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+36], 0

; 53   :     stream.opaque = (voidpf)0;

  00072	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+40], 0

; 54   : 
; 55   :     err = inflateInit(&stream);

  00079	6a 38		 push	 56			; 00000038H
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_06CJNJFBNP@1?42?411@
  00080	8d 55 c4	 lea	 edx, DWORD PTR _stream$[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 _inflateInit_@12
  00089	89 45 bc	 mov	 DWORD PTR _err$[ebp], eax

; 56   :     if (err != Z_OK) return err;

  0008c	83 7d bc 00	 cmp	 DWORD PTR _err$[ebp], 0
  00090	74 08		 je	 SHORT $LN7@uncompress
  00092	8b 45 bc	 mov	 eax, DWORD PTR _err$[ebp]
  00095	e9 01 01 00 00	 jmp	 $LN1@uncompress
$LN7@uncompress:

; 57   : 
; 58   :     stream.next_out = dest;

  0009a	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0009d	89 45 d0	 mov	 DWORD PTR _stream$[ebp+12], eax

; 59   :     stream.avail_out = 0;

  000a0	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _stream$[ebp+16], 0
$LN4@uncompress:

; 60   : 
; 61   :     do {
; 62   :         if (stream.avail_out == 0) {

  000a7	83 7d d4 00	 cmp	 DWORD PTR _stream$[ebp+16], 0
  000ab	75 25		 jne	 SHORT $LN8@uncompress

; 63   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  000ad	8b 4d b0	 mov	 ecx, DWORD PTR _left$[ebp]
  000b0	3b 4d b8	 cmp	 ecx, DWORD PTR _max$[ebp]
  000b3	76 08		 jbe	 SHORT $LN14@uncompress
  000b5	8b 55 b8	 mov	 edx, DWORD PTR _max$[ebp]
  000b8	89 55 a0	 mov	 DWORD PTR tv72[ebp], edx
  000bb	eb 06		 jmp	 SHORT $LN15@uncompress
$LN14@uncompress:
  000bd	8b 45 b0	 mov	 eax, DWORD PTR _left$[ebp]
  000c0	89 45 a0	 mov	 DWORD PTR tv72[ebp], eax
$LN15@uncompress:
  000c3	8b 4d a0	 mov	 ecx, DWORD PTR tv72[ebp]
  000c6	89 4d d4	 mov	 DWORD PTR _stream$[ebp+16], ecx

; 64   :             left -= stream.avail_out;

  000c9	8b 55 b0	 mov	 edx, DWORD PTR _left$[ebp]
  000cc	2b 55 d4	 sub	 edx, DWORD PTR _stream$[ebp+16]
  000cf	89 55 b0	 mov	 DWORD PTR _left$[ebp], edx
$LN8@uncompress:

; 65   :         }
; 66   :         if (stream.avail_in == 0) {

  000d2	83 7d c8 00	 cmp	 DWORD PTR _stream$[ebp+4], 0
  000d6	75 25		 jne	 SHORT $LN9@uncompress

; 67   :             stream.avail_in = len > (uLong)max ? max : (uInt)len;

  000d8	8b 45 b4	 mov	 eax, DWORD PTR _len$[ebp]
  000db	3b 45 b8	 cmp	 eax, DWORD PTR _max$[ebp]
  000de	76 08		 jbe	 SHORT $LN16@uncompress
  000e0	8b 4d b8	 mov	 ecx, DWORD PTR _max$[ebp]
  000e3	89 4d 9c	 mov	 DWORD PTR tv76[ebp], ecx
  000e6	eb 06		 jmp	 SHORT $LN17@uncompress
$LN16@uncompress:
  000e8	8b 55 b4	 mov	 edx, DWORD PTR _len$[ebp]
  000eb	89 55 9c	 mov	 DWORD PTR tv76[ebp], edx
$LN17@uncompress:
  000ee	8b 45 9c	 mov	 eax, DWORD PTR tv76[ebp]
  000f1	89 45 c8	 mov	 DWORD PTR _stream$[ebp+4], eax

; 68   :             len -= stream.avail_in;

  000f4	8b 4d b4	 mov	 ecx, DWORD PTR _len$[ebp]
  000f7	2b 4d c8	 sub	 ecx, DWORD PTR _stream$[ebp+4]
  000fa	89 4d b4	 mov	 DWORD PTR _len$[ebp], ecx
$LN9@uncompress:

; 69   :         }
; 70   :         err = inflate(&stream, Z_NO_FLUSH);

  000fd	6a 00		 push	 0
  000ff	8d 55 c4	 lea	 edx, DWORD PTR _stream$[ebp]
  00102	52		 push	 edx
  00103	e8 00 00 00 00	 call	 _inflate@8
  00108	89 45 bc	 mov	 DWORD PTR _err$[ebp], eax

; 71   :     } while (err == Z_OK);

  0010b	83 7d bc 00	 cmp	 DWORD PTR _err$[ebp], 0
  0010f	74 96		 je	 SHORT $LN4@uncompress

; 72   : 
; 73   :     *sourceLen -= len + stream.avail_in;

  00111	8b 45 b4	 mov	 eax, DWORD PTR _len$[ebp]
  00114	03 45 c8	 add	 eax, DWORD PTR _stream$[ebp+4]
  00117	8b 4d 14	 mov	 ecx, DWORD PTR _sourceLen$[ebp]
  0011a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011c	2b d0		 sub	 edx, eax
  0011e	8b 45 14	 mov	 eax, DWORD PTR _sourceLen$[ebp]
  00121	89 10		 mov	 DWORD PTR [eax], edx

; 74   :     if (dest != buf)

  00123	8d 4d ab	 lea	 ecx, DWORD PTR _buf$[ebp]
  00126	39 4d 08	 cmp	 DWORD PTR _dest$[ebp], ecx
  00129	74 0a		 je	 SHORT $LN10@uncompress

; 75   :         *destLen = stream.total_out;

  0012b	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  0012e	8b 45 d8	 mov	 eax, DWORD PTR _stream$[ebp+20]
  00131	89 02		 mov	 DWORD PTR [edx], eax
  00133	eb 13		 jmp	 SHORT $LN11@uncompress
$LN10@uncompress:

; 76   :     else if (stream.total_out && err == Z_BUF_ERROR)

  00135	83 7d d8 00	 cmp	 DWORD PTR _stream$[ebp+20], 0
  00139	74 0d		 je	 SHORT $LN11@uncompress
  0013b	83 7d bc fb	 cmp	 DWORD PTR _err$[ebp], -5 ; fffffffbH
  0013f	75 07		 jne	 SHORT $LN11@uncompress

; 77   :         left = 1;

  00141	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR _left$[ebp], 1
$LN11@uncompress:

; 78   : 
; 79   :     inflateEnd(&stream);

  00148	8d 4d c4	 lea	 ecx, DWORD PTR _stream$[ebp]
  0014b	51		 push	 ecx
  0014c	e8 00 00 00 00	 call	 _inflateEnd@4

; 80   :     return err == Z_STREAM_END ? Z_OK :

  00151	83 7d bc 01	 cmp	 DWORD PTR _err$[ebp], 1
  00155	75 09		 jne	 SHORT $LN22@uncompress
  00157	c7 45 98 00 00
	00 00		 mov	 DWORD PTR tv95[ebp], 0
  0015e	eb 38		 jmp	 SHORT $LN23@uncompress
$LN22@uncompress:
  00160	83 7d bc 02	 cmp	 DWORD PTR _err$[ebp], 2
  00164	75 09		 jne	 SHORT $LN20@uncompress
  00166	c7 45 94 fd ff
	ff ff		 mov	 DWORD PTR tv94[ebp], -3	; fffffffdH
  0016d	eb 23		 jmp	 SHORT $LN21@uncompress
$LN20@uncompress:
  0016f	83 7d bc fb	 cmp	 DWORD PTR _err$[ebp], -5 ; fffffffbH
  00173	75 11		 jne	 SHORT $LN18@uncompress
  00175	8b 55 b0	 mov	 edx, DWORD PTR _left$[ebp]
  00178	03 55 d4	 add	 edx, DWORD PTR _stream$[ebp+16]
  0017b	74 09		 je	 SHORT $LN18@uncompress
  0017d	c7 45 90 fd ff
	ff ff		 mov	 DWORD PTR tv93[ebp], -3	; fffffffdH
  00184	eb 06		 jmp	 SHORT $LN19@uncompress
$LN18@uncompress:
  00186	8b 45 bc	 mov	 eax, DWORD PTR _err$[ebp]
  00189	89 45 90	 mov	 DWORD PTR tv93[ebp], eax
$LN19@uncompress:
  0018c	8b 4d 90	 mov	 ecx, DWORD PTR tv93[ebp]
  0018f	89 4d 94	 mov	 DWORD PTR tv94[ebp], ecx
$LN21@uncompress:
  00192	8b 55 94	 mov	 edx, DWORD PTR tv94[ebp]
  00195	89 55 98	 mov	 DWORD PTR tv95[ebp], edx
$LN23@uncompress:
  00198	8b 45 98	 mov	 eax, DWORD PTR tv95[ebp]
$LN1@uncompress:

; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;
; 84   : }

  0019b	52		 push	 edx
  0019c	8b cd		 mov	 ecx, ebp
  0019e	50		 push	 eax
  0019f	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN28@uncompress
  001a5	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001aa	58		 pop	 eax
  001ab	5a		 pop	 edx
  001ac	5f		 pop	 edi
  001ad	83 c4 70	 add	 esp, 112		; 00000070H
  001b0	3b ec		 cmp	 ebp, esp
  001b2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b7	8b e5		 mov	 esp, ebp
  001b9	5d		 pop	 ebp
  001ba	c2 10 00	 ret	 16			; 00000010H
  001bd	0f 1f 00	 npad	 3
$LN28@uncompress:
  001c0	02 00 00 00	 DD	 2
  001c4	00 00 00 00	 DD	 $LN27@uncompress
$LN27@uncompress:
  001c8	c4 ff ff ff	 DD	 -60			; ffffffc4H
  001cc	38 00 00 00	 DD	 56			; 00000038H
  001d0	00 00 00 00	 DD	 $LN25@uncompress
  001d4	ab ff ff ff	 DD	 -85			; ffffffabH
  001d8	01 00 00 00	 DD	 1
  001dc	00 00 00 00	 DD	 $LN26@uncompress
$LN26@uncompress:
  001e0	62		 DB	 98			; 00000062H
  001e1	75		 DB	 117			; 00000075H
  001e2	66		 DB	 102			; 00000066H
  001e3	00		 DB	 0
$LN25@uncompress:
  001e4	73		 DB	 115			; 00000073H
  001e5	74		 DB	 116			; 00000074H
  001e6	72		 DB	 114			; 00000072H
  001e7	65		 DB	 101			; 00000065H
  001e8	61		 DB	 97			; 00000061H
  001e9	6d		 DB	 109			; 0000006dH
  001ea	00		 DB	 0
_uncompress2@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\uncompr.c
;	COMDAT _uncompress@16
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_destLen$ = 12						; size = 4
_source$ = 16						; size = 4
_sourceLen$ = 20					; size = 4
_uncompress@16 PROC					; COMDAT

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __2B8D9255_zutil@c
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 92   :     return uncompress2(dest, destLen, source, &sourceLen);

  0000d	8d 45 14	 lea	 eax, DWORD PTR _sourceLen$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 10	 mov	 ecx, DWORD PTR _source$[ebp]
  00014	51		 push	 ecx
  00015	8b 55 0c	 mov	 edx, DWORD PTR _destLen$[ebp]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _uncompress2@16

; 93   : }

  00022	3b ec		 cmp	 ebp, esp
  00024	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00029	5d		 pop	 ebp
  0002a	c2 10 00	 ret	 16			; 00000010H
_uncompress@16 ENDP
_TEXT	ENDS
END
