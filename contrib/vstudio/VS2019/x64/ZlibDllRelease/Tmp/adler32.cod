; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__ABDB54D7_adler32@c DB 01H
PUBLIC	adler32_combine
PUBLIC	adler32
PUBLIC	adler32_z
PUBLIC	__JustMyCode_Default
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__chkstk:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$adler32_combine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine_ DD imagerel adler32_combine_
	DD	imagerel adler32_combine_+328
	DD	imagerel $unwind$adler32_combine_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32 DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$adler32
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_z DD imagerel $LN24
	DD	imagerel $LN24+2160
	DD	imagerel $unwind$adler32_z
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_z DD 022601H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32 DD 022601H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine_ DD 022501H
	DD	0700e5212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine DD 022501H
	DD	0700e3212H
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	c2 00 00	 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT adler32_z
_TEXT	SEGMENT
sum2$ = 32
n$ = 36
tv82 = 40
tv297 = 48
adler$ = 80
buf$ = 88
len$ = 96
adler32_z PROC						; COMDAT

; 67   : {

$LN24:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 10 00 00 00	 mov	 ecx, 16
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	8b 4c 24 50	 mov	 ecx, DWORD PTR [rsp+80]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 68   :     unsigned long sum2;
; 69   :     unsigned n;
; 70   : 
; 71   :     /* split Adler-32 into component sums */
; 72   :     sum2 = (adler >> 16) & 0xffff;

  00032	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00036	c1 e8 10	 shr	 eax, 16
  00039	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0003e	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax

; 73   :     adler &= 0xffff;

  00042	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00046	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004b	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax

; 74   : 
; 75   :     /* in case user likes doing a byte at a time, keep it fast */
; 76   :     if (len == 1) {

  0004f	48 83 7c 24 60
	01		 cmp	 QWORD PTR len$[rsp], 1
  00055	75 70		 jne	 SHORT $LN13@adler32_z

; 77   :         adler += buf[0];

  00057	b8 01 00 00 00	 mov	 eax, 1
  0005c	48 6b c0 00	 imul	 rax, rax, 0
  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00065	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00069	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0006d	03 c8		 add	 ecx, eax
  0006f	8b c1		 mov	 eax, ecx
  00071	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax

; 78   :         if (adler >= BASE)

  00075	81 7c 24 50 f1
	ff 00 00	 cmp	 DWORD PTR adler$[rsp], 65521 ; 0000fff1H
  0007d	72 0d		 jb	 SHORT $LN14@adler32_z

; 79   :             adler -= BASE;

  0007f	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00083	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00088	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
$LN14@adler32_z:

; 80   :         sum2 += adler;

  0008c	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00090	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00094	03 c8		 add	 ecx, eax
  00096	8b c1		 mov	 eax, ecx
  00098	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax

; 81   :         if (sum2 >= BASE)

  0009c	81 7c 24 20 f1
	ff 00 00	 cmp	 DWORD PTR sum2$[rsp], 65521 ; 0000fff1H
  000a4	72 0d		 jb	 SHORT $LN15@adler32_z

; 82   :             sum2 -= BASE;

  000a6	8b 44 24 20	 mov	 eax, DWORD PTR sum2$[rsp]
  000aa	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000af	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
$LN15@adler32_z:

; 83   :         return adler | (sum2 << 16);

  000b3	8b 44 24 20	 mov	 eax, DWORD PTR sum2$[rsp]
  000b7	c1 e0 10	 shl	 eax, 16
  000ba	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  000be	0b c8		 or	 ecx, eax
  000c0	8b c1		 mov	 eax, ecx
  000c2	e9 a3 07 00 00	 jmp	 $LN1@adler32_z
$LN13@adler32_z:

; 84   :     }
; 85   : 
; 86   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 87   :     if (buf == Z_NULL)

  000c7	48 83 7c 24 58
	00		 cmp	 QWORD PTR buf$[rsp], 0
  000cd	75 0a		 jne	 SHORT $LN16@adler32_z

; 88   :         return 1L;

  000cf	b8 01 00 00 00	 mov	 eax, 1
  000d4	e9 91 07 00 00	 jmp	 $LN1@adler32_z
$LN16@adler32_z:

; 89   : 
; 90   :     /* in case short lengths are provided, keep it somewhat fast */
; 91   :     if (len < 16) {

  000d9	48 83 7c 24 60
	10		 cmp	 QWORD PTR len$[rsp], 16
  000df	0f 83 90 00 00
	00		 jae	 $LN17@adler32_z
$LN2@adler32_z:

; 92   :         while (len--) {

  000e5	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  000ea	48 89 44 24 28	 mov	 QWORD PTR tv82[rsp], rax
  000ef	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  000f4	48 ff c8	 dec	 rax
  000f7	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax
  000fc	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv82[rsp], 0
  00102	74 33		 je	 SHORT $LN3@adler32_z

; 93   :             adler += *buf++;

  00104	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  00109	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0010c	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00110	03 c8		 add	 ecx, eax
  00112	8b c1		 mov	 eax, ecx
  00114	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00118	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  0011d	48 ff c0	 inc	 rax
  00120	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp], rax

; 94   :             sum2 += adler;

  00125	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00129	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  0012d	03 c8		 add	 ecx, eax
  0012f	8b c1		 mov	 eax, ecx
  00131	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax

; 95   :         }

  00135	eb ae		 jmp	 SHORT $LN2@adler32_z
$LN3@adler32_z:

; 96   :         if (adler >= BASE)

  00137	81 7c 24 50 f1
	ff 00 00	 cmp	 DWORD PTR adler$[rsp], 65521 ; 0000fff1H
  0013f	72 0d		 jb	 SHORT $LN18@adler32_z

; 97   :             adler -= BASE;

  00141	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00145	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  0014a	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
$LN18@adler32_z:

; 98   :         MOD28(sum2);            /* only added so many BASE's */

  0014e	33 d2		 xor	 edx, edx
  00150	8b 44 24 20	 mov	 eax, DWORD PTR sum2$[rsp]
  00154	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00159	f7 f1		 div	 ecx
  0015b	8b c2		 mov	 eax, edx
  0015d	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax

; 99   :         return adler | (sum2 << 16);

  00161	8b 44 24 20	 mov	 eax, DWORD PTR sum2$[rsp]
  00165	c1 e0 10	 shl	 eax, 16
  00168	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0016c	0b c8		 or	 ecx, eax
  0016e	8b c1		 mov	 eax, ecx
  00170	e9 f5 06 00 00	 jmp	 $LN1@adler32_z
$LN17@adler32_z:
$LN4@adler32_z:

; 100  :     }
; 101  : 
; 102  :     /* do length NMAX blocks -- requires just one modulo operation */
; 103  :     while (len >= NMAX) {

  00175	48 81 7c 24 60
	b0 15 00 00	 cmp	 QWORD PTR len$[rsp], 5552 ; 000015b0H
  0017e	0f 82 46 03 00
	00		 jb	 $LN5@adler32_z

; 104  :         len -= NMAX;

  00184	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  00189	48 2d b0 15 00
	00		 sub	 rax, 5552		; 000015b0H
  0018f	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 105  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  00194	c7 44 24 24 5b
	01 00 00	 mov	 DWORD PTR n$[rsp], 347	; 0000015bH
$LN8@adler32_z:

; 106  :         do {
; 107  :             DO16(buf);          /* 16 sums unrolled */

  0019c	b8 01 00 00 00	 mov	 eax, 1
  001a1	48 6b c0 00	 imul	 rax, rax, 0
  001a5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  001aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ae	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  001b2	03 c8		 add	 ecx, eax
  001b4	8b c1		 mov	 eax, ecx
  001b6	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  001ba	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  001be	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  001c2	03 c8		 add	 ecx, eax
  001c4	8b c1		 mov	 eax, ecx
  001c6	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  001ca	b8 01 00 00 00	 mov	 eax, 1
  001cf	48 6b c0 01	 imul	 rax, rax, 1
  001d3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  001d8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001dc	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  001e0	03 c8		 add	 ecx, eax
  001e2	8b c1		 mov	 eax, ecx
  001e4	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  001e8	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  001ec	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  001f0	03 c8		 add	 ecx, eax
  001f2	8b c1		 mov	 eax, ecx
  001f4	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  001f8	b8 01 00 00 00	 mov	 eax, 1
  001fd	48 6b c0 02	 imul	 rax, rax, 2
  00201	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00206	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0020a	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0020e	03 c8		 add	 ecx, eax
  00210	8b c1		 mov	 eax, ecx
  00212	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00216	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  0021a	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  0021e	03 c8		 add	 ecx, eax
  00220	8b c1		 mov	 eax, ecx
  00222	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00226	b8 01 00 00 00	 mov	 eax, 1
  0022b	48 6b c0 03	 imul	 rax, rax, 3
  0022f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00234	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00238	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0023c	03 c8		 add	 ecx, eax
  0023e	8b c1		 mov	 eax, ecx
  00240	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00244	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00248	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  0024c	03 c8		 add	 ecx, eax
  0024e	8b c1		 mov	 eax, ecx
  00250	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00254	b8 01 00 00 00	 mov	 eax, 1
  00259	48 6b c0 04	 imul	 rax, rax, 4
  0025d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00262	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00266	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0026a	03 c8		 add	 ecx, eax
  0026c	8b c1		 mov	 eax, ecx
  0026e	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00272	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00276	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  0027a	03 c8		 add	 ecx, eax
  0027c	8b c1		 mov	 eax, ecx
  0027e	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00282	b8 01 00 00 00	 mov	 eax, 1
  00287	48 6b c0 05	 imul	 rax, rax, 5
  0028b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00290	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00294	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00298	03 c8		 add	 ecx, eax
  0029a	8b c1		 mov	 eax, ecx
  0029c	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  002a0	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  002a4	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  002a8	03 c8		 add	 ecx, eax
  002aa	8b c1		 mov	 eax, ecx
  002ac	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  002b0	b8 01 00 00 00	 mov	 eax, 1
  002b5	48 6b c0 06	 imul	 rax, rax, 6
  002b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  002be	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c2	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  002c6	03 c8		 add	 ecx, eax
  002c8	8b c1		 mov	 eax, ecx
  002ca	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  002ce	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  002d2	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  002d6	03 c8		 add	 ecx, eax
  002d8	8b c1		 mov	 eax, ecx
  002da	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  002de	b8 01 00 00 00	 mov	 eax, 1
  002e3	48 6b c0 07	 imul	 rax, rax, 7
  002e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  002ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002f0	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  002f4	03 c8		 add	 ecx, eax
  002f6	8b c1		 mov	 eax, ecx
  002f8	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  002fc	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00300	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00304	03 c8		 add	 ecx, eax
  00306	8b c1		 mov	 eax, ecx
  00308	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  0030c	b8 01 00 00 00	 mov	 eax, 1
  00311	48 6b c0 08	 imul	 rax, rax, 8
  00315	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0031a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031e	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00322	03 c8		 add	 ecx, eax
  00324	8b c1		 mov	 eax, ecx
  00326	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  0032a	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  0032e	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00332	03 c8		 add	 ecx, eax
  00334	8b c1		 mov	 eax, ecx
  00336	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  0033a	b8 01 00 00 00	 mov	 eax, 1
  0033f	48 6b c0 09	 imul	 rax, rax, 9
  00343	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00348	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034c	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00350	03 c8		 add	 ecx, eax
  00352	8b c1		 mov	 eax, ecx
  00354	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00358	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  0035c	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00360	03 c8		 add	 ecx, eax
  00362	8b c1		 mov	 eax, ecx
  00364	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00368	b8 01 00 00 00	 mov	 eax, 1
  0036d	48 6b c0 0a	 imul	 rax, rax, 10
  00371	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00376	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0037a	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0037e	03 c8		 add	 ecx, eax
  00380	8b c1		 mov	 eax, ecx
  00382	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00386	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  0038a	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  0038e	03 c8		 add	 ecx, eax
  00390	8b c1		 mov	 eax, ecx
  00392	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00396	b8 01 00 00 00	 mov	 eax, 1
  0039b	48 6b c0 0b	 imul	 rax, rax, 11
  0039f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  003a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003a8	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  003ac	03 c8		 add	 ecx, eax
  003ae	8b c1		 mov	 eax, ecx
  003b0	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  003b4	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  003b8	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  003bc	03 c8		 add	 ecx, eax
  003be	8b c1		 mov	 eax, ecx
  003c0	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  003c4	b8 01 00 00 00	 mov	 eax, 1
  003c9	48 6b c0 0c	 imul	 rax, rax, 12
  003cd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  003d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003d6	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  003da	03 c8		 add	 ecx, eax
  003dc	8b c1		 mov	 eax, ecx
  003de	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  003e2	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  003e6	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  003ea	03 c8		 add	 ecx, eax
  003ec	8b c1		 mov	 eax, ecx
  003ee	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  003f2	b8 01 00 00 00	 mov	 eax, 1
  003f7	48 6b c0 0d	 imul	 rax, rax, 13
  003fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00400	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00404	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00408	03 c8		 add	 ecx, eax
  0040a	8b c1		 mov	 eax, ecx
  0040c	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00410	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00414	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00418	03 c8		 add	 ecx, eax
  0041a	8b c1		 mov	 eax, ecx
  0041c	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00420	b8 01 00 00 00	 mov	 eax, 1
  00425	48 6b c0 0e	 imul	 rax, rax, 14
  00429	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0042e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00432	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00436	03 c8		 add	 ecx, eax
  00438	8b c1		 mov	 eax, ecx
  0043a	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  0043e	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00442	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00446	03 c8		 add	 ecx, eax
  00448	8b c1		 mov	 eax, ecx
  0044a	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  0044e	b8 01 00 00 00	 mov	 eax, 1
  00453	48 6b c0 0f	 imul	 rax, rax, 15
  00457	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0045c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00460	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00464	03 c8		 add	 ecx, eax
  00466	8b c1		 mov	 eax, ecx
  00468	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  0046c	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00470	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00474	03 c8		 add	 ecx, eax
  00476	8b c1		 mov	 eax, ecx
  00478	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax

; 108  :             buf += 16;

  0047c	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  00481	48 83 c0 10	 add	 rax, 16
  00485	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp], rax

; 109  :         } while (--n);

  0048a	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  0048e	ff c8		 dec	 eax
  00490	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
  00494	83 7c 24 24 00	 cmp	 DWORD PTR n$[rsp], 0
  00499	0f 85 fd fc ff
	ff		 jne	 $LN8@adler32_z

; 110  :         MOD(adler);

  0049f	33 d2		 xor	 edx, edx
  004a1	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  004a5	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  004aa	f7 f1		 div	 ecx
  004ac	8b c2		 mov	 eax, edx
  004ae	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax

; 111  :         MOD(sum2);

  004b2	33 d2		 xor	 edx, edx
  004b4	8b 44 24 20	 mov	 eax, DWORD PTR sum2$[rsp]
  004b8	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  004bd	f7 f1		 div	 ecx
  004bf	8b c2		 mov	 eax, edx
  004c1	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax

; 112  :     }

  004c5	e9 ab fc ff ff	 jmp	 $LN4@adler32_z
$LN5@adler32_z:

; 113  : 
; 114  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 115  :     if (len) {                  /* avoid modulos if none remaining */

  004ca	48 83 7c 24 60
	00		 cmp	 QWORD PTR len$[rsp], 0
  004d0	0f 84 85 03 00
	00		 je	 $LN19@adler32_z
$LN9@adler32_z:

; 116  :         while (len >= 16) {

  004d6	48 83 7c 24 60
	10		 cmp	 QWORD PTR len$[rsp], 16
  004dc	0f 82 01 03 00
	00		 jb	 $LN10@adler32_z

; 117  :             len -= 16;

  004e2	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  004e7	48 83 e8 10	 sub	 rax, 16
  004eb	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 118  :             DO16(buf);

  004f0	b8 01 00 00 00	 mov	 eax, 1
  004f5	48 6b c0 00	 imul	 rax, rax, 0
  004f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  004fe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00502	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00506	03 c8		 add	 ecx, eax
  00508	8b c1		 mov	 eax, ecx
  0050a	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  0050e	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00512	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00516	03 c8		 add	 ecx, eax
  00518	8b c1		 mov	 eax, ecx
  0051a	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  0051e	b8 01 00 00 00	 mov	 eax, 1
  00523	48 6b c0 01	 imul	 rax, rax, 1
  00527	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0052c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00530	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00534	03 c8		 add	 ecx, eax
  00536	8b c1		 mov	 eax, ecx
  00538	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  0053c	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00540	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00544	03 c8		 add	 ecx, eax
  00546	8b c1		 mov	 eax, ecx
  00548	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  0054c	b8 01 00 00 00	 mov	 eax, 1
  00551	48 6b c0 02	 imul	 rax, rax, 2
  00555	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0055a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0055e	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00562	03 c8		 add	 ecx, eax
  00564	8b c1		 mov	 eax, ecx
  00566	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  0056a	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  0056e	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00572	03 c8		 add	 ecx, eax
  00574	8b c1		 mov	 eax, ecx
  00576	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  0057a	b8 01 00 00 00	 mov	 eax, 1
  0057f	48 6b c0 03	 imul	 rax, rax, 3
  00583	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00588	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0058c	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00590	03 c8		 add	 ecx, eax
  00592	8b c1		 mov	 eax, ecx
  00594	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00598	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  0059c	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  005a0	03 c8		 add	 ecx, eax
  005a2	8b c1		 mov	 eax, ecx
  005a4	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  005a8	b8 01 00 00 00	 mov	 eax, 1
  005ad	48 6b c0 04	 imul	 rax, rax, 4
  005b1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  005b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005ba	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  005be	03 c8		 add	 ecx, eax
  005c0	8b c1		 mov	 eax, ecx
  005c2	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  005c6	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  005ca	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  005ce	03 c8		 add	 ecx, eax
  005d0	8b c1		 mov	 eax, ecx
  005d2	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  005d6	b8 01 00 00 00	 mov	 eax, 1
  005db	48 6b c0 05	 imul	 rax, rax, 5
  005df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  005e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005e8	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  005ec	03 c8		 add	 ecx, eax
  005ee	8b c1		 mov	 eax, ecx
  005f0	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  005f4	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  005f8	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  005fc	03 c8		 add	 ecx, eax
  005fe	8b c1		 mov	 eax, ecx
  00600	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00604	b8 01 00 00 00	 mov	 eax, 1
  00609	48 6b c0 06	 imul	 rax, rax, 6
  0060d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00612	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00616	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0061a	03 c8		 add	 ecx, eax
  0061c	8b c1		 mov	 eax, ecx
  0061e	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00622	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00626	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  0062a	03 c8		 add	 ecx, eax
  0062c	8b c1		 mov	 eax, ecx
  0062e	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00632	b8 01 00 00 00	 mov	 eax, 1
  00637	48 6b c0 07	 imul	 rax, rax, 7
  0063b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00640	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00644	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00648	03 c8		 add	 ecx, eax
  0064a	8b c1		 mov	 eax, ecx
  0064c	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00650	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00654	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00658	03 c8		 add	 ecx, eax
  0065a	8b c1		 mov	 eax, ecx
  0065c	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00660	b8 01 00 00 00	 mov	 eax, 1
  00665	48 6b c0 08	 imul	 rax, rax, 8
  00669	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0066e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00672	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00676	03 c8		 add	 ecx, eax
  00678	8b c1		 mov	 eax, ecx
  0067a	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  0067e	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00682	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00686	03 c8		 add	 ecx, eax
  00688	8b c1		 mov	 eax, ecx
  0068a	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  0068e	b8 01 00 00 00	 mov	 eax, 1
  00693	48 6b c0 09	 imul	 rax, rax, 9
  00697	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0069c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006a0	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  006a4	03 c8		 add	 ecx, eax
  006a6	8b c1		 mov	 eax, ecx
  006a8	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  006ac	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  006b0	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  006b4	03 c8		 add	 ecx, eax
  006b6	8b c1		 mov	 eax, ecx
  006b8	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  006bc	b8 01 00 00 00	 mov	 eax, 1
  006c1	48 6b c0 0a	 imul	 rax, rax, 10
  006c5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  006ca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006ce	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  006d2	03 c8		 add	 ecx, eax
  006d4	8b c1		 mov	 eax, ecx
  006d6	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  006da	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  006de	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  006e2	03 c8		 add	 ecx, eax
  006e4	8b c1		 mov	 eax, ecx
  006e6	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  006ea	b8 01 00 00 00	 mov	 eax, 1
  006ef	48 6b c0 0b	 imul	 rax, rax, 11
  006f3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  006f8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006fc	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00700	03 c8		 add	 ecx, eax
  00702	8b c1		 mov	 eax, ecx
  00704	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00708	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  0070c	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  00710	03 c8		 add	 ecx, eax
  00712	8b c1		 mov	 eax, ecx
  00714	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00718	b8 01 00 00 00	 mov	 eax, 1
  0071d	48 6b c0 0c	 imul	 rax, rax, 12
  00721	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00726	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0072a	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0072e	03 c8		 add	 ecx, eax
  00730	8b c1		 mov	 eax, ecx
  00732	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00736	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  0073a	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  0073e	03 c8		 add	 ecx, eax
  00740	8b c1		 mov	 eax, ecx
  00742	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00746	b8 01 00 00 00	 mov	 eax, 1
  0074b	48 6b c0 0d	 imul	 rax, rax, 13
  0074f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00754	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00758	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0075c	03 c8		 add	 ecx, eax
  0075e	8b c1		 mov	 eax, ecx
  00760	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00764	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00768	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  0076c	03 c8		 add	 ecx, eax
  0076e	8b c1		 mov	 eax, ecx
  00770	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  00774	b8 01 00 00 00	 mov	 eax, 1
  00779	48 6b c0 0e	 imul	 rax, rax, 14
  0077d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  00782	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00786	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0078a	03 c8		 add	 ecx, eax
  0078c	8b c1		 mov	 eax, ecx
  0078e	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00792	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00796	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  0079a	03 c8		 add	 ecx, eax
  0079c	8b c1		 mov	 eax, ecx
  0079e	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
  007a2	b8 01 00 00 00	 mov	 eax, 1
  007a7	48 6b c0 0f	 imul	 rax, rax, 15
  007ab	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  007b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007b4	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  007b8	03 c8		 add	 ecx, eax
  007ba	8b c1		 mov	 eax, ecx
  007bc	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  007c0	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  007c4	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  007c8	03 c8		 add	 ecx, eax
  007ca	8b c1		 mov	 eax, ecx
  007cc	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax

; 119  :             buf += 16;

  007d0	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  007d5	48 83 c0 10	 add	 rax, 16
  007d9	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp], rax

; 120  :         }

  007de	e9 f3 fc ff ff	 jmp	 $LN9@adler32_z
$LN10@adler32_z:
$LN11@adler32_z:

; 121  :         while (len--) {

  007e3	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  007e8	48 89 44 24 30	 mov	 QWORD PTR tv297[rsp], rax
  007ed	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  007f2	48 ff c8	 dec	 rax
  007f5	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax
  007fa	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv297[rsp], 0
  00800	74 33		 je	 SHORT $LN12@adler32_z

; 122  :             adler += *buf++;

  00802	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  00807	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0080a	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  0080e	03 c8		 add	 ecx, eax
  00810	8b c1		 mov	 eax, ecx
  00812	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax
  00816	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  0081b	48 ff c0	 inc	 rax
  0081e	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp], rax

; 123  :             sum2 += adler;

  00823	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  00827	8b 4c 24 20	 mov	 ecx, DWORD PTR sum2$[rsp]
  0082b	03 c8		 add	 ecx, eax
  0082d	8b c1		 mov	 eax, ecx
  0082f	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax

; 124  :         }

  00833	eb ae		 jmp	 SHORT $LN11@adler32_z
$LN12@adler32_z:

; 125  :         MOD(adler);

  00835	33 d2		 xor	 edx, edx
  00837	8b 44 24 50	 mov	 eax, DWORD PTR adler$[rsp]
  0083b	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00840	f7 f1		 div	 ecx
  00842	8b c2		 mov	 eax, edx
  00844	89 44 24 50	 mov	 DWORD PTR adler$[rsp], eax

; 126  :         MOD(sum2);

  00848	33 d2		 xor	 edx, edx
  0084a	8b 44 24 20	 mov	 eax, DWORD PTR sum2$[rsp]
  0084e	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00853	f7 f1		 div	 ecx
  00855	8b c2		 mov	 eax, edx
  00857	89 44 24 20	 mov	 DWORD PTR sum2$[rsp], eax
$LN19@adler32_z:

; 127  :     }
; 128  : 
; 129  :     /* return recombined sums */
; 130  :     return adler | (sum2 << 16);

  0085b	8b 44 24 20	 mov	 eax, DWORD PTR sum2$[rsp]
  0085f	c1 e0 10	 shl	 eax, 16
  00862	8b 4c 24 50	 mov	 ecx, DWORD PTR adler$[rsp]
  00866	0b c8		 or	 ecx, eax
  00868	8b c1		 mov	 eax, ecx
$LN1@adler32_z:

; 131  : }

  0086a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0086e	5f		 pop	 rdi
  0086f	c3		 ret	 0
adler32_z ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT adler32
_TEXT	SEGMENT
adler$ = 48
buf$ = 56
len$ = 64
adler32	PROC						; COMDAT

; 138  : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 08 00 00 00	 mov	 ecx, 8
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	8b 4c 24 30	 mov	 ecx, DWORD PTR [rsp+48]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002d	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 139  :     return adler32_z(adler, buf, len);

  00032	8b 44 24 40	 mov	 eax, DWORD PTR len$[rsp]
  00036	44 8b c0	 mov	 r8d, eax
  00039	48 8b 54 24 38	 mov	 rdx, QWORD PTR buf$[rsp]
  0003e	8b 4c 24 30	 mov	 ecx, DWORD PTR adler$[rsp]
  00042	e8 00 00 00 00	 call	 adler32_z

; 140  : }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
adler32	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT adler32_combine_
_TEXT	SEGMENT
sum1$ = 32
sum2$ = 36
rem$ = 40
adler1$ = 64
adler2$ = 72
len2$ = 80
adler32_combine_ PROC					; COMDAT

; 147  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 0c 00 00 00	 mov	 ecx, 12
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 4c 24 40	 mov	 ecx, DWORD PTR [rsp+64]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 148  :     unsigned long sum1;
; 149  :     unsigned long sum2;
; 150  :     unsigned rem;
; 151  : 
; 152  :     /* for negative len, return invalid adler32 as a clue for debugging */
; 153  :     if (len2 < 0)

  00031	48 83 7c 24 50
	00		 cmp	 QWORD PTR len2$[rsp], 0
  00037	7d 0a		 jge	 SHORT $LN2@adler32_co

; 154  :         return 0xffffffffUL;

  00039	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0003e	e9 ff 00 00 00	 jmp	 $LN1@adler32_co
$LN2@adler32_co:

; 155  : 
; 156  :     /* the derivation of this formula is left as an exercise for the reader */
; 157  :     MOD63(len2);                /* assumes len2 >= 0 */

  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR len2$[rsp]
  00048	48 99		 cdq
  0004a	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0004f	48 f7 f9	 idiv	 rcx
  00052	48 8b c2	 mov	 rax, rdx
  00055	48 89 44 24 50	 mov	 QWORD PTR len2$[rsp], rax

; 158  :     rem = (unsigned)len2;

  0005a	8b 44 24 50	 mov	 eax, DWORD PTR len2$[rsp]
  0005e	89 44 24 28	 mov	 DWORD PTR rem$[rsp], eax

; 159  :     sum1 = adler1 & 0xffff;

  00062	8b 44 24 40	 mov	 eax, DWORD PTR adler1$[rsp]
  00066	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0006b	89 44 24 20	 mov	 DWORD PTR sum1$[rsp], eax

; 160  :     sum2 = rem * sum1;

  0006f	8b 44 24 28	 mov	 eax, DWORD PTR rem$[rsp]
  00073	0f af 44 24 20	 imul	 eax, DWORD PTR sum1$[rsp]
  00078	89 44 24 24	 mov	 DWORD PTR sum2$[rsp], eax

; 161  :     MOD(sum2);

  0007c	33 d2		 xor	 edx, edx
  0007e	8b 44 24 24	 mov	 eax, DWORD PTR sum2$[rsp]
  00082	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00087	f7 f1		 div	 ecx
  00089	8b c2		 mov	 eax, edx
  0008b	89 44 24 24	 mov	 DWORD PTR sum2$[rsp], eax

; 162  :     sum1 += (adler2 & 0xffff) + BASE - 1;

  0008f	8b 44 24 48	 mov	 eax, DWORD PTR adler2$[rsp]
  00093	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00098	8b 4c 24 20	 mov	 ecx, DWORD PTR sum1$[rsp]
  0009c	8d 84 01 f0 ff
	00 00		 lea	 eax, DWORD PTR [rcx+rax+65520]
  000a3	89 44 24 20	 mov	 DWORD PTR sum1$[rsp], eax

; 163  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  000a7	8b 44 24 40	 mov	 eax, DWORD PTR adler1$[rsp]
  000ab	c1 e8 10	 shr	 eax, 16
  000ae	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000b3	8b 4c 24 48	 mov	 ecx, DWORD PTR adler2$[rsp]
  000b7	c1 e9 10	 shr	 ecx, 16
  000ba	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  000c0	8d 84 08 f1 ff
	00 00		 lea	 eax, DWORD PTR [rax+rcx+65521]
  000c7	2b 44 24 28	 sub	 eax, DWORD PTR rem$[rsp]
  000cb	8b 4c 24 24	 mov	 ecx, DWORD PTR sum2$[rsp]
  000cf	03 c8		 add	 ecx, eax
  000d1	8b c1		 mov	 eax, ecx
  000d3	89 44 24 24	 mov	 DWORD PTR sum2$[rsp], eax

; 164  :     if (sum1 >= BASE) sum1 -= BASE;

  000d7	81 7c 24 20 f1
	ff 00 00	 cmp	 DWORD PTR sum1$[rsp], 65521 ; 0000fff1H
  000df	72 0d		 jb	 SHORT $LN3@adler32_co
  000e1	8b 44 24 20	 mov	 eax, DWORD PTR sum1$[rsp]
  000e5	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000ea	89 44 24 20	 mov	 DWORD PTR sum1$[rsp], eax
$LN3@adler32_co:

; 165  :     if (sum1 >= BASE) sum1 -= BASE;

  000ee	81 7c 24 20 f1
	ff 00 00	 cmp	 DWORD PTR sum1$[rsp], 65521 ; 0000fff1H
  000f6	72 0d		 jb	 SHORT $LN4@adler32_co
  000f8	8b 44 24 20	 mov	 eax, DWORD PTR sum1$[rsp]
  000fc	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00101	89 44 24 20	 mov	 DWORD PTR sum1$[rsp], eax
$LN4@adler32_co:

; 166  :     if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);

  00105	81 7c 24 24 e2
	ff 01 00	 cmp	 DWORD PTR sum2$[rsp], 131042 ; 0001ffe2H
  0010d	72 0d		 jb	 SHORT $LN5@adler32_co
  0010f	8b 44 24 24	 mov	 eax, DWORD PTR sum2$[rsp]
  00113	2d e2 ff 01 00	 sub	 eax, 131042		; 0001ffe2H
  00118	89 44 24 24	 mov	 DWORD PTR sum2$[rsp], eax
$LN5@adler32_co:

; 167  :     if (sum2 >= BASE) sum2 -= BASE;

  0011c	81 7c 24 24 f1
	ff 00 00	 cmp	 DWORD PTR sum2$[rsp], 65521 ; 0000fff1H
  00124	72 0d		 jb	 SHORT $LN6@adler32_co
  00126	8b 44 24 24	 mov	 eax, DWORD PTR sum2$[rsp]
  0012a	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  0012f	89 44 24 24	 mov	 DWORD PTR sum2$[rsp], eax
$LN6@adler32_co:

; 168  :     return sum1 | (sum2 << 16);

  00133	8b 44 24 24	 mov	 eax, DWORD PTR sum2$[rsp]
  00137	c1 e0 10	 shl	 eax, 16
  0013a	8b 4c 24 20	 mov	 ecx, DWORD PTR sum1$[rsp]
  0013e	0b c8		 or	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
$LN1@adler32_co:

; 169  : }

  00142	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00146	5f		 pop	 rdi
  00147	c3		 ret	 0
adler32_combine_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\adler32.c
;	COMDAT adler32_combine
_TEXT	SEGMENT
adler1$ = 48
adler2$ = 56
len2$ = 64
adler32_combine PROC					; COMDAT

; 176  : {

$LN4:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	48 8b fc	 mov	 rdi, rsp
  00015	b9 08 00 00 00	 mov	 ecx, 8
  0001a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001f	f3 ab		 rep stosd
  00021	8b 4c 24 30	 mov	 ecx, DWORD PTR [rsp+48]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002c	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 177  :     return adler32_combine_(adler1, adler2, len2);

  00031	48 63 44 24 40	 movsxd	 rax, DWORD PTR len2$[rsp]
  00036	4c 8b c0	 mov	 r8, rax
  00039	8b 54 24 38	 mov	 edx, DWORD PTR adler2$[rsp]
  0003d	8b 4c 24 30	 mov	 ecx, DWORD PTR adler1$[rsp]
  00041	e8 00 00 00 00	 call	 adler32_combine_

; 178  : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
adler32_combine ENDP
_TEXT	ENDS
END
