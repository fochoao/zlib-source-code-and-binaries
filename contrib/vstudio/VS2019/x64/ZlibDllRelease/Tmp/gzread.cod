; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@	; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error@	; `string'
PUBLIC	??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@ ; `string'
PUBLIC	??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@ ; `string'
EXTRN	__imp_strerror:PROC
EXTRN	__imp_memchr:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp__close:PROC
EXTRN	__imp__read:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@ DB 'out of room t'
	DB	'o push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@
CONST	SEGMENT
??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@ DB 'request doe'
	DB	's not fit in a size_t', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@
CONST	SEGMENT
??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@ DB 'request does'
	DB	' not fit in an int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error@ DB 'compressed data error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ DB 'internal err'
	DB	'or: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@ DB 'unexpected end of file', 00H ; `string'
__DB664BEB_corecrt_stdio_config@h DB 01H
__E28BBA23_corecrt_wstdio@h DB 01H
__4A1C29A8_stdio@h DB 01H
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__077EA387_gzread@c DB 01H
PUBLIC	gzdirect
PUBLIC	gzgets
PUBLIC	gzungetc
PUBLIC	gzgetc_
PUBLIC	gzgetc
PUBLIC	gzfread
PUBLIC	gzread
PUBLIC	gzclose_r
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdirect DD imagerel $LN6
	DD	imagerel $LN6+123
	DD	imagerel $unwind$gzdirect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgets DD imagerel $LN22
	DD	imagerel $LN22+581
	DD	imagerel $unwind$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzungetc DD imagerel $LN17
	DD	imagerel $LN17+614
	DD	imagerel $unwind$gzungetc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgetc_ DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$gzgetc_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgetc DD imagerel $LN11
	DD	imagerel $LN11+298
	DD	imagerel $unwind$gzgetc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzfread DD imagerel $LN11
	DD	imagerel $LN11+253
	DD	imagerel $unwind$gzfread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzread DD imagerel $LN10
	DD	imagerel $LN10+231
	DD	imagerel $unwind$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_read DD imagerel gz_read
	DD	imagerel gz_read+617
	DD	imagerel $unwind$gz_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_skip DD imagerel gz_skip
	DD	imagerel gz_skip+272
	DD	imagerel $unwind$gz_skip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_fetch DD imagerel gz_fetch
	DD	imagerel gz_fetch+322
	DD	imagerel $unwind$gz_fetch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_decomp DD imagerel gz_decomp
	DD	imagerel gz_decomp+428
	DD	imagerel $unwind$gz_decomp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_look DD imagerel gz_look
	DD	imagerel gz_look+748
	DD	imagerel $unwind$gz_look
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_avail DD imagerel gz_avail
	DD	imagerel gz_avail+345
	DD	imagerel $unwind$gz_avail
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_load DD imagerel gz_load
	DD	imagerel gz_load+270
	DD	imagerel $unwind$gz_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_r DD imagerel $LN11
	DD	imagerel $LN11+283
	DD	imagerel $unwind$gzclose_r
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_r DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_load DD 022d01H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_avail DD 021e01H
	DD	07006b20aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
gz_avail$rtcName$0 DB 067H
	DB	06fH
	DB	074H
	DB	00H
	ORG $+12
gz_avail$rtcVarDesc DD 024H
	DD	04H
	DQ	FLAT:gz_avail$rtcName$0
	ORG $+48
gz_avail$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:gz_avail$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_look DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_decomp DD 021e01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_fetch DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_skip DD 022301H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_read DD 022801H
	DD	070109214H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
gz_read$rtcName$0 DB 06eH
	DB	00H
	ORG $+14
gz_read$rtcVarDesc DD 034H
	DD	04H
	DQ	FLAT:gz_read$rtcName$0
	ORG $+48
gz_read$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:gz_read$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzread DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzfread DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgetc DD 021e01H
	DD	07006b20aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
gzgetc$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+12
gzgetc$rtcVarDesc DD 034H
	DD	01H
	DQ	FLAT:gzgetc$rtcName$0
	ORG $+48
gzgetc$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:gzgetc$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgetc_ DD 021e01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzungetc DD 022101H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgets DD 022801H
	DD	070109214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdirect DD 021e01H
	DD	07006520aH
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzclose_r
_TEXT	SEGMENT
ret$ = 32
err$ = 36
state$ = 40
tv77 = 48
tv88 = 52
file$ = 80
gzclose_r PROC						; COMDAT

; 629  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 630  :     int ret, err;
; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  0002a	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  00030	75 0a		 jne	 SHORT $LN2@gzclose_r

; 635  :         return Z_STREAM_ERROR;

  00032	b8 fe ff ff ff	 mov	 eax, -2
  00037	e9 d9 00 00 00	 jmp	 $LN1@gzclose_r
$LN2@gzclose_r:

; 636  :     state = (gz_statep)file;

  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  00041	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 637  : 
; 638  :     /* check that we're reading */
; 639  :     if (state->mode != GZ_READ)

  00046	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0004b	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00052	74 0a		 je	 SHORT $LN3@gzclose_r

; 640  :         return Z_STREAM_ERROR;

  00054	b8 fe ff ff ff	 mov	 eax, -2
  00059	e9 b7 00 00 00	 jmp	 $LN1@gzclose_r
$LN3@gzclose_r:

; 641  : 
; 642  :     /* free memory and close file */
; 643  :     if (state->size) {

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00063	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00067	74 2f		 je	 SHORT $LN4@gzclose_r

; 644  :         inflateEnd(&(state->strm));

  00069	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0006e	48 83 c0 78	 add	 rax, 120		; 00000078H
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 inflateEnd

; 645  :         free(state->out);

  0007a	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0007f	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 646  :         free(state->in);

  00089	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0008e	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@gzclose_r:

; 647  :     }
; 648  :     err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;

  00098	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0009d	83 78 6c fb	 cmp	 DWORD PTR [rax+108], -5
  000a1	75 0a		 jne	 SHORT $LN6@gzclose_r
  000a3	c7 44 24 30 fb
	ff ff ff	 mov	 DWORD PTR tv77[rsp], -5
  000ab	eb 08		 jmp	 SHORT $LN7@gzclose_r
$LN6@gzclose_r:
  000ad	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN7@gzclose_r:
  000b5	8b 44 24 30	 mov	 eax, DWORD PTR tv77[rsp]
  000b9	89 44 24 24	 mov	 DWORD PTR err$[rsp], eax

; 649  :     gz_error(state, Z_OK, NULL);

  000bd	45 33 c0	 xor	 r8d, r8d
  000c0	33 d2		 xor	 edx, edx
  000c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000c7	e8 00 00 00 00	 call	 gz_error

; 650  :     free(state->path);

  000cc	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d1	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 651  :     ret = close(state->fd);

  000db	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e0	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__close
  000e9	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 652  :     free(state);

  000ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 653  :     return ret ? Z_ERRNO : err;

  000f8	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  000fd	74 0a		 je	 SHORT $LN8@gzclose_r
  000ff	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv88[rsp], -1
  00107	eb 08		 jmp	 SHORT $LN9@gzclose_r
$LN8@gzclose_r:
  00109	8b 44 24 24	 mov	 eax, DWORD PTR err$[rsp]
  0010d	89 44 24 34	 mov	 DWORD PTR tv88[rsp], eax
$LN9@gzclose_r:
  00111	8b 44 24 34	 mov	 eax, DWORD PTR tv88[rsp]
$LN1@gzclose_r:

; 654  : }

  00115	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00119	5f		 pop	 rdi
  0011a	c3		 ret	 0
gzclose_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_load
_TEXT	SEGMENT
ret$ = 32
get$ = 36
max$ = 40
state$ = 64
buf$ = 72
len$ = 80
have$ = 88
gz_load	PROC						; COMDAT

; 26   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 0c 00 00 00	 mov	 ecx, 12
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00034	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 27   :     int ret;
; 28   :     unsigned get, max = ((unsigned)-1 >> 2) + 1;

  00039	c7 44 24 28 00
	00 00 40	 mov	 DWORD PTR max$[rsp], 1073741824 ; 40000000H

; 29   : 
; 30   :     *have = 0;

  00041	48 8b 44 24 58	 mov	 rax, QWORD PTR have$[rsp]
  00046	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN4@gz_load:

; 31   :     do {
; 32   :         get = len - *have;

  0004c	48 8b 44 24 58	 mov	 rax, QWORD PTR have$[rsp]
  00051	8b 00		 mov	 eax, DWORD PTR [rax]
  00053	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  00057	2b c8		 sub	 ecx, eax
  00059	8b c1		 mov	 eax, ecx
  0005b	89 44 24 24	 mov	 DWORD PTR get$[rsp], eax

; 33   :         if (get > max)

  0005f	8b 44 24 28	 mov	 eax, DWORD PTR max$[rsp]
  00063	39 44 24 24	 cmp	 DWORD PTR get$[rsp], eax
  00067	76 08		 jbe	 SHORT $LN5@gz_load

; 34   :             get = max;

  00069	8b 44 24 28	 mov	 eax, DWORD PTR max$[rsp]
  0006d	89 44 24 24	 mov	 DWORD PTR get$[rsp], eax
$LN5@gz_load:

; 35   :         ret = read(state->fd, buf + *have, get);

  00071	48 8b 44 24 58	 mov	 rax, QWORD PTR have$[rsp]
  00076	8b 00		 mov	 eax, DWORD PTR [rax]
  00078	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  0007d	48 03 c8	 add	 rcx, rax
  00080	48 8b c1	 mov	 rax, rcx
  00083	44 8b 44 24 24	 mov	 r8d, DWORD PTR get$[rsp]
  00088	48 8b d0	 mov	 rdx, rax
  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00090	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__read
  00099	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 36   :         if (ret <= 0)

  0009d	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  000a2	7f 02		 jg	 SHORT $LN6@gz_load

; 37   :             break;

  000a4	eb 1f		 jmp	 SHORT $LN3@gz_load
$LN6@gz_load:

; 38   :         *have += (unsigned)ret;

  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR have$[rsp]
  000ab	8b 00		 mov	 eax, DWORD PTR [rax]
  000ad	03 44 24 20	 add	 eax, DWORD PTR ret$[rsp]
  000b1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR have$[rsp]
  000b6	89 01		 mov	 DWORD PTR [rcx], eax

; 39   :     } while (*have < len);

  000b8	48 8b 44 24 58	 mov	 rax, QWORD PTR have$[rsp]
  000bd	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  000c1	39 08		 cmp	 DWORD PTR [rax], ecx
  000c3	72 87		 jb	 SHORT $LN4@gz_load
$LN3@gz_load:

; 40   :     if (ret < 0) {

  000c5	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  000ca	7d 27		 jge	 SHORT $LN7@gz_load

; 41   :         gz_error(state, Z_ERRNO, zstrerror());

  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d2	8b 08		 mov	 ecx, DWORD PTR [rax]
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  000da	4c 8b c0	 mov	 r8, rax
  000dd	ba ff ff ff ff	 mov	 edx, -1
  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000e7	e8 00 00 00 00	 call	 gz_error

; 42   :         return -1;

  000ec	b8 ff ff ff ff	 mov	 eax, -1
  000f1	eb 15		 jmp	 SHORT $LN1@gz_load
$LN7@gz_load:

; 43   :     }
; 44   :     if (ret == 0)

  000f3	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  000f8	75 0c		 jne	 SHORT $LN8@gz_load

; 45   :         state->eof = 1;

  000fa	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000ff	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [rax+80], 1
$LN8@gz_load:

; 46   :     return 0;

  00106	33 c0		 xor	 eax, eax
$LN1@gz_load:

; 47   : }

  00108	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010c	5f		 pop	 rdi
  0010d	c3		 ret	 0
gz_load	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_avail
_TEXT	SEGMENT
got$ = 36
strm$ = 56
p$4 = 64
q$5 = 72
n$6 = 80
state$ = 112
gz_avail PROC						; COMDAT

; 58   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 18 00 00 00	 mov	 ecx, 24
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 59   :     unsigned got;
; 60   :     z_streamp strm = &(state->strm);

  0002a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0002f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00033	48 89 44 24 38	 mov	 QWORD PTR strm$[rsp], rax

; 61   : 
; 62   :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00038	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0003d	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00041	74 15		 je	 SHORT $LN5@gz_avail
  00043	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00048	83 78 6c fb	 cmp	 DWORD PTR [rax+108], -5
  0004c	74 0a		 je	 SHORT $LN5@gz_avail

; 63   :         return -1;

  0004e	b8 ff ff ff ff	 mov	 eax, -1
  00053	e9 e6 00 00 00	 jmp	 $LN1@gz_avail
$LN5@gz_avail:

; 64   :     if (state->eof == 0) {

  00058	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0005d	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  00061	0f 85 d5 00 00
	00		 jne	 $LN6@gz_avail

; 65   :         if (strm->avail_in) {       /* copy what's there to the start */

  00067	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  0006c	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00070	74 61		 je	 SHORT $LN7@gz_avail

; 66   :             unsigned char *p = state->in;

  00072	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00077	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0007b	48 89 44 24 40	 mov	 QWORD PTR p$4[rsp], rax

; 67   :             unsigned const char *q = strm->next_in;

  00080	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  00085	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00088	48 89 44 24 48	 mov	 QWORD PTR q$5[rsp], rax

; 68   :             unsigned n = strm->avail_in;

  0008d	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  00092	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00095	89 44 24 50	 mov	 DWORD PTR n$6[rsp], eax
$LN4@gz_avail:

; 69   :             do {
; 70   :                 *p++ = *q++;

  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR p$4[rsp]
  0009e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR q$5[rsp]
  000a3	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000a6	88 08		 mov	 BYTE PTR [rax], cl
  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR p$4[rsp]
  000ad	48 ff c0	 inc	 rax
  000b0	48 89 44 24 40	 mov	 QWORD PTR p$4[rsp], rax
  000b5	48 8b 44 24 48	 mov	 rax, QWORD PTR q$5[rsp]
  000ba	48 ff c0	 inc	 rax
  000bd	48 89 44 24 48	 mov	 QWORD PTR q$5[rsp], rax

; 71   :             } while (--n);

  000c2	8b 44 24 50	 mov	 eax, DWORD PTR n$6[rsp]
  000c6	ff c8		 dec	 eax
  000c8	89 44 24 50	 mov	 DWORD PTR n$6[rsp], eax
  000cc	83 7c 24 50 00	 cmp	 DWORD PTR n$6[rsp], 0
  000d1	75 c6		 jne	 SHORT $LN4@gz_avail
$LN7@gz_avail:

; 72   :         }
; 73   :         if (gz_load(state, state->in + strm->avail_in,
; 74   :                     state->size - strm->avail_in, &got) == -1)

  000d3	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000d8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR strm$[rsp]
  000dd	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000e0	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000e3	2b c1		 sub	 eax, ecx
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR strm$[rsp]
  000ea	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000ed	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  000f2	48 03 4a 30	 add	 rcx, QWORD PTR [rdx+48]
  000f6	4c 8d 4c 24 24	 lea	 r9, QWORD PTR got$[rsp]
  000fb	44 8b c0	 mov	 r8d, eax
  000fe	48 8b d1	 mov	 rdx, rcx
  00101	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00106	e8 00 00 00 00	 call	 gz_load
  0010b	83 f8 ff	 cmp	 eax, -1
  0010e	75 07		 jne	 SHORT $LN8@gz_avail

; 75   :             return -1;

  00110	b8 ff ff ff ff	 mov	 eax, -1
  00115	eb 27		 jmp	 SHORT $LN1@gz_avail
$LN8@gz_avail:

; 76   :         strm->avail_in += got;

  00117	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  0011c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0011f	03 44 24 24	 add	 eax, DWORD PTR got$[rsp]
  00123	48 8b 4c 24 38	 mov	 rcx, QWORD PTR strm$[rsp]
  00128	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 77   :         strm->next_in = state->in;

  0012b	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  00130	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00135	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00139	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN6@gz_avail:

; 78   :     }
; 79   :     return 0;

  0013c	33 c0		 xor	 eax, eax
$LN1@gz_avail:

; 80   : }

  0013e	48 8b f8	 mov	 rdi, rax
  00141	48 8b cc	 mov	 rcx, rsp
  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gz_avail$rtcFrameData
  0014b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00150	48 8b c7	 mov	 rax, rdi
  00153	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00157	5f		 pop	 rdi
  00158	c3		 ret	 0
gz_avail ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_look
_TEXT	SEGMENT
strm$ = 32
state$ = 64
gz_look	PROC						; COMDAT

; 93   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 94   :     z_streamp strm = &(state->strm);

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0002f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00033	48 89 44 24 20	 mov	 QWORD PTR strm$[rsp], rax

; 95   : 
; 96   :     /* allocate read buffers and inflate memory */
; 97   :     if (state->size == 0) {

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0003d	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00041	0f 85 59 01 00
	00		 jne	 $LN2@gz_look

; 98   :         /* allocate buffers */
; 99   :         state->in = (unsigned char *)malloc(state->want);

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0004c	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0004f	8b c8		 mov	 ecx, eax
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0005c	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 100  :         state->out = (unsigned char *)malloc(state->want << 1);

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00065	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00068	d1 e0		 shl	 eax, 1
  0006a	8b c0		 mov	 eax, eax
  0006c	8b c8		 mov	 ecx, eax
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00079	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 101  :         if (state->in == NULL || state->out == NULL) {

  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00082	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00087	74 0c		 je	 SHORT $LN4@gz_look
  00089	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0008e	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00093	75 3e		 jne	 SHORT $LN3@gz_look
$LN4@gz_look:

; 102  :             free(state->out);

  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0009a	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 103  :             free(state->in);

  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000a9	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 104  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  000ba	ba fc ff ff ff	 mov	 edx, -4
  000bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000c4	e8 00 00 00 00	 call	 gz_error

; 105  :             return -1;

  000c9	b8 ff ff ff ff	 mov	 eax, -1
  000ce	e9 13 02 00 00	 jmp	 $LN1@gz_look
$LN3@gz_look:

; 106  :         }
; 107  :         state->size = state->want;

  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000dd	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  000e0	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 108  : 
; 109  :         /* allocate inflate memory */
; 110  :         state->strm.zalloc = Z_NULL;

  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000e8	48 c7 80 a8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+168], 0

; 111  :         state->strm.zfree = Z_NULL;

  000f3	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000f8	48 c7 80 b0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+176], 0

; 112  :         state->strm.opaque = Z_NULL;

  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00108	48 c7 80 b8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+184], 0

; 113  :         state->strm.avail_in = 0;

  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00118	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+128], 0

; 114  :         state->strm.next_in = Z_NULL;

  00122	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00127	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 115  :         if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */

  0012f	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00134	48 83 c0 78	 add	 rax, 120		; 00000078H
  00138	41 b9 58 00 00
	00		 mov	 r9d, 88			; 00000058H
  0013e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411@
  00145	ba 1f 00 00 00	 mov	 edx, 31
  0014a	48 8b c8	 mov	 rcx, rax
  0014d	e8 00 00 00 00	 call	 inflateInit2_
  00152	85 c0		 test	 eax, eax
  00154	74 4a		 je	 SHORT $LN5@gz_look

; 116  :             free(state->out);

  00156	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0015b	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 117  :             free(state->in);

  00165	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0016a	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 118  :             state->size = 0;

  00174	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00179	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 119  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00180	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  00187	ba fc ff ff ff	 mov	 edx, -4
  0018c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00191	e8 00 00 00 00	 call	 gz_error

; 120  :             return -1;

  00196	b8 ff ff ff ff	 mov	 eax, -1
  0019b	e9 46 01 00 00	 jmp	 $LN1@gz_look
$LN5@gz_look:
$LN2@gz_look:

; 121  :         }
; 122  :     }
; 123  : 
; 124  :     /* get at least the magic bytes in the input buffer */
; 125  :     if (strm->avail_in < 2) {

  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  001a5	83 78 08 02	 cmp	 DWORD PTR [rax+8], 2
  001a9	73 2b		 jae	 SHORT $LN6@gz_look

; 126  :         if (gz_avail(state) == -1)

  001ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  001b0	e8 00 00 00 00	 call	 gz_avail
  001b5	83 f8 ff	 cmp	 eax, -1
  001b8	75 0a		 jne	 SHORT $LN7@gz_look

; 127  :             return -1;

  001ba	b8 ff ff ff ff	 mov	 eax, -1
  001bf	e9 22 01 00 00	 jmp	 $LN1@gz_look
$LN7@gz_look:

; 128  :         if (strm->avail_in == 0)

  001c4	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  001c9	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  001cd	75 07		 jne	 SHORT $LN8@gz_look

; 129  :             return 0;

  001cf	33 c0		 xor	 eax, eax
  001d1	e9 10 01 00 00	 jmp	 $LN1@gz_look
$LN8@gz_look:
$LN6@gz_look:

; 130  :     }
; 131  : 
; 132  :     /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
; 133  :        a logical dilemma here when considering the case of a partially written
; 134  :        gzip file, to wit, if a single 31 byte is written, then we cannot tell
; 135  :        whether this is a single-byte file, or just a partially written gzip
; 136  :        file -- for here we assume that if a gzip file is being written, then
; 137  :        the header will be written in a single operation, so that reading a
; 138  :        single byte is sufficient indication that it is not a gzip file) */
; 139  :     if (strm->avail_in > 1 &&
; 140  :             strm->next_in[0] == 31 && strm->next_in[1] == 139) {

  001d6	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  001db	83 78 08 01	 cmp	 DWORD PTR [rax+8], 1
  001df	76 5f		 jbe	 SHORT $LN9@gz_look
  001e1	b8 01 00 00 00	 mov	 eax, 1
  001e6	48 6b c0 00	 imul	 rax, rax, 0
  001ea	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  001ef	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f6	83 f8 1f	 cmp	 eax, 31
  001f9	75 45		 jne	 SHORT $LN9@gz_look
  001fb	b8 01 00 00 00	 mov	 eax, 1
  00200	48 6b c0 01	 imul	 rax, rax, 1
  00204	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  00209	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0020c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00210	3d 8b 00 00 00	 cmp	 eax, 139		; 0000008bH
  00215	75 29		 jne	 SHORT $LN9@gz_look

; 141  :         inflateReset(strm);

  00217	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  0021c	e8 00 00 00 00	 call	 inflateReset

; 142  :         state->how = GZIP;

  00221	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00226	c7 40 44 02 00
	00 00		 mov	 DWORD PTR [rax+68], 2

; 143  :         state->direct = 0;

  0022d	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00232	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 144  :         return 0;

  00239	33 c0		 xor	 eax, eax
  0023b	e9 a6 00 00 00	 jmp	 $LN1@gz_look
$LN9@gz_look:

; 145  :     }
; 146  : 
; 147  :     /* no gzip header -- if we were decoding gzip before, then this is trailing
; 148  :        garbage.  Ignore the trailing garbage and finish. */
; 149  :     if (state->direct == 0) {

  00240	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00245	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00249	75 27		 jne	 SHORT $LN10@gz_look

; 150  :         strm->avail_in = 0;

  0024b	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00250	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 151  :         state->eof = 1;

  00257	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0025c	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [rax+80], 1

; 152  :         state->x.have = 0;

  00263	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00268	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 153  :         return 0;

  0026e	33 c0		 xor	 eax, eax
  00270	eb 74		 jmp	 SHORT $LN1@gz_look
$LN10@gz_look:

; 154  :     }
; 155  : 
; 156  :     /* doing raw i/o, copy any leftover input to output -- this assumes that
; 157  :        the output buffer is larger than the input buffer, which also assures
; 158  :        space for gzungetc() */
; 159  :     state->x.next = state->out;

  00272	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00277	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0027c	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00280	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 160  :     if (strm->avail_in) {

  00284	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00289	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0028d	74 3d		 je	 SHORT $LN11@gz_look

; 161  :         memcpy(state->x.next, strm->next_in, strm->avail_in);

  0028f	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00294	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00297	44 8b c0	 mov	 r8d, eax
  0029a	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0029f	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  002a2	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  002a7	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 162  :         state->x.have = strm->avail_in;

  002b1	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  002b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  002bb	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  002be	89 08		 mov	 DWORD PTR [rax], ecx

; 163  :         strm->avail_in = 0;

  002c0	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  002c5	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0
$LN11@gz_look:

; 164  :     }
; 165  :     state->how = COPY;

  002cc	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  002d1	c7 40 44 01 00
	00 00		 mov	 DWORD PTR [rax+68], 1

; 166  :     state->direct = 1;

  002d8	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  002dd	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1

; 167  :     return 0;

  002e4	33 c0		 xor	 eax, eax
$LN1@gz_look:

; 168  : }

  002e6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002ea	5f		 pop	 rdi
  002eb	c3		 ret	 0
gz_look	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_decomp
_TEXT	SEGMENT
ret$ = 32
had$ = 36
strm$ = 40
tv92 = 48
state$ = 80
gz_decomp PROC						; COMDAT

; 177  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 10 00 00 00	 mov	 ecx, 16
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 178  :     int ret = Z_OK;

  0002a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0

; 179  :     unsigned had;
; 180  :     z_streamp strm = &(state->strm);

  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00037	48 83 c0 78	 add	 rax, 120		; 00000078H
  0003b	48 89 44 24 28	 mov	 QWORD PTR strm$[rsp], rax

; 181  : 
; 182  :     /* fill output buffer up to end of deflate stream */
; 183  :     had = strm->avail_out;

  00040	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00045	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00048	89 44 24 24	 mov	 DWORD PTR had$[rsp], eax
$LN4@gz_decomp:

; 184  :     do {
; 185  :         /* get more input for inflate() */
; 186  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  0004c	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00051	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00055	75 19		 jne	 SHORT $LN5@gz_decomp
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0005c	e8 00 00 00 00	 call	 gz_avail
  00061	83 f8 ff	 cmp	 eax, -1
  00064	75 0a		 jne	 SHORT $LN5@gz_decomp

; 187  :             return -1;

  00066	b8 ff ff ff ff	 mov	 eax, -1
  0006b	e9 36 01 00 00	 jmp	 $LN1@gz_decomp
$LN5@gz_decomp:

; 188  :         if (strm->avail_in == 0) {

  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00075	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00079	75 1b		 jne	 SHORT $LN6@gz_decomp

; 189  :             gz_error(state, Z_BUF_ERROR, "unexpected end of file");

  0007b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
  00082	ba fb ff ff ff	 mov	 edx, -5
  00087	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0008c	e8 00 00 00 00	 call	 gz_error

; 190  :             break;

  00091	e9 c5 00 00 00	 jmp	 $LN3@gz_decomp
$LN6@gz_decomp:

; 191  :         }
; 192  : 
; 193  :         /* decompress and handle errors */
; 194  :         ret = inflate(strm, Z_NO_FLUSH);

  00096	33 d2		 xor	 edx, edx
  00098	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0009d	e8 00 00 00 00	 call	 inflate
  000a2	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 195  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  000a6	83 7c 24 20 fe	 cmp	 DWORD PTR ret$[rsp], -2
  000ab	74 07		 je	 SHORT $LN8@gz_decomp
  000ad	83 7c 24 20 02	 cmp	 DWORD PTR ret$[rsp], 2
  000b2	75 20		 jne	 SHORT $LN7@gz_decomp
$LN8@gz_decomp:

; 196  :             gz_error(state, Z_STREAM_ERROR,

  000b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
  000bb	ba fe ff ff ff	 mov	 edx, -2
  000c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000c5	e8 00 00 00 00	 call	 gz_error

; 197  :                      "internal error: inflate stream corrupt");
; 198  :             return -1;

  000ca	b8 ff ff ff ff	 mov	 eax, -1
  000cf	e9 d2 00 00 00	 jmp	 $LN1@gz_decomp
$LN7@gz_decomp:

; 199  :         }
; 200  :         if (ret == Z_MEM_ERROR) {

  000d4	83 7c 24 20 fc	 cmp	 DWORD PTR ret$[rsp], -4
  000d9	75 20		 jne	 SHORT $LN9@gz_decomp

; 201  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  000e2	ba fc ff ff ff	 mov	 edx, -4
  000e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000ec	e8 00 00 00 00	 call	 gz_error

; 202  :             return -1;

  000f1	b8 ff ff ff ff	 mov	 eax, -1
  000f6	e9 ab 00 00 00	 jmp	 $LN1@gz_decomp
$LN9@gz_decomp:

; 203  :         }
; 204  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  000fb	83 7c 24 20 fd	 cmp	 DWORD PTR ret$[rsp], -3
  00100	75 43		 jne	 SHORT $LN10@gz_decomp

; 205  :             gz_error(state, Z_DATA_ERROR,

  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00107	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0010c	75 0e		 jne	 SHORT $LN14@gz_decomp
  0010e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@HCKBMIHF@compressed?5data?5error@
  00115	48 89 44 24 30	 mov	 QWORD PTR tv92[rsp], rax
  0011a	eb 0e		 jmp	 SHORT $LN15@gz_decomp
$LN14@gz_decomp:
  0011c	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00121	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00125	48 89 44 24 30	 mov	 QWORD PTR tv92[rsp], rax
$LN15@gz_decomp:
  0012a	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv92[rsp]
  0012f	ba fd ff ff ff	 mov	 edx, -3
  00134	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00139	e8 00 00 00 00	 call	 gz_error

; 206  :                      strm->msg == NULL ? "compressed data error" : strm->msg);
; 207  :             return -1;

  0013e	b8 ff ff ff ff	 mov	 eax, -1
  00143	eb 61		 jmp	 SHORT $LN1@gz_decomp
$LN10@gz_decomp:

; 208  :         }
; 209  :     } while (strm->avail_out && ret != Z_STREAM_END);

  00145	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  0014a	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0014e	74 0b		 je	 SHORT $LN11@gz_decomp
  00150	83 7c 24 20 01	 cmp	 DWORD PTR ret$[rsp], 1
  00155	0f 85 f1 fe ff
	ff		 jne	 $LN4@gz_decomp
$LN11@gz_decomp:
$LN3@gz_decomp:

; 210  : 
; 211  :     /* update available output */
; 212  :     state->x.have = had - strm->avail_out;

  0015b	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00160	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00163	8b 4c 24 24	 mov	 ecx, DWORD PTR had$[rsp]
  00167	2b c8		 sub	 ecx, eax
  00169	8b c1		 mov	 eax, ecx
  0016b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00170	89 01		 mov	 DWORD PTR [rcx], eax

; 213  :     state->x.next = strm->next_out - state->x.have;

  00172	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00177	8b 00		 mov	 eax, DWORD PTR [rax]
  00179	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0017e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00182	48 2b c8	 sub	 rcx, rax
  00185	48 8b c1	 mov	 rax, rcx
  00188	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0018d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 214  : 
; 215  :     /* if the gzip stream completed successfully, look for another */
; 216  :     if (ret == Z_STREAM_END)

  00191	83 7c 24 20 01	 cmp	 DWORD PTR ret$[rsp], 1
  00196	75 0c		 jne	 SHORT $LN12@gz_decomp

; 217  :         state->how = LOOK;

  00198	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  0019d	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [rax+68], 0
$LN12@gz_decomp:

; 218  : 
; 219  :     /* good decompression */
; 220  :     return 0;

  001a4	33 c0		 xor	 eax, eax
$LN1@gz_decomp:

; 221  : }

  001a6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001aa	5f		 pop	 rdi
  001ab	c3		 ret	 0
gz_decomp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_fetch
_TEXT	SEGMENT
strm$ = 32
tv66 = 40
state$ = 64
gz_fetch PROC						; COMDAT

; 231  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 232  :     z_streamp strm = &(state->strm);

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0002f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00033	48 89 44 24 20	 mov	 QWORD PTR strm$[rsp], rax
$LN16@gz_fetch:
$LN4@gz_fetch:

; 233  : 
; 234  :     do {
; 235  :         switch(state->how) {

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0003d	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00040	89 44 24 28	 mov	 DWORD PTR tv66[rsp], eax
  00044	83 7c 24 28 00	 cmp	 DWORD PTR tv66[rsp], 0
  00049	74 13		 je	 SHORT $LN7@gz_fetch
  0004b	83 7c 24 28 01	 cmp	 DWORD PTR tv66[rsp], 1
  00050	74 3c		 je	 SHORT $LN10@gz_fetch
  00052	83 7c 24 28 02	 cmp	 DWORD PTR tv66[rsp], 2
  00057	74 7f		 je	 SHORT $LN12@gz_fetch
  00059	e9 b4 00 00 00	 jmp	 $LN5@gz_fetch
$LN7@gz_fetch:

; 236  :         case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
; 237  :             if (gz_look(state) == -1)

  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00063	e8 00 00 00 00	 call	 gz_look
  00068	83 f8 ff	 cmp	 eax, -1
  0006b	75 0a		 jne	 SHORT $LN8@gz_fetch

; 238  :                 return -1;

  0006d	b8 ff ff ff ff	 mov	 eax, -1
  00072	e9 c5 00 00 00	 jmp	 $LN1@gz_fetch
$LN8@gz_fetch:

; 239  :             if (state->how == LOOK)

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0007c	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  00080	75 07		 jne	 SHORT $LN9@gz_fetch

; 240  :                 return 0;

  00082	33 c0		 xor	 eax, eax
  00084	e9 b3 00 00 00	 jmp	 $LN1@gz_fetch
$LN9@gz_fetch:

; 241  :             break;

  00089	e9 84 00 00 00	 jmp	 $LN5@gz_fetch
$LN10@gz_fetch:

; 242  :         case COPY:      /* -> COPY */
; 243  :             if (gz_load(state, state->out, state->size << 1, &(state->x.have))
; 244  :                     == -1)

  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00098	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0009b	d1 e1		 shl	 ecx, 1
  0009d	4c 8b c8	 mov	 r9, rax
  000a0	44 8b c1	 mov	 r8d, ecx
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000a8	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000b1	e8 00 00 00 00	 call	 gz_load
  000b6	83 f8 ff	 cmp	 eax, -1
  000b9	75 07		 jne	 SHORT $LN11@gz_fetch

; 245  :                 return -1;

  000bb	b8 ff ff ff ff	 mov	 eax, -1
  000c0	eb 7a		 jmp	 SHORT $LN1@gz_fetch
$LN11@gz_fetch:

; 246  :             state->x.next = state->out;

  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000c7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000cc	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000d0	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 247  :             return 0;

  000d4	33 c0		 xor	 eax, eax
  000d6	eb 64		 jmp	 SHORT $LN1@gz_fetch
$LN12@gz_fetch:

; 248  :         case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
; 249  :             strm->avail_out = state->size << 1;

  000d8	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000dd	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000e0	d1 e0		 shl	 eax, 1
  000e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  000e7	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 250  :             strm->next_out = state->out;

  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  000ef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000f4	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000f8	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 251  :             if (gz_decomp(state) == -1)

  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00101	e8 00 00 00 00	 call	 gz_decomp
  00106	83 f8 ff	 cmp	 eax, -1
  00109	75 07		 jne	 SHORT $LN13@gz_fetch

; 252  :                 return -1;

  0010b	b8 ff ff ff ff	 mov	 eax, -1
  00110	eb 2a		 jmp	 SHORT $LN1@gz_fetch
$LN13@gz_fetch:
$LN5@gz_fetch:

; 253  :         }
; 254  :     } while (state->x.have == 0 && (!state->eof || strm->avail_in));

  00112	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00117	83 38 00	 cmp	 DWORD PTR [rax], 0
  0011a	75 1e		 jne	 SHORT $LN14@gz_fetch
  0011c	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00121	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  00125	0f 84 0d ff ff
	ff		 je	 $LN4@gz_fetch
  0012b	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00130	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00134	0f 85 fe fe ff
	ff		 jne	 $LN16@gz_fetch
$LN14@gz_fetch:

; 255  :     return 0;

  0013a	33 c0		 xor	 eax, eax
$LN1@gz_fetch:

; 256  : }

  0013c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00140	5f		 pop	 rdi
  00141	c3		 ret	 0
gz_fetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_skip
_TEXT	SEGMENT
n$ = 32
tv72 = 36
state$ = 64
len$ = 72
gz_skip	PROC						; COMDAT

; 262  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 0c 00 00 00	 mov	 ecx, 12
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode
$LN2@gz_skip:

; 263  :     unsigned n;
; 264  : 
; 265  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 266  :     while (len)

  0002f	48 83 7c 24 48
	00		 cmp	 QWORD PTR len$[rsp], 0
  00035	0f 84 cd 00 00
	00		 je	 $LN3@gz_skip

; 267  :         /* skip over whatever is in output buffer */
; 268  :         if (state->x.have) {

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00040	83 38 00	 cmp	 DWORD PTR [rax], 0
  00043	0f 84 87 00 00
	00		 je	 $LN4@gz_skip

; 269  :             n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?

  00049	33 c0		 xor	 eax, eax
  0004b	85 c0		 test	 eax, eax
  0004d	75 1b		 jne	 SHORT $LN10@gz_skip
  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00054	8b 00		 mov	 eax, DWORD PTR [rax]
  00056	48 3b 44 24 48	 cmp	 rax, QWORD PTR len$[rsp]
  0005b	7f 0d		 jg	 SHORT $LN10@gz_skip
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00062	8b 00		 mov	 eax, DWORD PTR [rax]
  00064	89 44 24 24	 mov	 DWORD PTR tv72[rsp], eax
  00068	eb 08		 jmp	 SHORT $LN11@gz_skip
$LN10@gz_skip:
  0006a	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  0006e	89 44 24 24	 mov	 DWORD PTR tv72[rsp], eax
$LN11@gz_skip:
  00072	8b 44 24 24	 mov	 eax, DWORD PTR tv72[rsp]
  00076	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 270  :                 (unsigned)len : state->x.have;
; 271  :             state->x.have -= n;

  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0007f	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00083	8b 00		 mov	 eax, DWORD PTR [rax]
  00085	2b c1		 sub	 eax, ecx
  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0008c	89 01		 mov	 DWORD PTR [rcx], eax

; 272  :             state->x.next += n;

  0008e	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00097	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000a0	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 273  :             state->x.pos += n;

  000a4	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000ad	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000b6	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 274  :             len -= n;

  000ba	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000be	48 8b 4c 24 48	 mov	 rcx, QWORD PTR len$[rsp]
  000c3	48 2b c8	 sub	 rcx, rax
  000c6	48 8b c1	 mov	 rax, rcx
  000c9	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax

; 275  :         }

  000ce	eb 33		 jmp	 SHORT $LN5@gz_skip
$LN4@gz_skip:

; 276  : 
; 277  :         /* output buffer empty -- return if we're at the end of the input */
; 278  :         else if (state->eof && state->strm.avail_in == 0)

  000d0	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000d5	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  000d9	74 12		 je	 SHORT $LN6@gz_skip
  000db	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000e0	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  000e7	75 04		 jne	 SHORT $LN6@gz_skip

; 279  :             break;

  000e9	eb 1d		 jmp	 SHORT $LN3@gz_skip
  000eb	eb 16		 jmp	 SHORT $LN7@gz_skip
$LN6@gz_skip:

; 280  : 
; 281  :         /* need more data to skip -- load up output buffer */
; 282  :         else {
; 283  :             /* get more output, looking for header if required */
; 284  :             if (gz_fetch(state) == -1)

  000ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000f2	e8 00 00 00 00	 call	 gz_fetch
  000f7	83 f8 ff	 cmp	 eax, -1
  000fa	75 07		 jne	 SHORT $LN8@gz_skip

; 285  :                 return -1;

  000fc	b8 ff ff ff ff	 mov	 eax, -1
  00101	eb 07		 jmp	 SHORT $LN1@gz_skip
$LN8@gz_skip:
$LN7@gz_skip:
$LN5@gz_skip:

; 286  :         }

  00103	e9 27 ff ff ff	 jmp	 $LN2@gz_skip
$LN3@gz_skip:

; 287  :     return 0;

  00108	33 c0		 xor	 eax, eax
$LN1@gz_skip:

; 288  : }

  0010a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
gz_skip	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gz_read
_TEXT	SEGMENT
got$ = 32
n$ = 52
state$ = 96
buf$ = 104
len$ = 112
gz_read	PROC						; COMDAT

; 298  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 14 00 00 00	 mov	 ecx, 20
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 299  :     z_size_t got;
; 300  :     unsigned n;
; 301  : 
; 302  :     /* if len is zero, avoid unnecessary operations */
; 303  :     if (len == 0)

  00034	48 83 7c 24 70
	00		 cmp	 QWORD PTR len$[rsp], 0
  0003a	75 07		 jne	 SHORT $LN5@gz_read

; 304  :         return 0;

  0003c	33 c0		 xor	 eax, eax
  0003e	e9 0b 02 00 00	 jmp	 $LN1@gz_read
$LN5@gz_read:

; 305  : 
; 306  :     /* process a skip request */
; 307  :     if (state->seek) {

  00043	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00048	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  0004c	74 2b		 je	 SHORT $LN6@gz_read

; 308  :         state->seek = 0;

  0004e	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00053	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 309  :         if (gz_skip(state, state->skip) == -1)

  0005a	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0005f	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00063	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00068	e8 00 00 00 00	 call	 gz_skip
  0006d	83 f8 ff	 cmp	 eax, -1
  00070	75 07		 jne	 SHORT $LN7@gz_read

; 310  :             return 0;

  00072	33 c0		 xor	 eax, eax
  00074	e9 d5 01 00 00	 jmp	 $LN1@gz_read
$LN7@gz_read:
$LN6@gz_read:

; 311  :     }
; 312  : 
; 313  :     /* get len bytes to buf, or less than len if at the end */
; 314  :     got = 0;

  00079	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR got$[rsp], 0
$LN4@gz_read:

; 315  :     do {
; 316  :         /* set n to the maximum amount of len that fits in an unsigned int */
; 317  :         n = -1;

  00082	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR n$[rsp], -1	; ffffffffH

; 318  :         if (n > len)

  0008a	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  0008e	48 3b 44 24 70	 cmp	 rax, QWORD PTR len$[rsp]
  00093	76 08		 jbe	 SHORT $LN8@gz_read

; 319  :             n = len;

  00095	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  00099	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN8@gz_read:

; 320  : 
; 321  :         /* first just try copying data from the output buffer */
; 322  :         if (state->x.have) {

  0009d	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000a2	83 38 00	 cmp	 DWORD PTR [rax], 0
  000a5	74 62		 je	 SHORT $LN9@gz_read

; 323  :             if (state->x.have < n)

  000a7	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000ac	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  000b0	39 08		 cmp	 DWORD PTR [rax], ecx
  000b2	73 0b		 jae	 SHORT $LN11@gz_read

; 324  :                 n = state->x.have;

  000b4	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000b9	8b 00		 mov	 eax, DWORD PTR [rax]
  000bb	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN11@gz_read:

; 325  :             memcpy(buf, state->x.next, n);

  000bf	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  000c3	44 8b c0	 mov	 r8d, eax
  000c6	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000cb	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000cf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 326  :             state->x.next += n;

  000da	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  000de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000e3	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  000e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000ec	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 327  :             state->x.have -= n;

  000f0	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000f5	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  000f9	8b 00		 mov	 eax, DWORD PTR [rax]
  000fb	2b c1		 sub	 eax, ecx
  000fd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00102	89 01		 mov	 DWORD PTR [rcx], eax

; 328  :         }

  00104	e9 e2 00 00 00	 jmp	 $LN10@gz_read
$LN9@gz_read:

; 329  : 
; 330  :         /* output buffer empty -- return if we're at the end of the input */
; 331  :         else if (state->eof && state->strm.avail_in == 0) {

  00109	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0010e	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  00112	74 24		 je	 SHORT $LN12@gz_read
  00114	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00119	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  00120	75 16		 jne	 SHORT $LN12@gz_read

; 332  :             state->past = 1;        /* tried to read past end */

  00122	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00127	c7 40 54 01 00
	00 00		 mov	 DWORD PTR [rax+84], 1

; 333  :             break;

  0012e	e9 16 01 00 00	 jmp	 $LN3@gz_read

; 334  :         }

  00133	e9 b3 00 00 00	 jmp	 $LN13@gz_read
$LN12@gz_read:

; 335  : 
; 336  :         /* need output data -- for small len or new stream load up our output
; 337  :            buffer */
; 338  :         else if (state->how == LOOK || n < (state->size << 1)) {

  00138	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0013d	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  00141	74 10		 je	 SHORT $LN16@gz_read
  00143	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00148	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0014b	d1 e0		 shl	 eax, 1
  0014d	39 44 24 34	 cmp	 DWORD PTR n$[rsp], eax
  00151	73 1d		 jae	 SHORT $LN14@gz_read
$LN16@gz_read:

; 339  :             /* get more output, looking for header if required */
; 340  :             if (gz_fetch(state) == -1)

  00153	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00158	e8 00 00 00 00	 call	 gz_fetch
  0015d	83 f8 ff	 cmp	 eax, -1
  00160	75 07		 jne	 SHORT $LN17@gz_read

; 341  :                 return 0;

  00162	33 c0		 xor	 eax, eax
  00164	e9 e5 00 00 00	 jmp	 $LN1@gz_read
$LN17@gz_read:

; 342  :             continue;       /* no progress yet -- go back to copy above */

  00169	e9 cf 00 00 00	 jmp	 $LN2@gz_read

; 343  :             /* the copy above assures that we will leave with space in the
; 344  :                output buffer, allowing at least one gzungetc() to succeed */
; 345  :         }

  0016e	eb 7b		 jmp	 SHORT $LN15@gz_read
$LN14@gz_read:

; 346  : 
; 347  :         /* large len -- read directly into user buffer */
; 348  :         else if (state->how == COPY) {      /* read directly */

  00170	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00175	83 78 44 01	 cmp	 DWORD PTR [rax+68], 1
  00179	75 27		 jne	 SHORT $LN18@gz_read

; 349  :             if (gz_load(state, (unsigned char *)buf, n, &n) == -1)

  0017b	4c 8d 4c 24 34	 lea	 r9, QWORD PTR n$[rsp]
  00180	44 8b 44 24 34	 mov	 r8d, DWORD PTR n$[rsp]
  00185	48 8b 54 24 68	 mov	 rdx, QWORD PTR buf$[rsp]
  0018a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0018f	e8 00 00 00 00	 call	 gz_load
  00194	83 f8 ff	 cmp	 eax, -1
  00197	75 07		 jne	 SHORT $LN20@gz_read

; 350  :                 return 0;

  00199	33 c0		 xor	 eax, eax
  0019b	e9 ae 00 00 00	 jmp	 $LN1@gz_read
$LN20@gz_read:

; 351  :         }

  001a0	eb 49		 jmp	 SHORT $LN19@gz_read
$LN18@gz_read:

; 352  : 
; 353  :         /* large len -- decompress directly into user buffer */
; 354  :         else {  /* state->how == GZIP */
; 355  :             state->strm.avail_out = n;

  001a2	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001a7	8b 4c 24 34	 mov	 ecx, DWORD PTR n$[rsp]
  001ab	89 88 90 00 00
	00		 mov	 DWORD PTR [rax+144], ecx

; 356  :             state->strm.next_out = (unsigned char *)buf;

  001b1	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001b6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  001bb	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 357  :             if (gz_decomp(state) == -1)

  001c2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001c7	e8 00 00 00 00	 call	 gz_decomp
  001cc	83 f8 ff	 cmp	 eax, -1
  001cf	75 04		 jne	 SHORT $LN21@gz_read

; 358  :                 return 0;

  001d1	33 c0		 xor	 eax, eax
  001d3	eb 79		 jmp	 SHORT $LN1@gz_read
$LN21@gz_read:

; 359  :             n = state->x.have;

  001d5	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001da	8b 00		 mov	 eax, DWORD PTR [rax]
  001dc	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 360  :             state->x.have = 0;

  001e0	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001e5	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN19@gz_read:
$LN15@gz_read:
$LN13@gz_read:
$LN10@gz_read:

; 361  :         }
; 362  : 
; 363  :         /* update progress */
; 364  :         len -= n;

  001eb	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  001ef	48 8b 4c 24 70	 mov	 rcx, QWORD PTR len$[rsp]
  001f4	48 2b c8	 sub	 rcx, rax
  001f7	48 8b c1	 mov	 rax, rcx
  001fa	48 89 44 24 70	 mov	 QWORD PTR len$[rsp], rax

; 365  :         buf = (char *)buf + n;

  001ff	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00203	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  00208	48 03 c8	 add	 rcx, rax
  0020b	48 8b c1	 mov	 rax, rcx
  0020e	48 89 44 24 68	 mov	 QWORD PTR buf$[rsp], rax

; 366  :         got += n;

  00213	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00217	48 8b 4c 24 20	 mov	 rcx, QWORD PTR got$[rsp]
  0021c	48 03 c8	 add	 rcx, rax
  0021f	48 8b c1	 mov	 rax, rcx
  00222	48 89 44 24 20	 mov	 QWORD PTR got$[rsp], rax

; 367  :         state->x.pos += n;

  00227	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  0022b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00230	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00234	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00239	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN2@gz_read:

; 368  :     } while (len);

  0023d	48 83 7c 24 70
	00		 cmp	 QWORD PTR len$[rsp], 0
  00243	0f 85 39 fe ff
	ff		 jne	 $LN4@gz_read
$LN3@gz_read:

; 369  : 
; 370  :     /* return number of bytes read into user buffer */
; 371  :     return got;

  00249	48 8b 44 24 20	 mov	 rax, QWORD PTR got$[rsp]
$LN1@gz_read:

; 372  : }

  0024e	48 8b f8	 mov	 rdi, rax
  00251	48 8b cc	 mov	 rcx, rsp
  00254	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gz_read$rtcFrameData
  0025b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00260	48 8b c7	 mov	 rax, rdi
  00263	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00267	5f		 pop	 rdi
  00268	c3		 ret	 0
gz_read	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzread
_TEXT	SEGMENT
state$ = 32
file$ = 64
buf$ = 72
len$ = 80
gzread	PROC						; COMDAT

; 379  : {

$LN10:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 380  :     gz_statep state;
; 381  : 
; 382  :     /* get internal structure */
; 383  :     if (file == NULL)

  00034	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  0003a	75 0a		 jne	 SHORT $LN2@gzread

; 384  :         return -1;

  0003c	b8 ff ff ff ff	 mov	 eax, -1
  00041	e9 9b 00 00 00	 jmp	 $LN1@gzread
$LN2@gzread:

; 385  :     state = (gz_statep)file;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0004b	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 386  : 
; 387  :     /* check that we're reading and that there's no (serious) error */
; 388  :     if (state->mode != GZ_READ ||

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00055	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  0005c	75 16		 jne	 SHORT $LN4@gzread
  0005e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00063	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00067	74 12		 je	 SHORT $LN3@gzread
  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0006e	83 78 6c fb	 cmp	 DWORD PTR [rax+108], -5
  00072	74 07		 je	 SHORT $LN3@gzread
$LN4@gzread:

; 389  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 390  :         return -1;

  00074	b8 ff ff ff ff	 mov	 eax, -1
  00079	eb 66		 jmp	 SHORT $LN1@gzread
$LN3@gzread:

; 391  : 
; 392  :     /* since an int is returned, make sure len fits in one, otherwise return
; 393  :        with an error (this avoids a flaw in the interface) */
; 394  :     if ((int)len < 0) {

  0007b	83 7c 24 50 00	 cmp	 DWORD PTR len$[rsp], 0
  00080	7d 1d		 jge	 SHORT $LN5@gzread

; 395  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in an int");

  00082	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@
  00089	ba fe ff ff ff	 mov	 edx, -2
  0008e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00093	e8 00 00 00 00	 call	 gz_error

; 396  :         return -1;

  00098	b8 ff ff ff ff	 mov	 eax, -1
  0009d	eb 42		 jmp	 SHORT $LN1@gzread
$LN5@gzread:

; 397  :     }
; 398  : 
; 399  :     /* read len or fewer bytes to buf */
; 400  :     len = gz_read(state, buf, len);

  0009f	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  000a3	44 8b c0	 mov	 r8d, eax
  000a6	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  000ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000b0	e8 00 00 00 00	 call	 gz_read
  000b5	89 44 24 50	 mov	 DWORD PTR len$[rsp], eax

; 401  : 
; 402  :     /* check for an error */
; 403  :     if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)

  000b9	83 7c 24 50 00	 cmp	 DWORD PTR len$[rsp], 0
  000be	75 1d		 jne	 SHORT $LN6@gzread
  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000c5	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  000c9	74 12		 je	 SHORT $LN6@gzread
  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000d0	83 78 6c fb	 cmp	 DWORD PTR [rax+108], -5
  000d4	74 07		 je	 SHORT $LN6@gzread

; 404  :         return -1;

  000d6	b8 ff ff ff ff	 mov	 eax, -1
  000db	eb 04		 jmp	 SHORT $LN1@gzread
$LN6@gzread:

; 405  : 
; 406  :     /* return the number of bytes read (this is assured to fit in an int) */
; 407  :     return (int)len;

  000dd	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
$LN1@gzread:

; 408  : }

  000e1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e5	5f		 pop	 rdi
  000e6	c3		 ret	 0
gzread	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzfread
_TEXT	SEGMENT
len$ = 32
state$ = 40
tv84 = 48
buf$ = 80
size$ = 88
nitems$ = 96
file$ = 104
gzfread	PROC						; COMDAT

; 416  : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00034	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 417  :     z_size_t len;
; 418  :     gz_statep state;
; 419  : 
; 420  :     /* get internal structure */
; 421  :     if (file == NULL)

  00039	48 83 7c 24 68
	00		 cmp	 QWORD PTR file$[rsp], 0
  0003f	75 07		 jne	 SHORT $LN2@gzfread

; 422  :         return 0;

  00041	33 c0		 xor	 eax, eax
  00043	e9 af 00 00 00	 jmp	 $LN1@gzfread
$LN2@gzfread:

; 423  :     state = (gz_statep)file;

  00048	48 8b 44 24 68	 mov	 rax, QWORD PTR file$[rsp]
  0004d	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 424  : 
; 425  :     /* check that we're reading and that there's no (serious) error */
; 426  :     if (state->mode != GZ_READ ||

  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00057	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  0005e	75 16		 jne	 SHORT $LN4@gzfread
  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00065	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00069	74 0f		 je	 SHORT $LN3@gzfread
  0006b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00070	83 78 6c fb	 cmp	 DWORD PTR [rax+108], -5
  00074	74 04		 je	 SHORT $LN3@gzfread
$LN4@gzfread:

; 427  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 428  :         return 0;

  00076	33 c0		 xor	 eax, eax
  00078	eb 7d		 jmp	 SHORT $LN1@gzfread
$LN3@gzfread:

; 429  : 
; 430  :     /* compute bytes to read -- error on overflow */
; 431  :     len = nitems * size;

  0007a	48 8b 44 24 60	 mov	 rax, QWORD PTR nitems$[rsp]
  0007f	48 0f af 44 24
	58		 imul	 rax, QWORD PTR size$[rsp]
  00085	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 432  :     if (size && len / size != nitems) {

  0008a	48 83 7c 24 58
	00		 cmp	 QWORD PTR size$[rsp], 0
  00090	74 2d		 je	 SHORT $LN5@gzfread
  00092	33 d2		 xor	 edx, edx
  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR len$[rsp]
  00099	48 f7 74 24 58	 div	 QWORD PTR size$[rsp]
  0009e	48 3b 44 24 60	 cmp	 rax, QWORD PTR nitems$[rsp]
  000a3	74 1a		 je	 SHORT $LN5@gzfread

; 433  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");

  000a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@
  000ac	ba fe ff ff ff	 mov	 edx, -2
  000b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000b6	e8 00 00 00 00	 call	 gz_error

; 434  :         return 0;

  000bb	33 c0		 xor	 eax, eax
  000bd	eb 38		 jmp	 SHORT $LN1@gzfread
$LN5@gzfread:

; 435  :     }
; 436  : 
; 437  :     /* read len or fewer bytes to buf, return the number of full items read */
; 438  :     return len ? gz_read(state, buf, len) / size : 0;

  000bf	48 83 7c 24 20
	00		 cmp	 QWORD PTR len$[rsp], 0
  000c5	74 22		 je	 SHORT $LN7@gzfread
  000c7	4c 8b 44 24 20	 mov	 r8, QWORD PTR len$[rsp]
  000cc	48 8b 54 24 50	 mov	 rdx, QWORD PTR buf$[rsp]
  000d1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000d6	e8 00 00 00 00	 call	 gz_read
  000db	33 d2		 xor	 edx, edx
  000dd	48 f7 74 24 58	 div	 QWORD PTR size$[rsp]
  000e2	48 89 44 24 30	 mov	 QWORD PTR tv84[rsp], rax
  000e7	eb 09		 jmp	 SHORT $LN8@gzfread
$LN7@gzfread:
  000e9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv84[rsp], 0
$LN8@gzfread:
  000f2	48 8b 44 24 30	 mov	 rax, QWORD PTR tv84[rsp]
$LN1@gzfread:

; 439  : }

  000f7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000fb	5f		 pop	 rdi
  000fc	c3		 ret	 0
gzfread	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzgetc
_TEXT	SEGMENT
ret$ = 32
buf$ = 52
state$ = 72
tv86 = 80
tv129 = 84
file$ = 112
gzgetc	PROC						; COMDAT

; 449  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 18 00 00 00	 mov	 ecx, 24
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 450  :     int ret;
; 451  :     unsigned char buf[1];
; 452  :     gz_statep state;
; 453  : 
; 454  :     /* get internal structure */
; 455  :     if (file == NULL)

  0002a	48 83 7c 24 70
	00		 cmp	 QWORD PTR file$[rsp], 0
  00030	75 0a		 jne	 SHORT $LN2@gzgetc

; 456  :         return -1;

  00032	b8 ff ff ff ff	 mov	 eax, -1
  00037	e9 d3 00 00 00	 jmp	 $LN1@gzgetc
$LN2@gzgetc:

; 457  :     state = (gz_statep)file;

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR file$[rsp]
  00041	48 89 44 24 48	 mov	 QWORD PTR state$[rsp], rax

; 458  : 
; 459  :     /* check that we're reading and that there's no (serious) error */
; 460  :     if (state->mode != GZ_READ ||

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  0004b	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00052	75 16		 jne	 SHORT $LN4@gzgetc
  00054	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00059	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  0005d	74 15		 je	 SHORT $LN3@gzgetc
  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00064	83 78 6c fb	 cmp	 DWORD PTR [rax+108], -5
  00068	74 0a		 je	 SHORT $LN3@gzgetc
$LN4@gzgetc:

; 461  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 462  :         return -1;

  0006a	b8 ff ff ff ff	 mov	 eax, -1
  0006f	e9 9b 00 00 00	 jmp	 $LN1@gzgetc
$LN3@gzgetc:

; 463  : 
; 464  :     /* try output buffer (no need to check for skip request) */
; 465  :     if (state->x.have) {

  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00079	83 38 00	 cmp	 DWORD PTR [rax], 0
  0007c	74 51		 je	 SHORT $LN5@gzgetc

; 466  :         state->x.have--;

  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00083	8b 00		 mov	 eax, DWORD PTR [rax]
  00085	ff c8		 dec	 eax
  00087	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  0008c	89 01		 mov	 DWORD PTR [rcx], eax

; 467  :         state->x.pos++;

  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00093	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00097	48 ff c0	 inc	 rax
  0009a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  0009f	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 468  :         return *(state->x.next)++;

  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  000a8	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ac	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000af	88 44 24 50	 mov	 BYTE PTR tv86[rsp], al
  000b3	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  000b8	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000bc	48 ff c0	 inc	 rax
  000bf	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  000c4	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  000c8	0f b6 44 24 50	 movzx	 eax, BYTE PTR tv86[rsp]
  000cd	eb 40		 jmp	 SHORT $LN1@gzgetc
$LN5@gzgetc:

; 469  :     }
; 470  : 
; 471  :     /* nothing there -- try gz_read() */
; 472  :     ret = gz_read(state, buf, 1);

  000cf	41 b8 01 00 00
	00		 mov	 r8d, 1
  000d5	48 8d 54 24 34	 lea	 rdx, QWORD PTR buf$[rsp]
  000da	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  000df	e8 00 00 00 00	 call	 gz_read
  000e4	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 473  :     return ret < 1 ? -1 : buf[0];

  000e8	83 7c 24 20 01	 cmp	 DWORD PTR ret$[rsp], 1
  000ed	7d 0a		 jge	 SHORT $LN7@gzgetc
  000ef	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR tv129[rsp], -1
  000f7	eb 12		 jmp	 SHORT $LN8@gzgetc
$LN7@gzgetc:
  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	48 6b c0 00	 imul	 rax, rax, 0
  00102	0f b6 44 04 34	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00107	89 44 24 54	 mov	 DWORD PTR tv129[rsp], eax
$LN8@gzgetc:
  0010b	8b 44 24 54	 mov	 eax, DWORD PTR tv129[rsp]
$LN1@gzgetc:

; 474  : }

  0010f	48 8b f8	 mov	 rdi, rax
  00112	48 8b cc	 mov	 rcx, rsp
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gzgetc$rtcFrameData
  0011c	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00121	48 8b c7	 mov	 rax, rdi
  00124	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00128	5f		 pop	 rdi
  00129	c3		 ret	 0
gzgetc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzgetc_
_TEXT	SEGMENT
file$ = 48
gzgetc_	PROC						; COMDAT

; 478  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 08 00 00 00	 mov	 ecx, 8
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 479  :     return gzgetc(file);

  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR file$[rsp]
  0002f	e8 00 00 00 00	 call	 gzgetc

; 480  : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
gzgetc_	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzungetc
_TEXT	SEGMENT
state$ = 32
src$1 = 40
dest$2 = 48
c$ = 80
file$ = 88
gzungetc PROC						; COMDAT

; 486  : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 10 00 00 00	 mov	 ecx, 16
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	8b 4c 24 50	 mov	 ecx, DWORD PTR [rsp+80]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00028	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 487  :     gz_statep state;
; 488  : 
; 489  :     /* get internal structure */
; 490  :     if (file == NULL)

  0002d	48 83 7c 24 58
	00		 cmp	 QWORD PTR file$[rsp], 0
  00033	75 0a		 jne	 SHORT $LN4@gzungetc

; 491  :         return -1;

  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	e9 21 02 00 00	 jmp	 $LN1@gzungetc
$LN4@gzungetc:

; 492  :     state = (gz_statep)file;

  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR file$[rsp]
  00044	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 493  : 
; 494  :     /* check that we're reading and that there's no (serious) error */
; 495  :     if (state->mode != GZ_READ ||

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0004e	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00055	75 16		 jne	 SHORT $LN6@gzungetc
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005c	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00060	74 15		 je	 SHORT $LN5@gzungetc
  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00067	83 78 6c fb	 cmp	 DWORD PTR [rax+108], -5
  0006b	74 0a		 je	 SHORT $LN5@gzungetc
$LN6@gzungetc:

; 496  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 497  :         return -1;

  0006d	b8 ff ff ff ff	 mov	 eax, -1
  00072	e9 e9 01 00 00	 jmp	 $LN1@gzungetc
$LN5@gzungetc:

; 498  : 
; 499  :     /* process a skip request */
; 500  :     if (state->seek) {

  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0007c	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00080	74 2e		 je	 SHORT $LN7@gzungetc

; 501  :         state->seek = 0;

  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00087	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 502  :         if (gz_skip(state, state->skip) == -1)

  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00093	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0009c	e8 00 00 00 00	 call	 gz_skip
  000a1	83 f8 ff	 cmp	 eax, -1
  000a4	75 0a		 jne	 SHORT $LN8@gzungetc

; 503  :             return -1;

  000a6	b8 ff ff ff ff	 mov	 eax, -1
  000ab	e9 b0 01 00 00	 jmp	 $LN1@gzungetc
$LN8@gzungetc:
$LN7@gzungetc:

; 504  :     }
; 505  : 
; 506  :     /* can't push EOF */
; 507  :     if (c < 0)

  000b0	83 7c 24 50 00	 cmp	 DWORD PTR c$[rsp], 0
  000b5	7d 0a		 jge	 SHORT $LN9@gzungetc

; 508  :         return -1;

  000b7	b8 ff ff ff ff	 mov	 eax, -1
  000bc	e9 9f 01 00 00	 jmp	 $LN1@gzungetc
$LN9@gzungetc:

; 509  : 
; 510  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 511  :     if (state->x.have == 0) {

  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000c6	83 38 00	 cmp	 DWORD PTR [rax], 0
  000c9	75 72		 jne	 SHORT $LN10@gzungetc

; 512  :         state->x.have = 1;

  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000d0	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 513  :         state->x.next = state->out + (state->size << 1) - 1;

  000d6	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000db	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000de	d1 e0		 shl	 eax, 1
  000e0	8b c0		 mov	 eax, eax
  000e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000e7	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000eb	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  000f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000f5	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 514  :         state->x.next[0] = (unsigned char)c;

  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	48 6b c0 00	 imul	 rax, rax, 0
  00102	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00107	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0010b	0f b6 54 24 50	 movzx	 edx, BYTE PTR c$[rsp]
  00110	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 515  :         state->x.pos--;

  00113	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00118	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0011c	48 ff c8	 dec	 rax
  0011f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00124	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 516  :         state->past = 0;

  00128	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0012d	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [rax+84], 0

; 517  :         return c;

  00134	8b 44 24 50	 mov	 eax, DWORD PTR c$[rsp]
  00138	e9 23 01 00 00	 jmp	 $LN1@gzungetc
$LN10@gzungetc:

; 518  :     }
; 519  : 
; 520  :     /* if no room, give up (must have already done a gzungetc()) */
; 521  :     if (state->x.have == (state->size << 1)) {

  0013d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00142	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00145	d1 e0		 shl	 eax, 1
  00147	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0014c	39 01		 cmp	 DWORD PTR [rcx], eax
  0014e	75 20		 jne	 SHORT $LN11@gzungetc

; 522  :         gz_error(state, Z_DATA_ERROR, "out of room to push characters");

  00150	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@
  00157	ba fd ff ff ff	 mov	 edx, -3
  0015c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00161	e8 00 00 00 00	 call	 gz_error

; 523  :         return -1;

  00166	b8 ff ff ff ff	 mov	 eax, -1
  0016b	e9 f0 00 00 00	 jmp	 $LN1@gzungetc
$LN11@gzungetc:

; 524  :     }
; 525  : 
; 526  :     /* slide output data if needed and insert byte before existing data */
; 527  :     if (state->x.next == state->out) {

  00170	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00175	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0017a	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0017e	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00182	75 78		 jne	 SHORT $LN12@gzungetc

; 528  :         unsigned char *src = state->out + state->x.have;

  00184	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00189	8b 00		 mov	 eax, DWORD PTR [rax]
  0018b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00190	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  00194	48 89 44 24 28	 mov	 QWORD PTR src$1[rsp], rax

; 529  :         unsigned char *dest = state->out + (state->size << 1);

  00199	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0019e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001a1	d1 e0		 shl	 eax, 1
  001a3	8b c0		 mov	 eax, eax
  001a5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  001aa	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  001ae	48 89 44 24 30	 mov	 QWORD PTR dest$2[rsp], rax
$LN2@gzungetc:

; 530  :         while (src > state->out)

  001b3	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001b8	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  001bc	48 39 44 24 28	 cmp	 QWORD PTR src$1[rsp], rax
  001c1	76 2b		 jbe	 SHORT $LN3@gzungetc

; 531  :             *--dest = *--src;

  001c3	48 8b 44 24 28	 mov	 rax, QWORD PTR src$1[rsp]
  001c8	48 ff c8	 dec	 rax
  001cb	48 89 44 24 28	 mov	 QWORD PTR src$1[rsp], rax
  001d0	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$2[rsp]
  001d5	48 ff c8	 dec	 rax
  001d8	48 89 44 24 30	 mov	 QWORD PTR dest$2[rsp], rax
  001dd	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$2[rsp]
  001e2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$1[rsp]
  001e7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001ea	88 08		 mov	 BYTE PTR [rax], cl
  001ec	eb c5		 jmp	 SHORT $LN2@gzungetc
$LN3@gzungetc:

; 532  :         state->x.next = dest;

  001ee	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  001f3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dest$2[rsp]
  001f8	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN12@gzungetc:

; 533  :     }
; 534  :     state->x.have++;

  001fc	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00201	8b 00		 mov	 eax, DWORD PTR [rax]
  00203	ff c0		 inc	 eax
  00205	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0020a	89 01		 mov	 DWORD PTR [rcx], eax

; 535  :     state->x.next--;

  0020c	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00211	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00215	48 ff c8	 dec	 rax
  00218	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0021d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 536  :     state->x.next[0] = (unsigned char)c;

  00221	b8 01 00 00 00	 mov	 eax, 1
  00226	48 6b c0 00	 imul	 rax, rax, 0
  0022a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0022f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00233	0f b6 54 24 50	 movzx	 edx, BYTE PTR c$[rsp]
  00238	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 537  :     state->x.pos--;

  0023b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00240	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00244	48 ff c8	 dec	 rax
  00247	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0024c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 538  :     state->past = 0;

  00250	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00255	c7 40 54 00 00
	00 00		 mov	 DWORD PTR [rax+84], 0

; 539  :     return c;

  0025c	8b 44 24 50	 mov	 eax, DWORD PTR c$[rsp]
$LN1@gzungetc:

; 540  : }

  00260	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00264	5f		 pop	 rdi
  00265	c3		 ret	 0
gzungetc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzgets
_TEXT	SEGMENT
left$ = 32
n$ = 36
str$ = 40
eol$ = 48
state$ = 56
tv94 = 64
file$ = 96
buf$ = 104
len$ = 112
gzgets	PROC						; COMDAT

; 547  : {

$LN22:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 14 00 00 00	 mov	 ecx, 20
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 548  :     unsigned left, n;
; 549  :     char *str;
; 550  :     unsigned char *eol;
; 551  :     gz_statep state;
; 552  : 
; 553  :     /* check parameters and get internal structure */
; 554  :     if (file == NULL || buf == NULL || len < 1)

  00034	48 83 7c 24 60
	00		 cmp	 QWORD PTR file$[rsp], 0
  0003a	74 0f		 je	 SHORT $LN6@gzgets
  0003c	48 83 7c 24 68
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00042	74 07		 je	 SHORT $LN6@gzgets
  00044	83 7c 24 70 01	 cmp	 DWORD PTR len$[rsp], 1
  00049	7d 07		 jge	 SHORT $LN5@gzgets
$LN6@gzgets:

; 555  :         return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	e9 ed 01 00 00	 jmp	 $LN1@gzgets
$LN5@gzgets:

; 556  :     state = (gz_statep)file;

  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR file$[rsp]
  00057	48 89 44 24 38	 mov	 QWORD PTR state$[rsp], rax

; 557  : 
; 558  :     /* check that we're reading and that there's no (serious) error */
; 559  :     if (state->mode != GZ_READ ||

  0005c	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00061	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  00068	75 16		 jne	 SHORT $LN8@gzgets
  0006a	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0006f	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00073	74 12		 je	 SHORT $LN7@gzgets
  00075	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0007a	83 78 6c fb	 cmp	 DWORD PTR [rax+108], -5
  0007e	74 07		 je	 SHORT $LN7@gzgets
$LN8@gzgets:

; 560  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 561  :         return NULL;

  00080	33 c0		 xor	 eax, eax
  00082	e9 b8 01 00 00	 jmp	 $LN1@gzgets
$LN7@gzgets:

; 562  : 
; 563  :     /* process a skip request */
; 564  :     if (state->seek) {

  00087	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0008c	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00090	74 2b		 je	 SHORT $LN9@gzgets

; 565  :         state->seek = 0;

  00092	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00097	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 566  :         if (gz_skip(state, state->skip) == -1)

  0009e	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000a3	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  000ac	e8 00 00 00 00	 call	 gz_skip
  000b1	83 f8 ff	 cmp	 eax, -1
  000b4	75 07		 jne	 SHORT $LN10@gzgets

; 567  :             return NULL;

  000b6	33 c0		 xor	 eax, eax
  000b8	e9 82 01 00 00	 jmp	 $LN1@gzgets
$LN10@gzgets:
$LN9@gzgets:

; 568  :     }
; 569  : 
; 570  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 571  :        append a terminating zero to the string (we don't check for a zero in
; 572  :        the contents, let the user worry about that) */
; 573  :     str = buf;

  000bd	48 8b 44 24 68	 mov	 rax, QWORD PTR buf$[rsp]
  000c2	48 89 44 24 28	 mov	 QWORD PTR str$[rsp], rax

; 574  :     left = (unsigned)len - 1;

  000c7	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  000cb	ff c8		 dec	 eax
  000cd	89 44 24 20	 mov	 DWORD PTR left$[rsp], eax

; 575  :     if (left) do {

  000d1	83 7c 24 20 00	 cmp	 DWORD PTR left$[rsp], 0
  000d6	0f 84 3c 01 00
	00		 je	 $LN11@gzgets
$LN4@gzgets:

; 576  :         /* assure that something is in the output buffer */
; 577  :         if (state->x.have == 0 && gz_fetch(state) == -1)

  000dc	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000e1	83 38 00	 cmp	 DWORD PTR [rax], 0
  000e4	75 16		 jne	 SHORT $LN12@gzgets
  000e6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  000eb	e8 00 00 00 00	 call	 gz_fetch
  000f0	83 f8 ff	 cmp	 eax, -1
  000f3	75 07		 jne	 SHORT $LN12@gzgets

; 578  :             return NULL;                /* error */

  000f5	33 c0		 xor	 eax, eax
  000f7	e9 43 01 00 00	 jmp	 $LN1@gzgets
$LN12@gzgets:

; 579  :         if (state->x.have == 0) {       /* end of file */

  000fc	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00101	83 38 00	 cmp	 DWORD PTR [rax], 0
  00104	75 11		 jne	 SHORT $LN13@gzgets

; 580  :             state->past = 1;            /* read past end */

  00106	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0010b	c7 40 54 01 00
	00 00		 mov	 DWORD PTR [rax+84], 1

; 581  :             break;                      /* return what we have */

  00112	e9 01 01 00 00	 jmp	 $LN3@gzgets
$LN13@gzgets:

; 582  :         }
; 583  : 
; 584  :         /* look for end-of-line in current output buffer */
; 585  :         n = state->x.have > left ? left : state->x.have;

  00117	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0011c	8b 4c 24 20	 mov	 ecx, DWORD PTR left$[rsp]
  00120	39 08		 cmp	 DWORD PTR [rax], ecx
  00122	76 0a		 jbe	 SHORT $LN18@gzgets
  00124	8b 44 24 20	 mov	 eax, DWORD PTR left$[rsp]
  00128	89 44 24 40	 mov	 DWORD PTR tv94[rsp], eax
  0012c	eb 0e		 jmp	 SHORT $LN19@gzgets
$LN18@gzgets:
  0012e	0f ae e8	 lfence
  00131	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00136	8b 00		 mov	 eax, DWORD PTR [rax]
  00138	89 44 24 40	 mov	 DWORD PTR tv94[rsp], eax
$LN19@gzgets:
  0013c	8b 44 24 40	 mov	 eax, DWORD PTR tv94[rsp]
  00140	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax

; 586  :         eol = (unsigned char *)memchr(state->x.next, '\n', n);

  00144	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00148	44 8b c0	 mov	 r8d, eax
  0014b	ba 0a 00 00 00	 mov	 edx, 10
  00150	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00155	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0015f	48 89 44 24 30	 mov	 QWORD PTR eol$[rsp], rax

; 587  :         if (eol != NULL)

  00164	48 83 7c 24 30
	00		 cmp	 QWORD PTR eol$[rsp], 0
  0016a	74 1a		 je	 SHORT $LN14@gzgets

; 588  :             n = (unsigned)(eol - state->x.next) + 1;

  0016c	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00171	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00175	48 8b 4c 24 30	 mov	 rcx, QWORD PTR eol$[rsp]
  0017a	48 2b c8	 sub	 rcx, rax
  0017d	48 8b c1	 mov	 rax, rcx
  00180	ff c0		 inc	 eax
  00182	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
$LN14@gzgets:

; 589  : 
; 590  :         /* copy through end-of-line, or remainder if not found */
; 591  :         memcpy(buf, state->x.next, n);

  00186	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  0018a	44 8b c0	 mov	 r8d, eax
  0018d	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00192	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00196	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 592  :         state->x.have -= n;

  001a1	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  001a6	8b 4c 24 24	 mov	 ecx, DWORD PTR n$[rsp]
  001aa	8b 00		 mov	 eax, DWORD PTR [rax]
  001ac	2b c1		 sub	 eax, ecx
  001ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  001b3	89 01		 mov	 DWORD PTR [rcx], eax

; 593  :         state->x.next += n;

  001b5	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  001b9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  001be	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  001c2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  001c7	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 594  :         state->x.pos += n;

  001cb	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  001cf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  001d4	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001d8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  001dd	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 595  :         left -= n;

  001e1	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  001e5	8b 4c 24 20	 mov	 ecx, DWORD PTR left$[rsp]
  001e9	2b c8		 sub	 ecx, eax
  001eb	8b c1		 mov	 eax, ecx
  001ed	89 44 24 20	 mov	 DWORD PTR left$[rsp], eax

; 596  :         buf += n;

  001f1	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  001f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  001fa	48 03 c8	 add	 rcx, rax
  001fd	48 8b c1	 mov	 rax, rcx
  00200	48 89 44 24 68	 mov	 QWORD PTR buf$[rsp], rax

; 597  :     } while (left && eol == NULL);

  00205	83 7c 24 20 00	 cmp	 DWORD PTR left$[rsp], 0
  0020a	74 0c		 je	 SHORT $LN15@gzgets
  0020c	48 83 7c 24 30
	00		 cmp	 QWORD PTR eol$[rsp], 0
  00212	0f 84 c4 fe ff
	ff		 je	 $LN4@gzgets
$LN15@gzgets:
$LN3@gzgets:
$LN11@gzgets:

; 598  : 
; 599  :     /* return terminated string, or if nothing, end of file */
; 600  :     if (buf == str)

  00218	48 8b 44 24 28	 mov	 rax, QWORD PTR str$[rsp]
  0021d	48 39 44 24 68	 cmp	 QWORD PTR buf$[rsp], rax
  00222	75 04		 jne	 SHORT $LN16@gzgets

; 601  :         return NULL;

  00224	33 c0		 xor	 eax, eax
  00226	eb 17		 jmp	 SHORT $LN1@gzgets
$LN16@gzgets:

; 602  :     buf[0] = 0;

  00228	b8 01 00 00 00	 mov	 eax, 1
  0022d	48 6b c0 00	 imul	 rax, rax, 0
  00231	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  00236	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 603  :     return str;

  0023a	48 8b 44 24 28	 mov	 rax, QWORD PTR str$[rsp]
$LN1@gzgets:

; 604  : }

  0023f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00243	5f		 pop	 rdi
  00244	c3		 ret	 0
gzgets	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzread.c
;	COMDAT gzdirect
_TEXT	SEGMENT
state$ = 32
file$ = 64
gzdirect PROC						; COMDAT

; 609  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 610  :     gz_statep state;
; 611  : 
; 612  :     /* get internal structure */
; 613  :     if (file == NULL)

  0002a	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00030	75 04		 jne	 SHORT $LN2@gzdirect

; 614  :         return 0;

  00032	33 c0		 xor	 eax, eax
  00034	eb 3f		 jmp	 SHORT $LN1@gzdirect
$LN2@gzdirect:

; 615  :     state = (gz_statep)file;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0003b	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 616  : 
; 617  :     /* if the state is not known, but we can find out, then do so (this is
; 618  :        mainly for right after a gzopen() or gzdopen()) */
; 619  :     if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00045	81 78 18 4f 1c
	00 00		 cmp	 DWORD PTR [rax+24], 7247 ; 00001c4fH
  0004c	75 1f		 jne	 SHORT $LN3@gzdirect
  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00053	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  00057	75 14		 jne	 SHORT $LN3@gzdirect
  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00061	75 0a		 jne	 SHORT $LN3@gzdirect

; 620  :         (void)gz_look(state);

  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00068	e8 00 00 00 00	 call	 gz_look
$LN3@gzdirect:

; 621  : 
; 622  :     /* return 1 if transparent, 0 if processing a gzip stream */
; 623  :     return state->direct;

  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00072	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
$LN1@gzdirect:

; 624  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
gzdirect ENDP
_TEXT	ENDS
END
