; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__876F72AD_uncompr@c DB 01H
PUBLIC	uncompress
PUBLIC	uncompress2
;	COMDAT pdata
pdata	SEGMENT
$pdata$uncompress DD imagerel $LN4
	DD	imagerel $LN4+88
	DD	imagerel $unwind$uncompress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$uncompress2 DD imagerel $LN25
	DD	imagerel $LN25+768
	DD	imagerel $unwind$uncompress2
;	COMDAT xdata
xdata	SEGMENT
$unwind$uncompress2 DD 033301H
	DD	01c011cH
	DD	07015H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
uncompress2$rtcName$0 DB 073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	00H
	ORG $+1
uncompress2$rtcName$1 DB 062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+4
uncompress2$rtcVarDesc DD 0b4H
	DD	01H
	DQ	FLAT:uncompress2$rtcName$1
	DD	030H
	DD	058H
	DQ	FLAT:uncompress2$rtcName$0
	ORG $+96
uncompress2$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:uncompress2$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$uncompress DD 022d01H
	DD	070153219H
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\uncompr.c
;	COMDAT uncompress2
_TEXT	SEGMENT
stream$ = 48
err$ = 148
max$ = 152
len$ = 156
left$ = 160
buf$ = 180
tv72 = 196
tv76 = 200
tv95 = 204
tv94 = 208
tv93 = 212
dest$ = 240
destLen$ = 248
source$ = 256
sourceLen$ = 264
uncompress2 PROC					; COMDAT

; 32   : {

$LN25:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  0001c	48 8b fc	 mov	 rdi, rsp
  0001f	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00024	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00029	f3 ab		 rep stosd
  0002b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0003a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 33   :     z_stream stream;
; 34   :     int err;
; 35   :     const uInt max = (uInt)-1;

  0003f	c7 84 24 98 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR max$[rsp], -1	; ffffffffH

; 36   :     uLong len, left;
; 37   :     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
; 38   : 
; 39   :     len = *sourceLen;

  0004a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR sourceLen$[rsp]
  00052	8b 00		 mov	 eax, DWORD PTR [rax]
  00054	89 84 24 9c 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 40   :     if (*destLen) {

  0005b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR destLen$[rsp]
  00063	83 38 00	 cmp	 DWORD PTR [rax], 0
  00066	74 21		 je	 SHORT $LN5@uncompress

; 41   :         left = *destLen;

  00068	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR destLen$[rsp]
  00070	8b 00		 mov	 eax, DWORD PTR [rax]
  00072	89 84 24 a0 00
	00 00		 mov	 DWORD PTR left$[rsp], eax

; 42   :         *destLen = 0;

  00079	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR destLen$[rsp]
  00081	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 43   :     }

  00087	eb 1b		 jmp	 SHORT $LN6@uncompress
$LN5@uncompress:

; 44   :     else {
; 45   :         left = 1;

  00089	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR left$[rsp], 1

; 46   :         dest = buf;

  00094	48 8d 84 24 b4
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  0009c	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax
$LN6@uncompress:

; 47   :     }
; 48   : 
; 49   :     stream.next_in = (z_const Bytef *)source;

  000a4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR source$[rsp]
  000ac	48 89 44 24 30	 mov	 QWORD PTR stream$[rsp], rax

; 50   :     stream.avail_in = 0;

  000b1	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR stream$[rsp+8], 0

; 51   :     stream.zalloc = (alloc_func)0;

  000b9	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR stream$[rsp+48], 0

; 52   :     stream.zfree = (free_func)0;

  000c2	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR stream$[rsp+56], 0

; 53   :     stream.opaque = (voidpf)0;

  000cb	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR stream$[rsp+64], 0

; 54   : 
; 55   :     err = inflateInit(&stream);

  000d4	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411@
  000e1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  000e6	e8 00 00 00 00	 call	 inflateInit_
  000eb	89 84 24 94 00
	00 00		 mov	 DWORD PTR err$[rsp], eax

; 56   :     if (err != Z_OK) return err;

  000f2	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR err$[rsp], 0
  000fa	74 0c		 je	 SHORT $LN7@uncompress
  000fc	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR err$[rsp]
  00103	e9 da 01 00 00	 jmp	 $LN1@uncompress
$LN7@uncompress:

; 57   : 
; 58   :     stream.next_out = dest;

  00108	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  00110	48 89 44 24 40	 mov	 QWORD PTR stream$[rsp+16], rax

; 59   :     stream.avail_out = 0;

  00115	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR stream$[rsp+24], 0
$LN4@uncompress:

; 60   : 
; 61   :     do {
; 62   :         if (stream.avail_out == 0) {

  0011d	83 7c 24 48 00	 cmp	 DWORD PTR stream$[rsp+24], 0
  00122	75 4f		 jne	 SHORT $LN8@uncompress

; 63   :             stream.avail_out = left > (uLong)max ? max : (uInt)left;

  00124	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  0012b	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR left$[rsp], eax
  00132	76 10		 jbe	 SHORT $LN14@uncompress
  00134	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  0013b	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv72[rsp], eax
  00142	eb 0e		 jmp	 SHORT $LN15@uncompress
$LN14@uncompress:
  00144	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR left$[rsp]
  0014b	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv72[rsp], eax
$LN15@uncompress:
  00152	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv72[rsp]
  00159	89 44 24 48	 mov	 DWORD PTR stream$[rsp+24], eax

; 64   :             left -= stream.avail_out;

  0015d	8b 44 24 48	 mov	 eax, DWORD PTR stream$[rsp+24]
  00161	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR left$[rsp]
  00168	2b c8		 sub	 ecx, eax
  0016a	8b c1		 mov	 eax, ecx
  0016c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR left$[rsp], eax
$LN8@uncompress:

; 65   :         }
; 66   :         if (stream.avail_in == 0) {

  00173	83 7c 24 38 00	 cmp	 DWORD PTR stream$[rsp+8], 0
  00178	75 4f		 jne	 SHORT $LN9@uncompress

; 67   :             stream.avail_in = len > (uLong)max ? max : (uInt)len;

  0017a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00181	39 84 24 9c 00
	00 00		 cmp	 DWORD PTR len$[rsp], eax
  00188	76 10		 jbe	 SHORT $LN16@uncompress
  0018a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00191	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv76[rsp], eax
  00198	eb 0e		 jmp	 SHORT $LN17@uncompress
$LN16@uncompress:
  0019a	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001a1	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv76[rsp], eax
$LN17@uncompress:
  001a8	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv76[rsp]
  001af	89 44 24 38	 mov	 DWORD PTR stream$[rsp+8], eax

; 68   :             len -= stream.avail_in;

  001b3	8b 44 24 38	 mov	 eax, DWORD PTR stream$[rsp+8]
  001b7	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  001be	2b c8		 sub	 ecx, eax
  001c0	8b c1		 mov	 eax, ecx
  001c2	89 84 24 9c 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
$LN9@uncompress:

; 69   :         }
; 70   :         err = inflate(&stream, Z_NO_FLUSH);

  001c9	33 d2		 xor	 edx, edx
  001cb	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  001d0	e8 00 00 00 00	 call	 inflate
  001d5	89 84 24 94 00
	00 00		 mov	 DWORD PTR err$[rsp], eax

; 71   :     } while (err == Z_OK);

  001dc	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR err$[rsp], 0
  001e4	0f 84 33 ff ff
	ff		 je	 $LN4@uncompress

; 72   : 
; 73   :     *sourceLen -= len + stream.avail_in;

  001ea	8b 44 24 38	 mov	 eax, DWORD PTR stream$[rsp+8]
  001ee	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  001f5	03 c8		 add	 ecx, eax
  001f7	8b c1		 mov	 eax, ecx
  001f9	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR sourceLen$[rsp]
  00201	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00203	2b c8		 sub	 ecx, eax
  00205	8b c1		 mov	 eax, ecx
  00207	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR sourceLen$[rsp]
  0020f	89 01		 mov	 DWORD PTR [rcx], eax

; 74   :     if (dest != buf)

  00211	48 8d 84 24 b4
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00219	48 39 84 24 f0
	00 00 00	 cmp	 QWORD PTR dest$[rsp], rax
  00221	74 10		 je	 SHORT $LN10@uncompress

; 75   :         *destLen = stream.total_out;

  00223	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR destLen$[rsp]
  0022b	8b 4c 24 4c	 mov	 ecx, DWORD PTR stream$[rsp+28]
  0022f	89 08		 mov	 DWORD PTR [rax], ecx
  00231	eb 1c		 jmp	 SHORT $LN11@uncompress
$LN10@uncompress:

; 76   :     else if (stream.total_out && err == Z_BUF_ERROR)

  00233	83 7c 24 4c 00	 cmp	 DWORD PTR stream$[rsp+28], 0
  00238	74 15		 je	 SHORT $LN12@uncompress
  0023a	83 bc 24 94 00
	00 00 fb	 cmp	 DWORD PTR err$[rsp], -5
  00242	75 0b		 jne	 SHORT $LN12@uncompress

; 77   :         left = 1;

  00244	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR left$[rsp], 1
$LN12@uncompress:
$LN11@uncompress:

; 78   : 
; 79   :     inflateEnd(&stream);

  0024f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stream$[rsp]
  00254	e8 00 00 00 00	 call	 inflateEnd

; 80   :     return err == Z_STREAM_END ? Z_OK :

  00259	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR err$[rsp], 1
  00261	75 0d		 jne	 SHORT $LN22@uncompress
  00263	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv95[rsp], 0
  0026e	eb 6b		 jmp	 SHORT $LN23@uncompress
$LN22@uncompress:
  00270	83 bc 24 94 00
	00 00 02	 cmp	 DWORD PTR err$[rsp], 2
  00278	75 0d		 jne	 SHORT $LN20@uncompress
  0027a	c7 84 24 d0 00
	00 00 fd ff ff
	ff		 mov	 DWORD PTR tv94[rsp], -3
  00285	eb 46		 jmp	 SHORT $LN21@uncompress
$LN20@uncompress:
  00287	83 bc 24 94 00
	00 00 fb	 cmp	 DWORD PTR err$[rsp], -5
  0028f	75 20		 jne	 SHORT $LN18@uncompress
  00291	8b 44 24 48	 mov	 eax, DWORD PTR stream$[rsp+24]
  00295	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR left$[rsp]
  0029c	03 c8		 add	 ecx, eax
  0029e	8b c1		 mov	 eax, ecx
  002a0	85 c0		 test	 eax, eax
  002a2	74 0d		 je	 SHORT $LN18@uncompress
  002a4	c7 84 24 d4 00
	00 00 fd ff ff
	ff		 mov	 DWORD PTR tv93[rsp], -3
  002af	eb 0e		 jmp	 SHORT $LN19@uncompress
$LN18@uncompress:
  002b1	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR err$[rsp]
  002b8	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv93[rsp], eax
$LN19@uncompress:
  002bf	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv93[rsp]
  002c6	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv94[rsp], eax
$LN21@uncompress:
  002cd	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv94[rsp]
  002d4	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv95[rsp], eax
$LN23@uncompress:
  002db	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR tv95[rsp]
$LN1@uncompress:

; 81   :            err == Z_NEED_DICT ? Z_DATA_ERROR  :
; 82   :            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
; 83   :            err;
; 84   : }

  002e2	48 8b f8	 mov	 rdi, rax
  002e5	48 8b cc	 mov	 rcx, rsp
  002e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:uncompress2$rtcFrameData
  002ef	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  002f4	48 8b c7	 mov	 rax, rdi
  002f7	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  002fe	5f		 pop	 rdi
  002ff	c3		 ret	 0
uncompress2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\uncompr.c
;	COMDAT uncompress
_TEXT	SEGMENT
dest$ = 48
destLen$ = 56
source$ = 64
sourceLen$ = 72
uncompress PROC						; COMDAT

; 91   : {

$LN4:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 08 00 00 00	 mov	 ecx, 8
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR [rsp+48]
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00034	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 92   :     return uncompress2(dest, destLen, source, &sourceLen);

  00039	4c 8d 4c 24 48	 lea	 r9, QWORD PTR sourceLen$[rsp]
  0003e	4c 8b 44 24 40	 mov	 r8, QWORD PTR source$[rsp]
  00043	48 8b 54 24 38	 mov	 rdx, QWORD PTR destLen$[rsp]
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dest$[rsp]
  0004d	e8 00 00 00 00	 call	 uncompress2

; 93   : }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
uncompress ENDP
_TEXT	ENDS
END
