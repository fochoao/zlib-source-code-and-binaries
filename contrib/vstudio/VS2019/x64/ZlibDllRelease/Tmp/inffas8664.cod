; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	inffas8664fnc:PROC
__DB664BEB_corecrt_stdio_config@h DB 01H
__E28BBA23_corecrt_wstdio@h DB 01H
__4A1C29A8_stdio@h DB 01H
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__77E8E7A8_inffas8664@c DB 01H
PUBLIC	inflate_fast
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN17
	DD	imagerel $LN17+1027
	DD	imagerel $unwind$inflate_fast
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 032801H
	DD	01c0111H
	DD	0700aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
inflate_fast$rtcName$0 DB 061H
	DB	072H
	DB	00H
	ORG $+13
inflate_fast$rtcVarDesc DD 040H
	DD	078H
	DQ	FLAT:inflate_fast$rtcName$0
	ORG $+48
inflate_fast$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:inflate_fast$rtcVarDesc
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\contrib\masmx64\inffas8664.c
;	COMDAT inflate_fast
_TEXT	SEGMENT
state$ = 32
ar$ = 64
tv246 = 196
tv251 = 200
tv274 = 204
tv192 = 208
tv200 = 216
strm$ = 240
start$ = 248
inflate_fast PROC					; COMDAT

; 109  : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00011	48 8b fc	 mov	 rdi, rsp
  00014	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00019	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001e	f3 ab		 rep stosd
  00020	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR [rsp+240]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 110  :     struct inflate_state FAR *state;
; 111  :     type_ar ar;
; 112  :     void inffas8664fnc(struct inffast_ar * par);
; 113  : 
; 114  : 
; 115  : 
; 116  : #if (defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )) || (defined(_MSC_VER) && defined(_M_AMD64))
; 117  : #define PAD_AVAIL_IN 6
; 118  : #define PAD_AVAIL_OUT 258
; 119  : #else
; 120  : #define PAD_AVAIL_IN 5
; 121  : #define PAD_AVAIL_OUT 257
; 122  : #endif
; 123  : 
; 124  :     /* copy state to local variables */
; 125  :     state = (struct inflate_state FAR *)strm->state;

  00034	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0003c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00040	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 126  : 
; 127  :     ar.in = strm->next_in;

  00045	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	48 89 44 24 50	 mov	 QWORD PTR ar$[rsp+16], rax

; 128  :     ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);

  00055	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0005d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00060	83 e8 06	 sub	 eax, 6
  00063	8b c0		 mov	 eax, eax
  00065	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ar$[rsp+16]
  0006a	48 03 c8	 add	 rcx, rax
  0006d	48 8b c1	 mov	 rax, rcx
  00070	48 89 44 24 58	 mov	 QWORD PTR ar$[rsp+24], rax

; 129  :     ar.out = strm->next_out;

  00075	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0007d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00081	48 89 44 24 60	 mov	 QWORD PTR ar$[rsp+32], rax

; 130  :     ar.beg = ar.out - (start - strm->avail_out);

  00086	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0008e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00091	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR start$[rsp]
  00098	2b c8		 sub	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	8b c0		 mov	 eax, eax
  0009e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ar$[rsp+32]
  000a3	48 2b c8	 sub	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 89 44 24 68	 mov	 QWORD PTR ar$[rsp+40], rax

; 131  :     ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);

  000ae	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000b6	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000b9	2d 02 01 00 00	 sub	 eax, 258		; 00000102H
  000be	8b c0		 mov	 eax, eax
  000c0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ar$[rsp+32]
  000c5	48 03 c8	 add	 rcx, rax
  000c8	48 8b c1	 mov	 rax, rcx
  000cb	48 89 44 24 70	 mov	 QWORD PTR ar$[rsp+48], rax

; 132  :     ar.wsize = state->wsize;

  000d0	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000d5	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  000d8	89 84 24 9c 00
	00 00		 mov	 DWORD PTR ar$[rsp+92], eax

; 133  :     ar.write = state->wnext;

  000df	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000e4	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  000e7	89 84 24 a0 00
	00 00		 mov	 DWORD PTR ar$[rsp+96], eax

; 134  :     ar.window = state->window;

  000ee	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000f3	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  000f7	48 89 44 24 78	 mov	 QWORD PTR ar$[rsp+56], rax

; 135  :     ar.hold = state->hold;

  000fc	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00101	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00104	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ar$[rsp+80], rax

; 136  :     ar.bits = state->bits;

  0010c	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00111	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00114	89 84 24 98 00
	00 00		 mov	 DWORD PTR ar$[rsp+88], eax

; 137  :     ar.lcode = state->lencode;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00120	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00124	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ar$[rsp+64], rax

; 138  :     ar.dcode = state->distcode;

  0012c	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00131	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00135	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ar$[rsp+72], rax

; 139  :     ar.lmask = (1U << state->lenbits) - 1;

  0013d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00142	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00145	b9 01 00 00 00	 mov	 ecx, 1
  0014a	89 8c 24 c4 00
	00 00		 mov	 DWORD PTR tv246[rsp], ecx
  00151	0f b6 c8	 movzx	 ecx, al
  00154	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv246[rsp]
  0015b	d3 e0		 shl	 eax, cl
  0015d	ff c8		 dec	 eax
  0015f	89 84 24 a4 00
	00 00		 mov	 DWORD PTR ar$[rsp+100], eax

; 140  :     ar.dmask = (1U << state->distbits) - 1;

  00166	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0016b	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0016e	b9 01 00 00 00	 mov	 ecx, 1
  00173	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR tv251[rsp], ecx
  0017a	0f b6 c8	 movzx	 ecx, al
  0017d	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv251[rsp]
  00184	d3 e0		 shl	 eax, cl
  00186	ff c8		 dec	 eax
  00188	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ar$[rsp+104], eax
$LN2@inflate_fa:

; 141  : 
; 142  :     /* decode literals and length/distances until end-of-block or not enough
; 143  :        input data or output space */
; 144  : 
; 145  :     /* align in on 1/2 hold size boundary */
; 146  :     while (((size_t)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {

  0018f	48 8b 44 24 50	 mov	 rax, QWORD PTR ar$[rsp+16]
  00194	48 83 e0 03	 and	 rax, 3
  00198	48 85 c0	 test	 rax, rax
  0019b	74 49		 je	 SHORT $LN3@inflate_fa

; 147  :         ar.hold += (unsigned long)*ar.in++ << ar.bits;

  0019d	48 8b 44 24 50	 mov	 rax, QWORD PTR ar$[rsp+16]
  001a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a5	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR ar$[rsp+88]
  001ac	d3 e0		 shl	 eax, cl
  001ae	8b c0		 mov	 eax, eax
  001b0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ar$[rsp+80]
  001b8	48 03 c8	 add	 rcx, rax
  001bb	48 8b c1	 mov	 rax, rcx
  001be	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ar$[rsp+80], rax
  001c6	48 8b 44 24 50	 mov	 rax, QWORD PTR ar$[rsp+16]
  001cb	48 ff c0	 inc	 rax
  001ce	48 89 44 24 50	 mov	 QWORD PTR ar$[rsp+16], rax

; 148  :         ar.bits += 8;

  001d3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR ar$[rsp+88]
  001da	83 c0 08	 add	 eax, 8
  001dd	89 84 24 98 00
	00 00		 mov	 DWORD PTR ar$[rsp+88], eax

; 149  :     }

  001e4	eb a9		 jmp	 SHORT $LN2@inflate_fa
$LN3@inflate_fa:

; 150  : 
; 151  :     inffas8664fnc(&ar);

  001e6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ar$[rsp]
  001eb	e8 00 00 00 00	 call	 inffas8664fnc

; 152  : 
; 153  :     if (ar.status > 1) {

  001f0	83 bc 24 b4 00
	00 00 01	 cmp	 DWORD PTR ar$[rsp+116], 1
  001f8	76 5f		 jbe	 SHORT $LN4@inflate_fa

; 154  :         if (ar.status == 2)

  001fa	83 bc 24 b4 00
	00 00 02	 cmp	 DWORD PTR ar$[rsp+116], 2
  00202	75 15		 jne	 SHORT $LN6@inflate_fa

; 155  :             strm->msg = "invalid literal/length code";

  00204	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0020c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  00213	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  00217	eb 32		 jmp	 SHORT $LN7@inflate_fa
$LN6@inflate_fa:

; 156  :         else if (ar.status == 3)

  00219	83 bc 24 b4 00
	00 00 03	 cmp	 DWORD PTR ar$[rsp+116], 3
  00221	75 15		 jne	 SHORT $LN8@inflate_fa

; 157  :             strm->msg = "invalid distance code";

  00223	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  00232	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  00236	eb 13		 jmp	 SHORT $LN9@inflate_fa
$LN8@inflate_fa:

; 158  :         else
; 159  :             strm->msg = "invalid distance too far back";

  00238	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
  00247	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
$LN9@inflate_fa:
$LN7@inflate_fa:

; 160  :         state->mode = BAD;

  0024b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00250	c7 40 08 51 3f
	00 00		 mov	 DWORD PTR [rax+8], 16209 ; 00003f51H

; 161  :     }

  00257	eb 16		 jmp	 SHORT $LN5@inflate_fa
$LN4@inflate_fa:

; 162  :     else if ( ar.status == 1 ) {

  00259	83 bc 24 b4 00
	00 00 01	 cmp	 DWORD PTR ar$[rsp+116], 1
  00261	75 0c		 jne	 SHORT $LN10@inflate_fa

; 163  :         state->mode = TYPE;

  00263	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00268	c7 40 08 3f 3f
	00 00		 mov	 DWORD PTR [rax+8], 16191 ; 00003f3fH
$LN10@inflate_fa:
$LN5@inflate_fa:

; 164  :     }
; 165  : 
; 166  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 167  :     ar.len = ar.bits >> 3;

  0026f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR ar$[rsp+88]
  00276	c1 e8 03	 shr	 eax, 3
  00279	89 84 24 ac 00
	00 00		 mov	 DWORD PTR ar$[rsp+108], eax

; 168  :     ar.in -= ar.len;

  00280	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR ar$[rsp+108]
  00287	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ar$[rsp+16]
  0028c	48 2b c8	 sub	 rcx, rax
  0028f	48 8b c1	 mov	 rax, rcx
  00292	48 89 44 24 50	 mov	 QWORD PTR ar$[rsp+16], rax

; 169  :     ar.bits -= ar.len << 3;

  00297	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR ar$[rsp+108]
  0029e	c1 e0 03	 shl	 eax, 3
  002a1	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR ar$[rsp+88]
  002a8	2b c8		 sub	 ecx, eax
  002aa	8b c1		 mov	 eax, ecx
  002ac	89 84 24 98 00
	00 00		 mov	 DWORD PTR ar$[rsp+88], eax

; 170  :     ar.hold &= (1U << ar.bits) - 1;

  002b3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR ar$[rsp+88]
  002ba	b9 01 00 00 00	 mov	 ecx, 1
  002bf	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv274[rsp], ecx
  002c6	0f b6 c8	 movzx	 ecx, al
  002c9	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR tv274[rsp]
  002d0	d3 e0		 shl	 eax, cl
  002d2	ff c8		 dec	 eax
  002d4	8b c0		 mov	 eax, eax
  002d6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ar$[rsp+80]
  002de	48 23 c8	 and	 rcx, rax
  002e1	48 8b c1	 mov	 rax, rcx
  002e4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ar$[rsp+80], rax

; 171  : 
; 172  :     /* update state and return */
; 173  :     strm->next_in = ar.in;

  002ec	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  002f4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ar$[rsp+16]
  002f9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 174  :     strm->next_out = ar.out;

  002fc	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00304	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ar$[rsp+32]
  00309	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 175  :     strm->avail_in = (unsigned)(ar.in < ar.last ?

  0030d	48 8b 44 24 58	 mov	 rax, QWORD PTR ar$[rsp+24]
  00312	48 39 44 24 50	 cmp	 QWORD PTR ar$[rsp+16], rax
  00317	73 1e		 jae	 SHORT $LN12@inflate_fa
  00319	48 8b 44 24 50	 mov	 rax, QWORD PTR ar$[rsp+16]
  0031e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ar$[rsp+24]
  00323	48 2b c8	 sub	 rcx, rax
  00326	48 8b c1	 mov	 rax, rcx
  00329	48 83 c0 06	 add	 rax, 6
  0032d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv192[rsp], rax
  00335	eb 23		 jmp	 SHORT $LN13@inflate_fa
$LN12@inflate_fa:
  00337	48 8b 44 24 58	 mov	 rax, QWORD PTR ar$[rsp+24]
  0033c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ar$[rsp+16]
  00341	48 2b c8	 sub	 rcx, rax
  00344	48 8b c1	 mov	 rax, rcx
  00347	b9 06 00 00 00	 mov	 ecx, 6
  0034c	48 2b c8	 sub	 rcx, rax
  0034f	48 8b c1	 mov	 rax, rcx
  00352	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv192[rsp], rax
$LN13@inflate_fa:
  0035a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00362	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv192[rsp]
  00369	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 176  :                                 PAD_AVAIL_IN + (ar.last - ar.in) :
; 177  :                                 PAD_AVAIL_IN - (ar.in - ar.last));
; 178  :     strm->avail_out = (unsigned)(ar.out < ar.end ?

  0036c	48 8b 44 24 70	 mov	 rax, QWORD PTR ar$[rsp+48]
  00371	48 39 44 24 60	 cmp	 QWORD PTR ar$[rsp+32], rax
  00376	73 20		 jae	 SHORT $LN14@inflate_fa
  00378	48 8b 44 24 60	 mov	 rax, QWORD PTR ar$[rsp+32]
  0037d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ar$[rsp+48]
  00382	48 2b c8	 sub	 rcx, rax
  00385	48 8b c1	 mov	 rax, rcx
  00388	48 05 02 01 00
	00		 add	 rax, 258		; 00000102H
  0038e	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv200[rsp], rax
  00396	eb 23		 jmp	 SHORT $LN15@inflate_fa
$LN14@inflate_fa:
  00398	48 8b 44 24 70	 mov	 rax, QWORD PTR ar$[rsp+48]
  0039d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ar$[rsp+32]
  003a2	48 2b c8	 sub	 rcx, rax
  003a5	48 8b c1	 mov	 rax, rcx
  003a8	b9 02 01 00 00	 mov	 ecx, 258		; 00000102H
  003ad	48 2b c8	 sub	 rcx, rax
  003b0	48 8b c1	 mov	 rax, rcx
  003b3	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv200[rsp], rax
$LN15@inflate_fa:
  003bb	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  003c3	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv200[rsp]
  003ca	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 179  :                                  PAD_AVAIL_OUT + (ar.end - ar.out) :
; 180  :                                  PAD_AVAIL_OUT - (ar.out - ar.end));
; 181  :     state->hold = (unsigned long)ar.hold;

  003cd	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  003d2	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ar$[rsp+80]
  003d9	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 182  :     state->bits = ar.bits;

  003dc	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  003e1	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR ar$[rsp+88]
  003e8	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 183  :     return;
; 184  : }

  003eb	48 8b cc	 mov	 rcx, rsp
  003ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:inflate_fast$rtcFrameData
  003f5	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  003fa	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  00401	5f		 pop	 rdi
  00402	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END
