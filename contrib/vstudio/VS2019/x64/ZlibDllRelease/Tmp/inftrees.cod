; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+10
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	04dH
	DW	0caH
	ORG $+2
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__DA0D6CC2_inftrees@c DB 01H
PUBLIC	inflate_table
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN69
	DD	imagerel $LN69+2234
	DD	imagerel $unwind$inflate_table
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 033101H
	DD	028011bH
	DD	07014H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
inflate_table$rtcName$0 DB 068H
	DB	065H
	DB	072H
	DB	065H
	DB	00H
	ORG $+3
inflate_table$rtcName$1 DB 063H
	DB	06fH
	DB	075H
	DB	06eH
	DB	074H
	DB	00H
	ORG $+2
inflate_table$rtcName$2 DB 06fH
	DB	066H
	DB	066H
	DB	073H
	DB	00H
	ORG $+3
inflate_table$rtcFrameData DD 03H
	DD	00H
	DQ	FLAT:inflate_table$rtcVarDesc
	ORG $+8
inflate_table$rtcVarDesc DD 0e8H
	DD	020H
	DQ	FLAT:inflate_table$rtcName$2
	DD	0a8H
	DD	020H
	DQ	FLAT:inflate_table$rtcName$1
	DD	064H
	DD	04H
	DQ	FLAT:inflate_table$rtcName$0
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\inftrees.c
;	COMDAT inflate_table
_TEXT	SEGMENT
len$ = 32
sym$ = 36
min$ = 40
max$ = 44
root$ = 48
curr$ = 52
drop$ = 56
left$ = 60
used$ = 64
huff$ = 68
incr$ = 72
fill$ = 76
low$ = 80
mask$ = 84
here$ = 100
next$ = 120
base$ = 128
extra$ = 136
match$ = 144
count$ = 168
offs$ = 232
tv202 = 276
tv450 = 280
tv471 = 284
tv474 = 288
tv486 = 292
tv301 = 296
tv509 = 300
tv519 = 304
type$ = 336
lens$ = 344
codes$ = 352
table$ = 360
bits$ = 368
work$ = 376
inflate_table PROC					; COMDAT

; 39   : {

$LN69:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	57		 push	 rdi
  00014	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001b	48 8b fc	 mov	 rdi, rsp
  0001e	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR [rsp+336]
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00038	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     unsigned match;             /* use base and extra for symbol >= match */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  0003d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  00045	eb 0a		 jmp	 SHORT $LN4@inflate_ta
$LN2@inflate_ta:
  00047	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0004b	ff c0		 inc	 eax
  0004d	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN4@inflate_ta:
  00051	83 7c 24 20 0f	 cmp	 DWORD PTR len$[rsp], 15
  00056	77 10		 ja	 SHORT $LN3@inflate_ta

; 108  :         count[len] = 0;

  00058	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0005c	33 c9		 xor	 ecx, ecx
  0005e	66 89 8c 44 a8
	00 00 00	 mov	 WORD PTR count$[rsp+rax*2], cx
  00066	eb df		 jmp	 SHORT $LN2@inflate_ta
$LN3@inflate_ta:

; 109  :     for (sym = 0; sym < codes; sym++)

  00068	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR sym$[rsp], 0
  00070	eb 0a		 jmp	 SHORT $LN7@inflate_ta
$LN5@inflate_ta:
  00072	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  00076	ff c0		 inc	 eax
  00078	89 44 24 24	 mov	 DWORD PTR sym$[rsp], eax
$LN7@inflate_ta:
  0007c	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR codes$[rsp]
  00083	39 44 24 24	 cmp	 DWORD PTR sym$[rsp], eax
  00087	73 35		 jae	 SHORT $LN6@inflate_ta

; 110  :         count[lens[sym]]++;

  00089	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  0008d	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR lens$[rsp]
  00095	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00099	0f b7 84 44 a8
	00 00 00	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  000a1	66 ff c0	 inc	 ax
  000a4	8b 4c 24 24	 mov	 ecx, DWORD PTR sym$[rsp]
  000a8	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR lens$[rsp]
  000b0	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  000b4	66 89 84 4c a8
	00 00 00	 mov	 WORD PTR count$[rsp+rcx*2], ax
  000bc	eb b4		 jmp	 SHORT $LN5@inflate_ta
$LN6@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  000be	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR bits$[rsp]
  000c6	8b 00		 mov	 eax, DWORD PTR [rax]
  000c8	89 44 24 30	 mov	 DWORD PTR root$[rsp], eax

; 114  :     for (max = MAXBITS; max >= 1; max--)

  000cc	c7 44 24 2c 0f
	00 00 00	 mov	 DWORD PTR max$[rsp], 15
  000d4	eb 0a		 jmp	 SHORT $LN10@inflate_ta
$LN8@inflate_ta:
  000d6	8b 44 24 2c	 mov	 eax, DWORD PTR max$[rsp]
  000da	ff c8		 dec	 eax
  000dc	89 44 24 2c	 mov	 DWORD PTR max$[rsp], eax
$LN10@inflate_ta:
  000e0	83 7c 24 2c 01	 cmp	 DWORD PTR max$[rsp], 1
  000e5	72 14		 jb	 SHORT $LN9@inflate_ta

; 115  :         if (count[max] != 0) break;

  000e7	8b 44 24 2c	 mov	 eax, DWORD PTR max$[rsp]
  000eb	0f b7 84 44 a8
	00 00 00	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  000f3	85 c0		 test	 eax, eax
  000f5	74 02		 je	 SHORT $LN35@inflate_ta
  000f7	eb 02		 jmp	 SHORT $LN9@inflate_ta
$LN35@inflate_ta:
  000f9	eb db		 jmp	 SHORT $LN8@inflate_ta
$LN9@inflate_ta:

; 116  :     if (root > max) root = max;

  000fb	8b 44 24 2c	 mov	 eax, DWORD PTR max$[rsp]
  000ff	39 44 24 30	 cmp	 DWORD PTR root$[rsp], eax
  00103	76 08		 jbe	 SHORT $LN36@inflate_ta
  00105	8b 44 24 2c	 mov	 eax, DWORD PTR max$[rsp]
  00109	89 44 24 30	 mov	 DWORD PTR root$[rsp], eax
$LN36@inflate_ta:

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  0010d	83 7c 24 2c 00	 cmp	 DWORD PTR max$[rsp], 0
  00112	75 7c		 jne	 SHORT $LN37@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */

  00114	c6 44 24 64 40	 mov	 BYTE PTR here$[rsp], 64	; 00000040H

; 119  :         here.bits = (unsigned char)1;

  00119	c6 44 24 65 01	 mov	 BYTE PTR here$[rsp+1], 1

; 120  :         here.val = (unsigned short)0;

  0011e	33 c0		 xor	 eax, eax
  00120	66 89 44 24 66	 mov	 WORD PTR here$[rsp+2], ax

; 121  :         *(*table)++ = here;             /* make a table to force an error */

  00125	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR table$[rsp]
  0012d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00130	8b 4c 24 64	 mov	 ecx, DWORD PTR here$[rsp]
  00134	89 08		 mov	 DWORD PTR [rax], ecx
  00136	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR table$[rsp]
  0013e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00141	48 83 c0 04	 add	 rax, 4
  00145	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0014d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 122  :         *(*table)++ = here;

  00150	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00158	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0015b	8b 4c 24 64	 mov	 ecx, DWORD PTR here$[rsp]
  0015f	89 08		 mov	 DWORD PTR [rax], ecx
  00161	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00169	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0016c	48 83 c0 04	 add	 rax, 4
  00170	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00178	48 89 01	 mov	 QWORD PTR [rcx], rax

; 123  :         *bits = 1;

  0017b	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR bits$[rsp]
  00183	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  00189	33 c0		 xor	 eax, eax
  0018b	e9 0c 07 00 00	 jmp	 $LN1@inflate_ta
$LN37@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00190	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR min$[rsp], 1
  00198	eb 0a		 jmp	 SHORT $LN13@inflate_ta
$LN11@inflate_ta:
  0019a	8b 44 24 28	 mov	 eax, DWORD PTR min$[rsp]
  0019e	ff c0		 inc	 eax
  001a0	89 44 24 28	 mov	 DWORD PTR min$[rsp], eax
$LN13@inflate_ta:
  001a4	8b 44 24 2c	 mov	 eax, DWORD PTR max$[rsp]
  001a8	39 44 24 28	 cmp	 DWORD PTR min$[rsp], eax
  001ac	73 14		 jae	 SHORT $LN12@inflate_ta

; 127  :         if (count[min] != 0) break;

  001ae	8b 44 24 28	 mov	 eax, DWORD PTR min$[rsp]
  001b2	0f b7 84 44 a8
	00 00 00	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  001ba	85 c0		 test	 eax, eax
  001bc	74 02		 je	 SHORT $LN38@inflate_ta
  001be	eb 02		 jmp	 SHORT $LN12@inflate_ta
$LN38@inflate_ta:
  001c0	eb d8		 jmp	 SHORT $LN11@inflate_ta
$LN12@inflate_ta:

; 128  :     if (root < min) root = min;

  001c2	8b 44 24 28	 mov	 eax, DWORD PTR min$[rsp]
  001c6	39 44 24 30	 cmp	 DWORD PTR root$[rsp], eax
  001ca	73 08		 jae	 SHORT $LN39@inflate_ta
  001cc	8b 44 24 28	 mov	 eax, DWORD PTR min$[rsp]
  001d0	89 44 24 30	 mov	 DWORD PTR root$[rsp], eax
$LN39@inflate_ta:

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  001d4	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR left$[rsp], 1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  001dc	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR len$[rsp], 1
  001e4	eb 0a		 jmp	 SHORT $LN16@inflate_ta
$LN14@inflate_ta:
  001e6	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  001ea	ff c0		 inc	 eax
  001ec	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN16@inflate_ta:
  001f0	83 7c 24 20 0f	 cmp	 DWORD PTR len$[rsp], 15
  001f5	77 35		 ja	 SHORT $LN15@inflate_ta

; 133  :         left <<= 1;

  001f7	8b 44 24 3c	 mov	 eax, DWORD PTR left$[rsp]
  001fb	d1 e0		 shl	 eax, 1
  001fd	89 44 24 3c	 mov	 DWORD PTR left$[rsp], eax

; 134  :         left -= count[len];

  00201	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00205	0f b7 84 44 a8
	00 00 00	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  0020d	8b 4c 24 3c	 mov	 ecx, DWORD PTR left$[rsp]
  00211	2b c8		 sub	 ecx, eax
  00213	8b c1		 mov	 eax, ecx
  00215	89 44 24 3c	 mov	 DWORD PTR left$[rsp], eax

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  00219	83 7c 24 3c 00	 cmp	 DWORD PTR left$[rsp], 0
  0021e	7d 0a		 jge	 SHORT $LN40@inflate_ta
  00220	b8 ff ff ff ff	 mov	 eax, -1
  00225	e9 72 06 00 00	 jmp	 $LN1@inflate_ta
$LN40@inflate_ta:

; 136  :     }

  0022a	eb ba		 jmp	 SHORT $LN14@inflate_ta
$LN15@inflate_ta:

; 137  :     if (left > 0 && (type == CODES || max != 1))

  0022c	83 7c 24 3c 00	 cmp	 DWORD PTR left$[rsp], 0
  00231	7e 1b		 jle	 SHORT $LN41@inflate_ta
  00233	83 bc 24 50 01
	00 00 00	 cmp	 DWORD PTR type$[rsp], 0
  0023b	74 07		 je	 SHORT $LN42@inflate_ta
  0023d	83 7c 24 2c 01	 cmp	 DWORD PTR max$[rsp], 1
  00242	74 0a		 je	 SHORT $LN41@inflate_ta
$LN42@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  00244	b8 ff ff ff ff	 mov	 eax, -1
  00249	e9 4e 06 00 00	 jmp	 $LN1@inflate_ta
$LN41@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  0024e	b8 02 00 00 00	 mov	 eax, 2
  00253	48 6b c0 01	 imul	 rax, rax, 1
  00257	33 c9		 xor	 ecx, ecx
  00259	66 89 8c 04 e8
	00 00 00	 mov	 WORD PTR offs$[rsp+rax], cx

; 142  :     for (len = 1; len < MAXBITS; len++)

  00261	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR len$[rsp], 1
  00269	eb 0a		 jmp	 SHORT $LN19@inflate_ta
$LN17@inflate_ta:
  0026b	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0026f	ff c0		 inc	 eax
  00271	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN19@inflate_ta:
  00275	83 7c 24 20 0f	 cmp	 DWORD PTR len$[rsp], 15
  0027a	73 2c		 jae	 SHORT $LN18@inflate_ta

; 143  :         offs[len + 1] = offs[len] + count[len];

  0027c	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00280	0f b7 84 44 e8
	00 00 00	 movzx	 eax, WORD PTR offs$[rsp+rax*2]
  00288	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0028c	0f b7 8c 4c a8
	00 00 00	 movzx	 ecx, WORD PTR count$[rsp+rcx*2]
  00294	03 c1		 add	 eax, ecx
  00296	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0029a	ff c1		 inc	 ecx
  0029c	8b c9		 mov	 ecx, ecx
  0029e	66 89 84 4c e8
	00 00 00	 mov	 WORD PTR offs$[rsp+rcx*2], ax
  002a6	eb c3		 jmp	 SHORT $LN17@inflate_ta
$LN18@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  002a8	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR sym$[rsp], 0
  002b0	eb 0a		 jmp	 SHORT $LN22@inflate_ta
$LN20@inflate_ta:
  002b2	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  002b6	ff c0		 inc	 eax
  002b8	89 44 24 24	 mov	 DWORD PTR sym$[rsp], eax
$LN22@inflate_ta:
  002bc	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR codes$[rsp]
  002c3	39 44 24 24	 cmp	 DWORD PTR sym$[rsp], eax
  002c7	73 75		 jae	 SHORT $LN21@inflate_ta

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  002c9	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  002cd	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR lens$[rsp]
  002d5	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  002d9	85 c0		 test	 eax, eax
  002db	74 5c		 je	 SHORT $LN43@inflate_ta
  002dd	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  002e1	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR lens$[rsp]
  002e9	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  002ed	0f b7 84 44 e8
	00 00 00	 movzx	 eax, WORD PTR offs$[rsp+rax*2]
  002f5	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  002fd	0f b7 54 24 24	 movzx	 edx, WORD PTR sym$[rsp]
  00302	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  00306	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  0030a	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR lens$[rsp]
  00312	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00316	0f b7 84 44 e8
	00 00 00	 movzx	 eax, WORD PTR offs$[rsp+rax*2]
  0031e	66 ff c0	 inc	 ax
  00321	8b 4c 24 24	 mov	 ecx, DWORD PTR sym$[rsp]
  00325	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR lens$[rsp]
  0032d	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  00331	66 89 84 4c e8
	00 00 00	 mov	 WORD PTR offs$[rsp+rcx*2], ax
$LN43@inflate_ta:
  00339	e9 74 ff ff ff	 jmp	 $LN20@inflate_ta
$LN21@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  0033e	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR type$[rsp]
  00345	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv202[rsp], eax
  0034c	83 bc 24 14 01
	00 00 00	 cmp	 DWORD PTR tv202[rsp], 0
  00354	74 0c		 je	 SHORT $LN44@inflate_ta
  00356	83 bc 24 14 01
	00 00 01	 cmp	 DWORD PTR tv202[rsp], 1
  0035e	74 2f		 je	 SHORT $LN45@inflate_ta
  00360	eb 58		 jmp	 SHORT $LN46@inflate_ta
$LN44@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  00362	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR work$[rsp]
  0036a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR extra$[rsp], rax
  00372	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR extra$[rsp]
  0037a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR base$[rsp], rax

; 184  :         match = 20;

  00382	c7 84 24 90 00
	00 00 14 00 00
	00		 mov	 DWORD PTR match$[rsp], 20

; 185  :         break;

  0038d	eb 54		 jmp	 SHORT $LN23@inflate_ta
$LN45@inflate_ta:

; 186  :     case LENS:
; 187  :         base = lbase;

  0038f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9
  00396	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR base$[rsp], rax

; 188  :         extra = lext;

  0039e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  003a5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR extra$[rsp], rax

; 189  :         match = 257;

  003ad	c7 84 24 90 00
	00 00 01 01 00
	00		 mov	 DWORD PTR match$[rsp], 257 ; 00000101H

; 190  :         break;

  003b8	eb 29		 jmp	 SHORT $LN23@inflate_ta
$LN46@inflate_ta:

; 191  :     default:    /* DISTS */
; 192  :         base = dbase;

  003ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dbase@?1??inflate_table@@9@9
  003c1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR base$[rsp], rax

; 193  :         extra = dext;

  003c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  003d0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR extra$[rsp], rax

; 194  :         match = 0;

  003d8	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR match$[rsp], 0
$LN23@inflate_ta:

; 195  :     }
; 196  : 
; 197  :     /* initialize state for loop */
; 198  :     huff = 0;                   /* starting code */

  003e3	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0

; 199  :     sym = 0;                    /* starting code symbol */

  003eb	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR sym$[rsp], 0

; 200  :     len = min;                  /* starting code length */

  003f3	8b 44 24 28	 mov	 eax, DWORD PTR min$[rsp]
  003f7	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 201  :     next = *table;              /* current table to fill in */

  003fb	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00403	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00406	48 89 44 24 78	 mov	 QWORD PTR next$[rsp], rax

; 202  :     curr = root;                /* current table index bits */

  0040b	8b 44 24 30	 mov	 eax, DWORD PTR root$[rsp]
  0040f	89 44 24 34	 mov	 DWORD PTR curr$[rsp], eax

; 203  :     drop = 0;                   /* current bits to drop from code for index */

  00413	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR drop$[rsp], 0

; 204  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */

  0041b	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR low$[rsp], -1	; ffffffffH

; 205  :     used = 1U << root;          /* use root table entries */

  00423	8b 44 24 30	 mov	 eax, DWORD PTR root$[rsp]
  00427	b9 01 00 00 00	 mov	 ecx, 1
  0042c	89 8c 24 18 01
	00 00		 mov	 DWORD PTR tv450[rsp], ecx
  00433	0f b6 c8	 movzx	 ecx, al
  00436	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR tv450[rsp]
  0043d	d3 e0		 shl	 eax, cl
  0043f	89 44 24 40	 mov	 DWORD PTR used$[rsp], eax

; 206  :     mask = used - 1;            /* mask for comparing low */

  00443	8b 44 24 40	 mov	 eax, DWORD PTR used$[rsp]
  00447	ff c8		 dec	 eax
  00449	89 44 24 54	 mov	 DWORD PTR mask$[rsp], eax

; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  0044d	83 bc 24 50 01
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00455	75 0a		 jne	 SHORT $LN49@inflate_ta
  00457	81 7c 24 40 54
	03 00 00	 cmp	 DWORD PTR used$[rsp], 852 ; 00000354H
  0045f	77 14		 ja	 SHORT $LN48@inflate_ta
$LN49@inflate_ta:
  00461	83 bc 24 50 01
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  00469	75 14		 jne	 SHORT $LN47@inflate_ta
  0046b	81 7c 24 40 50
	02 00 00	 cmp	 DWORD PTR used$[rsp], 592 ; 00000250H
  00473	76 0a		 jbe	 SHORT $LN47@inflate_ta
$LN48@inflate_ta:

; 210  :         (type == DISTS && used > ENOUGH_DISTS))
; 211  :         return 1;

  00475	b8 01 00 00 00	 mov	 eax, 1
  0047a	e9 1d 04 00 00	 jmp	 $LN1@inflate_ta
$LN47@inflate_ta:
$LN25@inflate_ta:

; 212  : 
; 213  :     /* process all codes and make table entries */
; 214  :     for (;;) {
; 215  :         /* create table entry */
; 216  :         here.bits = (unsigned char)(len - drop);

  0047f	8b 44 24 38	 mov	 eax, DWORD PTR drop$[rsp]
  00483	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00487	2b c8		 sub	 ecx, eax
  00489	8b c1		 mov	 eax, ecx
  0048b	88 44 24 65	 mov	 BYTE PTR here$[rsp+1], al

; 217  :         if (work[sym] + 1U < match) {

  0048f	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  00493	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  0049b	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0049f	ff c0		 inc	 eax
  004a1	3b 84 24 90 00
	00 00		 cmp	 eax, DWORD PTR match$[rsp]
  004a8	73 1c		 jae	 SHORT $LN50@inflate_ta

; 218  :             here.op = (unsigned char)0;

  004aa	c6 44 24 64 00	 mov	 BYTE PTR here$[rsp], 0

; 219  :             here.val = work[sym];

  004af	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  004b3	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  004bb	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  004bf	66 89 44 24 66	 mov	 WORD PTR here$[rsp+2], ax

; 220  :         }

  004c4	eb 7a		 jmp	 SHORT $LN51@inflate_ta
$LN50@inflate_ta:

; 221  :         else if (work[sym] >= match) {

  004c6	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  004ca	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  004d2	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  004d6	3b 84 24 90 00
	00 00		 cmp	 eax, DWORD PTR match$[rsp]
  004dd	72 55		 jb	 SHORT $LN52@inflate_ta

; 222  :             here.op = (unsigned char)(extra[work[sym] - match]);

  004df	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  004e3	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  004eb	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  004ef	2b 84 24 90 00
	00 00		 sub	 eax, DWORD PTR match$[rsp]
  004f6	8b c0		 mov	 eax, eax
  004f8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR extra$[rsp]
  00500	0f b6 04 41	 movzx	 eax, BYTE PTR [rcx+rax*2]
  00504	88 44 24 64	 mov	 BYTE PTR here$[rsp], al

; 223  :             here.val = base[work[sym] - match];

  00508	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  0050c	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  00514	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00518	2b 84 24 90 00
	00 00		 sub	 eax, DWORD PTR match$[rsp]
  0051f	8b c0		 mov	 eax, eax
  00521	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR base$[rsp]
  00529	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  0052d	66 89 44 24 66	 mov	 WORD PTR here$[rsp+2], ax

; 224  :         }

  00532	eb 0c		 jmp	 SHORT $LN53@inflate_ta
$LN52@inflate_ta:

; 225  :         else {
; 226  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  00534	c6 44 24 64 60	 mov	 BYTE PTR here$[rsp], 96	; 00000060H

; 227  :             here.val = 0;

  00539	33 c0		 xor	 eax, eax
  0053b	66 89 44 24 66	 mov	 WORD PTR here$[rsp+2], ax
$LN53@inflate_ta:
$LN51@inflate_ta:

; 228  :         }
; 229  : 
; 230  :         /* replicate for those indices with low len bits equal to huff */
; 231  :         incr = 1U << (len - drop);

  00540	8b 44 24 38	 mov	 eax, DWORD PTR drop$[rsp]
  00544	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00548	2b c8		 sub	 ecx, eax
  0054a	8b c1		 mov	 eax, ecx
  0054c	b9 01 00 00 00	 mov	 ecx, 1
  00551	89 8c 24 1c 01
	00 00		 mov	 DWORD PTR tv471[rsp], ecx
  00558	0f b6 c8	 movzx	 ecx, al
  0055b	8b 84 24 1c 01
	00 00		 mov	 eax, DWORD PTR tv471[rsp]
  00562	d3 e0		 shl	 eax, cl
  00564	89 44 24 48	 mov	 DWORD PTR incr$[rsp], eax

; 232  :         fill = 1U << curr;

  00568	8b 44 24 34	 mov	 eax, DWORD PTR curr$[rsp]
  0056c	b9 01 00 00 00	 mov	 ecx, 1
  00571	89 8c 24 20 01
	00 00		 mov	 DWORD PTR tv474[rsp], ecx
  00578	0f b6 c8	 movzx	 ecx, al
  0057b	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR tv474[rsp]
  00582	d3 e0		 shl	 eax, cl
  00584	89 44 24 4c	 mov	 DWORD PTR fill$[rsp], eax

; 233  :         min = fill;                 /* save offset to next table */

  00588	8b 44 24 4c	 mov	 eax, DWORD PTR fill$[rsp]
  0058c	89 44 24 28	 mov	 DWORD PTR min$[rsp], eax
$LN30@inflate_ta:

; 234  :         do {
; 235  :             fill -= incr;

  00590	8b 44 24 48	 mov	 eax, DWORD PTR incr$[rsp]
  00594	8b 4c 24 4c	 mov	 ecx, DWORD PTR fill$[rsp]
  00598	2b c8		 sub	 ecx, eax
  0059a	8b c1		 mov	 eax, ecx
  0059c	89 44 24 4c	 mov	 DWORD PTR fill$[rsp], eax

; 236  :             next[(huff >> drop) + fill] = here;

  005a0	8b 44 24 38	 mov	 eax, DWORD PTR drop$[rsp]
  005a4	0f b6 c8	 movzx	 ecx, al
  005a7	8b 44 24 44	 mov	 eax, DWORD PTR huff$[rsp]
  005ab	d3 e8		 shr	 eax, cl
  005ad	03 44 24 4c	 add	 eax, DWORD PTR fill$[rsp]
  005b1	8b c0		 mov	 eax, eax
  005b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR next$[rsp]
  005b8	8b 54 24 64	 mov	 edx, DWORD PTR here$[rsp]
  005bc	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 237  :         } while (fill != 0);

  005bf	83 7c 24 4c 00	 cmp	 DWORD PTR fill$[rsp], 0
  005c4	75 ca		 jne	 SHORT $LN30@inflate_ta

; 238  : 
; 239  :         /* backwards increment the len-bit code huff */
; 240  :         incr = 1U << (len - 1);

  005c6	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  005ca	ff c8		 dec	 eax
  005cc	b9 01 00 00 00	 mov	 ecx, 1
  005d1	89 8c 24 24 01
	00 00		 mov	 DWORD PTR tv486[rsp], ecx
  005d8	0f b6 c8	 movzx	 ecx, al
  005db	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR tv486[rsp]
  005e2	d3 e0		 shl	 eax, cl
  005e4	89 44 24 48	 mov	 DWORD PTR incr$[rsp], eax
$LN31@inflate_ta:

; 241  :         while (huff & incr)

  005e8	8b 44 24 48	 mov	 eax, DWORD PTR incr$[rsp]
  005ec	8b 4c 24 44	 mov	 ecx, DWORD PTR huff$[rsp]
  005f0	23 c8		 and	 ecx, eax
  005f2	8b c1		 mov	 eax, ecx
  005f4	85 c0		 test	 eax, eax
  005f6	74 0c		 je	 SHORT $LN32@inflate_ta

; 242  :             incr >>= 1;

  005f8	8b 44 24 48	 mov	 eax, DWORD PTR incr$[rsp]
  005fc	d1 e8		 shr	 eax, 1
  005fe	89 44 24 48	 mov	 DWORD PTR incr$[rsp], eax
  00602	eb e4		 jmp	 SHORT $LN31@inflate_ta
$LN32@inflate_ta:

; 243  :         if (incr != 0) {

  00604	83 7c 24 48 00	 cmp	 DWORD PTR incr$[rsp], 0
  00609	74 24		 je	 SHORT $LN54@inflate_ta

; 244  :             huff &= incr - 1;

  0060b	8b 44 24 48	 mov	 eax, DWORD PTR incr$[rsp]
  0060f	ff c8		 dec	 eax
  00611	8b 4c 24 44	 mov	 ecx, DWORD PTR huff$[rsp]
  00615	23 c8		 and	 ecx, eax
  00617	8b c1		 mov	 eax, ecx
  00619	89 44 24 44	 mov	 DWORD PTR huff$[rsp], eax

; 245  :             huff += incr;

  0061d	8b 44 24 48	 mov	 eax, DWORD PTR incr$[rsp]
  00621	8b 4c 24 44	 mov	 ecx, DWORD PTR huff$[rsp]
  00625	03 c8		 add	 ecx, eax
  00627	8b c1		 mov	 eax, ecx
  00629	89 44 24 44	 mov	 DWORD PTR huff$[rsp], eax

; 246  :         }

  0062d	eb 08		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:

; 247  :         else
; 248  :             huff = 0;

  0062f	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0
$LN55@inflate_ta:

; 249  : 
; 250  :         /* go to next symbol, update count, len */
; 251  :         sym++;

  00637	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  0063b	ff c0		 inc	 eax
  0063d	89 44 24 24	 mov	 DWORD PTR sym$[rsp], eax

; 252  :         if (--(count[len]) == 0) {

  00641	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00645	0f b7 84 44 a8
	00 00 00	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  0064d	66 ff c8	 dec	 ax
  00650	66 89 84 24 28
	01 00 00	 mov	 WORD PTR tv301[rsp], ax
  00658	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0065c	0f b7 8c 24 28
	01 00 00	 movzx	 ecx, WORD PTR tv301[rsp]
  00664	66 89 8c 44 a8
	00 00 00	 mov	 WORD PTR count$[rsp+rax*2], cx
  0066c	0f b7 84 24 28
	01 00 00	 movzx	 eax, WORD PTR tv301[rsp]
  00674	85 c0		 test	 eax, eax
  00676	75 2f		 jne	 SHORT $LN56@inflate_ta

; 253  :             if (len == max) break;

  00678	8b 44 24 2c	 mov	 eax, DWORD PTR max$[rsp]
  0067c	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  00680	75 05		 jne	 SHORT $LN57@inflate_ta
  00682	e9 b4 01 00 00	 jmp	 $LN26@inflate_ta
$LN57@inflate_ta:

; 254  :             len = lens[work[sym]];

  00687	8b 44 24 24	 mov	 eax, DWORD PTR sym$[rsp]
  0068b	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  00693	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00697	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR lens$[rsp]
  0069f	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  006a3	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN56@inflate_ta:

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  006a7	8b 44 24 30	 mov	 eax, DWORD PTR root$[rsp]
  006ab	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  006af	0f 86 81 01 00
	00		 jbe	 $LN58@inflate_ta
  006b5	8b 44 24 54	 mov	 eax, DWORD PTR mask$[rsp]
  006b9	8b 4c 24 44	 mov	 ecx, DWORD PTR huff$[rsp]
  006bd	23 c8		 and	 ecx, eax
  006bf	8b c1		 mov	 eax, ecx
  006c1	3b 44 24 50	 cmp	 eax, DWORD PTR low$[rsp]
  006c5	0f 84 6b 01 00
	00		 je	 $LN58@inflate_ta

; 259  :             /* if first time, transition to sub-tables */
; 260  :             if (drop == 0)

  006cb	83 7c 24 38 00	 cmp	 DWORD PTR drop$[rsp], 0
  006d0	75 08		 jne	 SHORT $LN59@inflate_ta

; 261  :                 drop = root;

  006d2	8b 44 24 30	 mov	 eax, DWORD PTR root$[rsp]
  006d6	89 44 24 38	 mov	 DWORD PTR drop$[rsp], eax
$LN59@inflate_ta:

; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  006da	8b 44 24 28	 mov	 eax, DWORD PTR min$[rsp]
  006de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR next$[rsp]
  006e3	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  006e7	48 89 44 24 78	 mov	 QWORD PTR next$[rsp], rax

; 265  : 
; 266  :             /* determine length of next table */
; 267  :             curr = len - drop;

  006ec	8b 44 24 38	 mov	 eax, DWORD PTR drop$[rsp]
  006f0	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  006f4	2b c8		 sub	 ecx, eax
  006f6	8b c1		 mov	 eax, ecx
  006f8	89 44 24 34	 mov	 DWORD PTR curr$[rsp], eax

; 268  :             left = (int)(1 << curr);

  006fc	8b 44 24 34	 mov	 eax, DWORD PTR curr$[rsp]
  00700	b9 01 00 00 00	 mov	 ecx, 1
  00705	89 8c 24 2c 01
	00 00		 mov	 DWORD PTR tv509[rsp], ecx
  0070c	0f b6 c8	 movzx	 ecx, al
  0070f	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR tv509[rsp]
  00716	d3 e0		 shl	 eax, cl
  00718	89 44 24 3c	 mov	 DWORD PTR left$[rsp], eax
$LN33@inflate_ta:

; 269  :             while (curr + drop < max) {

  0071c	8b 44 24 38	 mov	 eax, DWORD PTR drop$[rsp]
  00720	8b 4c 24 34	 mov	 ecx, DWORD PTR curr$[rsp]
  00724	03 c8		 add	 ecx, eax
  00726	8b c1		 mov	 eax, ecx
  00728	3b 44 24 2c	 cmp	 eax, DWORD PTR max$[rsp]
  0072c	73 41		 jae	 SHORT $LN34@inflate_ta

; 270  :                 left -= count[curr + drop];

  0072e	8b 44 24 38	 mov	 eax, DWORD PTR drop$[rsp]
  00732	8b 4c 24 34	 mov	 ecx, DWORD PTR curr$[rsp]
  00736	03 c8		 add	 ecx, eax
  00738	8b c1		 mov	 eax, ecx
  0073a	8b c0		 mov	 eax, eax
  0073c	0f b7 84 44 a8
	00 00 00	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  00744	8b 4c 24 3c	 mov	 ecx, DWORD PTR left$[rsp]
  00748	2b c8		 sub	 ecx, eax
  0074a	8b c1		 mov	 eax, ecx
  0074c	89 44 24 3c	 mov	 DWORD PTR left$[rsp], eax

; 271  :                 if (left <= 0) break;

  00750	83 7c 24 3c 00	 cmp	 DWORD PTR left$[rsp], 0
  00755	7f 02		 jg	 SHORT $LN60@inflate_ta
  00757	eb 16		 jmp	 SHORT $LN34@inflate_ta
$LN60@inflate_ta:

; 272  :                 curr++;

  00759	8b 44 24 34	 mov	 eax, DWORD PTR curr$[rsp]
  0075d	ff c0		 inc	 eax
  0075f	89 44 24 34	 mov	 DWORD PTR curr$[rsp], eax

; 273  :                 left <<= 1;

  00763	8b 44 24 3c	 mov	 eax, DWORD PTR left$[rsp]
  00767	d1 e0		 shl	 eax, 1
  00769	89 44 24 3c	 mov	 DWORD PTR left$[rsp], eax

; 274  :             }

  0076d	eb ad		 jmp	 SHORT $LN33@inflate_ta
$LN34@inflate_ta:

; 275  : 
; 276  :             /* check for enough space */
; 277  :             used += 1U << curr;

  0076f	8b 44 24 34	 mov	 eax, DWORD PTR curr$[rsp]
  00773	b9 01 00 00 00	 mov	 ecx, 1
  00778	89 8c 24 30 01
	00 00		 mov	 DWORD PTR tv519[rsp], ecx
  0077f	0f b6 c8	 movzx	 ecx, al
  00782	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR tv519[rsp]
  00789	d3 e0		 shl	 eax, cl
  0078b	8b 4c 24 40	 mov	 ecx, DWORD PTR used$[rsp]
  0078f	03 c8		 add	 ecx, eax
  00791	8b c1		 mov	 eax, ecx
  00793	89 44 24 40	 mov	 DWORD PTR used$[rsp], eax

; 278  :             if ((type == LENS && used > ENOUGH_LENS) ||

  00797	83 bc 24 50 01
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  0079f	75 0a		 jne	 SHORT $LN63@inflate_ta
  007a1	81 7c 24 40 54
	03 00 00	 cmp	 DWORD PTR used$[rsp], 852 ; 00000354H
  007a9	77 14		 ja	 SHORT $LN62@inflate_ta
$LN63@inflate_ta:
  007ab	83 bc 24 50 01
	00 00 02	 cmp	 DWORD PTR type$[rsp], 2
  007b3	75 14		 jne	 SHORT $LN61@inflate_ta
  007b5	81 7c 24 40 50
	02 00 00	 cmp	 DWORD PTR used$[rsp], 592 ; 00000250H
  007bd	76 0a		 jbe	 SHORT $LN61@inflate_ta
$LN62@inflate_ta:

; 279  :                 (type == DISTS && used > ENOUGH_DISTS))
; 280  :                 return 1;

  007bf	b8 01 00 00 00	 mov	 eax, 1
  007c4	e9 d3 00 00 00	 jmp	 $LN1@inflate_ta
$LN61@inflate_ta:

; 281  : 
; 282  :             /* point entry in root table to sub-table */
; 283  :             low = huff & mask;

  007c9	8b 44 24 54	 mov	 eax, DWORD PTR mask$[rsp]
  007cd	8b 4c 24 44	 mov	 ecx, DWORD PTR huff$[rsp]
  007d1	23 c8		 and	 ecx, eax
  007d3	8b c1		 mov	 eax, ecx
  007d5	89 44 24 50	 mov	 DWORD PTR low$[rsp], eax

; 284  :             (*table)[low].op = (unsigned char)curr;

  007d9	8b 44 24 50	 mov	 eax, DWORD PTR low$[rsp]
  007dd	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  007e5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  007e8	0f b6 54 24 34	 movzx	 edx, BYTE PTR curr$[rsp]
  007ed	88 14 81	 mov	 BYTE PTR [rcx+rax*4], dl

; 285  :             (*table)[low].bits = (unsigned char)root;

  007f0	8b 44 24 50	 mov	 eax, DWORD PTR low$[rsp]
  007f4	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  007fc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  007ff	0f b6 54 24 30	 movzx	 edx, BYTE PTR root$[rsp]
  00804	88 54 81 01	 mov	 BYTE PTR [rcx+rax*4+1], dl

; 286  :             (*table)[low].val = (unsigned short)(next - *table);

  00808	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00810	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00813	48 8b 4c 24 78	 mov	 rcx, QWORD PTR next$[rsp]
  00818	48 2b c8	 sub	 rcx, rax
  0081b	48 8b c1	 mov	 rax, rcx
  0081e	48 c1 f8 02	 sar	 rax, 2
  00822	8b 4c 24 50	 mov	 ecx, DWORD PTR low$[rsp]
  00826	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR table$[rsp]
  0082e	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00831	66 89 44 8a 02	 mov	 WORD PTR [rdx+rcx*4+2], ax
$LN58@inflate_ta:

; 287  :         }
; 288  :     }

  00836	e9 44 fc ff ff	 jmp	 $LN25@inflate_ta
$LN26@inflate_ta:

; 289  : 
; 290  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 291  :        at most one remaining entry, since if the code is incomplete, the
; 292  :        maximum code length that was allowed to get this far is one bit) */
; 293  :     if (huff != 0) {

  0083b	83 7c 24 44 00	 cmp	 DWORD PTR huff$[rsp], 0
  00840	74 2c		 je	 SHORT $LN64@inflate_ta

; 294  :         here.op = (unsigned char)64;            /* invalid code marker */

  00842	c6 44 24 64 40	 mov	 BYTE PTR here$[rsp], 64	; 00000040H

; 295  :         here.bits = (unsigned char)(len - drop);

  00847	8b 44 24 38	 mov	 eax, DWORD PTR drop$[rsp]
  0084b	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0084f	2b c8		 sub	 ecx, eax
  00851	8b c1		 mov	 eax, ecx
  00853	88 44 24 65	 mov	 BYTE PTR here$[rsp+1], al

; 296  :         here.val = (unsigned short)0;

  00857	33 c0		 xor	 eax, eax
  00859	66 89 44 24 66	 mov	 WORD PTR here$[rsp+2], ax

; 297  :         next[huff] = here;

  0085e	8b 44 24 44	 mov	 eax, DWORD PTR huff$[rsp]
  00862	48 8b 4c 24 78	 mov	 rcx, QWORD PTR next$[rsp]
  00867	8b 54 24 64	 mov	 edx, DWORD PTR here$[rsp]
  0086b	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN64@inflate_ta:

; 298  :     }
; 299  : 
; 300  :     /* set return parameters */
; 301  :     *table += used;

  0086e	8b 44 24 40	 mov	 eax, DWORD PTR used$[rsp]
  00872	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0087a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0087d	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00881	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00889	48 89 01	 mov	 QWORD PTR [rcx], rax

; 302  :     *bits = root;

  0088c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR bits$[rsp]
  00894	8b 4c 24 30	 mov	 ecx, DWORD PTR root$[rsp]
  00898	89 08		 mov	 DWORD PTR [rax], ecx

; 303  :     return 0;

  0089a	33 c0		 xor	 eax, eax
$LN1@inflate_ta:

; 304  : }

  0089c	48 8b f8	 mov	 rdi, rax
  0089f	48 8b cc	 mov	 rcx, rsp
  008a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:inflate_table$rtcFrameData
  008a9	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  008ae	48 8b c7	 mov	 rax, rdi
  008b1	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  008b8	5f		 pop	 rdi
  008b9	c3		 ret	 0
inflate_table ENDP
_TEXT	ENDS
END
