; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27525.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ ; `string'
EXTRN	__imp__write:PROC
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ DB 'requested le'
	DB	'ngth does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@ DB 'internal err'
	DB	'or: deflate stream corrupt', 00H		; `string'
__DB664BEB_corecrt_stdio_config@h DB 01H
__E28BBA23_corecrt_wstdio@h DB 01H
__4A1C29A8_stdio@h DB 01H
__95347B96_ctype@h DB 01H
__149DB6BE_basetsd@h DB 01H
__9CFFAB73_corecrt_memcpy_s@h DB 01H
__55B7CB8D_corecrt_wstring@h DB 01H
__2F7506B6_string@h DB 01H
__5BA8817F_winnt@h DB 01H
__8421AFE7_processthreadsapi@h DB 01H
__F192E00B_memoryapi@h DB 01H
__0DF854E2_winerror@h DB 01H
__940BF1C4_winbase@h DB 01H
__78A3E64A_stralign@h DB 01H
__B2FA0A71_gzwrite@c DB 01H
PUBLIC	gzsetparams
PUBLIC	gzflush
PUBLIC	gzprintf
PUBLIC	gzvprintf
PUBLIC	gzputs
PUBLIC	gzputc
PUBLIC	gzfwrite
PUBLIC	gzwrite
PUBLIC	gzclose_w
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzsetparams DD imagerel $LN12
	DD	imagerel $LN12+323
	DD	imagerel $unwind$gzsetparams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzflush DD imagerel $LN11
	DD	imagerel $LN11+215
	DD	imagerel $unwind$gzflush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzprintf DD imagerel $LN4
	DD	imagerel $LN4+129
	DD	imagerel $unwind$gzprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzvprintf DD imagerel $LN19
	DD	imagerel $LN19+703
	DD	imagerel $unwind$gzvprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputs DD imagerel $LN9
	DD	imagerel $LN9+187
	DD	imagerel $unwind$gzputs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputc DD imagerel $LN14
	DD	imagerel $LN14+431
	DD	imagerel $unwind$gzputc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzfwrite DD imagerel $LN11
	DD	imagerel $LN11+242
	DD	imagerel $unwind$gzfwrite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzwrite DD imagerel $LN9
	DD	imagerel $LN9+164
	DD	imagerel $unwind$gzwrite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_write DD imagerel gz_write
	DD	imagerel gz_write+635
	DD	imagerel $unwind$gz_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_zero DD imagerel gz_zero
	DD	imagerel gz_zero+317
	DD	imagerel $unwind$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_comp DD imagerel gz_comp
	DD	imagerel gz_comp+759
	DD	imagerel $unwind$gz_comp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_init DD imagerel gz_init
	DD	imagerel gz_init+506
	DD	imagerel $unwind$gz_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_w DD imagerel $LN12
	DD	imagerel $LN12+340
	DD	imagerel $unwind$gzclose_w
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_w DD 021e01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_init DD 021e01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_comp DD 022201H
	DD	0700a920eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_zero DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_write DD 022801H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzwrite DD 022801H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzfwrite DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputc DD 022201H
	DD	0700ab20eH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
gzputc$rtcName$0 DB 062H
	DB	075H
	DB	066H
	DB	00H
	ORG $+12
gzputc$rtcVarDesc DD 034H
	DD	01H
	DQ	FLAT:gzputc$rtcName$0
	ORG $+48
gzputc$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:gzputc$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputs DD 022301H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzvprintf DD 022801H
	DD	07010b214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzprintf DD 022d01H
	DD	070157219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
gzprintf$rtcName$0 DB 076H
	DB	061H
	DB	00H
	ORG $+13
gzprintf$rtcVarDesc DD 028H
	DD	08H
	DQ	FLAT:gzprintf$rtcName$0
	ORG $+48
gzprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:gzprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzflush DD 022201H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzsetparams DD 022701H
	DD	0700f5213H
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzclose_w
_TEXT	SEGMENT
ret$ = 32
state$ = 40
file$ = 64
gzclose_w PROC						; COMDAT

; 629  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 0c 00 00 00	 mov	 ecx, 12
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 630  :     int ret = Z_OK;

  0002a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0

; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  00032	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00038	75 0a		 jne	 SHORT $LN2@gzclose_w

; 635  :         return Z_STREAM_ERROR;

  0003a	b8 fe ff ff ff	 mov	 eax, -2
  0003f	e9 0a 01 00 00	 jmp	 $LN1@gzclose_w
$LN2@gzclose_w:

; 636  :     state = (gz_statep)file;

  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00049	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 637  : 
; 638  :     /* check that we're writing */
; 639  :     if (state->mode != GZ_WRITE)

  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00053	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  0005a	74 0a		 je	 SHORT $LN3@gzclose_w

; 640  :         return Z_STREAM_ERROR;

  0005c	b8 fe ff ff ff	 mov	 eax, -2
  00061	e9 e8 00 00 00	 jmp	 $LN1@gzclose_w
$LN3@gzclose_w:

; 641  : 
; 642  :     /* check for seek request */
; 643  :     if (state->seek) {

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0006b	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  0006f	74 30		 je	 SHORT $LN4@gzclose_w

; 644  :         state->seek = 0;

  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00076	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 645  :         if (gz_zero(state, state->skip) == -1)

  0007d	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00082	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00086	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0008b	e8 00 00 00 00	 call	 gz_zero
  00090	83 f8 ff	 cmp	 eax, -1
  00093	75 0c		 jne	 SHORT $LN5@gzclose_w

; 646  :             ret = state->err;

  00095	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0009a	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0009d	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax
$LN5@gzclose_w:
$LN4@gzclose_w:

; 647  :     }
; 648  : 
; 649  :     /* flush, free memory, and close file */
; 650  :     if (gz_comp(state, Z_FINISH) == -1)

  000a1	ba 04 00 00 00	 mov	 edx, 4
  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000ab	e8 00 00 00 00	 call	 gz_comp
  000b0	83 f8 ff	 cmp	 eax, -1
  000b3	75 0c		 jne	 SHORT $LN6@gzclose_w

; 651  :         ret = state->err;

  000b5	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ba	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000bd	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax
$LN6@gzclose_w:

; 652  :     if (state->size) {

  000c1	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000c6	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  000ca	74 3a		 je	 SHORT $LN7@gzclose_w

; 653  :         if (!state->direct) {

  000cc	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d1	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  000d5	75 20		 jne	 SHORT $LN8@gzclose_w

; 654  :             (void)deflateEnd(&(state->strm));

  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000dc	48 83 c0 78	 add	 rax, 120		; 00000078H
  000e0	48 8b c8	 mov	 rcx, rax
  000e3	e8 00 00 00 00	 call	 deflateEnd

; 655  :             free(state->out);

  000e8	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ed	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@gzclose_w:

; 656  :         }
; 657  :         free(state->in);

  000f7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000fc	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@gzclose_w:

; 658  :     }
; 659  :     gz_error(state, Z_OK, NULL);

  00106	45 33 c0	 xor	 r8d, r8d
  00109	33 d2		 xor	 edx, edx
  0010b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00110	e8 00 00 00 00	 call	 gz_error

; 660  :     free(state->path);

  00115	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0011a	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 661  :     if (close(state->fd) == -1)

  00124	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00129	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__close
  00132	83 f8 ff	 cmp	 eax, -1
  00135	75 08		 jne	 SHORT $LN9@gzclose_w

; 662  :         ret = Z_ERRNO;

  00137	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -1
$LN9@gzclose_w:

; 663  :     free(state);

  0013f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 664  :     return ret;

  0014a	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
$LN1@gzclose_w:

; 665  : }

  0014e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00152	5f		 pop	 rdi
  00153	c3		 ret	 0
gzclose_w ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gz_init
_TEXT	SEGMENT
ret$ = 64
strm$ = 72
state$ = 96
gz_init	PROC						; COMDAT

; 19   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b fc	 mov	 rdi, rsp
  0000d	b9 14 00 00 00	 mov	 ecx, 20
  00012	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00017	f3 ab		 rep stosd
  00019	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00025	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 20   :     int ret;
; 21   :     z_streamp strm = &(state->strm);

  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0002f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00033	48 89 44 24 48	 mov	 QWORD PTR strm$[rsp], rax

; 22   : 
; 23   :     /* allocate input buffer (double size for gzprintf) */
; 24   :     state->in = (unsigned char *)malloc(state->want << 1);

  00038	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0003d	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00040	d1 e0		 shl	 eax, 1
  00042	8b c0		 mov	 eax, eax
  00044	8b c8		 mov	 ecx, eax
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00051	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 25   :     if (state->in == NULL) {

  00055	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0005a	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0005f	75 20		 jne	 SHORT $LN2@gz_init

; 26   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  00061	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  00068	ba fc ff ff ff	 mov	 edx, -4
  0006d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00072	e8 00 00 00 00	 call	 gz_error

; 27   :         return -1;

  00077	b8 ff ff ff ff	 mov	 eax, -1
  0007c	e9 73 01 00 00	 jmp	 $LN1@gz_init
$LN2@gz_init:

; 28   :     }
; 29   : 
; 30   :     /* only need output buffer and deflate state if compressing */
; 31   :     if (!state->direct) {

  00081	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00086	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  0008a	0f 85 13 01 00
	00		 jne	 $LN3@gz_init

; 32   :         /* allocate output buffer */
; 33   :         state->out = (unsigned char *)malloc(state->want);

  00090	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00095	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00098	8b c8		 mov	 ecx, eax
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000a5	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 34   :         if (state->out == NULL) {

  000a9	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000ae	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000b3	75 2f		 jne	 SHORT $LN4@gz_init

; 35   :             free(state->in);

  000b5	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000ba	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 36   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  000cb	ba fc ff ff ff	 mov	 edx, -4
  000d0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000d5	e8 00 00 00 00	 call	 gz_error

; 37   :             return -1;

  000da	b8 ff ff ff ff	 mov	 eax, -1
  000df	e9 10 01 00 00	 jmp	 $LN1@gz_init
$LN4@gz_init:

; 38   :         }
; 39   : 
; 40   :         /* allocate deflate memory, set up for gzip compression */
; 41   :         strm->zalloc = Z_NULL;

  000e4	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  000e9	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 42   :         strm->zfree = Z_NULL;

  000f1	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  000f6	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 43   :         strm->opaque = Z_NULL;

  000fe	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  00103	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 44   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,

  0010b	c7 44 24 38 58
	00 00 00	 mov	 DWORD PTR [rsp+56], 88	; 00000058H
  00113	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06CJNJFBNP@1?42?411@
  0011a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0011f	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00124	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  00127	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0012b	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00133	41 b9 1f 00 00
	00		 mov	 r9d, 31
  00139	41 b8 08 00 00
	00		 mov	 r8d, 8
  0013f	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00144	8b 50 58	 mov	 edx, DWORD PTR [rax+88]
  00147	48 8b 4c 24 48	 mov	 rcx, QWORD PTR strm$[rsp]
  0014c	e8 00 00 00 00	 call	 deflateInit2_
  00151	89 44 24 40	 mov	 DWORD PTR ret$[rsp], eax

; 45   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
; 46   :         if (ret != Z_OK) {

  00155	83 7c 24 40 00	 cmp	 DWORD PTR ret$[rsp], 0
  0015a	74 3b		 je	 SHORT $LN5@gz_init

; 47   :             free(state->out);

  0015c	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00161	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 48   :             free(state->in);

  0016b	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00170	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 49   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0017a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  00181	ba fc ff ff ff	 mov	 edx, -4
  00186	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0018b	e8 00 00 00 00	 call	 gz_error

; 50   :             return -1;

  00190	b8 ff ff ff ff	 mov	 eax, -1
  00195	eb 5d		 jmp	 SHORT $LN1@gz_init
$LN5@gz_init:

; 51   :         }
; 52   :         strm->next_in = NULL;

  00197	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  0019c	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN3@gz_init:

; 53   :     }
; 54   : 
; 55   :     /* mark state as initialized */
; 56   :     state->size = state->want;

  001a3	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001ad	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  001b0	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 57   : 
; 58   :     /* initialize write buffer if compressing */
; 59   :     if (!state->direct) {

  001b3	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001b8	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  001bc	75 34		 jne	 SHORT $LN6@gz_init

; 60   :         strm->avail_out = state->size;

  001be	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  001c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001c8	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  001cb	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 61   :         strm->next_out = state->out;

  001ce	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  001d3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001d8	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  001dc	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 62   :         state->x.next = strm->next_out;

  001e0	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001e5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR strm$[rsp]
  001ea	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  001ee	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN6@gz_init:

; 63   :     }
; 64   :     return 0;

  001f2	33 c0		 xor	 eax, eax
$LN1@gz_init:

; 65   : }

  001f4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001f8	5f		 pop	 rdi
  001f9	c3		 ret	 0
gz_init	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gz_comp
_TEXT	SEGMENT
ret$ = 32
writ$ = 36
have$ = 40
put$ = 44
max$ = 48
strm$ = 56
tv77 = 64
tv147 = 68
state$ = 96
flush$ = 104
gz_comp	PROC						; COMDAT

; 76   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 14 00 00 00	 mov	 ecx, 20
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 77   :     int ret, writ;
; 78   :     unsigned have, put, max = ((unsigned)-1 >> 2) + 1;

  0002e	c7 44 24 30 00
	00 00 40	 mov	 DWORD PTR max$[rsp], 1073741824 ; 40000000H

; 79   :     z_streamp strm = &(state->strm);

  00036	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0003b	48 83 c0 78	 add	 rax, 120		; 00000078H
  0003f	48 89 44 24 38	 mov	 QWORD PTR strm$[rsp], rax

; 80   : 
; 81   :     /* allocate memory if this is the first time through */
; 82   :     if (state->size == 0 && gz_init(state) == -1)

  00044	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00049	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0004d	75 19		 jne	 SHORT $LN9@gz_comp
  0004f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00054	e8 00 00 00 00	 call	 gz_init
  00059	83 f8 ff	 cmp	 eax, -1
  0005c	75 0a		 jne	 SHORT $LN9@gz_comp

; 83   :         return -1;

  0005e	b8 ff ff ff ff	 mov	 eax, -1
  00063	e9 89 02 00 00	 jmp	 $LN1@gz_comp
$LN9@gz_comp:

; 84   : 
; 85   :     /* write directly if requested */
; 86   :     if (state->direct) {

  00068	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  0006d	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00071	0f 84 c5 00 00
	00		 je	 $LN10@gz_comp
$LN2@gz_comp:

; 87   :         while (strm->avail_in) {

  00077	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  0007c	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00080	0f 84 af 00 00
	00		 je	 $LN3@gz_comp

; 88   :             put = strm->avail_in > max ? max : strm->avail_in;

  00086	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR max$[rsp]
  0008f	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00092	76 0a		 jbe	 SHORT $LN20@gz_comp
  00094	8b 44 24 30	 mov	 eax, DWORD PTR max$[rsp]
  00098	89 44 24 40	 mov	 DWORD PTR tv77[rsp], eax
  0009c	eb 0f		 jmp	 SHORT $LN21@gz_comp
$LN20@gz_comp:
  0009e	0f ae e8	 lfence
  000a1	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  000a6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000a9	89 44 24 40	 mov	 DWORD PTR tv77[rsp], eax
$LN21@gz_comp:
  000ad	8b 44 24 40	 mov	 eax, DWORD PTR tv77[rsp]
  000b1	89 44 24 2c	 mov	 DWORD PTR put$[rsp], eax

; 89   :             writ = write(state->fd, strm->next_in, put);

  000b5	44 8b 44 24 2c	 mov	 r8d, DWORD PTR put$[rsp]
  000ba	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  000bf	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000c2	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  000c7	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__write
  000d0	89 44 24 24	 mov	 DWORD PTR writ$[rsp], eax

; 90   :             if (writ < 0) {

  000d4	83 7c 24 24 00	 cmp	 DWORD PTR writ$[rsp], 0
  000d9	7d 2a		 jge	 SHORT $LN11@gz_comp

; 91   :                 gz_error(state, Z_ERRNO, zstrerror());

  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e1	8b 08		 mov	 ecx, DWORD PTR [rax]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  000e9	4c 8b c0	 mov	 r8, rax
  000ec	ba ff ff ff ff	 mov	 edx, -1
  000f1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  000f6	e8 00 00 00 00	 call	 gz_error

; 92   :                 return -1;

  000fb	b8 ff ff ff ff	 mov	 eax, -1
  00100	e9 ec 01 00 00	 jmp	 $LN1@gz_comp
$LN11@gz_comp:

; 93   :             }
; 94   :             strm->avail_in -= (unsigned)writ;

  00105	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  0010a	8b 4c 24 24	 mov	 ecx, DWORD PTR writ$[rsp]
  0010e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00111	2b c1		 sub	 eax, ecx
  00113	48 8b 4c 24 38	 mov	 rcx, QWORD PTR strm$[rsp]
  00118	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 95   :             strm->next_in += writ;

  0011b	48 63 44 24 24	 movsxd	 rax, DWORD PTR writ$[rsp]
  00120	48 8b 4c 24 38	 mov	 rcx, QWORD PTR strm$[rsp]
  00125	48 03 01	 add	 rax, QWORD PTR [rcx]
  00128	48 8b 4c 24 38	 mov	 rcx, QWORD PTR strm$[rsp]
  0012d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 96   :         }

  00130	e9 42 ff ff ff	 jmp	 $LN2@gz_comp
$LN3@gz_comp:

; 97   :         return 0;

  00135	33 c0		 xor	 eax, eax
  00137	e9 b5 01 00 00	 jmp	 $LN1@gz_comp
$LN10@gz_comp:

; 98   :     }
; 99   : 
; 100  :     /* run deflate() on provided input until it produces no more output */
; 101  :     ret = Z_OK;

  0013c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0
$LN6@gz_comp:

; 102  :     do {
; 103  :         /* write out current buffer contents if full, or if flushing, but if
; 104  :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 105  :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&

  00144	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  00149	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0014d	74 1d		 je	 SHORT $LN13@gz_comp
  0014f	83 7c 24 68 00	 cmp	 DWORD PTR flush$[rsp], 0
  00154	0f 84 23 01 00
	00		 je	 $LN12@gz_comp
  0015a	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  0015f	75 0b		 jne	 SHORT $LN14@gz_comp
  00161	83 7c 24 20 01	 cmp	 DWORD PTR ret$[rsp], 1
  00166	0f 85 11 01 00
	00		 jne	 $LN12@gz_comp
$LN14@gz_comp:
$LN13@gz_comp:
$LN7@gz_comp:

; 106  :             (flush != Z_FINISH || ret == Z_STREAM_END))) {
; 107  :             while (strm->next_out > state->x.next) {

  0016c	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  00171	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00176	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0017a	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  0017e	0f 86 ba 00 00
	00		 jbe	 $LN8@gz_comp

; 108  :                 put = strm->next_out - state->x.next > (int)max ? max :

  00184	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  00189	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0018e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00192	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00196	48 2b c1	 sub	 rax, rcx
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR max$[rsp]
  0019e	48 3b c1	 cmp	 rax, rcx
  001a1	7e 0a		 jle	 SHORT $LN22@gz_comp
  001a3	8b 44 24 30	 mov	 eax, DWORD PTR max$[rsp]
  001a7	89 44 24 44	 mov	 DWORD PTR tv147[rsp], eax
  001ab	eb 1c		 jmp	 SHORT $LN23@gz_comp
$LN22@gz_comp:
  001ad	0f ae e8	 lfence
  001b0	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  001b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  001ba	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  001be	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001c2	48 2b c1	 sub	 rax, rcx
  001c5	89 44 24 44	 mov	 DWORD PTR tv147[rsp], eax
$LN23@gz_comp:
  001c9	8b 44 24 44	 mov	 eax, DWORD PTR tv147[rsp]
  001cd	89 44 24 2c	 mov	 DWORD PTR put$[rsp], eax

; 109  :                       (unsigned)(strm->next_out - state->x.next);
; 110  :                 writ = write(state->fd, state->x.next, put);

  001d1	44 8b 44 24 2c	 mov	 r8d, DWORD PTR put$[rsp]
  001d6	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001db	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  001df	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  001e4	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__write
  001ed	89 44 24 24	 mov	 DWORD PTR writ$[rsp], eax

; 111  :                 if (writ < 0) {

  001f1	83 7c 24 24 00	 cmp	 DWORD PTR writ$[rsp], 0
  001f6	7d 2a		 jge	 SHORT $LN15@gz_comp

; 112  :                     gz_error(state, Z_ERRNO, zstrerror());

  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001fe	8b 08		 mov	 ecx, DWORD PTR [rax]
  00200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00206	4c 8b c0	 mov	 r8, rax
  00209	ba ff ff ff ff	 mov	 edx, -1
  0020e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00213	e8 00 00 00 00	 call	 gz_error

; 113  :                     return -1;

  00218	b8 ff ff ff ff	 mov	 eax, -1
  0021d	e9 cf 00 00 00	 jmp	 $LN1@gz_comp
$LN15@gz_comp:

; 114  :                 }
; 115  :                 state->x.next += writ;

  00222	48 63 44 24 24	 movsxd	 rax, DWORD PTR writ$[rsp]
  00227	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  0022c	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00230	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00235	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 116  :             }

  00239	e9 2e ff ff ff	 jmp	 $LN7@gz_comp
$LN8@gz_comp:

; 117  :             if (strm->avail_out == 0) {

  0023e	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  00243	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00247	75 34		 jne	 SHORT $LN16@gz_comp

; 118  :                 strm->avail_out = state->size;

  00249	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  0024e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00253	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00256	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 119  :                 strm->next_out = state->out;

  00259	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  0025e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00263	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00267	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 120  :                 state->x.next = state->out;

  0026b	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  00270	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  00275	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00279	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN16@gz_comp:
$LN12@gz_comp:

; 121  :             }
; 122  :         }
; 123  : 
; 124  :         /* compress */
; 125  :         have = strm->avail_out;

  0027d	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  00282	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00285	89 44 24 28	 mov	 DWORD PTR have$[rsp], eax

; 126  :         ret = deflate(strm, flush);

  00289	8b 54 24 68	 mov	 edx, DWORD PTR flush$[rsp]
  0028d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR strm$[rsp]
  00292	e8 00 00 00 00	 call	 deflate
  00297	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 127  :         if (ret == Z_STREAM_ERROR) {

  0029b	83 7c 24 20 fe	 cmp	 DWORD PTR ret$[rsp], -2
  002a0	75 1d		 jne	 SHORT $LN17@gz_comp

; 128  :             gz_error(state, Z_STREAM_ERROR,

  002a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@
  002a9	ba fe ff ff ff	 mov	 edx, -2
  002ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR state$[rsp]
  002b3	e8 00 00 00 00	 call	 gz_error

; 129  :                       "internal error: deflate stream corrupt");
; 130  :             return -1;

  002b8	b8 ff ff ff ff	 mov	 eax, -1
  002bd	eb 32		 jmp	 SHORT $LN1@gz_comp
$LN17@gz_comp:

; 131  :         }
; 132  :         have -= strm->avail_out;

  002bf	48 8b 44 24 38	 mov	 rax, QWORD PTR strm$[rsp]
  002c4	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  002c7	8b 4c 24 28	 mov	 ecx, DWORD PTR have$[rsp]
  002cb	2b c8		 sub	 ecx, eax
  002cd	8b c1		 mov	 eax, ecx
  002cf	89 44 24 28	 mov	 DWORD PTR have$[rsp], eax

; 133  :     } while (have);

  002d3	83 7c 24 28 00	 cmp	 DWORD PTR have$[rsp], 0
  002d8	0f 85 66 fe ff
	ff		 jne	 $LN6@gz_comp

; 134  : 
; 135  :     /* if that completed a deflate stream, allow another to start */
; 136  :     if (flush == Z_FINISH)

  002de	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  002e3	75 0a		 jne	 SHORT $LN18@gz_comp

; 137  :         deflateReset(strm);

  002e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR strm$[rsp]
  002ea	e8 00 00 00 00	 call	 deflateReset
$LN18@gz_comp:

; 138  : 
; 139  :     /* all done, no errors */
; 140  :     return 0;

  002ef	33 c0		 xor	 eax, eax
$LN1@gz_comp:

; 141  : }

  002f1	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002f5	5f		 pop	 rdi
  002f6	c3		 ret	 0
gz_comp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gz_zero
_TEXT	SEGMENT
first$ = 32
n$ = 36
strm$ = 40
tv77 = 48
state$ = 80
len$ = 88
gz_zero	PROC						; COMDAT

; 148  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 149  :     int first;
; 150  :     unsigned n;
; 151  :     z_streamp strm = &(state->strm);

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00034	48 83 c0 78	 add	 rax, 120		; 00000078H
  00038	48 89 44 24 28	 mov	 QWORD PTR strm$[rsp], rax

; 152  : 
; 153  :     /* consume whatever's left in the input buffer */
; 154  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0003d	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  00042	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00046	74 1b		 je	 SHORT $LN4@gz_zero
  00048	33 d2		 xor	 edx, edx
  0004a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0004f	e8 00 00 00 00	 call	 gz_comp
  00054	83 f8 ff	 cmp	 eax, -1
  00057	75 0a		 jne	 SHORT $LN4@gz_zero

; 155  :         return -1;

  00059	b8 ff ff ff ff	 mov	 eax, -1
  0005e	e9 d4 00 00 00	 jmp	 $LN1@gz_zero
$LN4@gz_zero:

; 156  : 
; 157  :     /* compress len zeros (len guaranteed > 0) */
; 158  :     first = 1;

  00063	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR first$[rsp], 1
$LN2@gz_zero:

; 159  :     while (len) {

  0006b	48 83 7c 24 58
	00		 cmp	 QWORD PTR len$[rsp], 0
  00071	0f 84 be 00 00
	00		 je	 $LN3@gz_zero

; 160  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?

  00077	33 c0		 xor	 eax, eax
  00079	85 c0		 test	 eax, eax
  0007b	75 1d		 jne	 SHORT $LN8@gz_zero
  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00082	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00085	48 3b 44 24 58	 cmp	 rax, QWORD PTR len$[rsp]
  0008a	7f 0e		 jg	 SHORT $LN8@gz_zero
  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00091	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00094	89 44 24 30	 mov	 DWORD PTR tv77[rsp], eax
  00098	eb 08		 jmp	 SHORT $LN9@gz_zero
$LN8@gz_zero:
  0009a	8b 44 24 58	 mov	 eax, DWORD PTR len$[rsp]
  0009e	89 44 24 30	 mov	 DWORD PTR tv77[rsp], eax
$LN9@gz_zero:
  000a2	8b 44 24 30	 mov	 eax, DWORD PTR tv77[rsp]
  000a6	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax

; 161  :             (unsigned)len : state->size;
; 162  :         if (first) {

  000aa	83 7c 24 20 00	 cmp	 DWORD PTR first$[rsp], 0
  000af	74 20		 je	 SHORT $LN5@gz_zero

; 163  :             memset(state->in, 0, n);

  000b1	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  000b5	44 8b c0	 mov	 r8d, eax
  000b8	33 d2		 xor	 edx, edx
  000ba	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  000bf	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memset

; 164  :             first = 0;

  000c9	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR first$[rsp], 0
$LN5@gz_zero:

; 165  :         }
; 166  :         strm->avail_in = n;

  000d1	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  000d6	8b 4c 24 24	 mov	 ecx, DWORD PTR n$[rsp]
  000da	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 167  :         strm->next_in = state->in;

  000dd	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000e7	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000eb	48 89 08	 mov	 QWORD PTR [rax], rcx

; 168  :         state->x.pos += n;

  000ee	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000f7	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00100	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 169  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00104	33 d2		 xor	 edx, edx
  00106	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0010b	e8 00 00 00 00	 call	 gz_comp
  00110	83 f8 ff	 cmp	 eax, -1
  00113	75 07		 jne	 SHORT $LN6@gz_zero

; 170  :             return -1;

  00115	b8 ff ff ff ff	 mov	 eax, -1
  0011a	eb 1b		 jmp	 SHORT $LN1@gz_zero
$LN6@gz_zero:

; 171  :         len -= n;

  0011c	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00120	48 8b 4c 24 58	 mov	 rcx, QWORD PTR len$[rsp]
  00125	48 2b c8	 sub	 rcx, rax
  00128	48 8b c1	 mov	 rax, rcx
  0012b	48 89 44 24 58	 mov	 QWORD PTR len$[rsp], rax

; 172  :     }

  00130	e9 36 ff ff ff	 jmp	 $LN2@gz_zero
$LN3@gz_zero:

; 173  :     return 0;

  00135	33 c0		 xor	 eax, eax
$LN1@gz_zero:

; 174  : }

  00137	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0013b	5f		 pop	 rdi
  0013c	c3		 ret	 0
gz_zero	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gz_write
_TEXT	SEGMENT
put$ = 32
have$1 = 40
copy$2 = 44
n$3 = 48
state$ = 80
buf$ = 88
len$ = 96
gz_write PROC						; COMDAT

; 182  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 10 00 00 00	 mov	 ecx, 16
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 183  :     z_size_t put = len;

  00034	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  00039	48 89 44 24 20	 mov	 QWORD PTR put$[rsp], rax

; 184  : 
; 185  :     /* if len is zero, avoid unnecessary operations */
; 186  :     if (len == 0)

  0003e	48 83 7c 24 60
	00		 cmp	 QWORD PTR len$[rsp], 0
  00044	75 07		 jne	 SHORT $LN8@gz_write

; 187  :         return 0;

  00046	33 c0		 xor	 eax, eax
  00048	e9 28 02 00 00	 jmp	 $LN1@gz_write
$LN8@gz_write:

; 188  : 
; 189  :     /* allocate memory if this is the first time through */
; 190  :     if (state->size == 0 && gz_init(state) == -1)

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00052	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00056	75 16		 jne	 SHORT $LN9@gz_write
  00058	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0005d	e8 00 00 00 00	 call	 gz_init
  00062	83 f8 ff	 cmp	 eax, -1
  00065	75 07		 jne	 SHORT $LN9@gz_write

; 191  :         return 0;

  00067	33 c0		 xor	 eax, eax
  00069	e9 07 02 00 00	 jmp	 $LN1@gz_write
$LN9@gz_write:

; 192  : 
; 193  :     /* check for seek request */
; 194  :     if (state->seek) {

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00073	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00077	74 2b		 je	 SHORT $LN10@gz_write

; 195  :         state->seek = 0;

  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  0007e	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 196  :         if (gz_zero(state, state->skip) == -1)

  00085	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  0008a	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00093	e8 00 00 00 00	 call	 gz_zero
  00098	83 f8 ff	 cmp	 eax, -1
  0009b	75 07		 jne	 SHORT $LN11@gz_write

; 197  :             return 0;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 d1 01 00 00	 jmp	 $LN1@gz_write
$LN11@gz_write:
$LN10@gz_write:

; 198  :     }
; 199  : 
; 200  :     /* for small len, copy to input buffer, otherwise compress directly */
; 201  :     if (len < state->size) {

  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  000a9	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000ac	48 39 44 24 60	 cmp	 QWORD PTR len$[rsp], rax
  000b1	0f 83 14 01 00
	00		 jae	 $LN12@gz_write
$LN4@gz_write:

; 202  :         /* copy to input buffer, compress when full */
; 203  :         do {
; 204  :             unsigned have, copy;
; 205  : 
; 206  :             if (state->strm.avail_in == 0)

  000b7	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  000bc	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  000c3	75 12		 jne	 SHORT $LN14@gz_write

; 207  :                 state->strm.next_in = state->in;

  000c5	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  000ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000cf	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000d3	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx
$LN14@gz_write:

; 208  :             have = (unsigned)((state->strm.next_in + state->strm.avail_in) -

  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  000dc	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000e7	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  000eb	48 03 c8	 add	 rcx, rax
  000ee	48 8b c1	 mov	 rax, rcx
  000f1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  000f6	48 2b 41 30	 sub	 rax, QWORD PTR [rcx+48]
  000fa	89 44 24 28	 mov	 DWORD PTR have$1[rsp], eax

; 209  :                               state->in);
; 210  :             copy = state->size - have;

  000fe	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00103	8b 4c 24 28	 mov	 ecx, DWORD PTR have$1[rsp]
  00107	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0010a	2b c1		 sub	 eax, ecx
  0010c	89 44 24 2c	 mov	 DWORD PTR copy$2[rsp], eax

; 211  :             if (copy > len)

  00110	8b 44 24 2c	 mov	 eax, DWORD PTR copy$2[rsp]
  00114	48 3b 44 24 60	 cmp	 rax, QWORD PTR len$[rsp]
  00119	76 08		 jbe	 SHORT $LN15@gz_write

; 212  :                 copy = len;

  0011b	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  0011f	89 44 24 2c	 mov	 DWORD PTR copy$2[rsp], eax
$LN15@gz_write:

; 213  :             memcpy(state->in + have, buf, copy);

  00123	8b 44 24 2c	 mov	 eax, DWORD PTR copy$2[rsp]
  00127	8b 4c 24 28	 mov	 ecx, DWORD PTR have$1[rsp]
  0012b	48 8b 54 24 50	 mov	 rdx, QWORD PTR state$[rsp]
  00130	48 03 4a 30	 add	 rcx, QWORD PTR [rdx+48]
  00134	44 8b c0	 mov	 r8d, eax
  00137	48 8b 54 24 58	 mov	 rdx, QWORD PTR buf$[rsp]
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 214  :             state->strm.avail_in += copy;

  00142	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  00147	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0014d	03 44 24 2c	 add	 eax, DWORD PTR copy$2[rsp]
  00151	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00156	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 215  :             state->x.pos += copy;

  0015c	8b 44 24 2c	 mov	 eax, DWORD PTR copy$2[rsp]
  00160	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00165	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00169	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0016e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 216  :             buf = (const char *)buf + copy;

  00172	8b 44 24 2c	 mov	 eax, DWORD PTR copy$2[rsp]
  00176	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0017b	48 03 c8	 add	 rcx, rax
  0017e	48 8b c1	 mov	 rax, rcx
  00181	48 89 44 24 58	 mov	 QWORD PTR buf$[rsp], rax

; 217  :             len -= copy;

  00186	8b 44 24 2c	 mov	 eax, DWORD PTR copy$2[rsp]
  0018a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR len$[rsp]
  0018f	48 2b c8	 sub	 rcx, rax
  00192	48 8b c1	 mov	 rax, rcx
  00195	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 218  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  0019a	48 83 7c 24 60
	00		 cmp	 QWORD PTR len$[rsp], 0
  001a0	74 18		 je	 SHORT $LN16@gz_write
  001a2	33 d2		 xor	 edx, edx
  001a4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  001a9	e8 00 00 00 00	 call	 gz_comp
  001ae	83 f8 ff	 cmp	 eax, -1
  001b1	75 07		 jne	 SHORT $LN16@gz_write

; 219  :                 return 0;

  001b3	33 c0		 xor	 eax, eax
  001b5	e9 bb 00 00 00	 jmp	 $LN1@gz_write
$LN16@gz_write:

; 220  :         } while (len);

  001ba	48 83 7c 24 60
	00		 cmp	 QWORD PTR len$[rsp], 0
  001c0	0f 85 f1 fe ff
	ff		 jne	 $LN4@gz_write

; 221  :     }

  001c6	e9 a5 00 00 00	 jmp	 $LN13@gz_write
$LN12@gz_write:

; 222  :     else {
; 223  :         /* consume whatever's left in the input buffer */
; 224  :         if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  001cb	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  001d0	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  001d7	74 18		 je	 SHORT $LN17@gz_write
  001d9	33 d2		 xor	 edx, edx
  001db	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  001e0	e8 00 00 00 00	 call	 gz_comp
  001e5	83 f8 ff	 cmp	 eax, -1
  001e8	75 07		 jne	 SHORT $LN17@gz_write

; 225  :             return 0;

  001ea	33 c0		 xor	 eax, eax
  001ec	e9 84 00 00 00	 jmp	 $LN1@gz_write
$LN17@gz_write:

; 226  : 
; 227  :         /* directly compress user buffer to file */
; 228  :         state->strm.next_in = (z_const Bytef *)buf;

  001f1	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  001f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  001fb	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx
$LN7@gz_write:

; 229  :         do {
; 230  :             unsigned n = (unsigned)-1;

  001ff	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR n$3[rsp], -1	; ffffffffH

; 231  :             if (n > len)

  00207	8b 44 24 30	 mov	 eax, DWORD PTR n$3[rsp]
  0020b	48 3b 44 24 60	 cmp	 rax, QWORD PTR len$[rsp]
  00210	76 08		 jbe	 SHORT $LN18@gz_write

; 232  :                 n = len;

  00212	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00216	89 44 24 30	 mov	 DWORD PTR n$3[rsp], eax
$LN18@gz_write:

; 233  :             state->strm.avail_in = n;

  0021a	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  0021f	8b 4c 24 30	 mov	 ecx, DWORD PTR n$3[rsp]
  00223	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx

; 234  :             state->x.pos += n;

  00229	8b 44 24 30	 mov	 eax, DWORD PTR n$3[rsp]
  0022d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00232	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00236	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  0023b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 235  :             if (gz_comp(state, Z_NO_FLUSH) == -1)

  0023f	33 d2		 xor	 edx, edx
  00241	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00246	e8 00 00 00 00	 call	 gz_comp
  0024b	83 f8 ff	 cmp	 eax, -1
  0024e	75 04		 jne	 SHORT $LN19@gz_write

; 236  :                 return 0;

  00250	33 c0		 xor	 eax, eax
  00252	eb 21		 jmp	 SHORT $LN1@gz_write
$LN19@gz_write:

; 237  :             len -= n;

  00254	8b 44 24 30	 mov	 eax, DWORD PTR n$3[rsp]
  00258	48 8b 4c 24 60	 mov	 rcx, QWORD PTR len$[rsp]
  0025d	48 2b c8	 sub	 rcx, rax
  00260	48 8b c1	 mov	 rax, rcx
  00263	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 238  :         } while (len);

  00268	48 83 7c 24 60
	00		 cmp	 QWORD PTR len$[rsp], 0
  0026e	75 8f		 jne	 SHORT $LN7@gz_write
$LN13@gz_write:

; 239  :     }
; 240  : 
; 241  :     /* input was all buffered or compressed */
; 242  :     return put;

  00270	48 8b 44 24 20	 mov	 rax, QWORD PTR put$[rsp]
$LN1@gz_write:

; 243  : }

  00275	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00279	5f		 pop	 rdi
  0027a	c3		 ret	 0
gz_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzwrite
_TEXT	SEGMENT
state$ = 32
file$ = 64
buf$ = 72
len$ = 80
gzwrite	PROC						; COMDAT

; 250  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 0c 00 00 00	 mov	 ecx, 12
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 251  :     gz_statep state;
; 252  : 
; 253  :     /* get internal structure */
; 254  :     if (file == NULL)

  00034	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  0003a	75 04		 jne	 SHORT $LN2@gzwrite

; 255  :         return 0;

  0003c	33 c0		 xor	 eax, eax
  0003e	eb 5e		 jmp	 SHORT $LN1@gzwrite
$LN2@gzwrite:

; 256  :     state = (gz_statep)file;

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00045	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 257  : 
; 258  :     /* check that we're writing and that there's no error */
; 259  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0004f	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  00056	75 0b		 jne	 SHORT $LN4@gzwrite
  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005d	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00061	74 04		 je	 SHORT $LN3@gzwrite
$LN4@gzwrite:

; 260  :         return 0;

  00063	33 c0		 xor	 eax, eax
  00065	eb 37		 jmp	 SHORT $LN1@gzwrite
$LN3@gzwrite:

; 261  : 
; 262  :     /* since an int is returned, make sure len fits in one, otherwise return
; 263  :        with an error (this avoids a flaw in the interface) */
; 264  :     if ((int)len < 0) {

  00067	83 7c 24 50 00	 cmp	 DWORD PTR len$[rsp], 0
  0006c	7d 1a		 jge	 SHORT $LN5@gzwrite

; 265  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  0006e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
  00075	ba fd ff ff ff	 mov	 edx, -3
  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0007f	e8 00 00 00 00	 call	 gz_error

; 266  :         return 0;

  00084	33 c0		 xor	 eax, eax
  00086	eb 16		 jmp	 SHORT $LN1@gzwrite
$LN5@gzwrite:

; 267  :     }
; 268  : 
; 269  :     /* write len bytes from buf (the return value will fit in an int) */
; 270  :     return (int)gz_write(state, buf, len);

  00088	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  0008c	44 8b c0	 mov	 r8d, eax
  0008f	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  00094	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00099	e8 00 00 00 00	 call	 gz_write
$LN1@gzwrite:

; 271  : }

  0009e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
gzwrite	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzfwrite
_TEXT	SEGMENT
len$ = 32
state$ = 40
tv82 = 48
buf$ = 80
size$ = 88
nitems$ = 96
file$ = 104
gzfwrite PROC						; COMDAT

; 279  : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00034	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 280  :     z_size_t len;
; 281  :     gz_statep state;
; 282  : 
; 283  :     /* get internal structure */
; 284  :     if (file == NULL)

  00039	48 83 7c 24 68
	00		 cmp	 QWORD PTR file$[rsp], 0
  0003f	75 07		 jne	 SHORT $LN2@gzfwrite

; 285  :         return 0;

  00041	33 c0		 xor	 eax, eax
  00043	e9 a4 00 00 00	 jmp	 $LN1@gzfwrite
$LN2@gzfwrite:

; 286  :     state = (gz_statep)file;

  00048	48 8b 44 24 68	 mov	 rax, QWORD PTR file$[rsp]
  0004d	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 287  : 
; 288  :     /* check that we're writing and that there's no error */
; 289  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00057	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  0005e	75 0b		 jne	 SHORT $LN4@gzfwrite
  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00065	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00069	74 04		 je	 SHORT $LN3@gzfwrite
$LN4@gzfwrite:

; 290  :         return 0;

  0006b	33 c0		 xor	 eax, eax
  0006d	eb 7d		 jmp	 SHORT $LN1@gzfwrite
$LN3@gzfwrite:

; 291  : 
; 292  :     /* compute bytes to read -- error on overflow */
; 293  :     len = nitems * size;

  0006f	48 8b 44 24 60	 mov	 rax, QWORD PTR nitems$[rsp]
  00074	48 0f af 44 24
	58		 imul	 rax, QWORD PTR size$[rsp]
  0007a	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 294  :     if (size && len / size != nitems) {

  0007f	48 83 7c 24 58
	00		 cmp	 QWORD PTR size$[rsp], 0
  00085	74 2d		 je	 SHORT $LN5@gzfwrite
  00087	33 d2		 xor	 edx, edx
  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR len$[rsp]
  0008e	48 f7 74 24 58	 div	 QWORD PTR size$[rsp]
  00093	48 3b 44 24 60	 cmp	 rax, QWORD PTR nitems$[rsp]
  00098	74 1a		 je	 SHORT $LN5@gzfwrite

; 295  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");

  0009a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@
  000a1	ba fe ff ff ff	 mov	 edx, -2
  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000ab	e8 00 00 00 00	 call	 gz_error

; 296  :         return 0;

  000b0	33 c0		 xor	 eax, eax
  000b2	eb 38		 jmp	 SHORT $LN1@gzfwrite
$LN5@gzfwrite:

; 297  :     }
; 298  : 
; 299  :     /* write len bytes to buf, return the number of full items written */
; 300  :     return len ? gz_write(state, buf, len) / size : 0;

  000b4	48 83 7c 24 20
	00		 cmp	 QWORD PTR len$[rsp], 0
  000ba	74 22		 je	 SHORT $LN7@gzfwrite
  000bc	4c 8b 44 24 20	 mov	 r8, QWORD PTR len$[rsp]
  000c1	48 8b 54 24 50	 mov	 rdx, QWORD PTR buf$[rsp]
  000c6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000cb	e8 00 00 00 00	 call	 gz_write
  000d0	33 d2		 xor	 edx, edx
  000d2	48 f7 74 24 58	 div	 QWORD PTR size$[rsp]
  000d7	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
  000dc	eb 09		 jmp	 SHORT $LN8@gzfwrite
$LN7@gzfwrite:
  000de	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv82[rsp], 0
$LN8@gzfwrite:
  000e7	48 8b 44 24 30	 mov	 rax, QWORD PTR tv82[rsp]
$LN1@gzfwrite:

; 301  : }

  000ec	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f0	5f		 pop	 rdi
  000f1	c3		 ret	 0
gzfwrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzputc
_TEXT	SEGMENT
have$ = 32
buf$ = 52
state$ = 72
strm$ = 80
file$ = 112
c$ = 120
gzputc	PROC						; COMDAT

; 307  : {

$LN14:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 18 00 00 00	 mov	 ecx, 24
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 308  :     unsigned have;
; 309  :     unsigned char buf[1];
; 310  :     gz_statep state;
; 311  :     z_streamp strm;
; 312  : 
; 313  :     /* get internal structure */
; 314  :     if (file == NULL)

  0002e	48 83 7c 24 70
	00		 cmp	 QWORD PTR file$[rsp], 0
  00034	75 0a		 jne	 SHORT $LN2@gzputc

; 315  :         return -1;

  00036	b8 ff ff ff ff	 mov	 eax, -1
  0003b	e9 54 01 00 00	 jmp	 $LN1@gzputc
$LN2@gzputc:

; 316  :     state = (gz_statep)file;

  00040	48 8b 44 24 70	 mov	 rax, QWORD PTR file$[rsp]
  00045	48 89 44 24 48	 mov	 QWORD PTR state$[rsp], rax

; 317  :     strm = &(state->strm);

  0004a	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  0004f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00053	48 89 44 24 50	 mov	 QWORD PTR strm$[rsp], rax

; 318  : 
; 319  :     /* check that we're writing and that there's no error */
; 320  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00058	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  0005d	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  00064	75 0b		 jne	 SHORT $LN4@gzputc
  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  0006b	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  0006f	74 0a		 je	 SHORT $LN3@gzputc
$LN4@gzputc:

; 321  :         return -1;

  00071	b8 ff ff ff ff	 mov	 eax, -1
  00076	e9 19 01 00 00	 jmp	 $LN1@gzputc
$LN3@gzputc:

; 322  : 
; 323  :     /* check for seek request */
; 324  :     if (state->seek) {

  0007b	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00080	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00084	74 2e		 je	 SHORT $LN5@gzputc

; 325  :         state->seek = 0;

  00086	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  0008b	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 326  :         if (gz_zero(state, state->skip) == -1)

  00092	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00097	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0009b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  000a0	e8 00 00 00 00	 call	 gz_zero
  000a5	83 f8 ff	 cmp	 eax, -1
  000a8	75 0a		 jne	 SHORT $LN6@gzputc

; 327  :             return -1;

  000aa	b8 ff ff ff ff	 mov	 eax, -1
  000af	e9 e0 00 00 00	 jmp	 $LN1@gzputc
$LN6@gzputc:
$LN5@gzputc:

; 328  :     }
; 329  : 
; 330  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 331  :        initialized) */
; 332  :     if (state->size) {

  000b4	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  000b9	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  000bd	0f 84 94 00 00
	00		 je	 $LN7@gzputc

; 333  :         if (strm->avail_in == 0)

  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000c8	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000cc	75 11		 jne	 SHORT $LN8@gzputc

; 334  :             strm->next_in = state->in;

  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000d3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  000d8	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000dc	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN8@gzputc:

; 335  :         have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  000df	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000e4	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  000ec	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ef	48 03 c8	 add	 rcx, rax
  000f2	48 8b c1	 mov	 rax, rcx
  000f5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  000fa	48 2b 41 30	 sub	 rax, QWORD PTR [rcx+48]
  000fe	89 44 24 20	 mov	 DWORD PTR have$[rsp], eax

; 336  :         if (have < state->size) {

  00102	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  00107	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0010a	39 44 24 20	 cmp	 DWORD PTR have$[rsp], eax
  0010e	73 47		 jae	 SHORT $LN9@gzputc

; 337  :             state->in[have] = (unsigned char)c;

  00110	8b 44 24 20	 mov	 eax, DWORD PTR have$[rsp]
  00114	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00119	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0011d	0f b6 54 24 78	 movzx	 edx, BYTE PTR c$[rsp]
  00122	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 338  :             strm->avail_in++;

  00125	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0012a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0012d	ff c0		 inc	 eax
  0012f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00134	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 339  :             state->x.pos++;

  00137	48 8b 44 24 48	 mov	 rax, QWORD PTR state$[rsp]
  0013c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00140	48 ff c0	 inc	 rax
  00143	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00148	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 340  :             return c & 0xff;

  0014c	8b 44 24 78	 mov	 eax, DWORD PTR c$[rsp]
  00150	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00155	eb 3d		 jmp	 SHORT $LN1@gzputc
$LN9@gzputc:
$LN7@gzputc:

; 341  :         }
; 342  :     }
; 343  : 
; 344  :     /* no room in buffer or not initialized, use gz_write() */
; 345  :     buf[0] = (unsigned char)c;

  00157	b8 01 00 00 00	 mov	 eax, 1
  0015c	48 6b c0 00	 imul	 rax, rax, 0
  00160	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR c$[rsp]
  00165	88 4c 04 34	 mov	 BYTE PTR buf$[rsp+rax], cl

; 346  :     if (gz_write(state, buf, 1) != 1)

  00169	41 b8 01 00 00
	00		 mov	 r8d, 1
  0016f	48 8d 54 24 34	 lea	 rdx, QWORD PTR buf$[rsp]
  00174	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00179	e8 00 00 00 00	 call	 gz_write
  0017e	48 83 f8 01	 cmp	 rax, 1
  00182	74 07		 je	 SHORT $LN10@gzputc

; 347  :         return -1;

  00184	b8 ff ff ff ff	 mov	 eax, -1
  00189	eb 09		 jmp	 SHORT $LN1@gzputc
$LN10@gzputc:

; 348  :     return c & 0xff;

  0018b	8b 44 24 78	 mov	 eax, DWORD PTR c$[rsp]
  0018f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
$LN1@gzputc:

; 349  : }

  00194	48 8b f8	 mov	 rdi, rax
  00197	48 8b cc	 mov	 rcx, rsp
  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gzputc$rtcFrameData
  001a1	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  001a6	48 8b c7	 mov	 rax, rdi
  001a9	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001ad	5f		 pop	 rdi
  001ae	c3		 ret	 0
gzputc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzputs
_TEXT	SEGMENT
ret$ = 32
len$ = 40
state$ = 48
tv78 = 56
file$ = 80
str$ = 88
gzputs	PROC						; COMDAT

; 355  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002a	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 356  :     int ret;
; 357  :     z_size_t len;
; 358  :     gz_statep state;
; 359  : 
; 360  :     /* get internal structure */
; 361  :     if (file == NULL)

  0002f	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  00035	75 07		 jne	 SHORT $LN2@gzputs

; 362  :         return -1;

  00037	b8 ff ff ff ff	 mov	 eax, -1
  0003c	eb 77		 jmp	 SHORT $LN1@gzputs
$LN2@gzputs:

; 363  :     state = (gz_statep)file;

  0003e	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  00043	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 364  : 
; 365  :     /* check that we're writing and that there's no error */
; 366  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0004d	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  00054	75 0b		 jne	 SHORT $LN4@gzputs
  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0005b	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  0005f	74 07		 je	 SHORT $LN3@gzputs
$LN4@gzputs:

; 367  :         return -1;

  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	eb 4d		 jmp	 SHORT $LN1@gzputs
$LN3@gzputs:

; 368  : 
; 369  :     /* write string */
; 370  :     len = strlen(str);

  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlen
  00073	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 371  :     ret = gz_write(state, str, len);

  00078	4c 8b 44 24 28	 mov	 r8, QWORD PTR len$[rsp]
  0007d	48 8b 54 24 58	 mov	 rdx, QWORD PTR str$[rsp]
  00082	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00087	e8 00 00 00 00	 call	 gz_write
  0008c	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 372  :     return ret == 0 && len != 0 ? -1 : ret;

  00090	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  00095	75 12		 jne	 SHORT $LN6@gzputs
  00097	48 83 7c 24 28
	00		 cmp	 QWORD PTR len$[rsp], 0
  0009d	74 0a		 je	 SHORT $LN6@gzputs
  0009f	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR tv78[rsp], -1
  000a7	eb 08		 jmp	 SHORT $LN7@gzputs
$LN6@gzputs:
  000a9	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
  000ad	89 44 24 38	 mov	 DWORD PTR tv78[rsp], eax
$LN7@gzputs:
  000b1	8b 44 24 38	 mov	 eax, DWORD PTR tv78[rsp]
$LN1@gzputs:

; 373  : }

  000b5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
gzputs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\stdio.h
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzvprintf
_TEXT	SEGMENT
len$ = 48
left$ = 52
next$ = 56
state$ = 64
strm$ = 72
_BufferCount$ = 80
_Result$1 = 88
tv194 = 92
file$ = 112
format$ = 120
va$ = 128
gzvprintf PROC						; COMDAT

; 380  : {

$LN19:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8b fc	 mov	 rdi, rsp
  00017	b9 18 00 00 00	 mov	 ecx, 24
  0001c	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00021	f3 ab		 rep stosd
  00023	48 8b 4c 24 70	 mov	 rcx, QWORD PTR [rsp+112]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002f	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 381  :     int len;
; 382  :     unsigned left;
; 383  :     char *next;
; 384  :     gz_statep state;
; 385  :     z_streamp strm;
; 386  : 
; 387  :     /* get internal structure */
; 388  :     if (file == NULL)

  00034	48 83 7c 24 70
	00		 cmp	 QWORD PTR file$[rsp], 0
  0003a	75 0a		 jne	 SHORT $LN2@gzvprintf

; 389  :         return Z_STREAM_ERROR;

  0003c	b8 fe ff ff ff	 mov	 eax, -2
  00041	e9 73 02 00 00	 jmp	 $LN1@gzvprintf
$LN2@gzvprintf:

; 390  :     state = (gz_statep)file;

  00046	48 8b 44 24 70	 mov	 rax, QWORD PTR file$[rsp]
  0004b	48 89 44 24 40	 mov	 QWORD PTR state$[rsp], rax

; 391  :     strm = &(state->strm);

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00055	48 83 c0 78	 add	 rax, 120		; 00000078H
  00059	48 89 44 24 48	 mov	 QWORD PTR strm$[rsp], rax

; 392  : 
; 393  :     /* check that we're writing and that there's no error */
; 394  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0005e	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00063	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  0006a	75 0b		 jne	 SHORT $LN4@gzvprintf
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00071	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00075	74 0a		 je	 SHORT $LN3@gzvprintf
$LN4@gzvprintf:

; 395  :         return Z_STREAM_ERROR;

  00077	b8 fe ff ff ff	 mov	 eax, -2
  0007c	e9 38 02 00 00	 jmp	 $LN1@gzvprintf
$LN3@gzvprintf:

; 396  : 
; 397  :     /* make sure we have some buffer space */
; 398  :     if (state->size == 0 && gz_init(state) == -1)

  00081	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00086	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0008a	75 1c		 jne	 SHORT $LN5@gzvprintf
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00091	e8 00 00 00 00	 call	 gz_init
  00096	83 f8 ff	 cmp	 eax, -1
  00099	75 0d		 jne	 SHORT $LN5@gzvprintf

; 399  :         return state->err;

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000a0	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000a3	e9 11 02 00 00	 jmp	 $LN1@gzvprintf
$LN5@gzvprintf:

; 400  : 
; 401  :     /* check for seek request */
; 402  :     if (state->seek) {

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000ad	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  000b1	74 31		 je	 SHORT $LN6@gzvprintf

; 403  :         state->seek = 0;

  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000b8	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 404  :         if (gz_zero(state, state->skip) == -1)

  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000c4	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000cd	e8 00 00 00 00	 call	 gz_zero
  000d2	83 f8 ff	 cmp	 eax, -1
  000d5	75 0d		 jne	 SHORT $LN7@gzvprintf

; 405  :             return state->err;

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  000dc	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000df	e9 d5 01 00 00	 jmp	 $LN1@gzvprintf
$LN7@gzvprintf:
$LN6@gzvprintf:

; 406  :     }
; 407  : 
; 408  :     /* do the printf() into the input buffer, put length in len -- the input
; 409  :        buffer is double-sized just for this function, so there is guaranteed to
; 410  :        be state->size bytes available after the current contents */
; 411  :     if (strm->avail_in == 0)

  000e4	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  000e9	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000ed	75 11		 jne	 SHORT $LN8@gzvprintf

; 412  :         strm->next_in = state->in;

  000ef	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  000f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  000f9	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000fd	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN8@gzvprintf:

; 413  :     next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);

  00100	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  00105	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0010a	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0010e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00111	48 2b c1	 sub	 rax, rcx
  00114	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00119	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0011d	48 03 c8	 add	 rcx, rax
  00120	48 8b c1	 mov	 rax, rcx
  00123	48 8b 4c 24 48	 mov	 rcx, QWORD PTR strm$[rsp]
  00128	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0012b	48 03 c1	 add	 rax, rcx
  0012e	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 414  :     next[state->size - 1] = 0;

  00133	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00138	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0013b	ff c8		 dec	 eax
  0013d	8b c0		 mov	 eax, eax
  0013f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  00144	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 428  :     len = vsnprintf(next, state->size, format, va);

  00148	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0014d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00150	48 89 44 24 50	 mov	 QWORD PTR _BufferCount$[rsp], rax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\stdio.h

; 1438 :         int const _Result = __stdio_common_vsprintf(

  00155	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0015a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0015d	48 83 c8 02	 or	 rax, 2
  00161	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR va$[rsp]
  00169	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00177	4c 8b 4c 24 78	 mov	 r9, QWORD PTR format$[rsp]
  0017c	4c 8b 44 24 50	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00181	48 8b 54 24 38	 mov	 rdx, QWORD PTR next$[rsp]
  00186	48 8b c8	 mov	 rcx, rax
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  0018f	89 44 24 58	 mov	 DWORD PTR _Result$1[rsp], eax

; 1439 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1440 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1441 : 
; 1442 :         return _Result < 0 ? -1 : _Result;

  00193	83 7c 24 58 00	 cmp	 DWORD PTR _Result$1[rsp], 0
  00198	7d 0a		 jge	 SHORT $LN16@gzvprintf
  0019a	c7 44 24 5c ff
	ff ff ff	 mov	 DWORD PTR tv194[rsp], -1
  001a2	eb 08		 jmp	 SHORT $LN17@gzvprintf
$LN16@gzvprintf:
  001a4	8b 44 24 58	 mov	 eax, DWORD PTR _Result$1[rsp]
  001a8	89 44 24 5c	 mov	 DWORD PTR tv194[rsp], eax
$LN17@gzvprintf:
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c

; 428  :     len = vsnprintf(next, state->size, format, va);

  001ac	8b 44 24 5c	 mov	 eax, DWORD PTR tv194[rsp]
  001b0	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 429  : #  endif
; 430  : #endif
; 431  : 
; 432  :     /* check that printf() results fit in buffer */
; 433  :     if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)

  001b4	83 7c 24 30 00	 cmp	 DWORD PTR len$[rsp], 0
  001b9	74 27		 je	 SHORT $LN10@gzvprintf
  001bb	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  001c0	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001c3	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  001c7	73 19		 jae	 SHORT $LN10@gzvprintf
  001c9	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  001ce	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001d1	ff c8		 dec	 eax
  001d3	8b c0		 mov	 eax, eax
  001d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  001da	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  001de	85 c0		 test	 eax, eax
  001e0	74 07		 je	 SHORT $LN9@gzvprintf
$LN10@gzvprintf:

; 434  :         return 0;

  001e2	33 c0		 xor	 eax, eax
  001e4	e9 d0 00 00 00	 jmp	 $LN1@gzvprintf
$LN9@gzvprintf:

; 435  : 
; 436  :     /* update buffer and position, compress first half if past that */
; 437  :     strm->avail_in += (unsigned)len;

  001e9	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  001ee	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001f1	03 44 24 30	 add	 eax, DWORD PTR len$[rsp]
  001f5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR strm$[rsp]
  001fa	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 438  :     state->x.pos += len;

  001fd	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00202	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00207	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0020b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00210	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 439  :     if (strm->avail_in >= state->size) {

  00214	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  00219	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0021e	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00221	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00224	0f 82 88 00 00
	00		 jb	 $LN11@gzvprintf

; 440  :         left = strm->avail_in - state->size;

  0022a	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  0022f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00234	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00237	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0023a	2b c1		 sub	 eax, ecx
  0023c	89 44 24 34	 mov	 DWORD PTR left$[rsp], eax

; 441  :         strm->avail_in = state->size;

  00240	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  00245	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0024a	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0024d	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 442  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00250	33 d2		 xor	 edx, edx
  00252	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00257	e8 00 00 00 00	 call	 gz_comp
  0025c	83 f8 ff	 cmp	 eax, -1
  0025f	75 0a		 jne	 SHORT $LN12@gzvprintf

; 443  :             return state->err;

  00261	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  00266	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00269	eb 4e		 jmp	 SHORT $LN1@gzvprintf
$LN12@gzvprintf:

; 444  :         memcpy(state->in, state->in + state->size, left);

  0026b	8b 44 24 34	 mov	 eax, DWORD PTR left$[rsp]
  0026f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00274	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00277	48 8b 54 24 40	 mov	 rdx, QWORD PTR state$[rsp]
  0027c	48 03 4a 30	 add	 rcx, QWORD PTR [rdx+48]
  00280	44 8b c0	 mov	 r8d, eax
  00283	48 8b d1	 mov	 rdx, rcx
  00286	48 8b 44 24 40	 mov	 rax, QWORD PTR state$[rsp]
  0028b	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0028f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memcpy

; 445  :         strm->next_in = state->in;

  00295	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  0029a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0029f	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  002a3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 446  :         strm->avail_in = left;

  002a6	48 8b 44 24 48	 mov	 rax, QWORD PTR strm$[rsp]
  002ab	8b 4c 24 34	 mov	 ecx, DWORD PTR left$[rsp]
  002af	89 48 08	 mov	 DWORD PTR [rax+8], ecx
$LN11@gzvprintf:

; 447  :     }
; 448  :     return len;

  002b2	0f ae e8	 lfence
  002b5	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
$LN1@gzvprintf:

; 449  : }

  002b9	48 83 c4 60	 add	 rsp, 96			; 00000060H
  002bd	5f		 pop	 rdi
  002be	c3		 ret	 0
gzvprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzprintf
_TEXT	SEGMENT
va$ = 40
ret$ = 52
file$ = 80
format$ = 88
gzprintf PROC						; COMDAT

; 452  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00019	48 8b fc	 mov	 rdi, rsp
  0001c	b9 10 00 00 00	 mov	 ecx, 16
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR [rsp+80]
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00034	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 453  :     va_list va;
; 454  :     int ret;
; 455  : 
; 456  :     va_start(va, format);

  00039	48 8d 44 24 60	 lea	 rax, QWORD PTR format$[rsp+8]
  0003e	48 89 44 24 28	 mov	 QWORD PTR va$[rsp], rax

; 457  :     ret = gzvprintf(file, format, va);

  00043	4c 8b 44 24 28	 mov	 r8, QWORD PTR va$[rsp]
  00048	48 8b 54 24 58	 mov	 rdx, QWORD PTR format$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00052	e8 00 00 00 00	 call	 gzvprintf
  00057	89 44 24 34	 mov	 DWORD PTR ret$[rsp], eax

; 458  :     va_end(va);

  0005b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 459  :     return ret;

  00064	8b 44 24 34	 mov	 eax, DWORD PTR ret$[rsp]

; 460  : }

  00068	8b f8		 mov	 edi, eax
  0006a	48 8b cc	 mov	 rcx, rsp
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gzprintf$rtcFrameData
  00074	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00079	8b c7		 mov	 eax, edi
  0007b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
gzprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzflush
_TEXT	SEGMENT
state$ = 32
file$ = 64
flush$ = 72
gzflush	PROC						; COMDAT

; 556  : {

$LN11:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b fc	 mov	 rdi, rsp
  00011	b9 0c 00 00 00	 mov	 ecx, 12
  00016	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001b	f3 ab		 rep stosd
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  00029	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 557  :     gz_statep state;
; 558  : 
; 559  :     /* get internal structure */
; 560  :     if (file == NULL)

  0002e	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00034	75 0a		 jne	 SHORT $LN2@gzflush

; 561  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2
  0003b	e9 91 00 00 00	 jmp	 $LN1@gzflush
$LN2@gzflush:

; 562  :     state = (gz_statep)file;

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00045	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 563  : 
; 564  :     /* check that we're writing and that there's no error */
; 565  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0004f	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  00056	75 0b		 jne	 SHORT $LN4@gzflush
  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0005d	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00061	74 07		 je	 SHORT $LN3@gzflush
$LN4@gzflush:

; 566  :         return Z_STREAM_ERROR;

  00063	b8 fe ff ff ff	 mov	 eax, -2
  00068	eb 67		 jmp	 SHORT $LN1@gzflush
$LN3@gzflush:

; 567  : 
; 568  :     /* check flush parameter */
; 569  :     if (flush < 0 || flush > Z_FINISH)

  0006a	83 7c 24 48 00	 cmp	 DWORD PTR flush$[rsp], 0
  0006f	7c 07		 jl	 SHORT $LN6@gzflush
  00071	83 7c 24 48 04	 cmp	 DWORD PTR flush$[rsp], 4
  00076	7e 07		 jle	 SHORT $LN5@gzflush
$LN6@gzflush:

; 570  :         return Z_STREAM_ERROR;

  00078	b8 fe ff ff ff	 mov	 eax, -2
  0007d	eb 52		 jmp	 SHORT $LN1@gzflush
$LN5@gzflush:

; 571  : 
; 572  :     /* check for seek request */
; 573  :     if (state->seek) {

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00084	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00088	74 2e		 je	 SHORT $LN7@gzflush

; 574  :         state->seek = 0;

  0008a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0008f	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 575  :         if (gz_zero(state, state->skip) == -1)

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0009b	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0009f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000a4	e8 00 00 00 00	 call	 gz_zero
  000a9	83 f8 ff	 cmp	 eax, -1
  000ac	75 0a		 jne	 SHORT $LN8@gzflush

; 576  :             return state->err;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000b3	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000b6	eb 19		 jmp	 SHORT $LN1@gzflush
$LN8@gzflush:
$LN7@gzflush:

; 577  :     }
; 578  : 
; 579  :     /* compress remaining data with requested flush */
; 580  :     (void)gz_comp(state, flush);

  000b8	0f ae e8	 lfence
  000bb	8b 54 24 48	 mov	 edx, DWORD PTR flush$[rsp]
  000bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000c4	e8 00 00 00 00	 call	 gz_comp

; 581  :     return state->err;

  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000ce	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
$LN1@gzflush:

; 582  : }

  000d1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d5	5f		 pop	 rdi
  000d6	c3		 ret	 0
gzflush	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File E:\cpython\externals\zlib-1.2.11\gzwrite.c
;	COMDAT gzsetparams
_TEXT	SEGMENT
state$ = 32
strm$ = 40
file$ = 64
level$ = 72
strategy$ = 80
gzsetparams PROC					; COMDAT

; 589  : {

$LN12:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00013	48 8b fc	 mov	 rdi, rsp
  00016	b9 0c 00 00 00	 mov	 ecx, 12
  0001b	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00020	f3 ab		 rep stosd
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR [rsp+64]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__2B8D9255_zutil@c
  0002e	e8 00 00 00 00	 call	 __CheckForDebuggerJustMyCode

; 590  :     gz_statep state;
; 591  :     z_streamp strm;
; 592  : 
; 593  :     /* get internal structure */
; 594  :     if (file == NULL)

  00033	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  00039	75 0a		 jne	 SHORT $LN2@gzsetparam

; 595  :         return Z_STREAM_ERROR;

  0003b	b8 fe ff ff ff	 mov	 eax, -2
  00040	e9 f8 00 00 00	 jmp	 $LN1@gzsetparam
$LN2@gzsetparam:

; 596  :     state = (gz_statep)file;

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0004a	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 597  :     strm = &(state->strm);

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00054	48 83 c0 78	 add	 rax, 120		; 00000078H
  00058	48 89 44 24 28	 mov	 QWORD PTR strm$[rsp], rax

; 598  : 
; 599  :     /* check that we're writing and that there's no error */
; 600  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00062	81 78 18 b1 79
	00 00		 cmp	 DWORD PTR [rax+24], 31153 ; 000079b1H
  00069	75 0b		 jne	 SHORT $LN4@gzsetparam
  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00070	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00074	74 0a		 je	 SHORT $LN3@gzsetparam
$LN4@gzsetparam:

; 601  :         return Z_STREAM_ERROR;

  00076	b8 fe ff ff ff	 mov	 eax, -2
  0007b	e9 bd 00 00 00	 jmp	 $LN1@gzsetparam
$LN3@gzsetparam:

; 602  : 
; 603  :     /* if no change is requested, then do nothing */
; 604  :     if (level == state->level && strategy == state->strategy)

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00085	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00088	39 44 24 48	 cmp	 DWORD PTR level$[rsp], eax
  0008c	75 15		 jne	 SHORT $LN5@gzsetparam
  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00093	8b 40 5c	 mov	 eax, DWORD PTR [rax+92]
  00096	39 44 24 50	 cmp	 DWORD PTR strategy$[rsp], eax
  0009a	75 07		 jne	 SHORT $LN5@gzsetparam

; 605  :         return Z_OK;

  0009c	33 c0		 xor	 eax, eax
  0009e	e9 9a 00 00 00	 jmp	 $LN1@gzsetparam
$LN5@gzsetparam:

; 606  : 
; 607  :     /* check for seek request */
; 608  :     if (state->seek) {

  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000a8	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  000ac	74 2e		 je	 SHORT $LN6@gzsetparam

; 609  :         state->seek = 0;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000b3	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 610  :         if (gz_zero(state, state->skip) == -1)

  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000bf	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000c8	e8 00 00 00 00	 call	 gz_zero
  000cd	83 f8 ff	 cmp	 eax, -1
  000d0	75 0a		 jne	 SHORT $LN7@gzsetparam

; 611  :             return state->err;

  000d2	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000d7	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000da	eb 61		 jmp	 SHORT $LN1@gzsetparam
$LN7@gzsetparam:
$LN6@gzsetparam:

; 612  :     }
; 613  : 
; 614  :     /* change compression parameters for subsequent input */
; 615  :     if (state->size) {

  000dc	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000e1	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  000e5	74 3c		 je	 SHORT $LN8@gzsetparam

; 616  :         /* flush previous input with previous parameters before changing */
; 617  :         if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)

  000e7	48 8b 44 24 28	 mov	 rax, QWORD PTR strm$[rsp]
  000ec	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000f0	74 1e		 je	 SHORT $LN9@gzsetparam
  000f2	ba 05 00 00 00	 mov	 edx, 5
  000f7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000fc	e8 00 00 00 00	 call	 gz_comp
  00101	83 f8 ff	 cmp	 eax, -1
  00104	75 0a		 jne	 SHORT $LN9@gzsetparam

; 618  :             return state->err;

  00106	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0010b	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0010e	eb 2d		 jmp	 SHORT $LN1@gzsetparam
$LN9@gzsetparam:

; 619  :         deflateParams(strm, level, strategy);

  00110	44 8b 44 24 50	 mov	 r8d, DWORD PTR strategy$[rsp]
  00115	8b 54 24 48	 mov	 edx, DWORD PTR level$[rsp]
  00119	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strm$[rsp]
  0011e	e8 00 00 00 00	 call	 deflateParams
$LN8@gzsetparam:

; 620  :     }
; 621  :     state->level = level;

  00123	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00128	8b 4c 24 48	 mov	 ecx, DWORD PTR level$[rsp]
  0012c	89 48 58	 mov	 DWORD PTR [rax+88], ecx

; 622  :     state->strategy = strategy;

  0012f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00134	8b 4c 24 50	 mov	 ecx, DWORD PTR strategy$[rsp]
  00138	89 48 5c	 mov	 DWORD PTR [rax+92], ecx

; 623  :     return Z_OK;

  0013b	33 c0		 xor	 eax, eax
$LN1@gzsetparam:

; 624  : }

  0013d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00141	5f		 pop	 rdi
  00142	c3		 ret	 0
gzsetparams ENDP
_TEXT	ENDS
END
