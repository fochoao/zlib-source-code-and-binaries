; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30133.0 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+10
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	04dH
	DW	0caH
	ORG $+2
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
PUBLIC	inflate_table
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN179
	DD	imagerel $LN179+545
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflate_table DD imagerel $LN179+545
	DD	imagerel $LN179+727
	DD	imagerel $chain$1$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflate_table DD imagerel $LN179+727
	DD	imagerel $LN179+1430
	DD	imagerel $chain$3$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflate_table DD imagerel $LN179+1430
	DD	imagerel $LN179+1450
	DD	imagerel $chain$4$inflate_table
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflate_table DD 021H
	DD	imagerel $LN179
	DD	imagerel $LN179+545
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflate_table DD 040021H
	DD	0d6400H
	DD	0e5400H
	DD	imagerel $LN179
	DD	imagerel $LN179+545
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflate_table DD 040a21H
	DD	0d640aH
	DD	0e5405H
	DD	imagerel $LN179
	DD	imagerel $LN179+545
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 071c01H
	DD	0f018e21cH
	DD	0d014e016H
	DD	07010c012H
	DD	0300fH
; Function compile flags: /Ogtpy
; File C:\cpython\externals\zlib-1.2.11\inftrees.c
;	COMDAT inflate_table
_TEXT	SEGMENT
match$1$ = 0
mask$1$ = 4
sym$1$ = 8
tv1918 = 12
extra$1$ = 16
base$1$ = 24
count$ = 32
offs$ = 64
type$ = 176
lens$ = 184
here$ = 192
codes$ = 192
table$ = 200
bits$ = 208
work$ = 216
inflate_table PROC					; COMDAT

; 39   : {

$LN179:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	53		 push	 rbx
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     unsigned match;             /* use base and extra for symbol >= match */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 77, 202};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  0001c	45 33 ff	 xor	 r15d, r15d
  0001f	41 8b d8	 mov	 ebx, r8d
  00022	45 0f b7 d7	 movzx	 r10d, r15w
  00026	4d 8b f1	 mov	 r14, r9
  00029	41 8b c2	 mov	 eax, r10d
  0002c	48 8b fa	 mov	 rdi, rdx
  0002f	41 c1 e2 10	 shl	 r10d, 16
  00033	44 8b e9	 mov	 r13d, ecx
  00036	44 0b d0	 or	 r10d, eax
  00039	66 41 0f 6e c2	 movd	 xmm0, r10d
  0003e	66 0f 70 c0 00	 pshufd	 xmm0, xmm0, 0
  00043	0f 11 44 24 20	 movups	 XMMWORD PTR count$[rsp], xmm0
  00048	0f 11 44 24 30	 movups	 XMMWORD PTR count$[rsp+16], xmm0

; 108  :         count[len] = 0;
; 109  :     for (sym = 0; sym < codes; sym++)

  0004d	45 85 c0	 test	 r8d, r8d
  00050	74 20		 je	 SHORT $LN6@inflate_ta
  00052	48 8b ca	 mov	 rcx, rdx
  00055	8b d3		 mov	 edx, ebx
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@inflate_ta:

; 110  :         count[lens[sym]]++;

  00060	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00063	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  00067	66 ff 44 44 20	 inc	 WORD PTR count$[rsp+rax*2]
  0006c	48 83 ea 01	 sub	 rdx, 1
  00070	75 ee		 jne	 SHORT $LL7@inflate_ta
$LN6@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00072	4c 8b 94 24 d0
	00 00 00	 mov	 r10, QWORD PTR bits$[rsp]
  0007a	ba 0d 00 00 00	 mov	 edx, 13

; 114  :     for (max = MAXBITS; max >= 1; max--)

  0007f	41 b9 0f 00 00
	00		 mov	 r9d, 15
  00085	45 8b 02	 mov	 r8d, DWORD PTR [r10]
  00088	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL10@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00090	41 8b c1	 mov	 eax, r9d
  00093	41 bc ff ff ff
	ff		 mov	 r12d, -1		; ffffffffH
  00099	66 44 39 7c 44
	20		 cmp	 WORD PTR count$[rsp+rax*2], r15w
  0009f	75 4f		 jne	 SHORT $LN78@inflate_ta
  000a1	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  000a4	66 44 39 7c 44
	20		 cmp	 WORD PTR count$[rsp+rax*2], r15w
  000aa	75 41		 jne	 SHORT $LN130@inflate_ta
  000ac	8b c2		 mov	 eax, edx
  000ae	66 44 39 7c 44
	20		 cmp	 WORD PTR count$[rsp+rax*2], r15w
  000b4	75 31		 jne	 SHORT $LN131@inflate_ta
  000b6	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  000b9	66 44 39 7c 44
	20		 cmp	 WORD PTR count$[rsp+rax*2], r15w
  000bf	75 20		 jne	 SHORT $LN132@inflate_ta
  000c1	8d 42 fe	 lea	 eax, DWORD PTR [rdx-2]
  000c4	66 44 39 7c 44
	20		 cmp	 WORD PTR count$[rsp+rax*2], r15w
  000ca	75 0f		 jne	 SHORT $LN133@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  000cc	41 83 c1 fb	 add	 r9d, -5			; fffffffbH
  000d0	83 c2 fb	 add	 edx, -5			; fffffffbH
  000d3	41 83 f9 01	 cmp	 r9d, 1
  000d7	73 b7		 jae	 SHORT $LL10@inflate_ta
  000d9	eb 15		 jmp	 SHORT $LN78@inflate_ta
$LN133@inflate_ta:

; 115  :         if (count[max] != 0) break;

  000db	41 83 c1 fc	 add	 r9d, -4			; fffffffcH
  000df	eb 0f		 jmp	 SHORT $LN78@inflate_ta
$LN132@inflate_ta:
  000e1	41 83 c1 fd	 add	 r9d, -3			; fffffffdH
  000e5	eb 09		 jmp	 SHORT $LN78@inflate_ta
$LN131@inflate_ta:
  000e7	41 83 c1 fe	 add	 r9d, -2			; fffffffeH
  000eb	eb 03		 jmp	 SHORT $LN78@inflate_ta
$LN130@inflate_ta:
  000ed	45 03 cc	 add	 r9d, r12d
$LN78@inflate_ta:

; 116  :     if (root > max) root = max;
; 117  :     if (max == 0) {                     /* no symbols to code at all */

  000f0	45 3b c1	 cmp	 r8d, r9d
  000f3	41 8b c9	 mov	 ecx, r9d
  000f6	41 0f 46 c8	 cmovbe	 ecx, r8d
  000fa	45 85 c9	 test	 r9d, r9d
  000fd	75 3c		 jne	 SHORT $LN37@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000ff	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  00102	c7 84 24 c0 00
	00 00 40 01 00
	00		 mov	 DWORD PTR here$[rsp], 320 ; 00000140H
  0010d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR here$[rsp]
  00114	89 01		 mov	 DWORD PTR [rcx], eax
  00116	49 83 06 04	 add	 QWORD PTR [r14], 4
  0011a	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  0011d	89 01		 mov	 DWORD PTR [rcx], eax
  0011f	49 83 06 04	 add	 QWORD PTR [r14], 4

; 122  :         *(*table)++ = here;
; 123  :         *bits = 1;
; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  00123	33 c0		 xor	 eax, eax
  00125	41 c7 02 01 00
	00 00		 mov	 DWORD PTR [r10], 1

; 304  : }

  0012c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00130	41 5f		 pop	 r15
  00132	41 5e		 pop	 r14
  00134	41 5d		 pop	 r13
  00136	41 5c		 pop	 r12
  00138	5f		 pop	 rdi
  00139	5b		 pop	 rbx
  0013a	c3		 ret	 0
$LN37@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  0013b	41 bb 01 00 00
	00		 mov	 r11d, 1
  00141	45 3b cb	 cmp	 r9d, r11d
  00144	76 1c		 jbe	 SHORT $LN163@inflate_ta
  00146	48 8d 44 24 22	 lea	 rax, QWORD PTR count$[rsp+2]
  0014b	0f 1f 44 00 00	 npad	 5
$LL13@inflate_ta:

; 127  :         if (count[min] != 0) break;

  00150	66 44 39 38	 cmp	 WORD PTR [rax], r15w
  00154	75 0c		 jne	 SHORT $LN163@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  00156	41 ff c3	 inc	 r11d
  00159	48 83 c0 02	 add	 rax, 2
  0015d	45 3b d9	 cmp	 r11d, r9d
  00160	72 ee		 jb	 SHORT $LL13@inflate_ta
$LN163@inflate_ta:

; 128  :     if (root < min) root = min;
; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  00162	41 3b cb	 cmp	 ecx, r11d
  00165	45 8b d3	 mov	 r10d, r11d

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00168	ba 01 00 00 00	 mov	 edx, 1
  0016d	44 0f 43 d1	 cmovae	 r10d, ecx
  00171	44 8b c2	 mov	 r8d, edx
  00174	44 89 54 24 0c	 mov	 DWORD PTR tv1918[rsp], r10d
  00179	0f 1f 80 00 00
	00 00		 npad	 7
$LL16@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  00180	8b c2		 mov	 eax, edx
  00182	45 03 c0	 add	 r8d, r8d
  00185	0f b7 4c 44 20	 movzx	 ecx, WORD PTR count$[rsp+rax*2]
  0018a	44 2b c1	 sub	 r8d, ecx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  0018d	0f 88 03 04 00
	00		 js	 $LN42@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00193	ff c2		 inc	 edx
  00195	83 fa 0f	 cmp	 edx, 15
  00198	76 e6		 jbe	 SHORT $LL16@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  0019a	45 85 c0	 test	 r8d, r8d
  0019d	7e 13		 jle	 SHORT $LN41@inflate_ta
  0019f	45 85 ed	 test	 r13d, r13d
  001a2	0f 84 ee 03 00
	00		 je	 $LN42@inflate_ta
  001a8	41 83 f9 01	 cmp	 r9d, 1
  001ac	0f 85 e4 03 00
	00		 jne	 $LN42@inflate_ta
$LN41@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  001b2	66 44 89 7c 24
	42		 mov	 WORD PTR offs$[rsp+2], r15w
  001b8	49 8b cf	 mov	 rcx, r15
  001bb	ba 0e 00 00 00	 mov	 edx, 14
$LL19@inflate_ta:

; 142  :     for (len = 1; len < MAXBITS; len++)
; 143  :         offs[len + 1] = offs[len] + count[len];

  001c0	0f b7 44 0c 22	 movzx	 eax, WORD PTR count$[rsp+rcx+2]
  001c5	66 03 44 0c 42	 add	 ax, WORD PTR offs$[rsp+rcx+2]
  001ca	66 89 44 0c 44	 mov	 WORD PTR offs$[rsp+rcx+4], ax
  001cf	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  001d3	48 83 ea 01	 sub	 rdx, 1
  001d7	75 e7		 jne	 SHORT $LL19@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001d9	45 8b c7	 mov	 r8d, r15d
  001dc	85 db		 test	 ebx, ebx
  001de	74 3b		 je	 SHORT $LN21@inflate_ta
  001e0	4c 8b 94 24 d8
	00 00 00	 mov	 r10, QWORD PTR work$[rsp]
  001e8	48 8b d7	 mov	 rdx, rdi
  001eb	0f 1f 44 00 00	 npad	 5
$LL22@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  001f0	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  001f3	66 85 c0	 test	 ax, ax
  001f6	74 12		 je	 SHORT $LN20@inflate_ta
  001f8	0f b7 4c 44 40	 movzx	 ecx, WORD PTR offs$[rsp+rax*2]
  001fd	66 45 89 04 4a	 mov	 WORD PTR [r10+rcx*2], r8w
  00202	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00205	66 ff 44 44 40	 inc	 WORD PTR offs$[rsp+rax*2]
$LN20@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  0020a	41 ff c0	 inc	 r8d
  0020d	48 83 c2 02	 add	 rdx, 2
  00211	44 3b c3	 cmp	 r8d, ebx
  00214	72 da		 jb	 SHORT $LL22@inflate_ta
  00216	44 8b 54 24 0c	 mov	 r10d, DWORD PTR tv1918[rsp]
$LN21@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  0021b	4d 8b 36	 mov	 r14, QWORD PTR [r14]
  0021e	41 8b ca	 mov	 ecx, r10d
  00221	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00226	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  0022b	be 01 00 00 00	 mov	 esi, 1
  00230	d3 e6		 shl	 esi, cl
  00232	8b ee		 mov	 ebp, esi
  00234	44 8d 56 ff	 lea	 r10d, DWORD PTR [rsi-1]
  00238	44 89 54 24 04	 mov	 DWORD PTR mask$1$[rsp], r10d
  0023d	45 85 ed	 test	 r13d, r13d
  00240	0f 84 c3 00 00
	00		 je	 $LN44@inflate_ta
  00246	41 83 fd 01	 cmp	 r13d, 1
  0024a	0f 84 87 00 00
	00		 je	 $LN45@inflate_ta

; 190  :         break;
; 191  :     default:    /* DISTS */
; 192  :         base = dbase;
; 193  :         extra = dext;
; 194  :         match = 0;
; 195  :     }
; 196  : 
; 197  :     /* initialize state for loop */
; 198  :     huff = 0;                   /* starting code */
; 199  :     sym = 0;                    /* starting code symbol */
; 200  :     len = min;                  /* starting code length */
; 201  :     next = *table;              /* current table to fill in */
; 202  :     curr = root;                /* current table index bits */
; 203  :     drop = 0;                   /* current bits to drop from code for index */
; 204  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 205  :     used = 1U << root;          /* use root table entries */
; 206  :     mask = used - 1;            /* mask for comparing low */

  00250	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:?dbase@?1??inflate_table@@9@9
  00257	44 89 3c 24	 mov	 DWORD PTR match$1$[rsp], r15d
  0025b	4c 89 6c 24 18	 mov	 QWORD PTR base$1$[rsp], r13
  00260	49 8b dd	 mov	 rbx, r13
  00263	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  0026a	8b c6		 mov	 eax, esi
  0026c	4c 89 6c 24 10	 mov	 QWORD PTR extra$1$[rsp], r13
  00271	49 8b fd	 mov	 rdi, r13

; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  00274	44 8b ac 24 b0
	00 00 00	 mov	 r13d, DWORD PTR type$[rsp]
  0027c	41 83 fd 01	 cmp	 r13d, 1
  00280	74 77		 je	 SHORT $LN162@inflate_ta
  00282	48 89 5c 24 18	 mov	 QWORD PTR base$1$[rsp], rbx
  00287	48 89 7c 24 10	 mov	 QWORD PTR extra$1$[rsp], rdi
  0028c	44 89 3c 24	 mov	 DWORD PTR match$1$[rsp], r15d
  00290	44 89 54 24 04	 mov	 DWORD PTR mask$1$[rsp], r10d
  00295	41 83 fd 02	 cmp	 r13d, 2
  00299	0f 85 86 00 00
	00		 jne	 $LN166@inflate_ta
  0029f	48 89 5c 24 18	 mov	 QWORD PTR base$1$[rsp], rbx
  002a4	48 89 7c 24 10	 mov	 QWORD PTR extra$1$[rsp], rdi
  002a9	44 89 3c 24	 mov	 DWORD PTR match$1$[rsp], r15d
  002ad	44 89 54 24 04	 mov	 DWORD PTR mask$1$[rsp], r10d
  002b2	3d 50 02 00 00	 cmp	 eax, 592		; 00000250H
  002b7	76 6c		 jbe	 SHORT $LN166@inflate_ta
$LN62@inflate_ta:

; 279  :                 (type == DISTS && used > ENOUGH_DISTS))
; 280  :                 return 1;

  002b9	b8 01 00 00 00	 mov	 eax, 1
$LN175@inflate_ta:
  002be	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  002c3	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]

; 304  : }

  002c8	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002cc	41 5f		 pop	 r15
  002ce	41 5e		 pop	 r14
  002d0	41 5d		 pop	 r13
  002d2	41 5c		 pop	 r12
  002d4	5f		 pop	 rdi
  002d5	5b		 pop	 rbx
  002d6	c3		 ret	 0
$LN45@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;

  002d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9

; 188  :         extra = lext;
; 189  :         match = 257;

  002de	41 bf 01 01 00
	00		 mov	 r15d, 257		; 00000101H
  002e4	48 89 44 24 18	 mov	 QWORD PTR base$1$[rsp], rax
  002e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  002f0	48 89 44 24 10	 mov	 QWORD PTR extra$1$[rsp], rax
  002f5	44 89 3c 24	 mov	 DWORD PTR match$1$[rsp], r15d
$LN162@inflate_ta:

; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  002f9	81 fd 54 03 00
	00		 cmp	 ebp, 852		; 00000354H
  002ff	77 b8		 ja	 SHORT $LN62@inflate_ta
  00301	8b 14 24	 mov	 edx, DWORD PTR match$1$[rsp]
  00304	45 33 ff	 xor	 r15d, r15d
  00307	eb 1f		 jmp	 SHORT $LN176@inflate_ta
$LN44@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  00309	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR work$[rsp]

; 184  :         match = 20;

  00311	ba 14 00 00 00	 mov	 edx, 20
  00316	4c 89 44 24 10	 mov	 QWORD PTR extra$1$[rsp], r8
  0031b	4c 89 44 24 18	 mov	 QWORD PTR base$1$[rsp], r8
  00320	89 14 24	 mov	 DWORD PTR match$1$[rsp], edx

; 207  : 
; 208  :     /* check available table space */
; 209  :     if ((type == LENS && used > ENOUGH_LENS) ||

  00323	eb 0b		 jmp	 SHORT $LN157@inflate_ta
$LN166@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00325	41 8b d7	 mov	 edx, r15d
$LN176@inflate_ta:
  00328	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR work$[rsp]
$LN157@inflate_ta:

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  00330	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR table$[rsp]
  00338	41 8b cf	 mov	 ecx, r15d
  0033b	89 4c 24 08	 mov	 DWORD PTR sym$1$[rsp], ecx
  0033f	41 8b df	 mov	 ebx, r15d
  00342	45 8b ef	 mov	 r13d, r15d
  00345	eb 19		 jmp	 SHORT $LL25@inflate_ta
  00347	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL167@inflate_ta:
  00350	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR table$[rsp]
$LN169@inflate_ta:

; 210  :         (type == DISTS && used > ENOUGH_DISTS))
; 211  :         return 1;
; 212  : 
; 213  :     /* process all codes and make table entries */
; 214  :     for (;;) {
; 215  :         /* create table entry */
; 216  :         here.bits = (unsigned char)(len - drop);

  00358	45 33 ff	 xor	 r15d, r15d
  0035b	0f 1f 44 00 00	 npad	 5
$LL25@inflate_ta:
  00360	41 0f b6 c3	 movzx	 eax, r11b
  00364	41 2a c5	 sub	 al, r13b
  00367	88 84 24 c1 00
	00 00		 mov	 BYTE PTR here$[rsp+1], al

; 217  :         if (work[sym] + 1U < match) {

  0036e	8b c1		 mov	 eax, ecx
  00370	41 0f b7 0c 40	 movzx	 ecx, WORD PTR [r8+rax*2]
  00375	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  00378	3b c2		 cmp	 eax, edx
  0037a	73 12		 jae	 SHORT $LN50@inflate_ta

; 218  :             here.op = (unsigned char)0;

  0037c	c6 84 24 c0 00
	00 00 00	 mov	 BYTE PTR here$[rsp], 0

; 219  :             here.val = work[sym];

  00384	66 89 8c 24 c2
	00 00 00	 mov	 WORD PTR here$[rsp+2], cx

; 220  :         }

  0038c	eb 3d		 jmp	 SHORT $LN53@inflate_ta
$LN50@inflate_ta:

; 221  :         else if (work[sym] >= match) {

  0038e	3b ca		 cmp	 ecx, edx
  00390	72 28		 jb	 SHORT $LN52@inflate_ta

; 222  :             here.op = (unsigned char)(extra[work[sym] - match]);

  00392	48 8b 44 24 10	 mov	 rax, QWORD PTR extra$1$[rsp]
  00397	2b ca		 sub	 ecx, edx
  00399	48 03 c9	 add	 rcx, rcx
  0039c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003a0	88 84 24 c0 00
	00 00		 mov	 BYTE PTR here$[rsp], al

; 223  :             here.val = base[work[sym] - match];

  003a7	48 8b 44 24 18	 mov	 rax, QWORD PTR base$1$[rsp]
  003ac	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  003b0	66 89 84 24 c2
	00 00 00	 mov	 WORD PTR here$[rsp+2], ax

; 224  :         }

  003b8	eb 11		 jmp	 SHORT $LN53@inflate_ta
$LN52@inflate_ta:

; 225  :         else {
; 226  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  003ba	c6 84 24 c0 00
	00 00 60	 mov	 BYTE PTR here$[rsp], 96	; 00000060H

; 227  :             here.val = 0;

  003c2	66 44 89 bc 24
	c2 00 00 00	 mov	 WORD PTR here$[rsp+2], r15w
$LN53@inflate_ta:

; 228  :         }
; 229  : 
; 230  :         /* replicate for those indices with low len bits equal to huff */
; 231  :         incr = 1U << (len - drop);

  003cb	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR here$[rsp]
  003d2	41 8b cb	 mov	 ecx, r11d
  003d5	41 2b cd	 sub	 ecx, r13d

; 232  :         fill = 1U << curr;

  003d8	44 8b c6	 mov	 r8d, esi
  003db	41 ba 01 00 00
	00		 mov	 r10d, 1
  003e1	8b d3		 mov	 edx, ebx
  003e3	41 d3 e2	 shl	 r10d, cl
  003e6	41 8b cd	 mov	 ecx, r13d
  003e9	d3 ea		 shr	 edx, cl
  003eb	03 d6		 add	 edx, esi
  003ed	0f 1f 00	 npad	 3
$LL30@inflate_ta:

; 233  :         min = fill;                 /* save offset to next table */
; 234  :         do {
; 235  :             fill -= incr;

  003f0	41 2b d2	 sub	 edx, r10d

; 236  :             next[(huff >> drop) + fill] = here;

  003f3	41 89 04 96	 mov	 DWORD PTR [r14+rdx*4], eax
  003f7	45 2b c2	 sub	 r8d, r10d

; 237  :         } while (fill != 0);

  003fa	75 f4		 jne	 SHORT $LL30@inflate_ta

; 238  : 
; 239  :         /* backwards increment the len-bit code huff */
; 240  :         incr = 1U << (len - 1);

  003fc	41 8d 4b ff	 lea	 ecx, DWORD PTR [r11-1]
  00400	ba 01 00 00 00	 mov	 edx, 1
  00405	d3 e2		 shl	 edx, cl

; 241  :         while (huff & incr)

  00407	85 d3		 test	 edx, ebx
  00409	74 0b		 je	 SHORT $LN32@inflate_ta
  0040b	0f 1f 44 00 00	 npad	 5
$LL31@inflate_ta:

; 242  :             incr >>= 1;

  00410	d1 ea		 shr	 edx, 1
  00412	85 d3		 test	 edx, ebx
  00414	75 fa		 jne	 SHORT $LL31@inflate_ta
$LN32@inflate_ta:

; 243  :         if (incr != 0) {

  00416	85 d2		 test	 edx, edx
  00418	74 0b		 je	 SHORT $LN54@inflate_ta

; 244  :             huff &= incr - 1;

  0041a	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  0041d	23 d8		 and	 ebx, eax

; 245  :             huff += incr;

  0041f	03 da		 add	 ebx, edx

; 246  :         }

  00421	33 d2		 xor	 edx, edx
  00423	eb 04		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:

; 247  :         else
; 248  :             huff = 0;

  00425	33 d2		 xor	 edx, edx
  00427	8b da		 mov	 ebx, edx
$LN55@inflate_ta:

; 249  : 
; 250  :         /* go to next symbol, update count, len */
; 251  :         sym++;

  00429	8b 4c 24 08	 mov	 ecx, DWORD PTR sym$1$[rsp]

; 252  :         if (--(count[len]) == 0) {

  0042d	41 b8 ff ff 00
	00		 mov	 r8d, 65535		; 0000ffffH
  00433	ff c1		 inc	 ecx
  00435	41 8b c3	 mov	 eax, r11d
  00438	89 4c 24 08	 mov	 DWORD PTR sym$1$[rsp], ecx
  0043c	66 44 01 44 44
	20		 add	 WORD PTR count$[rsp+rax*2], r8w
  00442	75 29		 jne	 SHORT $LN168@inflate_ta

; 253  :             if (len == max) break;

  00444	45 3b d9	 cmp	 r11d, r9d
  00447	0f 84 0a 01 00
	00		 je	 $LN82@inflate_ta

; 254  :             len = lens[work[sym]];

  0044d	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR work$[rsp]
  00455	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  0045d	41 0f b7 0c 48	 movzx	 ecx, WORD PTR [r8+rcx*2]
  00462	44 0f b7 1c 48	 movzx	 r11d, WORD PTR [rax+rcx*2]
  00467	8b 4c 24 08	 mov	 ecx, DWORD PTR sym$1$[rsp]
  0046b	eb 08		 jmp	 SHORT $LN56@inflate_ta
$LN168@inflate_ta:

; 252  :         if (--(count[len]) == 0) {

  0046d	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR work$[rsp]
$LN56@inflate_ta:

; 255  :         }
; 256  : 
; 257  :         /* create new sub-table if needed */
; 258  :         if (len > root && (huff & mask) != low) {

  00475	8b 44 24 0c	 mov	 eax, DWORD PTR tv1918[rsp]
  00479	8b 14 24	 mov	 edx, DWORD PTR match$1$[rsp]
  0047c	44 3b d8	 cmp	 r11d, eax
  0047f	0f 86 d3 fe ff
	ff		 jbe	 $LN169@inflate_ta
  00485	8b 7c 24 04	 mov	 edi, DWORD PTR mask$1$[rsp]
  00489	23 fb		 and	 edi, ebx
  0048b	41 3b fc	 cmp	 edi, r12d
  0048e	0f 84 bc fe ff
	ff		 je	 $LL167@inflate_ta

; 259  :             /* if first time, transition to sub-tables */
; 260  :             if (drop == 0)

  00494	45 85 ed	 test	 r13d, r13d

; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  00497	4d 8d 34 b6	 lea	 r14, QWORD PTR [r14+rsi*4]

; 265  : 
; 266  :             /* determine length of next table */
; 267  :             curr = len - drop;

  0049b	45 8b d3	 mov	 r10d, r11d

; 268  :             left = (int)(1 << curr);

  0049e	ba 01 00 00 00	 mov	 edx, 1
  004a3	44 0f 44 e8	 cmove	 r13d, eax
  004a7	45 2b d5	 sub	 r10d, r13d
  004aa	41 8b ca	 mov	 ecx, r10d
  004ad	d3 e2		 shl	 edx, cl

; 269  :             while (curr + drop < max) {

  004af	45 3b d9	 cmp	 r11d, r9d
  004b2	73 27		 jae	 SHORT $LN164@inflate_ta

; 261  :                 drop = root;
; 262  : 
; 263  :             /* increment past last table */
; 264  :             next += min;            /* here min is 1 << curr */

  004b4	45 8b c3	 mov	 r8d, r11d
  004b7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL33@inflate_ta:

; 270  :                 left -= count[curr + drop];

  004c0	41 8b c0	 mov	 eax, r8d
  004c3	0f b7 4c 44 20	 movzx	 ecx, WORD PTR count$[rsp+rax*2]
  004c8	2b d1		 sub	 edx, ecx

; 271  :                 if (left <= 0) break;

  004ca	85 d2		 test	 edx, edx
  004cc	7e 0d		 jle	 SHORT $LN164@inflate_ta

; 272  :                 curr++;

  004ce	41 ff c2	 inc	 r10d
  004d1	41 ff c0	 inc	 r8d

; 273  :                 left <<= 1;

  004d4	03 d2		 add	 edx, edx
  004d6	45 3b c1	 cmp	 r8d, r9d
  004d9	72 e5		 jb	 SHORT $LL33@inflate_ta
$LN164@inflate_ta:

; 274  :             }
; 275  : 
; 276  :             /* check for enough space */
; 277  :             used += 1U << curr;
; 278  :             if ((type == LENS && used > ENOUGH_LENS) ||

  004db	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR type$[rsp]
  004e2	41 8b ca	 mov	 ecx, r10d
  004e5	be 01 00 00 00	 mov	 esi, 1
  004ea	d3 e6		 shl	 esi, cl
  004ec	03 ee		 add	 ebp, esi
  004ee	83 f8 01	 cmp	 eax, 1
  004f1	75 08		 jne	 SHORT $LN63@inflate_ta
  004f3	81 fd 54 03 00
	00		 cmp	 ebp, 852		; 00000354H
  004f9	eb 0b		 jmp	 SHORT $LN177@inflate_ta
$LN63@inflate_ta:
  004fb	83 f8 02	 cmp	 eax, 2
  004fe	75 0c		 jne	 SHORT $LN61@inflate_ta
  00500	81 fd 50 02 00
	00		 cmp	 ebp, 592		; 00000250H
$LN177@inflate_ta:

; 281  : 
; 282  :             /* point entry in root table to sub-table */
; 283  :             low = huff & mask;

  00506	0f 87 ad fd ff
	ff		 ja	 $LN62@inflate_ta
$LN61@inflate_ta:

; 284  :             (*table)[low].op = (unsigned char)curr;
; 285  :             (*table)[low].bits = (unsigned char)root;

  0050c	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv1918[rsp]
  00510	48 8d 14 bd 00
	00 00 00	 lea	 rdx, QWORD PTR [rdi*4]

; 286  :             (*table)[low].val = (unsigned short)(next - *table);
; 287  :         }
; 288  :     }

  00518	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR work$[rsp]
  00520	44 8b e7	 mov	 r12d, edi
  00523	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR table$[rsp]
  0052b	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0052e	44 88 14 02	 mov	 BYTE PTR [rdx+rax], r10b
  00532	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00535	88 4c 02 01	 mov	 BYTE PTR [rdx+rax+1], cl
  00539	49 8b c6	 mov	 rax, r14
  0053c	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0053f	48 2b c1	 sub	 rax, rcx
  00542	48 c1 f8 02	 sar	 rax, 2
  00546	66 89 44 11 02	 mov	 WORD PTR [rcx+rdx+2], ax
  0054b	8b 4c 24 08	 mov	 ecx, DWORD PTR sym$1$[rsp]
  0054f	8b 14 24	 mov	 edx, DWORD PTR match$1$[rsp]
  00552	e9 01 fe ff ff	 jmp	 $LN169@inflate_ta
$LN82@inflate_ta:

; 289  : 
; 290  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 291  :        at most one remaining entry, since if the code is incomplete, the
; 292  :        maximum code length that was allowed to get this far is one bit) */
; 293  :     if (huff != 0) {

  00557	85 db		 test	 ebx, ebx
  00559	74 1d		 je	 SHORT $LN64@inflate_ta

; 294  :         here.op = (unsigned char)64;            /* invalid code marker */
; 295  :         here.bits = (unsigned char)(len - drop);
; 296  :         here.val = (unsigned short)0;
; 297  :         next[huff] = here;

  0055b	8b cb		 mov	 ecx, ebx
  0055d	c6 84 24 c0 00
	00 00 40	 mov	 BYTE PTR here$[rsp], 64	; 00000040H
  00565	66 89 94 24 c2
	00 00 00	 mov	 WORD PTR here$[rsp+2], dx
  0056d	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR here$[rsp]
  00574	41 89 04 8e	 mov	 DWORD PTR [r14+rcx*4], eax
$LN64@inflate_ta:

; 298  :     }
; 299  : 
; 300  :     /* set return parameters */
; 301  :     *table += used;
; 302  :     *bits = root;

  00578	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR bits$[rsp]
  00580	8b c5		 mov	 eax, ebp
  00582	48 c1 e0 02	 shl	 rax, 2
  00586	48 01 07	 add	 QWORD PTR [rdi], rax
  00589	8b 44 24 0c	 mov	 eax, DWORD PTR tv1918[rsp]
  0058d	89 01		 mov	 DWORD PTR [rcx], eax

; 303  :     return 0;

  0058f	33 c0		 xor	 eax, eax
  00591	e9 28 fd ff ff	 jmp	 $LN175@inflate_ta
$LN42@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  00596	b8 ff ff ff ff	 mov	 eax, -1

; 304  : }

  0059b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0059f	41 5f		 pop	 r15
  005a1	41 5e		 pop	 r14
  005a3	41 5d		 pop	 r13
  005a5	41 5c		 pop	 r12
  005a7	5f		 pop	 rdi
  005a8	5b		 pop	 rbx
  005a9	c3		 ret	 0
inflate_table ENDP
_TEXT	ENDS
END
